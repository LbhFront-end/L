<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赖同学</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://laibh.top/"/>
  <updated>2020-07-11T03:24:57.643Z</updated>
  <id>http://laibh.top/</id>
  
  <author>
    <name>赖彬鸿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>试题</title>
    <link href="http://laibh.top/2020-07-07-docker.html"/>
    <id>http://laibh.top/2020-07-07-docker.html</id>
    <published>2020-07-07T01:58:40.000Z</published>
    <updated>2020-07-11T03:24:57.643Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cntofu.com/book/139/index.html">docker学习，作者源于这里</a></p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="镜像Image"><a href="#镜像Image" class="headerlink" title="镜像Image"></a>镜像Image</h3><p>操作系统分为内核和用户空间，内核启动后，会挂载root文件系统为其提供用户空间支持。docker镜像就相当于是一个root文件系统。</p><p>是一个特殊文件系统，除了提供容器运行所需的程序、库、资源、配置等文件外，还包含一些为运行准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不会包含任何动态数据，其内容在构建之后也不会被改变</p><h4 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h4><p>镜像包含操作系统完整的root文件系统，体积庞大，在设计docker时，将其设计为分层存储架构。严格来说，镜像并非像一个ISO那要的打包文件，镜像只是一个虚拟概念，实际体现并非由一个文件组成，而是由一组文件系统组成，或说是多层文件系统联合组成。</p><p>镜像构建时，会一层层构建，前一层是后一层的基础，每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己的这一层。例如删除前一层文件的操作并不是真的删除前一层文件，而是仅在当前层标记为该文件已珊瑚虫。在最终容器运行时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉</p><p>分层存储的特性还使得镜像的复用、定制变得更加容易，甚至可以使用之前构建好的镜像作为基础层，然后进一步添加新的层，以定制自己所需的内容，构建新的镜像</p><h3 id="容器Container"><a href="#容器Container" class="headerlink" title="容器Container"></a>容器Container</h3><p>镜像和容器的关系，就像是面向对象程序中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容易可以被创建、启动、停止、删除、暂停等。</p><p>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行属于自己的独立的命名空间。因此容器可以拥有自己的root文件系统、自己的网络配置、自己的进程空间，设置自己的用户ID空间。容器内的进程是运行在一个隔离的环境里面，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。因为这种隔离特性，常常会混淆容器和虚拟机。</p><p>容易也是分层存储，每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，称这个为容器运行时读写而装备的存储层为容器存储层。</p><p>容器存储层的生存周期和容器一样，容器消亡时，容器存储层随之消亡。任何保存于容器存储层的信息都会随容器删除而丢失。</p><p>按照最佳实践的要求，容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有文件写入操作，都应该使用数据卷、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。</p><p>数据卷的生存周期独立容器，使用数据卷后，容器删除或者重新运行之后，数据不会丢失。</p><h3 id="仓库Repository"><a href="#仓库Repository" class="headerlink" title="仓库Repository"></a>仓库Repository</h3><p>镜像构建后，容易在当前宿主机上运行，但是如果需要在其他服务器上使用这个镜像，就需要一个集中的存储、分发镜像的服务，docker register就是这样的服务。一个docker regisert中可以包含多个仓库，仓库可以包含多个标签Tag,每个标签对应一个镜像。</p><p>通常一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。可以通过<code>&lt;仓库名&gt;:&lt;标签&gt;</code>的格式指定具体这个软件哪个版本的镜像。如果不给出标签，将以lasest作为默认版本。</p><h2 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h2><h3 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h3><blockquote><p>docker pull [选项] [Docker Register 地址[:端口号]/]仓库名[:标签]</p></blockquote><p>可通过<code>docker pull --help</code>命令看到。镜像名称格式：</p><ul><li>Docker 镜像仓库地址：地址的名称一般是<code>&lt;域名/IP&gt;[:端口号]</code>默认地址是Docker Hub</li><li>仓库名：仓库名是两段式名称，即<code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于Docker Hub不给出用户名，默认就是 library，也就是官方镜像</li></ul><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[1;32mdocker@default[0m:[1;34m~[0m</span><br><span class="line"><span class="meta">$</span><span class="bash"> docker pull ubuntu:16.04</span></span><br><span class="line">16.04: Pulling from library/ubuntu</span><br><span class="line"></span><br><span class="line">[1B8bd67045: Pulling fs layer</span><br><span class="line">[1Be4862c05: Pulling fs layer</span><br><span class="line">[1B8949dcb1: Pulling fs layer</span><br><span class="line">[1BDigest: sha256:69bc24edd22c270431d1a9e6dbf57cfc4a77b2da199462d0251b145fdd7fa538</span><br><span class="line">Status: Downloaded newer image for ubuntu:16.04</span><br></pre></td></tr></table></figure><p>上面命令没有给出docker镜像仓库地址，会从Docker Hub获取镜像，镜像名称是<code>ubuntu:16.04</code>,因此获取官方镜像<code>library/ubuntu</code>，仓库中标签为 16.04的镜像</p><p>下载过程中可以看出分层存储概念，镜像由多层存储所构成，下载也是一层层的去下载，并非单一文件。下载过程中给出每一层ID的前12位，并且下载结束后，给出该镜像sha256的完整摘要，以确保下载一致性</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>以镜像为基础启动并运行一个容器，启动里面的bash并镜像交互操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[1;32mdocker@default[0m:[1;34m~[0m$ [Kdocker run -it --rm ubuntu:16.04 bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前系统版本</span></span><br><span class="line">[K]0;root@0d248af097b5: /root@0d248af097b5:/# cat /etc/os-release</span><br><span class="line">NAME="Ubuntu"</span><br><span class="line">VERSION="16.04.6 LTS (Xenial Xerus)"</span><br><span class="line">ID=ubuntu</span><br><span class="line">ID_LIKE=debian</span><br><span class="line">PRETTY_NAME="Ubuntu 16.04.6 LTS"</span><br><span class="line">VERSION_ID="16.04"</span><br><span class="line">HOME_URL="http://www.ubuntu.com/"</span><br><span class="line">SUPPORT_URL="http://help.ubuntu.com/"</span><br><span class="line">BUG_REPORT_URL="http://bugs.launchpad.net/ubuntu/"</span><br><span class="line">VERSION_CODENAME=xenial</span><br><span class="line">UBUNTU_CODENAME=xenial</span><br><span class="line"><span class="meta">#</span><span class="bash"> 退出</span></span><br><span class="line">]0;root@0d248af097b5: /root@0d248af097b5:/# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p><code>docker run</code>是容器运行的命令：</p><ul><li><code>-it</code>:这是两个参数，也给是<code>-i</code>，交互式操作，一个是<code>-t</code>终端。进入<code>bash</code>执行一些命令并查看返回结果，因此需要交互式终端</li><li><code>--rm</code>：容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动<code>docker rm</code>。这里使用 <code>--rm</code>可以避免浪费空间，只是随便执行个命令，查看结果，不需要排障和保留结果</li><li><code>ubuntu:16.64</code>：这是用这个镜像为基础来启动容器</li><li><code>bash</code>：在镜像后的是命令，希望有个交互式的shell，使用的是<code>bash</code></li></ul><h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><p><code>docker image ls</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1;32mdocker@default[0m:[1;34m~[0m$ docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED        SIZE</span><br><span class="line">ubuntu              16.04               c522ac0d6194        8 hours ago    126MB</span><br><span class="line">nginx               latest              2622e6cca7eb        3 weeks ago    132MB</span><br><span class="line">hello-world         latest              fce289e99eb9        18 months ago  1.84kB</span><br></pre></td></tr></table></figure><p>列表包含了仓库名、标签、镜像ID、创建时间以及所占空间。</p><p>镜像ID是镜像的唯一标识，一个镜像可以对应多个标签。</p><h4 id="镜像体积"><a href="#镜像体积" class="headerlink" title="镜像体积"></a>镜像体积</h4><p>这里标识所占的空间和在Docker Hub上看到的镜像大小不一样，这是因为Docker Hub中显示的体积是压缩后的体积。在镜像下载和上传过程中镜像总是保持着压缩状态，因此Docker Hub中显示的大小是网络传输中更关心的流量大小，而<code>docker image ls</code>显示的是镜像下载到本地后展开的大小，是展开后的各层所占空间的总和，因此镜像到本地后，查看空间的时候，更关心的是本地磁盘空间所用的大小。</p><p>列表中的镜像体积总和并非是所有镜像实际硬盘消耗，由于docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层。由于Docker使用UnionFS，相同层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。</p><p>使用 <code>docker system df</code>查看镜像、容器、数据卷所占用的空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[1;32mdocker@default[0m:[1;34m~[0m$ docker system df</span><br><span class="line">TYPE                TOTAL               ACTIVE              SIZE      RECLAIMABLE</span><br><span class="line">Images              3                   1                   258.2MB   258.2MB (99%)</span><br><span class="line">Containers          1                   0                   0B        0B</span><br><span class="line">Local Volumes       0                   0                   0B        0B</span><br><span class="line">Build Cache         0                   0                   0B        0B</span><br></pre></td></tr></table></figure><h4 id="虚悬镜像"><a href="#虚悬镜像" class="headerlink" title="虚悬镜像"></a>虚悬镜像</h4><p>有时候会特殊镜像，既没有仓库名，也没有标签，为none</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;none&gt;   &lt;none&gt;    09089dhs989  5 days ago 23MB</span><br></pre></td></tr></table></figure><p>这些镜像原来是镜像名和标签的，随着官方镜像维护发布新版本，重新pull这个镜像，镜像名被转移到了新下载的镜像上，而旧的镜像上的名称则被取消，从而成为了<code>&lt;none&gt;</code>。docker build也可能导致这样的问题。由于新旧镜像同名，旧镜像名称被取消，从而仓库名、标签均为<code>&lt;none&gt;</code>。这类无标签镜像也被成为虚悬镜像（dangling image）,可以用<code>docker image ls -f dangling=true</code>显示这些镜像</p><p>虚悬镜像也是失去了存在价值，可以随意删除，用<code>docker image prune</code>删除</p><h4 id="中间层镜像"><a href="#中间层镜像" class="headerlink" title="中间层镜像"></a>中间层镜像</h4><p>为了加速镜像构建、重复利用资源，Docker会利用中间镜像，在使用一段时间后，会看到一些依赖的中间镜像。默认的<code>docker image ls</code>列表只会显示顶层镜像，如果希望显示中间层镜像在内的所有镜像的话，用<code>docker image ls -a</code></p><p>出现无标签镜像，与虚悬镜像不同，这些镜像都是中间层镜像，是其他镜像所依赖的镜像，删除这些镜像会导致上层镜像因为依赖丢失出错。删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除</p><h4 id="列出部分镜像"><a href="#列出部分镜像" class="headerlink" title="列出部分镜像"></a>列出部分镜像</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 根据仓库名</span></span><br><span class="line">docker image ls ubuntu</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定仓库名和标签</span></span><br><span class="line">docker image ls ubuntu:16.04</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤器参数--filter,简写-f,希望看到在mongo:3.2之后建立的镜像</span></span><br><span class="line">docker image ls -f since=mongo:3.2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 之前则是用before</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果镜像构建时，定义了LABEL,可通过LABEL过滤</span></span><br><span class="line">docker image ls -f label=com.example.version=0.1</span><br></pre></td></tr></table></figure><h4 id="特定格式显示"><a href="#特定格式显示" class="headerlink" title="特定格式显示"></a>特定格式显示</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将所有镜像的ID列出</span></span><br><span class="line">docker image ls -q</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出镜像结果只包含镜像ID和仓库名，使用了GO模板语法</span></span><br><span class="line">docker image ls --format "&#123;&#123;.ID&#125;&#125;: &#123;&#123;.Repository&#125;&#125;"</span><br><span class="line">c522ac0d6194: ubuntu</span><br><span class="line">2622e6cca7eb: nginx</span><br><span class="line">fce289e99eb9: hello-world</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以表格等距显示，并且有标题行，和默认一样，不过自己定义列</span></span><br><span class="line">docker image ls --format "table &#123;&#123;.ID&#125;&#125;\t&#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;"</span><br><span class="line">IMAGE ID            REPOSITORY          TAG</span><br><span class="line">c522ac0d6194        ubuntu              16.04</span><br><span class="line">2622e6cca7eb        nginx               latest</span><br><span class="line">fce289e99eb9        hello-world         latest</span><br></pre></td></tr></table></figure><h3 id="删除本地镜像"><a href="#删除本地镜像" class="headerlink" title="删除本地镜像"></a>删除本地镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image rm [选项] &lt;镜像1&gt;[&lt;镜像2&gt;...]</span><br></pre></td></tr></table></figure><p>ID、镜像名、摘要删除镜像</p><p>镜像可以是短id,长id,镜像名或者镜像摘要，短id取前3个字符以上，能区分别的镜像就可以</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker image rm 502</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用镜像名，&lt;仓库名&gt;:&lt;标签&gt;</span></span><br><span class="line">docker image rm centos</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示镜像摘要</span></span><br><span class="line">docker image ls --digests</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用镜像摘要删除镜像</span></span><br><span class="line">docker image rm node@sha256:b4f0e0bdeb578043c1ea6862f0d40cc4afe32a4a582f3be235a3b164422be228</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所有仓库名为redis的镜像</span></span><br><span class="line">docker image rm $(docker image ls -q redis)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除所在mongo:3.2之前的镜像</span></span><br><span class="line">docker image rm$(docker image ls -q -f before=mongo:3.2)</span><br></pre></td></tr></table></figure><h4 id="Untagged和Deleted"><a href="#Untagged和Deleted" class="headerlink" title="Untagged和Deleted"></a>Untagged和Deleted</h4><p>删除行为分为两种，一种是untagged，一种是deleted。镜像的唯一标识是其ID和摘要，而一个惊喜可以有多个标签。当我们删除指定标签后，可能还有别的标签指向这个镜像，那么delete行为不会发生，会显示untagged信息。</p><p>当该镜像所有标签都被取消了，改镜像可能就失去了存在的意义，因此会触发删除行为。镜像是多层存储结构，在删除的时候也是从上层向基础层方法依次进行判断删除。镜像的多层结构使得复用变动镜像容易，因此很有可能某个其他镜像正依赖当前镜像的某一层。这种情况不会触发删除该层行为。直到没有任何层依赖当前层时，才会真实删除当前层。</p><p>除了镜像依赖还有容器对镜像的依赖。如果有用这个镜像启动的容器存在，即使容器没有运行，那么同样不可以删除这个镜像。容器是以经为基础，再加一层容器存储层，组成这样的多层存储结构去运行。因此该镜像如果被这个容器所依赖，那么删除必然会导致故障。如果这些容器是不需要的，应该先将它们删除，然后来删除镜像。</p><h3 id="利用commit理解镜像构成"><a href="#利用commit理解镜像构成" class="headerlink" title="利用commit理解镜像构成"></a>利用commit理解镜像构成</h3><p>镜像是容器的基础，每次执行docker run的时候都会指定哪个镜像作为容器运行的基础。当Docker Hub的镜像无法满足需求时，我们就需要定制镜像。</p><p>定制Web服务器为例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> nginx镜像启用一个容器，命名为webserver,映射80端口，在浏览器可以访问这个nginx服务器</span></span><br><span class="line">docker run --name webserver -d -p 80:80 nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改欢迎页面,以交互式终端方式进入webserver容器，并执行bash命令，获得一个可操作的shell，使用新内容覆盖指定文件的内容</span></span><br><span class="line">docker exec -it webserver bash</span><br><span class="line">root@xxx: /# echo '&lt;h1&gt;Hello,Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span><br><span class="line">root@xxx: /# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>修改了容器文件，也就是改动了容器的存储层，通过 <code>docker diff</code>可以看到具体的改变</p><p>定制好变化后，保存下来形成镜像。当我们运行一个容器（不使用卷），我们做的任何文件修改都会被记录于容器存储层里。而docker提供了docker commit命令，可以将容器的存储层保存下来成为镜像。在原有镜像的基础上，再叠加上容器的存储层，并构成新的镜像。以后我们运行这个新镜像的时候，就会拥有原来容器最后的文件变化</p><blockquote><p>docker commit [选项] &lt;容器ID或容器名&gt; [&lt;仓库名&gt;[:&lt;标签&gt;]]</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将容器保存为镜像</span></span><br><span class="line">docker commit --author "Laibh &lt;544289495@qq.com&gt;" --message "修改默认页面" webserver nginx:v2</span><br></pre></td></tr></table></figure><p>接着</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看新定制的镜像并使用，也可以使用docker <span class="built_in">history</span>具体查看镜像内的历史记录</span></span><br><span class="line">docker image ls </span><br><span class="line"></span><br><span class="line">docker run --name web2 -d -p 81:80 nginx:v2</span><br></pre></td></tr></table></figure><p>使用 docker commit 命令可以直观帮助理解镜像分层存储概念，但是实际环境不会这么做。</p><p>仔细观察docker diff webserver的结果，会发现除了修改的文件外，由于命令的执行，还有很多文件被改动或者添加了，这仅仅是最简单的操作，如果是安装软件包、编译构建，那会有大量的无关内容被添加进来，如果不小心清理，将会导致镜像尤为臃肿。</p><p>此外，使用docker commit都是黑箱操作。只有制作者才知道做了什么，docker diff可以看出一些线索，但不能保证生成一致的镜像。</p><h3 id="Dockerfile定制镜像"><a href="#Dockerfile定制镜像" class="headerlink" title="Dockerfile定制镜像"></a>Dockerfile定制镜像</h3><p>dockerfile是一个文本文件，其内包含了一天天的指令（Instruction）,每一条指令构建一层，因此每一条指令的内容就是描述该层应当如何构建</p><p>在一个空白目录，建立一个文件夹，并命名为Dockerfile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir myngix</span><br><span class="line"><span class="built_in">cd</span> mynginx </span><br><span class="line">touch Dockerfile</span><br><span class="line">vi Dockerfile</span><br><span class="line"><span class="comment"># 内容为</span></span><br><span class="line">FROM nginx</span><br><span class="line">Run <span class="built_in">echo</span> <span class="string">'&lt;h1&gt;Hello,Docker!&lt;/h1&gt;'</span> &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure><h4 id="FROM指定基础镜像"><a href="#FROM指定基础镜像" class="headerlink" title="FROM指定基础镜像"></a>FROM指定基础镜像</h4><p>定制镜像是以一个镜像为基础，在其上进行定制，FROM就是指定基础镜像，因此FROM是Dockerfile文件的第一条指令，除了docker hub现有的镜像，还有一个特殊的镜像 <code>scratch</code>，虚拟镜像，表示一个空白的镜像</p><blockquote><p>FROM scratch</p></blockquote><p>以它为基础的话，意味着不以任何镜像为基础，接下来写的指令作为镜像的第一层开始存在。不以任何系统为基础，直接将可执行文件复制进镜像的做法不罕见，对于Linux下静态编译的程序来说，并不需要有操作系统提供运行时支持，所需的一切库都已经在可执行文件里了，因此直接FROM scratch会让镜像体积更加小巧。使用GO语言开发的引用会使用这种方式，这也是为什么说Go是特别适合容器微服务架构的语言的原因之一</p><h4 id="RUN指定命令"><a href="#RUN指定命令" class="headerlink" title="RUN指定命令"></a>RUN指定命令</h4><p>RUN指令是定制镜像最常见的指令之一。格式有两种：</p><p>shell格式：<code>RUN&lt;命令&gt;</code>，就像直接在命令行输入的命令一样</p><p>exec格式：<code>RUN[&quot;可执行命令&quot;,&quot;参数1&quot;,&quot;参数2&quot;]</code>，这更像是函数调用中格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line"></span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y gcc libc6-dev make</span><br><span class="line">RUN wget -O redis.tar.gz "http://download.redios.io/release/redis-3.2.5.tar.gz"</span><br><span class="line">RUN mkdir -p /usr/src/redis</span><br><span class="line">RUN tar -xzf redis.tar.gz -C /usr/src/redis --script-components=1</span><br><span class="line">RUN make -C /usr/src/redis</span><br><span class="line">RUN make -C /usr/src/redis install</span><br></pre></td></tr></table></figure><p>dockerfile中每个指令都会建立一层，RUN也不例外，每一个RUN的行为都会新建一层，在其上执行结果后，commit一层的修改，构成新的镜像，上面这种写法创建了7个镜像，这是完全没有意义的，运行时很多不需要的东西都被装进了镜像，比如编译、更新的软件包等，结果就是产生臃肿、非常多层的镜像，不仅增加了构建时间，也容易出错。UnionFS是有最大层数限制的，比如AUFS,曾经是最大不超过42层，现在是不超过127层。</p><p>上面的Dockerfile正确写法应该是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM debian:jessie</span><br><span class="line"></span><br><span class="line">RUN buildDeps='gcc libc6-dev make' \</span><br><span class="line">&amp;&amp; apt-get update \</span><br><span class="line">&amp;&amp; apt-get install -y $buildDeps \</span><br><span class="line">&amp;&amp; wget -O redis.tar.gz "http://download.redios.io/release/redis-3.2.5.tar.gz" \</span><br><span class="line">&amp;&amp; mkdir -p /usr/src/redis \ </span><br><span class="line">&amp;&amp; tar -xzf redis.tar.gz -C /usr/src/redis --script-components=1 \</span><br><span class="line">&amp;&amp; make -C /usr/src/redis \</span><br><span class="line">&amp;&amp; make -C /usr/src/redis install \</span><br><span class="line">&amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">&amp;&amp; rm redis.tar.gz \</span><br><span class="line">&amp;&amp; rm -r /usr/src/redis \</span><br><span class="line">&amp;&amp; apt-get purge -y --auto-remove $buildDeps</span><br></pre></td></tr></table></figure><p>之前所有命令的目的只有一个，就是编译、安装redis可执行文件。因此没有必要建立多层，这里仅使用一个RUN，并使用 <code>&amp;&amp;</code>将各个需要命令串联起来，将之前的7层变成1层。并且为了格式化还进行了换行。Dockerfile支持Shell类的行尾添加 <code>\</code>的命令行，以及行首 <code>#</code>进行注释的格式。良好的格式会让排障更加容易。</p><p>此外，上面的命令还进行了清理工作，删除了为了编译构建所需要的软件，清理了所有下载、展开的文件，并且还清理了apt缓存文件，在镜像构建过程要确保每一层只添加真正需要添加的东西，任何无关的东西都应该被清理掉。</p><h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><p>在Dockerfile文件所在目录执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker@default:~/mynginx$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/2 : FROM nginx</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 2622e6cca7eb</span></span><br><span class="line">Step 2/2 : RUN echo '&lt;h1&gt;Hello,Docker!!!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> Running <span class="keyword">in</span> 6b7204234c09</span></span><br><span class="line">Removing intermediate container 6b7204234c09</span><br><span class="line"><span class="meta"> ---&gt;</span><span class="bash"> 4021436fa2ed</span></span><br><span class="line">Successfully built 4021436fa2ed</span><br><span class="line">Successfully tagged nginx:v3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在Step2中，RUN启动了一个容器6b7204234c09，执行了要求的命令，并提交了这一层4021436fa2ed，删除所用到的容器RUN启动了一个容器6b7204234c09</span></span><br></pre></td></tr></table></figure><p><code>docker build</code>格式：</p><blockquote><p>docker build [选型] &lt;上下文路径/URL/-&gt;</p></blockquote><h4 id="镜像构建上下文（Context）"><a href="#镜像构建上下文（Context）" class="headerlink" title="镜像构建上下文（Context）"></a>镜像构建上下文（Context）</h4><p>docker build 命令最后一个 <code>.</code>，代表当前目录，而Dockerfile就在当前目录，所以会误以为这个路径是指定Dockerfile所在路径，这样的理解不准确，其实这是在指定上下文路径。</p><p>docker build的工作原理：Docker在运行时分为Docker引擎（也就是服务端守护进程）和客户端工具。Docker的引擎提供了一组REST API,被称为Docker Remote API，而docker命令这样的客户端工具，则是通过这组API与Dokcer引擎交互，从而完成各种功能。因此我们表面上好像在本机执行各种docker功能，实际上，一切都是使用的远程调用形式在服务端（Docker引擎）完成。也因为这种C/S设计，让我们操作远程服务器的Docker引擎变得轻而易举。</p><p>当我们进行镜像构建时，并非所有的定制都会通过RUN指令完成，经常会需要将一些本地文件复制进镜像，比如通过COPY指令，ADD指令。而docker build命令构建镜像，并非在本地构建，而是在服务端，也就是Docker引擎中构建。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？</p><p>这就引入了上下文概念，当构建的时候，用户会指定构建镜像上下文路径，docker build命令得知这个路径后，会将路径下的所有内容打包，然后上传给Docker引擎，这样Docker引擎收到这个上下文之后，展开就会获得构建镜像所需要的一切文件。</p><p>例如在Dockerfile这样写：</p><blockquote><p>COPY ./package.json /app/</p></blockquote><p>这并不是要复制执行docker build命令所在的目录下的package.json，也不是复制Dockerfile所在目录下的package.json,而是复制上下文context目录下的package.json</p><p>因此，COPY这类指令中的源文件的路径都是相对路径，如果真的需要那些文件，应该将它们复制到上下文目录中去。观察docker build输出，可以看到这个发送上下文的过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker@default:~/mynginx$ docker build -t nginx:v3 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br></pre></td></tr></table></figure><p>理解构建上下文对于镜像构建很重要，避免犯一些不应该的错误，比如初学者在发现 <code>Copy/opt/xxxx /app</code>不工作后，干脆把Dockerfile放到了硬盘跟目录去构建，结果发现docker build执行后，在发送一个几十GB的东西，极为缓慢而且容易构建失败，那是因为这种做法是让docker build打包整个硬盘，这显然是使用错误。</p><p>一般来说，应该会将Docker置于一个空目录，或者根目录下面，如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给Docker引擎，那么可以用<code>.dockerignore</code>剔除不需要作为上下文传递给Docker引擎的。</p><p>在默认情况下，如果不额外指定Dockerfile的话，会将上下文目录下的名为Dockerfile的文件作为Dockerfile，实际上不要求名字必须为Dockerfile，并且不要求必须位于上下文目录中，比如用 <code>-f ../Dockerfile.php</code>参数指定某个文件作为 Dockerfile</p><h4 id="其他Docker-build用法"><a href="#其他Docker-build用法" class="headerlink" title="其他Docker build用法"></a>其他Docker build用法</h4><h5 id="直接用-git-repo进行构建"><a href="#直接用-git-repo进行构建" class="headerlink" title="直接用 git repo进行构建"></a>直接用 git repo进行构建</h5><p>docker build还支持从URL构建，比如从 Git repo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定构建所需要的git repo，并且指定默认的master分支，构建目录为/814/，然后docker就会自己去git <span class="built_in">clone</span>这个项目、切换到指定分支，并进入到指定目录后开始构建</span></span><br><span class="line">docker build https://github.com/twang2218/gitlab-ce-zh.git#:8.14</span><br><span class="line">docker build https://github.com/twang2218/gitlab-ce-zh.git\#:8.14</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Step 1 : FROM gitlab/gitlab-ce:8.14.0-ce.0</span><br><span class="line">8.14.0-ce.0: Pulling from gitlab/gitlab-ce</span><br><span class="line">aed15891ba52: Already exists</span><br><span class="line">773ae8583d14: Already exists</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h5 id="用tar压缩包构建"><a href="#用tar压缩包构建" class="headerlink" title="用tar压缩包构建"></a>用tar压缩包构建</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build http://server/context.tar.gz</span><br></pre></td></tr></table></figure><p>如果给出的URL不是Git repo，而是个tar压缩包，那么Docker引擎会下载这个包，并自动解压，以其作为上下文，并且构建。</p><h5 id="从标准输入中读取Dockerfile进行构建"><a href="#从标准输入中读取Dockerfile进行构建" class="headerlink" title="从标准输入中读取Dockerfile进行构建"></a>从标准输入中读取Dockerfile进行构建</h5><blockquote><p>docker build - &lt; Dockerfile</p></blockquote><p>或者</p><blockquote><p>cat Dockerfile | docker build -</p></blockquote><p>如果标准输入传入的是文本文件，则将其视为Dockerfile，并开始构建。这种形式由于直接从标准输入中读取Dockerfile的内容，没有上下文，因此不可以像其他方法那样可以将本地文件COPY进镜像之类的事情</p><h5 id="从标准输入中读取上下文压缩包镜像构建"><a href="#从标准输入中读取上下文压缩包镜像构建" class="headerlink" title="从标准输入中读取上下文压缩包镜像构建"></a>从标准输入中读取上下文压缩包镜像构建</h5><blockquote><p>docker build - &lt; context.tar.gz</p></blockquote><p>如果发现标准输入的文件格式是 gzip/bzip2/xz的话，将会使其成为上下文压缩包，直接将其展开，将里面视为上下文，并开始构建。</p><h4 id="指令详解"><a href="#指令详解" class="headerlink" title="指令详解"></a>指令详解</h4><h5 id="COPY复制文件"><a href="#COPY复制文件" class="headerlink" title="COPY复制文件"></a>COPY复制文件</h5><p>格式：</p><ul><li><code>COPY &lt;源路径&gt;...&lt;目标路径&gt;</code></li><li><code>COPY[&quot;&lt;源路径1&gt;&quot;,...&quot;&lt;目标路径&gt;&quot;]</code></li></ul><p>和RUN指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用</p><p>COPY指令将从构建上下文目录中<code>&lt;源路径&gt;</code>的文件/目录复制到新的一层的镜像内的<code>&lt;目标路径&gt;</code>位置，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json /usr/src/app/</span><br></pre></td></tr></table></figure><p>源路径可以是多个，甚至是通配符，其通配符规则要满足GO的filepath.Match规则，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br></pre></td></tr></table></figure><p><code>&lt;目标路径&gt;</code>可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作路径可以用WORKDIR指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还有一点使用COPY指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用，特别是构建相关文件都在使用Git进行管理时。</p><h5 id="ADD更高级的复制文件"><a href="#ADD更高级的复制文件" class="headerlink" title="ADD更高级的复制文件"></a>ADD更高级的复制文件</h5><p>ADD指令和COPY的格式和性质基本一致，但是在COPY基础上增加了一些功能。</p><p>比如 <code>&lt;源路径&gt;</code>可以是一个URL,这种情况下Docker引擎会视图去下载这个链接的文件放到 <code>&lt;目标路径&gt;</code>去。下载后的文件权限自动设置为600，如果这并不是想要的权限，还要增加额外的一层RUN进行权限调整。另外，如果下载但是个压缩包，需要解压缩，也一样需要额外的一层RUN指令进行解压缩。所以不如直接使用RUN,然后用wget或者curl工具下载，处理权限、解压缩、然后清理无用文件更合理。因此这个功能其实并不好用，而且不推荐使用</p><p>如果<code>&lt;源路径&gt;</code>为一个tar压缩文件，压缩格式为gzip,bzip2以及xz的情况下，ADD指令将会自动解压缩这个压缩文件到 <code>&lt;目标路径&gt;</code>去。</p><p>在某些情况下，这个自动解压功能非常有用，比如官方镜像ubuntu中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM scratch</span><br><span class="line">ADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span><br></pre></td></tr></table></figure><p>在某些情况下，希望复制压缩文件而不解压就不用ADD命令了，在Dockerfile最佳实践文档中要求，尽可能使用COPY，因为它的语义很明确，就是复制文件而已，而ADD则包含了更复杂的功能，其行为也不一定很清晰。最适合用ADD的场合就是所提及的需要自动解压缩的场合。ADD指令会令镜像构建缓存失败，从而可能会令镜像构建变得比较缓慢。</p><p>因此COPY与ADD指令选择可以遵循这样的原则，所有文件复制均使用COPY指令，仅在需要自动解压缩的时候使用ADD</p><h5 id="CMD容器启动命令"><a href="#CMD容器启动命令" class="headerlink" title="CMD容器启动命令"></a>CMD容器启动命令</h5><p>CMD 指令格式和 RUN相似，也是两种格式：</p><ul><li>shell格式：CMD<code>&lt;命令&gt;</code></li><li>exec格式：CMD[“可执行文件”，“参数1”,”参数2”…]</li><li>参数列表格式：CMD[“参数1”,”参数2”]。在指定了ENTRYPOINT后，用CMD指定具体参数</li></ul><p>Docker不是虚拟机，容器就是进程，在启动容器的时候，需要指定所运行的程序及参数。CMD指令就是用指定默认的容器主进程的启动命令。</p><p>在运行时可以指定新的命令来提点镜像设置中的这个默认命令，比如ubuntu镜像默认的CMD是<code>/bin/bash</code>，如果我们直接docker run -it ubuntu的话，会直接进入bash，也可以在运行的时候指定运行别的命令，如 <code>docker run -it ubuntn cat /etc/os-release</code>，这里就是使用<code>cat /etc/os-release</code>命令替换了默认的 <code>/bin/bash</code>命令，输出了系统版本信息。</p><p>在指令格式上，一般推荐 exec格式，这类格式在解析时会被解析为JSON数组，因此一定要使用双引号，而不是单引号。使用shell的话，实际的命令会被包装为sh-c的参数的形式进行执行，比如：</p><blockquote><p>CMD echo \$HOME =》 CMD[“sh”,”-c”,”echo \$HOME”]</p></blockquote><p>这就是为什么可以使用环境变量的原因，因此这些环境变量会被shell进行解析处理。</p><p>Docker不是虚拟机，容器的应用都应该是以前台运行，而不是像虚拟机、物理机用<code>upstart/systemd</code>去启动后台服务，容器没有后台服务概念。一些人将CMD写为：</p><blockquote><p>CMD service nginx start</p></blockquote><p>然后发现容器执行后立即退出了，甚至在容器内去使用systemtcl命令结果却发现根本执行不了。</p><p>对于容器而言，其启动程序就是容器应用进程，容器就是为了主进程而存在的，主进程退出，容器就是去了生存的意义，从而退出，其他辅助进程不是它需要关心的东西。</p><p>而是用 service nginx start命令，则是希望upstart来以后台守护进程形式启动nginx，CMD service nginx start实际上是 <code>CMD[&quot;sh&quot;,&quot;-C&quot;,&quot;service nginx start&quot;]</code>，因此主进程实际上是sh,当 service nginx start命令结束后，sh也就结束了，sh作为主进程退出，自然容器退出。</p><p>正确的做法是直接执行nginx可执行文件，并且要求前台形式运行：</p><blockquote><p>CMD [“nginx”,”-g”,”daemon off”;]</p></blockquote><h5 id="ENTRYPOINT入口点"><a href="#ENTRYPOINT入口点" class="headerlink" title="ENTRYPOINT入口点"></a>ENTRYPOINT入口点</h5><p>与RUN指令一样，分为exec和shell格式。目的和CMD一样，都是在指定容器启动程序及参数。ENTRYPOINT在运行时也可以替代，不过比CMD要略繁琐，需要通过 docker run –entrypoint指定。</p><p>指定ENTRYPOINT后，CMD的含义就发生了变化，不再是直接的运行其命令，而是将CMD的内容作为参数传给ENTRYPOINT指令：</p><blockquote><p><ENTRYPOINT> “<CMD>“</p></blockquote><p>有了CMD后，为什么还要有ENTRYPOINT?</p><h6 id="场景一：让镜像变成像命令一样使用"><a href="#场景一：让镜像变成像命令一样使用" class="headerlink" title="场景一：让镜像变成像命令一样使用"></a>场景一：让镜像变成像命令一样使用</h6><p>假设我们需要一个得知自己当前公网IP的镜像，可以使用CMD实现</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-age update \</span><br><span class="line">&amp;&amp; apt-age install -y curl \</span><br><span class="line">&amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">CMD ["curl","-s","http://ipinfo.cn"]</span><br></pre></td></tr></table></figure><p>使用 <code>docker build -t myip .</code>来构建镜像的话，如果查询当前公网的ip，只需要执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run myip</span><br></pre></td></tr></table></figure><p>现在把镜像当做命令使用，如果命令有参数要怎么加上？CMD中实际的命令是curl，如果希望展示HTTP头部信息，就需要加上 <code>-i</code>参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run myip -i</span><br><span class="line">docker: Error response from daemon: invalid header field value "oci runtime error: container_linux.go:247: starting container process caused \"exec: \\\"-i\\\": executable file not found in $PATH\"\n".</span><br></pre></td></tr></table></figure><p>可以看到执行文件找不到的报错，<code>executable file not found</code>。在镜像后面的是 command，运行时会替换CMD的默认值，这里的<code>-i</code>替换了CMD,而不是加在 <code>curl -s http://ip.cn</code>后面。而 <code>-i</code>不是命令，所以自然找不到。</p><p>如果希望加入 <code>-i</code>这参数，就必须重新完整的输入这个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run myip curl -s http://ipinfo.cn -i</span><br></pre></td></tr></table></figure><p>这显然不是很好的解决方案，使用ENTRYPOINT可以解决这个问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu:16.04</span><br><span class="line">RUN apt-get update \</span><br><span class="line">&amp;&amp; apt-get install -y curl \</span><br><span class="line">&amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">ENTRYPOINT ["curl","-s","http://ipinfo.cn"]</span><br></pre></td></tr></table></figure><p>运行 docker run myip -i</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">docker@default:~/myip$ docker run myip</span><br><span class="line">&#123;</span><br><span class="line">  "ip": "113.70.180.56",</span><br><span class="line">  "city": "Foshan",</span><br><span class="line">  "region": "Guangdong",</span><br><span class="line">  "country": "CN",</span><br><span class="line">  "loc": "23.0268,113.1315",</span><br><span class="line">  "org": "AS4134 CHINANET-BACKBONE",</span><br><span class="line">  "timezone": "Asia/Shanghai",</span><br><span class="line">  "readme": "https://ipinfo.io/missingauth"</span><br><span class="line">&#125;docker@default:~/myip$ docker run myip -i</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Thu, 09 Jul 2020 03:16:44 GMT</span><br><span class="line">Content-Type: application/json; charset=utf-8</span><br><span class="line">Content-Length: 233</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Access-Control-Allow-Origin: *</span><br><span class="line">X-Frame-Options: DENY</span><br><span class="line">X-XSS-Protection: 1; mode=block</span><br><span class="line">X-Content-Type-Options: nosniff</span><br><span class="line">Referrer-Policy: strict-origin-when-cross-origin</span><br><span class="line">Set-Cookie: flash=; Path=/; Expires=Thu, 01 Jan 1970 00:00:00 GMT</span><br><span class="line">Via: 1.1 google</span><br><span class="line">Expires: Thu, 09 Jul 2020 03:16:44 GMT</span><br><span class="line">Cache-Control: private</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  "ip": "113.70.180.56",</span><br><span class="line">  "city": "Foshan",</span><br><span class="line">  "region": "Guangdong",</span><br><span class="line">  "country": "CN",</span><br><span class="line">  "loc": "23.0268,113.1315",</span><br><span class="line">  "org": "AS4134 CHINANET-BACKBONE",</span><br><span class="line">  "timezone": "Asia/Shanghai",</span><br><span class="line">  "readme": "https://ipinfo.io/missingauth"</span><br></pre></td></tr></table></figure><p>当存在ENTRYPOINT后，CMD的内容将会作为参数传给ENTRYPOINT,而 <code>-i</code>就是新的CMD,因此会作为参数传给curl。</p><h6 id="场景二：应用运行前的准备工作"><a href="#场景二：应用运行前的准备工作" class="headerlink" title="场景二：应用运行前的准备工作"></a>场景二：应用运行前的准备工作</h6><p>启动容器就是启动主进程，有时候在启动主进程前，需要一些准备工作。</p><p>例如mysql类的数据库，需要一些数据库配置、初始化工作，这些工作要在mysql服务器运行前解决。</p><p>另外，希望避免使用root用户去启动服务，从而提高安全性，而在启动前还需要以root身份执行一些必要的准备工作，最后切换到服务用户身份启动服务。或者除了服务外，其他命令依旧可以使用root身份执行，方便调试。</p><p>这些准备工作与容器CMD无关的，无论CMD为什么，都需要事先进行一个预处理的工作，这种情况可以写一个脚本，放入到ENTRYPOINT中去执行，而这个脚本也会将接收到的参数也就是CMD的命令作为命令，在脚本最后执行，官方镜像redis就是这样做的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:3.4</span><br><span class="line">...</span><br><span class="line">RUN addgroup -S redis &amp;&amp; adduser -S -G redis redis</span><br><span class="line">...</span><br><span class="line">ENTRYPOINT ["docker-entrypoint.sh"]</span><br><span class="line"></span><br><span class="line">EXPOSE 6379</span><br><span class="line">CMD ["redis-server"]</span><br></pre></td></tr></table></figure><p>可以看到为了redis服务创建redis用户，并在最后指定了ENTRYPOINT为docker-entrypoint.sh脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> !/bin/sh</span></span><br><span class="line">..</span><br><span class="line"><span class="meta">#</span><span class="bash"> allow the container to be started with <span class="string">'--user'</span></span></span><br><span class="line">if ["$1"='redis-server' -a "$(id-u)"='0'];then</span><br><span class="line">chown -R redis .</span><br><span class="line">exec su-exec redis "$0" "$@"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exec "$@"</span><br></pre></td></tr></table></figure><p>脚本的内容根据CMD的内容来判断如果是redis-server就切换到redis用户身份去启动服务器，否则使用root身份执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it redis id</span><br><span class="line">uid=0(root) git=0(root) groups=0(root)</span><br></pre></td></tr></table></figure><h5 id="ENV设置环境变量"><a href="#ENV设置环境变量" class="headerlink" title="ENV设置环境变量"></a>ENV设置环境变量</h5><p>格式：</p><ul><li>ENV<code>&lt;key&gt;&lt;value&gt;</code></li><li>ENV<code>&lt;key1&gt;=&lt;value&gt; &lt;key2&gt;=&lt;value2&gt;</code></li></ul><p>设置环境变量，无论是后面的其他指令RUN，还是运行时的引用，都可以直接使用这里定义的环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENV VERSION=1.0 DEBUG=on \</span><br><span class="line">NAME="Happy Feet"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 换行符以及当有空格的值用双引号括起来</span></span><br></pre></td></tr></table></figure><p>定义了环境变量，在后续的指令里面就可以使用这个环境变量，比如官方node镜像Dockerfile中妈就有类似这样的代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ENV NODE_VERSION 7.2.0</span><br><span class="line">RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz" \</span><br><span class="line">  &amp;&amp; curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc" \</span><br><span class="line">  &amp;&amp; gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc \</span><br><span class="line">  &amp;&amp; grep " node-v$NODE_VERSION-linux-x64.tar.xz\$" SHASUMS256.txt | sha256sum -c - \</span><br><span class="line">  &amp;&amp; tar -xJf "node-v$NODE_VERSION-linux-x64.tar.xz" -C /usr/local --strip-components=1 \</span><br><span class="line">  &amp;&amp; rm "node-v$NODE_VERSION-linux-x64.tar.xz" SHASUMS256.txt.asc SHASUMS256.txt \</span><br><span class="line">  &amp;&amp; ln -s /usr/local/bin/node /usr/local/bin/nodejs</span><br></pre></td></tr></table></figure><p>定义了NODE_VERSION环境变量，其后RUN这层，多次使用<code>$NODE_VERSION</code>来进行操作定制。可以看到，升级镜像构建版本的时候，只要更新7.2.0既可，构建维护变得更轻松了</p><p>下列的指令可以支持环境变量展开：</p><p>ADD/COPY/ENV/EXPOSE/LABEL/USER/WORKDIR/VOLUME/STOPSIGNAL/ONBUILD</p><h5 id="ARG构建参数"><a href="#ARG构建参数" class="headerlink" title="ARG构建参数"></a>ARG构建参数</h5><p>格式：ARG<code>&lt;参数名&gt;[=&lt;默认值&gt;]</code></p><p>构建参数和ENV的效果一样，都是设置环境变量，不同的是，ARG所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用ARG保存密码之类的信息，因为docker history还是可以看到所有值的。</p><p>Dockerfile中ARG指令是定义参数名称，以及定义其默认值。该默认值可以在构建命令docker build中用 <code>--build-arg&lt;参数名&gt;=&lt;值&gt;</code>来覆盖。</p><p>在1.13之前的版本，要求 <code>--build-arg</code>中的参数名，必须在Dockerfile中用ARG定义过了，如果没有则会报错退出构建。在1.13之后的版本，只是显示警告信息，并继续构建。这对于使用CI系统，用同样的构建流程构建不同的Dockerfile的时候比较有帮助，避免构建命令必须根据每个Dockerfile的内容修改</p><h5 id="VOLUME定义匿名卷"><a href="#VOLUME定义匿名卷" class="headerlink" title="VOLUME定义匿名卷"></a>VOLUME定义匿名卷</h5><p>格式为：</p><ul><li>VOLUME<code>[&quot;&lt;路径1&gt;&quot;,&quot;路径2&quot;...]</code></li><li>VOLUME<code>&lt;路径&gt;</code></li></ul><p>容器运行时应该尽量保持容器存储层不发生写操作，对于数据库需要保存动态数据的应用，其数据库文件应该保存于卷中，为了防止运行时用户忘记将动态文件所保存目录挂载为卷，在Dockerfile中，我们实现指定某些目录挂载为匿名卷，这样在运行时如果用户不指定挂载，其应用也可以正常运行，不会向容器存储层写入大量数据</p><blockquote><p>VOLUME /data</p></blockquote><p>这里的 <code>/data</code>目录就会在运行时自动挂载为匿名卷，任何向 <code>/data</code>中写入的信息都不会记录进容器存储层，从而保证了容器存储层的无状态化。运行时也可以覆盖这个挂载设置：</p><blockquote><p>docker run -d -v mydata:/data xxx</p></blockquote><p>使用了 mydata这个命令卷挂载到了 <code>/data</code>这个位置，替代了Dockerfile中定义的匿名卷的挂载配置</p><h5 id="EXPOSE声明端口"><a href="#EXPOSE声明端口" class="headerlink" title="EXPOSE声明端口"></a>EXPOSE声明端口</h5><p>格式为：EXPOSE<code>&lt;端口1&gt;[&lt;端口2&gt;...]</code></p><p>EXPOSE指令是声明运行时容器提供服务端口，在运行时并不会因为这个声明应用就会开启这个端口的服务，在Dockerfile中写入这样的声明有两个好处，一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；另一个好处就是运行时使用随机端口映射时，也就是docker run -P时，会自动随机映射EXPOSE端口</p><p>在早期Docker版本中还有一个特殊用处，以前所有的容器都是运行于默认桥接网络中，因此所有容器互相之间都可以直接访问，这样存在一定的安全性问题。于是有了一个Docker引擎参数 <code>--icc=false</code>，当指定该参数后，容器间将默认无法互访，除非互相使用了<code>--links</code>参数的容器才可以互通，并且只有镜像中EXPOSE所声明的端口才可以被访问。这个 <code>-icc=false</code>的用法在引入了docker network后已经基本不用了，通过自定义网络可以轻松实现容器间的互联与隔离。</p><p>要将 EXPOSE和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code>区分开，<code>-p</code>是映射宿主端口和容器端口，也就是将容器的对应端口服务公开给外界访问，而EXPOSE仅仅是声明容器打算使用什么端口而已，并不会自动在宿舍进行映射。</p><h5 id="WORKDIR指定工作目录"><a href="#WORKDIR指定工作目录" class="headerlink" title="WORKDIR指定工作目录"></a>WORKDIR指定工作目录</h5><p>格式：WORKDIR<code>&lt;工作目录路径&gt;</code></p><p>使用WORKDIR指令可以来指定工作目录（或者称为当前目录），以后各层的目录就被改成指定目录，如该目录不存在，WORKDIR就会帮你建立目录</p><p>错误例子：</p><blockquote><p>RUN cd /app</p><p>RUN echo “hello” &gt; world.txt</p></blockquote><p>把Dockerfile当做Shell脚本来书写，构建镜像运行后，会发现找不到 <code>/app/world.txt</code>文件，或者其内容不是hello.在shell中，连续两行是同一个进程执行环境，因此前一个命令修改的内存状态，会直接影响下一个命令；而在Dockerfile中，这两行RUN命令的执行环境根本不同，是两个完全不同的容器，这是对Dockerfile构建分层存储的概念不了解所导致的错误。</p><p>如果需要改变各层的工作目录位置，应该使用WORKDIR指令</p><h5 id="USER指定当前用户"><a href="#USER指定当前用户" class="headerlink" title="USER指定当前用户"></a>USER指定当前用户</h5><p>格式：USER<code>&lt;用户名&gt;</code></p><p>USER指令和WORKDIR相似，都是改变环境并影响以后的层，WORKDIR是改变工作目录，USER则是改变之后层的执行RUN,CMD以及ENTRYPOINT这类命令的身份</p><p>和WORKDIR一样，USER只是帮助切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line">USER redis</span><br><span class="line">RUN ["redis-server"]</span><br></pre></td></tr></table></figure><p>如果以root执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程。不要使用su或者sudo，这些都需要比较麻烦的配置，而且在TTY缺失的环境下经常出错，建议使用 gosu</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 建立 redis用户，并使用 gosu换另一个用户执行命令</span></span><br><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载 gosu</span></span><br><span class="line">RUN wget -O /usr/local/bin/gosu "http://github.com/tianon/gosu/release/download/1.7/gosu-amd64" \</span><br><span class="line">&amp;&amp; chmod +x /usr/local/bin/gosu \</span><br><span class="line">&amp;&amp; gosu nobody true</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置CMD,并以另外的用户执行</span></span><br><span class="line">CMD ["exec","gosu","redis","redis-server"]</span><br></pre></td></tr></table></figure><h5 id="HEALTHCHECK健康检查"><a href="#HEALTHCHECK健康检查" class="headerlink" title="HEALTHCHECK健康检查"></a>HEALTHCHECK健康检查</h5><p>格式：</p><ul><li>HEALTHCHECK <code>[选项] CMD &lt;命令&gt;</code>，设置检查容器健康状态的命令</li><li>HEALTHCHECK NONE：如果基础镜像有健康检查指令，使用这行可以屏蔽其健康检查指令。</li></ul><p>在没有HEALTHCHECK指令前，Docker引擎只可以通过容器内主进程是否退出来判断容器是否状态异常，很多情况下没问题，但是如果程序进入死锁状态，或者死循环，应用程序不会退出，但是该容器已经无法提供服务了。在1.12前，Docker不会检测到容器的这种状态，从而不会重新调度，导致可能会有部分容器已经无法提供服务却还在接受用户请求。</p><p>在1.12之后，Docker提供了这个指令，通过改指令指定一行命令，用这行命令来判断容器主进程服务状态是否还正常，从而比较真实的反应容器实际状态。</p><p>当在一个镜像指定了HEALTHCHECK指令后，用其启动容器，初始状态为starting，在HEALTHCHECK指令检查成功后变为healthy，如果连续一定次数失败，则会变为unhealthy</p><p>支持系列选项：</p><blockquote><p>–interval=&lt;间隔&gt;：两次健康检查的间隔，默认为30s</p><p>–timeout=&lt;时长&gt;：健康检查命令运行超时时间，如果超过这个时间，本次健康检查视为失败，默认30s</p><p>–retries=&lt;次数&gt;：当连续失败指定次数后，则容器状态为unhealthy，默认3次</p></blockquote><p>和CMD/ENTRYPOINT一样，HEALTHYCHECK只出现一次，如果写了多个，只有最后一个生效。</p><p>在<code>HEALTHYCHECK [选项] CMD</code>后面命令，格式和ENTRYPOINT一样，分为shell，和exec。命令的返回值决定了该次健康检查的成功与否：0为成功1是失败，2保留，不要使用这个值</p><p>假设我们有个镜像简单的Web服务，希望增加健康检查判断Web服务是否正常工作，用curl判断，dockerfile可以这么写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM nginx </span><br><span class="line">RUN agt-get update &amp;&amp; apt-get install -y curl &amp;&amp; rm -rf /var/lib/apt/lists/*</span><br><span class="line">HEALTHYCHECK --interval=5s --timeout=3s \</span><br><span class="line">CMD curl -fs http://localhost/ || exit 1</span><br></pre></td></tr></table></figure><p>设置了每5秒检查一次，如果健康检查超过3秒没响应就是视为失败。构建并启动容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">docker build -t myweb:v1</span><br><span class="line">docker run -d --name web -p 80:80 myweb:v1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看状态</span></span><br><span class="line">docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                            PORTS               NAMES</span><br><span class="line">03e28eb00bd0        myweb:v1            "nginx -g 'daemon off"   3 seconds ago       Up 2 seconds (health: starting)   80/tcp, 443/tcp     web</span><br><span class="line"><span class="meta">#</span><span class="bash"> 等待几秒后再查看，发现健康状态变成了healthy,如果健康检查连续失败超过重试次数，状态就为unhealthy</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为帮助排障，健康检查命令的输出stdout/stderr等都会被存储在健康状态，可用docker inspect查看</span></span><br><span class="line">docker inspect --format‘&#123;&#123;json .State.Health&#125;&#125;’ web | python -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">    "FailingStreak": 0,</span><br><span class="line">    "Log": [</span><br><span class="line">        &#123;</span><br><span class="line">            "End": "2016-11-25T14:35:37.940957051Z",</span><br><span class="line">            "ExitCode": 0,</span><br><span class="line">            "Output": "&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n&lt;title&gt;Welcome to nginx!&lt;/title&gt;\n&lt;style&gt;\n    body &#123;\n        width: 35em;\n        margin: 0 auto;\n        font-family: Tahoma, Verdana, Arial, sans-serif;\n    &#125;\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;\n&lt;p&gt;If you see this page, the nginx web server is successfully installed and\nworking. Further configuration is required.&lt;/p&gt;\n\n&lt;p&gt;For online documentation and support please refer to\n&lt;a href=\"http://nginx.org/\"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;\nCommercial support is available at\n&lt;a href=\"http://nginx.com/\"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;\n\n&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n",</span><br><span class="line">            "Start": "2016-11-25T14:35:37.780192565Z"</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    "Status": "healthy"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ONBUILD为他人做嫁衣裳"><a href="#ONBUILD为他人做嫁衣裳" class="headerlink" title="ONBUILD为他人做嫁衣裳"></a>ONBUILD为他人做嫁衣裳</h5><p>格式：ONBUILD<code>&lt;其他指令&gt;</code></p><p>ONBUILD是一个特殊的指令，后面跟着的是其他指令，例如RUN/COPY等，而这些指令，在当前镜像构建时不会被执行，只有当以当前镜像为基础，去构建下一个镜像才会执行</p><p>Dockerfile中的其他指令都是为了定制当前镜像而准备的，ONBUILD是为了帮助别人定制自己准备的。Nodejs使用npm管理，拿到程序后，一般会先安装依赖，然后启动，一般会这么写Dockerfile</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim</span><br><span class="line">RUN mkdir /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">COPY ./package.json /app</span><br><span class="line">RUN ["npm","install"]</span><br><span class="line">COPY . /app/</span><br><span class="line">CMD ["npm","start"]</span><br></pre></td></tr></table></figure><p>把这个Dockerfile放到Nodejs的根目录，构建好镜像后，就可以直接拿来启动容器运行，但是如果有第二个第三个差不多的项目，随着文件附件越多，版本控制就越难。</p><p>如果在第一个Nodejs项目发现了Dockerfile存在的问题，比如敲错字，或者需要安装额外的包，然后开发人员修复了这个Docker，再次构建，问题解决。但是其他项目呢？虽然最初Dockerfile是复制、粘贴自第一个项目，但是并不会因为第一个项目修复了Dockerfile就会自动修复</p><p>那么我们可以做一个基础镜像，然后各个项目使用这个基础镜像。镜像更新后就不用同步Dockerfile的变化，重新构建后就继续了基础镜像的更新：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim</span><br><span class="line">RUN mkdir /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">CMD ["npm","start"]</span><br></pre></td></tr></table></figure><p>这里把项目相关的构建指令拿出来，放在子项目去。假设这个基础镜像为my-node，各个项目内的Dockerfile就变成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM my-node</span><br><span class="line">COPY ./package.json /app</span><br><span class="line">RUN ["npm","install"]</span><br><span class="line">COPY . /app/</span><br></pre></td></tr></table></figure><p>基础镜像变化后，各个项目都用这个Dockerfile重新构建镜像，会基础基础镜像的更新。</p><p>但是问题并没有完全解决，这个Dockerfile如果有东西要修改，又要重新一个一个修改。这样制作镜像只解决了原来Dockerfile的前4条指令的变化问题，而后面三条指令的变化则完全没办法处理</p><p>ONBUILD可以解决这个问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FROM node:slim</span><br><span class="line">RUN mkdir /app</span><br><span class="line">WORKDIR /app</span><br><span class="line">ONBUILD COPY ./package.json /app</span><br><span class="line">ONBUILD RUN ["npm","install"]</span><br><span class="line">ONBULD COPY . /app/</span><br><span class="line">CMD ["npm","start"]</span><br></pre></td></tr></table></figure><p>在构建镜像的时候，这三行并不会被执行，然后各个项目的Dockerfile就变成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM my-node</span><br></pre></td></tr></table></figure><p>当在各个项目目录中，用这个只有一行的Dockerfile构建镜像时，之前基础镜像的那三行ONBUILD就会执行，成功的将当前项目的代码复制进镜像，并且针对本项目进行npm install，生成对应镜像</p><h4 id="多阶段构建"><a href="#多阶段构建" class="headerlink" title="多阶段构建"></a>多阶段构建</h4><p>在17.05之前，构建Docker镜像通常会采用两种方式</p><h5 id="全部放入一个Dockerfile"><a href="#全部放入一个Dockerfile" class="headerlink" title="全部放入一个Dockerfile"></a>全部放入一个Dockerfile</h5><p>一种方式是将所有的构建过程编包含在一个Dockerfile中，包括项目以及依赖库的编译、测试、打包等流程，这里可能会有一些问题：</p><ul><li>Dockerfile特别长，可维护性降低</li><li>镜像层次多，镜像体积较大，部署时间变长</li><li>源代码存在泄漏的问题</li></ul><p>例如：编写app.go文件，输出Hello World!</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line">function main()&#123;</span><br><span class="line">    fmt.Printf(<span class="string">'Hello World!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写Dockerfile.one文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.9-alpine</span><br><span class="line">RUN apk --no-cache add got ca-certificates</span><br><span class="line">WORKDIR /go/src/github.com/go/helloworld/</span><br><span class="line">COPY app.go .</span><br><span class="line">RUN go get -d -v github.com/go-sql-driver/mysql \</span><br><span class="line">&amp;&amp; CGO_ENABLED=0 GOOS=linux go buld -a -installsuffix cgo -o app . \</span><br><span class="line">&amp;&amp; cp /go/src/github.com/go/helloworld/app/root</span><br><span class="line"></span><br><span class="line">WORKDIR /root/</span><br><span class="line">CMD ["./app"]</span><br></pre></td></tr></table></figure><p>构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t go/helloworld:1 -f Dockerfile.one</span><br></pre></td></tr></table></figure><h5 id="分割到多个Dockerfile"><a href="#分割到多个Dockerfile" class="headerlink" title="分割到多个Dockerfile"></a>分割到多个Dockerfile</h5><p>另一种方式，就是事先在一个Dockerfile将项目以及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要编写两个Dockerfile和一些编译脚本才能将两个阶段自动整合起来，这种方式虽然可以很好规避第一种方式存在的风险，但明显部署过程比较复杂</p><p>Dockerfile.build文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.9-alpine</span><br><span class="line">RUN apk --no-cache add git</span><br><span class="line">WORKDIR /go/src/github.com/go/helloworld</span><br><span class="line">COPY app.go .</span><br><span class="line">RUN go get -d -v github.com/go-sql-driver/mysql \</span><br><span class="line">  &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .</span><br></pre></td></tr></table></figure><p>Dockerfile.copy文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM alpine:latest</span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY app .</span><br><span class="line">CMD ["./app"]</span><br></pre></td></tr></table></figure><p>新建build.sh</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">echo Building go/helloworld:build</span><br><span class="line"></span><br><span class="line">docker build -t go/helloworld:build . -f Dockerfile.build</span><br><span class="line"></span><br><span class="line">docker create --name extract go/helloworld:build</span><br><span class="line">docker cp extrace:go/src/github.com/go/helloworld/app ./app</span><br><span class="line">docker rm -f extract</span><br><span class="line"></span><br><span class="line">echo Building go/helloworld:2</span><br><span class="line"></span><br><span class="line">docker build --no-cache -t go/helloworld:2 -f Dockerfile.copy </span><br><span class="line">rm ./app</span><br></pre></td></tr></table></figure><p>运行脚本即可构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x build.sh</span><br><span class="line">./build.sh</span><br></pre></td></tr></table></figure><p>对比两种生成的镜像大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br><span class="line"></span><br><span class="line">REPOSITORY      TAG    IMAGE ID        CREATED         SIZE</span><br><span class="line">go/helloworld   2      f7cf3465432c    22 seconds ago  6.47MB</span><br><span class="line">go/helloworld   1      f55d3e16affc    2 minutes ago   295MB</span><br></pre></td></tr></table></figure><h5 id="使用多阶段构建"><a href="#使用多阶段构建" class="headerlink" title="使用多阶段构建"></a>使用多阶段构建</h5><p>为了解决以上的问题，17.05后开始支持多阶段构建（multistage builds）,使用多阶段构建可以解决上面的问题，并只需要编写一个Dockerfile：</p><p>例如：</p><p>编写Dockerfile文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.9-alpine as builder</span><br><span class="line">RUN apk --no-cache add git</span><br><span class="line">WORKDIR /go/src/github.com/go/helloworld/</span><br><span class="line">RUN go get -d -v github.com/go-sql-driver/mysql</span><br><span class="line">COPY app.go .</span><br><span class="line">RUN CGO_ENABLED=0 GOOS=linux go build -a installsuffix cgo -o app</span><br><span class="line">FROM alpine:latest as prod</span><br><span class="line">RUN apk --no-cache add ca-certificates</span><br><span class="line">WORKDIR /root/</span><br><span class="line">COPY --from=0 /go/src/github.com/go/helloworld/app .</span><br><span class="line">CMD ["./APP"]</span><br></pre></td></tr></table></figure><p>构建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t go/helloworld:3 .</span><br></pre></td></tr></table></figure><p>对比三个镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br><span class="line"></span><br><span class="line">REPOSITORY        TAG   IMAGE ID         CREATED            SIZE</span><br><span class="line">go/helloworld     3     d6911ed9c846     7 seconds ago      6.47MB</span><br><span class="line">go/helloworld     2     f7cf3465432c     22 seconds ago     6.47MB</span><br><span class="line">go/helloworld     1     f55d3e16affc     2 minutes ago      295MB</span><br></pre></td></tr></table></figure><p>很明显使用多阶段构建的镜像体积小，同时也解决了上边的问题</p><h5 id="只构建一阶段的镜像"><a href="#只构建一阶段的镜像" class="headerlink" title="只构建一阶段的镜像"></a>只构建一阶段的镜像</h5><p>使用as为某一阶段命令，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM golang:1.9-alpine as builder</span><br></pre></td></tr></table></figure><p>只构建builder阶段的镜像，可以在使用 docker build的时候加上<code>--target</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --target builder -t username/imagename:tag .</span><br></pre></td></tr></table></figure><h5 id="构建时从其他镜像复制文件"><a href="#构建时从其他镜像复制文件" class="headerlink" title="构建时从其他镜像复制文件"></a>构建时从其他镜像复制文件</h5><p>上面的例子使用 <code>COPY --from=0 /go/src/github.com/go/helloworld/app .</code>从上一阶段的镜像中复制文件，我们可以复制任意镜像中的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY --from=nginx:latest /ect/nginx/nginx.conf /nginx.conf</span><br></pre></td></tr></table></figure><h4 id="其他制作镜像的方式"><a href="#其他制作镜像的方式" class="headerlink" title="其他制作镜像的方式"></a>其他制作镜像的方式</h4><h5 id="从rootfs压缩包导入"><a href="#从rootfs压缩包导入" class="headerlink" title="从rootfs压缩包导入"></a>从rootfs压缩包导入</h5><p>格式：<code>docker import [选项] &lt;文件&gt;|&lt;URL&gt;|- [&lt;仓库名&gt;[:&lt;标签&gt;]]</code></p><p>压缩包可以是本地文件，远程Web文件，甚至是从标准输入中得出的，压缩包就会在镜像 <code>/</code>目录展开，并直接作为镜像第一层提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个OpenVZ的Ubuntu14.04模板的镜像：</span></span><br><span class="line">docker import \</span><br><span class="line">http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz \</span><br><span class="line">    openvz/ubuntu:14.04</span><br><span class="line">Downloading from http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz</span><br><span class="line">sha256:f477a6e18e989839d25223f301ef738b69621c4877600ae6467c4e5289822a79B/78.42 MB</span><br></pre></td></tr></table></figure><p>这条命令自动下载了 <code>ubuntu-14.04-x86_64-minimal.tar.gz</code> 文件，并且作为根文件系统展开导入，并保存为镜像 <code>openvz/ubuntu:14.04</code></p><p>导入成功后，使用 docker image ls可以看到这个导入的镜像</p><p>看到历史会看到描述中有导入的文件链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">history</span> openvz/ubuntu:14.04</span></span><br><span class="line">IMAGE               CREATED              CREATED BY          SIZE                COMMENT</span><br><span class="line">f477a6e18e98        About a minute ago                       214.9 MB            Imported from http://download.openvz.org/template/precreated/ubuntu-14.04-x86_64-minimal.tar.gz</span><br></pre></td></tr></table></figure><h5 id="docker-save和docker-load"><a href="#docker-save和docker-load" class="headerlink" title="docker save和docker load"></a>docker save和docker load</h5><p>将镜像保存为一个tar文件，然后传输到另外一个位置，再加载进来。这是在没有Docker Registry的做法，现在已不推荐。镜像迁移直接使用Docker Registry，无论是直接使用Docker Hub还是使用内网私有Registry都可以</p><p><strong>保存镜像</strong></p><p>docker save将镜像保存为归档文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save alpine | gzip &gt; alpine-latest.tar.gz</span><br></pre></td></tr></table></figure><p>然后将它复制到另外一个机器上，用下面的命令加载镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker load -i alpine-latest.tar.gz</span><br><span class="line">Loaded image: alpine:latest</span><br></pre></td></tr></table></figure><p>结合这两个命令和ssh甚至是pv，利用Linux管道可以写一个命令完成从一个机器将镜像迁移到另外一个机器，并且带进度条的功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker save &lt;镜像名&gt; | bzip2 | pv |ssh &lt;用户名&gt;@&lt;主机名&gt; 'cat|docker load'</span><br></pre></td></tr></table></figure><h4 id="镜像实现的原理"><a href="#镜像实现的原理" class="headerlink" title="镜像实现的原理"></a>镜像实现的原理</h4><p>Docker镜像是怎么实现增量的修改和维护的？</p><p>每个镜像都由多层次构成，Docker使用Union FS将这些不同层结合到一个镜像中去。</p><p>通常Union FS有两个用途，一方面可以实现不借助LVM,RAID将多个disk挂在同一个目录下，另一个更常用的就是讲一个只读的分支和一个可写的分支联合在一起。</p><h2 id="操作容器"><a href="#操作容器" class="headerlink" title="操作容器"></a>操作容器</h2><p>简单来说，容器似乎运行的一个或一组应用，以及它们的运行态环境，虚拟机可以理解为模拟运行的一整套操作系统（提供了运行态环境和其他系统环境）和跑在上面的应用</p><h4 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h4><p>启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。因为Docker的容器很轻级，用户可以随时删除和新建容器。</p><h5 id="新建并启动"><a href="#新建并启动" class="headerlink" title="新建并启动"></a>新建并启动</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出Hello World后终止容器</span></span><br><span class="line">docker run ubuntu:14.04 /bin/echo 'Hello world'</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动一个bash终端，允许用户进行交互,-t选项让Docker分配一个伪终端pseudo-tty并绑定到容器的标准输入上，-i则让容器的标准输入保持打开。在交互模式下，用户可以通过所创建的终端来输入命令</span></span><br><span class="line">docker run -t -i ubuntu:14.04 /bin/bash</span><br></pre></td></tr></table></figure><p>当利用 docker run来创建容器时，Docker在后台运行的标准操作包括：</p><ul><li>检查本地是否存在指定的镜像，不存在就从共有仓库下载</li><li>利用镜像创建并启动一个容器</li><li>分配一个文件系统，并在只读的镜像层外面挂载一层可读层</li><li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</li><li>从地址池配置一个ip地址给容器</li><li>执行用户指定的应用程序</li><li>执行完毕后容器被终止</li></ul><h5 id="启动已终止的容器"><a href="#启动已终止的容器" class="headerlink" title="启动已终止的容器"></a>启动已终止的容器</h5><p>docker container start命令可以将一个已经终止的容器启动运行。</p><p>容器的核心为所执行的应用程序，所需要的资源都是应用程序运行所必需的，除此之外没有其他资源。可以在伪终端中利用ps或top来查进程信息</p><h3 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h3><p>更多时候，需要让Docker在后台运行而不是直接把执行命令的结果输出在当前宿主机下。可以通过添加 <code>-d</code>参数实现。</p><p>不用 <code>-d</code>参数运行容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run ubuntu:17.10 /bin/sh -c "while true;do echo hello world;sleep 1;done"</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>容器会把输出结果stdout打印到宿主主机上面</p><p>如果使用了 <code>-d</code>参数运行容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d ubuntu:17.10 /bin/sh -c "while true;do echo hello world; sleep 1;done"</span><br><span class="line">77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a</span><br></pre></td></tr></table></figure><p>此时容器会在后台运行并不会把输出结果打印到宿主机上面（输出结果可以用docker logs查看）。</p><p>注：容器是否会长久运行，和 docker run 指令的命令有关，和 <code>-d</code>参数无关。</p><p>使用 <code>-d</code>参数启动后返回一个唯一的id，可以通过 docker container ls命令来查看容器信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker container ls</span><br><span class="line">CONTAINER ID  IMAGE         COMMAND               CREATED        STATUS       PORTS NAMES</span><br><span class="line">77b2dc01fe0f  ubuntu:17.10  /bin/sh -c 'while tr  2 minutes ago  Up 1 minute        agitated_wright</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 docker icontainer logis获取容器的输出信息</span></span><br><span class="line">docker container logs[container ID or NEWS]</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h3 id="终止"><a href="#终止" class="headerlink" title="终止"></a>终止</h3><p>使用 docker container stop 来终止一个运行中的容器</p><p>当Docker 容器中指定的应用终结时，容器也会自动终止。上面只启动了一个容器，用户可以通过exit或者ctrl+d来推出终端，所创建的容器立刻终止。</p><p>终止状态的容器可以使用 docker containers ls -a命令看到例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE                    COMMAND                CREATED             STATUS                          PORTS               NAMES</span><br><span class="line">ba267838cc1b        ubuntu:14.04             "/bin/bash"            30 minutes ago      Exited (0) About a minute ago                       trusting_newton</span><br><span class="line">98e5efa7d997        training/webapp:latest   "python app.py"        About an hour ago   Exited (0) 34 minutes ago                           backstabbing_pike</span><br></pre></td></tr></table></figure><p>然后通过 docker run restart命令会让一个运行态的容器终止，然后再重新启动它。</p><h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><p>使用 <code>-d</code>参数时，容器启动后会进入后台。某些时候需要进入容器操作，包括docker attch命令或docker exec命令，推荐使用docker exec</p><h4 id="attch命令"><a href="#attch命令" class="headerlink" title="attch命令"></a>attch命令</h4><p>docker attch是Docker自带命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit ubuntu</span><br><span class="line">243c32535da7d142fb0e6df616a3c3ada0b8ab417937c853a9e1c251f499f550</span><br><span class="line"></span><br><span class="line">docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">243c32535da7        ubuntu:latest       "/bin/bash"         18 seconds ago      Up 17 seconds                           nostalgic_hypatia</span><br><span class="line"></span><br><span class="line">docker attach 243c</span><br><span class="line">root@243c32535da7:/#</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果从这个stdin中<span class="built_in">exit</span>，会导致容器的停止</span></span><br></pre></td></tr></table></figure><h4 id="exec命令"><a href="#exec命令" class="headerlink" title="exec命令"></a>exec命令</h4><p><strong>-i -t参数</strong></p><p>docker exec可以跟多个参数</p><p>只用 <code>-i</code>参数时，由于没有分配伪终端，界面没有Linux命令符，但命令执行结果仍然可以返回</p><p>当 <code>-i</code>/<code>-t</code>参数一起使用时，可以看到Linux命令提示符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker run -dit ubuntu</span><br><span class="line">69d137adef7a8a689cbcb059e94da5489d3cddd240ff675c640c8d96e84fe1f6</span><br><span class="line"></span><br><span class="line">docker container ls</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">69d137adef7a        ubuntu:latest       "/bin/bash"         18 seconds ago      Up 17 seconds                           zealous_swirles</span><br><span class="line"></span><br><span class="line">docker exec -i 69d1 bash</span><br><span class="line">ls </span><br><span class="line">bin</span><br><span class="line">boot</span><br><span class="line">dev</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">docker exec -it 69d1 bash</span><br><span class="line">root@xxx:/#</span><br></pre></td></tr></table></figure><p>如果从这个stdin中exit，不会导致容器的停止。这就是为什么推荐使用 docker exec的原因</p><h3 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h3><h5 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker container ls -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                    PORTS               NAMES</span><br><span class="line">7691a814370e        ubuntu:14.04        "/bin/bash"         36 hours ago        Exited (0) 21 hours ago                       test</span><br><span class="line"></span><br><span class="line">docker export  7691a814370e &gt; ubuntn.tar</span><br><span class="line"><span class="meta">#</span><span class="bash">这样导出容器快照到本地文件</span></span><br></pre></td></tr></table></figure><h5 id="导入容器快照"><a href="#导入容器快照" class="headerlink" title="导入容器快照"></a>导入容器快照</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker import 从容器快照文件中再导入为镜像</span></span><br><span class="line">cat ubuntu.tar | docker import - test/ubuntu:v1.0</span><br><span class="line">docker image ls</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE</span><br><span class="line">test/ubuntu         v1.0                9d37a6082e97        About a minute ago   171.3 MB</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定URL或者某个目录来录入</span></span><br><span class="line">docker import http://example.com/exampleimage.tgz example/imagerepo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 用户既可以使用 docker load 来导入镜像存储文件到本地镜像库，也可以使用 docker import 来导入一个容器快照到本地镜像库。这两者区别在于容器快照文件将丢弃所有历史记录和元数据信息（即保存容器当时的快照状态），而镜像存储文件将保存完整记录，体积也要大，此外，从容器快照文件导入时可以重新制定标签等元数据信息</span></span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker container rm haha</span><br><span class="line">haha</span><br></pre></td></tr></table></figure><p>删除一个运行中的容器，可以添加 <code>-f</code>，Docker会发送 <code>SIGKILL</code>信号给容器</p><p>清理所有处于终止状态的容器:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker container prune</span><br></pre></td></tr></table></figure><h2 id="访问仓库"><a href="#访问仓库" class="headerlink" title="访问仓库"></a>访问仓库</h2><p>仓库Repository是集中存放镜像的地方。</p><p>一个容易混淆的概念是注册服务器（Registry）。实际上注册服务器是管理仓库的具体服务器，每个服务器可以有多个仓库，而每个仓库下面可以有多个镜像。从这方面来说，仓库被认为是一个具体的项目或者目录。例如对于 仓库地址<code>dl.dockerpool.com/ubuntu</code>来说，<code>dl.dockerpool.com</code>是注册服务器地址，<code>ubuntu</code>是仓库名。大部分时候并不需要严格区分这两者的概念</p><h3 id="Docker-Hub"><a href="#Docker-Hub" class="headerlink" title="Docker Hub"></a>Docker Hub</h3><p>Docker官方维护了一个公共仓库Docker Hub，大部分需求可以在Docker Hub中直接下载镜像实现</p><p>在 <a href="https://cloud.docker.com">https://cloud.docker.com</a> 免费注册一个 Docker 账号，通过docker login命令交互式输入用户名和密码完成在命令行登录，docker logout退出登录。</p><p>docker search命令查找官方仓库镜像，利用 docker pull命令将它下载到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> centos为关键词</span></span><br><span class="line">docker search centos</span><br><span class="line">NAME                                            DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">centos                                          The official build of CentOS.                   465       [OK]</span><br><span class="line">tianon/centos                                   CentOS 5 and 6, created using rinse instea...   28</span><br><span class="line">blalor/centos                                   Bare-bones base CentOS 6.5 image                6                    [OK]</span><br><span class="line">saltstack/centos-6-minimal                                                                      6                    [OK]</span><br><span class="line">tutum/centos-6.4                                DEPRECATED. Use tutum/centos:6.4 instead. ...   5                    [OK]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 可以看到返回包含关键字的镜像，其中包括镜像名字、描述、收藏数（表示该镜像的受关注程度）、是否官方创建、是否自动创建。官方的镜像说明是官方项目组创建和维护的，automated资源允许用户验证镜像的来源和内容。根据是否官方提供，资源镜像可以分为两种：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一种是类centor这样的镜像，被称为基础镜像或根镜像。这些基础镜像由Docker公司创建、验证、支持、提供。这样的镜像往往使用单个名词作为名字</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 还有一种类型，比如tianon/centos镜像，由Docker用户创建并维护的，往往带有用户名称前缀，可以通过前缀username/来指定某个用户名提供的镜像，比如tianon用户</span></span><br></pre></td></tr></table></figure><p>查找的时候通过 <code>--filter=stars=N</code>参数可以指定仅显示收藏数量为N以上的镜像</p><h4 id="推送镜像"><a href="#推送镜像" class="headerlink" title="推送镜像"></a>推送镜像</h4><p>用户登录后通过docker push推送自己的镜像到Docker Hub。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> username替换为Docker 账户用户名</span></span><br><span class="line">docker tag ubuntu:17.10 username/ubuntu:17.10</span><br><span class="line"></span><br><span class="line">docker image ls</span><br><span class="line">REPOSITORY                                               TAG                    IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu                                                   17.10                  275d79972a86        6 days ago          94.6MB</span><br><span class="line">username/ubuntu                                          17.10                  275d79972a86        6 days ago          94.6MB</span><br><span class="line"></span><br><span class="line">docker push username/ubuntu:17.10</span><br><span class="line"></span><br><span class="line">docker search username</span><br><span class="line">NAME                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">username/ubuntu</span><br></pre></td></tr></table></figure><h4 id="自动创建"><a href="#自动创建" class="headerlink" title="自动创建"></a>自动创建</h4><p>Automated Builds功能对于需要经常升级镜像内程序来说，十分方便。</p><p>用户创建了镜像，安装了某个软件，如果软件发布新版本则需要手动更新镜像。而自动创建运行用户通过Docker Hub指定一个跟踪网站上的项目，Github/BitBucket等，一旦项目发生新的提交或者创建新的标签，Docker Hub会自动构建镜像并推送到 Docker Hub中</p><p>配置自动创建，有几个步骤：</p><ul><li>创建并登陆Docker Hub，以及目标网站</li><li>在目标网站中连接账户到Docker Hub</li><li>在Docker Hub中配置一个自动创建</li><li>选取一个目标网站的项目（需含有Dockerfile）和分支</li><li>指定Dockerfile的位置，并提交创建</li></ul><p>之后可以在Docker Hub的自动创建页面中跟踪每次创建的状态</p><h3 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h3><p>用户可以创建一个本地仓库供私人使用</p><p>docker-registry是官方提供的工具，用户构建私有镜像库</p><h4 id="安装docker-registry"><a href="#安装docker-registry" class="headerlink" title="安装docker-registry"></a>安装docker-registry</h4><p>通过官方registry镜像来运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 5000:5000 --restart=always --name registry registry</span><br></pre></td></tr></table></figure><p>这将使用官方的registry镜像来启动私有仓库，默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code>目录下，可以通过<code>-v</code>参数指定镜像文件存在本地的指定路径。例如下面的例子将上传的镜像放到本地的<code>/opt/data/registry</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">-p 5000:5000</span><br><span class="line">-v /opt/data/registry:/var/lib/registry \</span><br><span class="line">registry</span><br></pre></td></tr></table></figure><h4 id="上传、搜索、下载"><a href="#上传、搜索、下载" class="headerlink" title="上传、搜索、下载"></a>上传、搜索、下载</h4><p>创建好私有仓库后，可以使用docker tag来标记一个镜像，然后将它推送到仓库，例如私有仓库地址为 <code>127.0.0.1:5000</code>,现在本机已有的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure><p>docker tag将 ubuntu:latest镜像标记为 <code>127.0.0.1:5000/ubuntu/:latest</code>，格式为：</p><blockquote><p>docker tag IMAGE[:TAG] [REGISTRT_HOST[:REGISTRY_PROT]/]REGISTORY[:TAG]</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker tag ubuntu:latest 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">docker image ls</span><br><span class="line">REPOSITORY                        TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">ubuntu                            latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br><span class="line">127.0.0.1:5000/ubuntu:latest      latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure><p>docker push上传标记的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker push 127.0.0.1:5000/ubtuntu:latest</span><br><span class="line">The push refers to repository [127.0.0.1:5000/ubuntu]</span><br><span class="line">373a30c24545: Pushed</span><br><span class="line">a9148f5200b0: Pushed</span><br><span class="line">cdd3de0940ab: Pushed</span><br><span class="line">fc56279bbb33: Pushed</span><br><span class="line">b38367233d37: Pushed</span><br><span class="line">2aebd096e0e2: Pushed</span><br><span class="line">latest: digest: sha256:fe4277621f10b5026266932ddf760f5a756d2facd505a94d2da12f4f52f71f5a size: 1568</span><br></pre></td></tr></table></figure><p>curl查看仓库中的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl 127.0.0.1:5000/v2/_catalog</span><br><span class="line">&#123;"repositories":["ubuntu"]&#125;</span><br></pre></td></tr></table></figure><p>删除已有的镜像从私有仓库下载镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker image rm 127.0.0.1:5000/ubuntu:latest</span><br><span class="line"></span><br><span class="line">docker pull 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">Pulling repository 127.0.0.1:5000/ubuntu:latest</span><br><span class="line">ba5877dc9bec: Download complete</span><br><span class="line">511136ea3c5a: Download complete</span><br><span class="line">9bad880da3d2: Download complete</span><br><span class="line">25f11f5fb0cb: Download complete</span><br><span class="line">ebc34468f71d: Download complete</span><br><span class="line">2318d26665ef: Download complete</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> docker image ls</span></span><br><span class="line">REPOSITORY                         TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</span><br><span class="line">127.0.0.1:5000/ubuntu:latest       latest              ba5877dc9bec        6 weeks ago         192.7 MB</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>如果不想使用 <code>127.0.0.1:5000</code> 作为仓库地址，比如想让本网段的其他主机也能把镜像推送到私有仓库。得把例如 <code>192.168.199.100:5000</code> 这样的内网地址作为私有仓库地址，这时会发现无法成功推送镜像。</p><p>这是因为 Docker 默认不允许非 <code>HTTPS</code> 方式推送镜像。通过 Docker 的配置选项来取消这个限制.</p><h4 id="Ubuntu-14-04-Debian-7-Wheezy"><a href="#Ubuntu-14-04-Debian-7-Wheezy" class="headerlink" title="Ubuntu 14.04, Debian 7 Wheezy"></a>Ubuntu 14.04, Debian 7 Wheezy</h4><p>对于使用 <code>upstart</code> 的系统而言，编辑 <code>/etc/default/docker</code> 文件，在其中的 <code>DOCKER_OPTS</code> 中增加如下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS=<span class="string">"--registry-mirror=https://registry.docker-cn.com --insecure-registries=192.168.199.100:5000"</span></span><br></pre></td></tr></table></figure><p>重新启动服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker restart</span><br></pre></td></tr></table></figure><h4 id="Ubuntu-16-04-Debian-8-centos-7"><a href="#Ubuntu-16-04-Debian-8-centos-7" class="headerlink" title="Ubuntu 16.04+, Debian 8+, centos 7"></a>Ubuntu 16.04+, Debian 8+, centos 7</h4><p>对于使用 <code>systemd</code> 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在新建该文件）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirror"</span>: [</span><br><span class="line">    <span class="string">"https://registry.docker-cn.com"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"insecure-registries"</span>: [</span><br><span class="line">    <span class="string">"192.168.199.100:5000"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：该文件必须符合 <code>json</code> 规范，否则 Docker 将不能启动。</p></blockquote><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>对于 Docker for Windows 、 Docker for Mac 在设置中编辑 <code>daemon.json</code> 增加和上边一样的字符串即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.cntofu.com/book/139/index.html&quot;&gt;docker学习，作者源于这里&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="docker" scheme="http://laibh.top/categories/docker/"/>
    
    
      <category term="docker" scheme="http://laibh.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs回顾</title>
    <link href="http://laibh.top/2020-06-19-NodeJS%E5%9B%9E%E9%A1%BE.html"/>
    <id>http://laibh.top/2020-06-19-NodeJS回顾.html</id>
    <published>2020-06-19T08:46:38.000Z</published>
    <updated>2020-07-11T03:24:57.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h1><h2 id="模块与文件"><a href="#模块与文件" class="headerlink" title="模块与文件"></a>模块与文件</h2><h3 id="require-的加载机制"><a href="#require-的加载机制" class="headerlink" title="require 的加载机制"></a>require 的加载机制</h3><h4 id="模块的分类"><a href="#模块的分类" class="headerlink" title="模块的分类"></a>模块的分类</h4><p>系统模块</p><ul><li>C/C++模块，也叫build-in内建模块，一般用于native模块嗲用，在require出去</li><li>native模块，在开发中使用的Node.js 的 http/buffer/fs等，底层也是调用的内建模块（C/C++）</li></ul><p>第三方模块：</p><p>非Node.js自带的模块被称为第三方模块，会分成路径形式的文件模块（以<code>.</code>、<code>..</code>、<code>/</code>开头的）和自定义的模块（比如express/koa/moment.js等）</p><p>在 Node.JS 中模块加载一般会经历3个步骤：路径分析、文件定位、编译执行</p><p>按照模块的分类，按照以下的顺序进行优先加载：</p><ul><li>系统缓存：模块被执行之后会进行缓存，首先是先进行缓存加载，判断换粗中是否有值。</li><li>系统模块：也就是原生模块，优先级次于系统缓存，部分核心模块已经被编译成二进制，省略了路径分析、文件定位，直接加载在内存中，系统模块定义在 Node.js 源码的lib目录下。</li><li>文件模块：优先加载 <code>.</code>、<code>..</code>、<code>/</code>开头的，如果文件没有加上拓展名，会依次按照<code>.js</code>、<code>.json</code>、<code>.node</code>尝试进行拓展名补足。（在尝试过程中也是以<strong>同步阻塞模式</strong>来判断文件是否存在的，从性能优化角度来看，<code>.json</code>、<code>node</code>最好还是加上文件的拓展名）</li><li>目录作为模块：文件模块加载过程中没有找到，但发现这是一个目录，这个适合就会把这个目录当做一个包来处理，Node采用了commonjs规范，会先在项目的根目录查找package.json文件，取出文件中定义的main属性描述的入口文件进行加载，也没有加载到，则会抛出默认错误：Error：Cannot find module ‘lib/hello.js’</li><li>node_modules目录加载：对于系统模块，路径文件模块都找不到，Nodejs会从当前模块的父目录进行查找，直到系统的根目录</li></ul><h3 id="module-exports-与-exports-的区别"><a href="#module-exports-与-exports-的区别" class="headerlink" title="module.exports 与 exports 的区别"></a>module.exports 与 exports 的区别</h3><p>exports相当于 module.exports 的快捷方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> exports = <span class="built_in">module</span>.exports</span><br></pre></td></tr></table></figure><p>但是不能改变 exports 的指向，我们可以通过 <code>exports.test = &#39;a&#39;</code>，这样来导出一个对象，但是不能通过下面的例子直接赋值，这样会改变 exports 的指向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法，将会得到 undefined</span></span><br><span class="line">exports = &#123;</span><br><span class="line">   <span class="string">'a'</span>:<span class="number">1</span>,</span><br><span class="line">   <span class="string">'b'</span>:<span class="number">2</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line">modules.exports =&#123;</span><br><span class="line">   <span class="string">'a'</span>:<span class="number">1</span>,</span><br><span class="line">   <span class="string">'b'</span>:<span class="number">2</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模块循环引用问题"><a href="#模块循环引用问题" class="headerlink" title="模块循环引用问题"></a>模块循环引用问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a模块start'</span>);</span><br><span class="line">exports.test = <span class="number">1</span>;</span><br><span class="line">undeclaredVariable = <span class="string">'a模块为声明变量'</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a模块加载完毕：b.test值'</span>,b.test);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b模块start'</span>);</span><br><span class="line">exports.test = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'undeclaredVariable:'</span>,undeclaredVariable)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b模块加载完毕：a.test值：'</span>,a.test)</span><br></pre></td></tr></table></figure><p>执行 <code>node a.js</code>,结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a模块start</span><br><span class="line">b模块start</span><br><span class="line">undeclaredVariable:a模块未声明变量</span><br><span class="line">b模块加载完毕：a.test值：1</span><br><span class="line">a模块加载完毕：b.test值：2</span><br></pre></td></tr></table></figure><p>启动a.js会加载b.js，那么在b.js中又加载到了a.js，但是此时a.js模块hi阿咩有执行完，返回的是一个a.js模块的exports对象未完成的副本给到b.js模块（因此不会陷入死循环），然后b.js完成加载之后将exports 对象退供给a.js模块</p><h4 id="a-模块中的-undeclaredVariable-变量在-b-js-是否会打印？"><a href="#a-模块中的-undeclaredVariable-变量在-b-js-是否会打印？" class="headerlink" title="a 模块中的 undeclaredVariable 变量在 b.js 是否会打印？"></a>a 模块中的 undeclaredVariable 变量在 b.js 是否会打印？</h4><p>undeclaredVariable 是一个未声明的变量，也就是一个挂在全局的变量，那么在其他地方是可以拿得到的</p><h4 id="假设有-a-js、b-js-两个模块相互引用，会有什么问题，会不会陷入死循环？"><a href="#假设有-a-js、b-js-两个模块相互引用，会有什么问题，会不会陷入死循环？" class="headerlink" title="假设有 a.js、b.js 两个模块相互引用，会有什么问题，会不会陷入死循环？"></a>假设有 a.js、b.js 两个模块相互引用，会有什么问题，会不会陷入死循环？</h4><p>不会陷入死循环</p><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><h3 id="Buffer与Cache的区别"><a href="#Buffer与Cache的区别" class="headerlink" title="Buffer与Cache的区别"></a>Buffer与Cache的区别</h3><h4 id="缓冲（Buffer）"><a href="#缓冲（Buffer）" class="headerlink" title="缓冲（Buffer）"></a>缓冲（Buffer）</h4><p>缓冲是用于处理二进制流数据，将数据存储起来，它是临时性的，对于流式数据来说，会采用缓冲区将数据临时存储起来，等缓冲到一定大小的时候存入硬盘中。视频播放器就是一个经典例子。</p><h4 id="缓存（Cache）"><a href="#缓存（Cache）" class="headerlink" title="缓存（Cache）"></a>缓存（Cache）</h4><p>缓存可以看做一个中间层，可以是永久性的将热点数据进行缓存，使得访问速度更快。例如我们通过对 memory、Redis等将数据从硬盘或者第三方接口中请求过来进行缓存，目的就是将数据存于内存的缓存区中，这样对同一个资源进行访问，速度会更快，也就是性能优化的一个重要点。</p><h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><h4 id="什么是进程（Process）和线程（Thread），之间的区别"><a href="#什么是进程（Process）和线程（Thread），之间的区别" class="headerlink" title="什么是进程（Process）和线程（Thread），之间的区别"></a>什么是进程（Process）和线程（Thread），之间的区别</h4><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>进程是计算中程序关于数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器。启动一个服务，运行一个实例，就是开一个服务进程。多进程就是进程的复制（fork），fork出来的每个进程都有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了IPC通信，进程之间才可以数据共享。</p><h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><p>线程是操作系统能够进行运算调度的最小单位，线程是隶属进程的，被包含与进程之中的。一个线程只能隶属一个进程，但是一个进程是可以拥有多个线程的。</p><p>同一个代码，可以根据系统CPU核心数启动多个进程，每个进程都有属于自己的独立运行空间，进程之间是不互相影响的。同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述和信号处理等。但 同一进程中的多个线程有各自的调用栈，自己的寄存器环境，自己的线程本地存储。</p><h3 id="什么是孤儿进程"><a href="#什么是孤儿进程" class="headerlink" title="什么是孤儿进程"></a>什么是孤儿进程</h3><p>父进程创建子进程之后，父进程退出了，但是父进程对应的一个或者多个子进程还在运行，这些子进程会被系统的init进程收养，对应的程序ppid为1，这就是孤儿进程。</p><h3 id="创建多进程时，代码里有app-listen-port-在进行fork时，为什么没有报端口被占用"><a href="#创建多进程时，代码里有app-listen-port-在进行fork时，为什么没有报端口被占用" class="headerlink" title="创建多进程时，代码里有app.listen(port)在进行fork时，为什么没有报端口被占用"></a>创建多进程时，代码里有<code>app.listen(port)</code>在进行fork时，为什么没有报端口被占用</h3><p>端口被占用的情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.js</span></span><br><span class="line"><span class="keyword">const</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</span><br><span class="line"><span class="keyword">const</span> cups = <span class="built_in">require</span>(<span class="string">'os'</span>).cups();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;cups.length;i++)&#123;</span><br><span class="line">    <span class="keyword">const</span> worker = fork(<span class="string">'worker.js'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'worker process created, pid: %s ppid: %s'</span>, worker.pid, process.pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(<span class="string">'I am worker,pid:'</span>+process.pid+<span class="string">', ppid: '</span>+process.pid)</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台执行node master.js只有一个worker 可以监听 3000 端口，其余会抛出 Error:listen EADDRINUSE :::3000错误</span></span><br></pre></td></tr></table></figure><p>多进程模式可通过句柄传递不会有端口占用的问题。</p><p>当父子进程之间建立IPC通道之后，通过子进程对象的send方法发送消息，第二个参数sendHandle就是句柄，可以是TCP套接字，TCP服务器、UDP套接字等，为了解决上面多进程端口占用问题，将主进程的socket传递到子进程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.js</span></span><br><span class="line"><span class="keyword">const</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</span><br><span class="line"><span class="keyword">const</span> cups = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus();</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer();</span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br><span class="line">process.title = <span class="string">'node-master'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;cpus.length;i++)&#123;</span><br><span class="line">    <span class="keyword">const</span> worker = fork(<span class="string">'worker.js'</span>)</span><br><span class="line">    worker.send(<span class="string">'server'</span>,server);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'worker process created, pid: %s ppid: %s'</span>, worker.pid, process.pid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(i+<span class="number">1</span> === cpus.length)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'serve close'</span>);</span><br><span class="line">        server.close(); <span class="comment">// 关闭服务器监听，交由子进程处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.end(<span class="string">'I am worker, pid: '</span> + process.pid + <span class="string">', ppid: '</span> + process.ppid);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> worker;</span><br><span class="line">process.title = <span class="string">'node-worker'</span>;</span><br><span class="line">process.on(<span class="string">'message'</span>,(message,sendHandle)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(message === <span class="string">'server'</span>)&#123;</span><br><span class="line">        worker = sendHandle;</span><br><span class="line">        worker.on(<span class="string">'connection'</span>,(socket)=&gt;&#123;</span><br><span class="line">            server.emit(<span class="string">'connection'</span>,socket)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="什么是IPC通信，如何建立，什么场景下会使用"><a href="#什么是IPC通信，如何建立，什么场景下会使用" class="headerlink" title="什么是IPC通信，如何建立，什么场景下会使用"></a>什么是IPC通信，如何建立，什么场景下会使用</h3><p>IPC(inter-process communication)，即进程间通信技术，由于每个进程创建之后都有自己的独立地址空间，实现IPC的目的就是进程之间的资源共享访问，实现IPC的方式有多种：管道、消息队列、信号量、Domain Socket，Nodejs通过pipe来实现。</p><p>未使用IPC的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pipe.js</span></span><br><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;</span><br><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">'node'</span>,[<span class="string">'worker.js'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(process.pid,child.pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'I am worker,PID:'</span>,process.pid)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 node pipe.js，输出主线程的id，子线程的id，但是子线程worker.js的信息没有在控制台打印，原因是新创建的子进程有自己的 stdio流</span></span><br></pre></td></tr></table></figure><p>创建一个父进程和子进程之间传递消息的IPC通道实现输出信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改pipe.js让子进程的stdio和当前进程的stdio之间建立管道链接，还可以通过spawn方法的stdio选项建立IPC机制</span></span><br><span class="line"><span class="comment">// pipe.js</span></span><br><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;</span><br><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">'node'</span>,[<span class="string">'worker.js'</span>]);</span><br><span class="line">child.stdout.pipe(process.stdout);</span><br><span class="line"><span class="built_in">console</span>.log(process.pid,child.pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程与子进程的通信</span></span><br><span class="line"><span class="comment">// 父进程在创建子进程之前会先去创建IPC通道并一直监听该通道，之后开始创建子进程并通过环境变量（NODE_CHANNEL_FD）的方式将IPC频道的文件描述符传递给子进程，子进程启动时根据传递的文件描述符去链接IPC通道，从而建立父子进程之间的通信机制。</span></span><br></pre></td></tr></table></figure><h3 id="Node-js是单线程还是多线程，为什么会单线程"><a href="#Node-js是单线程还是多线程，为什么会单线程" class="headerlink" title="Node.js是单线程还是多线程，为什么会单线程"></a>Node.js是单线程还是多线程，为什么会单线程</h3><p>javascript是单线程，在服务端运行环境的nodejs不是单线程。</p><p>浏览器环境中对于DOM的操作是单线程的，避免DOM渲染冲突，在浏览器中UI渲染线程和JS执行引擎是互斥的，一方在执行式都会导致另一方被挂起，这是由JS引擎所决定的。</p><h3 id="关于守护进程，是什么，为什么，怎么编写？"><a href="#关于守护进程，是什么，为什么，怎么编写？" class="headerlink" title="关于守护进程，是什么，为什么，怎么编写？"></a>关于守护进程，是什么，为什么，怎么编写？</h3><p>守护进程运行在后台不受终端影响。</p><h4 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h4><ol><li>创建子进程</li><li>在子进程中创建新会话（调用系统函数setsid）</li><li>改变子进程工作目录（如：’/‘或者’/usr/‘等）</li><li>父进程终止</li></ol><h3 id="编写demo"><a href="#编写demo" class="headerlink" title="编写demo"></a>编写demo</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js文件的处理逻辑使用 spawn创建子进程完成第一步，设置options.detached为true可以使得子进程在父进程退出后继续运行（系统层会调用setsid方法），这是第二步。options.cwd指定当前子进程工作目录不做设置默认继承当前工作目录，这是第三步。运行daemon.unref()退出父进程，第四步。</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startDaemon</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> daemon = spawn(<span class="string">'node'</span>,[<span class="string">'daemon.js'</span>],&#123;</span><br><span class="line">        cwd:<span class="string">'/usr'</span>,</span><br><span class="line">        datached:<span class="literal">true</span>,</span><br><span class="line">        stdio:<span class="string">'ignore'</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'守护进程开启 父进程 pid: %s, 守护进程 pid: %s'</span>, process.pid, daemon.pid);</span><br><span class="line">    daemon.unref();</span><br><span class="line">&#125;</span><br><span class="line">startDaemon();</span><br><span class="line"></span><br><span class="line"><span class="comment">// daemon.js文件哩逻辑开启一个定时器每10秒运行一次，使得这个资源不会退出，同时写入日志到子进程当前的工作目录下</span></span><br><span class="line"><span class="comment">// /usr/daemon.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;Console&#125; = <span class="built_in">require</span>(<span class="string">'console'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Console(fs.createWriteStream(<span class="string">'./stdout.log'</span>),fs.createWriteStream(<span class="string">'./stderr.log'</span>));</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    logger.log(<span class="string">'daemon pid:'</span>,process.pid,<span class="string">'ppid: '</span>,process.ppid)</span><br><span class="line">&#125;,<span class="number">1000</span>*<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>实际工作中守护进程很多，例如PM2,Egg-Cluster等，实际工作上对于守护进程的健壮性要求还是很高的，例如：进程的异常监听，工作进程管理调度，进程挂掉之后重启等等。</p><h3 id="实现一个简单的命令行交互程序"><a href="#实现一个简单的命令行交互程序" class="headerlink" title="实现一个简单的命令行交互程序"></a>实现一个简单的命令行交互程序</h3><p>采用子进程 child_process的spawn方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;</span><br><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">'echo'</span>,[<span class="string">'简单的命令行交互'</span>]);</span><br><span class="line">child.stdout.pipe(process.stdout) <span class="comment">// 将子进程的输出作为当前进程的输入，打印在控制台</span></span><br></pre></td></tr></table></figure><h3 id="进程的当前工作目录是什么，有什么用"><a href="#进程的当前工作目录是什么，有什么用" class="headerlink" title="进程的当前工作目录是什么，有什么用"></a>进程的当前工作目录是什么，有什么用</h3><p>进程的当前工作目录可以通过process.cwd()命令获取，默认为当前启动的目录，如果是创建子进程则继承于父进程的目录，可以通过process.chdir()命令重置，例如通过spawn命令创建的子进程可以指定cwd选项设置子进程的工作目录。</p><p>有什么用，例如fs读取文件，如果设置为相对路径则是相当于当前进程启动的目录进行查找，所以，启动目的设置有误的情况下将无法得到正确的结果。还有一种情况程序里引用第三方模块也是根据当前进程启动的目录来进行查找的</p><h3 id="多进程或者多个Web服务之间的状态共享问题"><a href="#多进程或者多个Web服务之间的状态共享问题" class="headerlink" title="多进程或者多个Web服务之间的状态共享问题"></a>多进程或者多个Web服务之间的状态共享问题</h3><p>多进程模式下各个进程之间是相互独立的，例如用户登录之后seesion的保存，如果保存在服务进程里，那么如果我有4个工作进程，每个进程都要保存一份这是没有必要的。假设服务重启了数据也会丢失。多个Web服务也是一样的，还会出现在A机器创建了Session，当负载均衡分到B机器上之后还需要再创建一份，一般的做法是通过Redis或者数据库来做数据共享</p><h3 id="什么是僵尸进程"><a href="#什么是僵尸进程" class="headerlink" title="什么是僵尸进程"></a>什么是僵尸进程</h3><p>使用fork可以创建子进程，正常情况进程退出，内核要释放进程所占用的资源：打开的文件、占用的内存等，但是进程的PID、退出状态、运行时间等会进行保留，知道父进程调用wait/waitpid来获取子进程的状态信息时，这些资源才会释放。</p><p>如果子进程退出之后，父进程没有调用wait/waitpid来获取子进程的状态，那么保留的进程号将会一直被占用，且占用系统资源，称为僵死或僵尸进程。</p><p>元凶是其父进程，我们把元凶kill掉之后，僵尸进程会变为孤儿进程被系统的 init 进程pid=1的进程所收养，init进程会对这些孤儿进程进行管理（调用wait/waitpid）释放其占用资源。</p><h2 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h2><h3 id="console是异步还是同步的"><a href="#console是异步还是同步的" class="headerlink" title="console是异步还是同步的"></a>console是异步还是同步的</h3><p>console既不是总是同步的，也不总是异步的，是否为同步取决于链接是什么流以及操作系统是Window还是Posix</p><p>同步写将会阻塞实践循环直到写完成。</p><ul><li>文件（Files）：Windows和POSIX平台都是同步</li><li>终端（TTYS）：Windows平台下同步，在POSIX平台下异步</li><li>管道（Pipes）：Windows平台下同步，POSIX平台下异步</li></ul><h3 id="如何实现一个console-log"><a href="#如何实现一个console-log" class="headerlink" title="如何实现一个console.log"></a>如何实现一个console.log</h3><p>可利用 process.stdout将输入流数据输出到输出流（即输出到终端）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.stdout.write(<span class="string">'xxx'</span>+<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><h3 id="为什么console-log-执行完就退出"><a href="#为什么console-log-执行完就退出" class="headerlink" title="为什么console.log()执行完就退出"></a>为什么console.log()执行完就退出</h3><p>一旦产生事件循环，就会长产生一个While(true)的死循环，例如定时器，console.log则没有产生watch/handlers，在事件循环一次就退出了。</p><p>Nodejs进程退出会等待异步处理完成，常见的运维过程中会碰到需要进程优雅退出的场景，Nodejs自然退出是最好的，process.exit是比较粗暴的。</p><p>常见的异步请求：</p><ul><li>http请求，数据库请求等IO请求操作</li><li>net.Server.listen()或者http.Server.listen等端口监听</li><li>fs.write()类型的文件IO操作</li><li>console.log()输出日志</li><li>setTimeout()/setInterval等定时器操作</li><li>process.send()等异步请求发送</li></ul><h2 id="Net模块"><a href="#Net模块" class="headerlink" title="Net模块"></a>Net模块</h2><table><thead><tr><th>OSI七层模型</th><th>TCP/IP五层模型</th><th>描述</th></tr></thead><tbody><tr><td>应用层</td><td>应</td><td>构建于传输层之上常用的HTTP、FTP文件传输协议、SMTP邮件传输协议等</td></tr><tr><td>表示层</td><td>用</td><td>构建于传输层之上常用的HTTP、FTP文件传输协议、SMTP邮件传输协议等</td></tr><tr><td>会话层</td><td>层</td><td>构建于传输层之上常用的HTTP、FTP文件传输协议、SMTP邮件传输协议等</td></tr><tr><td>传输层</td><td>传输层</td><td>向用户提供可靠的端到端服务TCP、UDP</td></tr><tr><td>网络层</td><td>网络层</td><td>IPV4、IPV6</td></tr><tr><td>数据链路层</td><td>数据链路层</td><td>设备驱动和硬件</td></tr><tr><td>物理层</td><td>物理层</td><td>设备驱动和硬件</td></tr></tbody></table><h3 id="什么是TCP协议，什么时候会选择TCP协议"><a href="#什么是TCP协议，什么时候会选择TCP协议" class="headerlink" title="什么是TCP协议，什么时候会选择TCP协议"></a>什么是TCP协议，什么时候会选择TCP协议</h3><p>IP协议是无连接通信协议，IP协议不会占用两个设备之间通信的线路，IP实际上主要负责将每个数据包路由至目的地，但是IP协议没有能确保数据包是否到达，传过去的数据是否按照顺序排列，所以IP数据包是不可靠的。而解决数据不可靠的问题就是由TCP协议来完成。</p><p>TCP（Transmission Control Protocol）是可靠的传输控制协议，三个特点：</p><ul><li>面向链接：需要对方主机在线，并建立链接</li><li>面向字节流：发送多少字节自己说了算，每次选出一段字节发送的时候，都会带上一个序号，这个序号就是发送的这段字节中编号最小的字节的编号。</li><li>可靠：保证数据有序的到达对方主机，每发送一个数据就会期待收到对方的回复，在指定时间内收到了ACK回复，就确认数据到达，如果超过一定的时间没有收到对方的回复，就认为对方没有收到，再重新发送一次。</li></ul><p>TCP报文</p><table><thead><tr><th>源端口（16）</th><th>目的端口（16）</th></tr></thead><tbody><tr><td>TCP序号（32）</td><td>TCP序号（32）</td></tr><tr><td>捎带的确认（32）</td><td>捎带的确认（32）</td></tr><tr><td>首部长度（4）保留（6）Flag（6：URG、ACK、PSH、RST、SYN、FIN）</td><td>窗口尺寸（16）</td></tr><tr><td>TCP校验和（16）</td><td>紧急指针（16）</td></tr><tr><td>数据包内容</td><td>数据包内容</td></tr></tbody></table><p>6个标志位：</p><ul><li>URG,紧急指针标志，当为1时表示紧急指针有效，为0时则忽略紧急指针</li><li>ACK,确认序号标志，为1表示确认有效，为0表示报文不含有确认信息，确认号无误</li><li>PSH,push标志，当为1时就是让接收方收到该TCP报文的时候不进入缓冲区排队而是快速发送给应用程序</li><li>RST,重置连接标志，当连接出现错误的时可以重置，或者用于拒绝非法的报文段和连接请求</li><li>SYN,同步序号，用于建立连接过程</li><li>FIN,finish标志，用于释放连接</li></ul><p>3次握手协议：</p><ol><li>第一次握手，当客户端需要去建立连接时，客户端就会发送SYN包（seq=x）到服务器，然后客户端进入SYN_SEND的状态，代表已经发SYN包过去，并且在等待服务器确认。此时，ACK=0,SYN=1。</li><li>第二次握手，服务器收到SYN包，会进行确认，由上面的标志知道SYN是表示同步序号，这时候会使得 确认号=序号+1，即ack等于x+1,然后服务器也会像客户端发送一个SYN包（seq=y),也就是服务器会发送SYN+ACK包，来表示确认到了客户端的一次握手并且二次握手建立，此时服务器进入SYN_RECV状态。此时，ACK=1,SYN=1。</li><li>第三次握手，客户端收到服务器的SYN+ACK包，然后就会向服务器发送确认包ACK(ack=y+1)和SYN(seq=x+1),等到这个包发送完毕之后客户端和服务器就会进入ESTABLISHED状态，完成三次握手，就可以在服务器与客户端之间传输数据了。</li></ol><p>SYN是同步序号，当SYN=1而ACK=0时表明这是一个连接请求报文，对方若同意连接，那应在报文中使SYN=1和ACK=1，因此SYN置1表示这是一个连接请求或者连接接受报文。而ACK状态是用来确认是否同意连接。也就是传了SYN,证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要ACK信号来验证</p><p>当在传送完数据之后，客户端与服务器端之间有四次握手协议：</p><ol><li>第一次握手：客户端发送一个FIN和序号过去（seq=u）用来表示客户端和服务端之间有关闭的请求，同时关闭客户端的数据传送，客户端就进入FIN_WAIT_1的状态</li><li>第二次握手：服务端收到FIN=1的标志位，就会发送一个ACK标志位表示确认，然后确认序号就变成了收到的序号+1,即ack=u+1(FIN和SYN在这点相同，但是作用不一样)这时候服务端进入CLOSE_WAIT状态，这是一个半关闭状态。只能服务端给客户端发送数据而客户端不能给服务端发送数据</li><li>第三次握手：这次握手还是服务端发起的。这是服务端在传完最后的数据（没有就不传）就会发送一个FIN=1和ACK=1,且序号seq会改变（没有传数据则不变），而ack不变，这时候服务端就会进入LAST_ACK状态，表示最后再确认一次。</li><li>第四次握手：客户端在接收到FIN之后，就会进入TIME_WAIT状态，接着发送一个ACK和seq=u+1,ack=w+1给服务端，这时候服务端就会进入CLOSED状态。而客户端进入TIME_WAIT状态的时候必须要等待2MSL的时间才会关闭</li></ol><p>TIME_WAIT状态的作用？（MSL：网络中数据报文存在的最大时间）</p><ol><li>TIME_WAIT状态可以确保有足够的时间让对方接收到ACK包，如果ACK没有到达，在传输过程丢失了或者一些其他原因，这样就可以让客户端重发ACK包，如果客户端直接关闭了，那么就有可能导致服务端在一些情况下没有接受到ACK包而无法与客户端断开连接。这样客户端发送ACK包到服务端，服务端请求重发，一来一回就刚好是2MSL</li><li>保证迟来的TCP报文段有足够的时间被识别并丢弃，linux中一个TCPort不能打开两次或者两次以上。当client处于time_wait状态时无法使用此port建立新连接，假设不存在time_wait状态，新连接可能会受到旧连接的数据</li></ol><h3 id="TCP粘包是什么-该怎么办"><a href="#TCP粘包是什么-该怎么办" class="headerlink" title="TCP粘包是什么,该怎么办"></a>TCP粘包是什么,该怎么办</h3><p>客户端（发送一端）在发送之前会将短时间有多个发送的数据块缓冲到一起（发送缓冲区），形成了一个大的数据块一并发送，同样接收端也有一个接收缓冲区，收到的数据先存放在接收端缓冲区，然后程序从这里读取部分数据进行消费，这样做也是为了减少I/O消耗达到性能优化。</p><p>数据达到缓冲区什么时间开发发送这个取决于TCP拥塞控制，是任何时刻内确定能被发送出去的字节数的控制因素之一，是阻止发送方至接收方之间的链路变得拥塞的手段</p><p>TCP粘包解决方案：</p><ol><li><p>延迟发送：设置延迟发送，sleep休眠一段时间。简单但是传输效率大大降低，只适用于交互频率低的情况</p></li><li><p>关闭nagle算法。nagle算法是一种改善网络传输效率的算法，避免网络中充斥着大量小的数据块，它所期望的是尽可能发送大的数据块，因此在每次请求一个数据块给TCP发送时，TCP并不会立即执行发送，而是等待一小段时间进行发送。</p><p>当网络中充斥着大量小的数据块时，Nagle算法能将小的数据块集合起来一起发送减少了网络拥堵，但并不是所有场景都需要这样。例如，REPL终端交互，当用户输入单个字符以获取响应，所以在nodejs中可以设置 socket.setNoDelay方法来关闭Nagle算法。<code>const server = net.createServer(); server.on(&#39;connection&#39;,socket=&gt;{socket.setNoDelay(true)})</code></p></li><li><p>封包/拆包。使用长度编码的方式，通信双方约定好格式，将消息分为定长的消息头（Header）和不定长的消息体（Body），在解析时读取消息头获取到内容的占用的长度，之后读取到的消息体内容字节数等于字节头的字节数时，认为它是一个完整的包。</p></li></ol><table><thead><tr><th>消息头序号（Header）</th><th>消息体长度（Header）</th><th>消息体（Body）</th></tr></thead><tbody><tr><td>SerialNumber</td><td>bodyLength</td><td>body</td></tr><tr><td>2字节</td><td>2字节</td><td>N字节</td></tr></tbody></table><p>Buffer的几个api：</p><ul><li>Buffer.alloc(size[,fill[,encoding]]),初始化一个size大小的Buffer空间，默认填充0，也可以指定fill进行自动以填充</li><li>Buffer.writeInt16BE(value[,offset]),value为要写入的Buffer值，offset为偏移量从哪个位置开始写入</li><li>Buffer.writeInt32BE(value[,offset]),value为要写入的Buffer值，不同的是writeInt16BE表示高位优先写入一个16位整型，这个是32位</li><li>Buffer.readInt16BE([offset])，高位优先读取16位整型，offset为读取之前要跳过的字节数</li><li>Buffer.readInt32BE([offset])，高位优先读取32位整型，offset为读取之前要跳过的字节数</li></ul><h4 id="编码-解码的实现"><a href="#编码-解码的实现" class="headerlink" title="编码/解码的实现"></a>编码/解码的实现</h4><p>TCP顶层是基于二进制数据，应用层通常是易于表达的字符串、数字等，需要先将数据通过Buffer转换为二进制，取出的时候同样需要解码操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transcoder.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transcoder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.packageHeaderLen = <span class="number">4</span>; <span class="comment">// 包头长度</span></span><br><span class="line">    <span class="keyword">this</span>.serialNumber = <span class="number">0</span>; <span class="comment">// 定义包序号</span></span><br><span class="line">    <span class="keyword">this</span>.packageSerialNumberLen = <span class="number">2</span>; <span class="comment">// 包序列号所占用的字节</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 编码</span></span><br><span class="line"><span class="comment">   * @param &#123;Object&#125; data Buffer 对象数据</span></span><br><span class="line"><span class="comment">   * @param &#123;Int&#125; serialNumber 包序号，客户端编码时自动生成，服务器解码之后在编码时需要传入解码的包序号</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  encode(data, serialNumber) &#123;</span><br><span class="line">    <span class="keyword">const</span> body = Buffer.from(data);</span><br><span class="line">    <span class="keyword">const</span> header = Buffer.alloc(<span class="keyword">this</span>.packageHeaderLen);</span><br><span class="line">    header.writeInt16BE(serialNumber || <span class="keyword">this</span>.serialNumber);</span><br><span class="line">    header.writeInt16BE(body.length, <span class="keyword">this</span>.packageSerialNumberLen); <span class="comment">// 跳过包序号的前两位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (serialNumber === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.serialNumber++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Buffer.concat([header, body])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 解码</span></span><br><span class="line"><span class="comment">   * @param &#123;Object&#125; buffer</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  decode(buffer) &#123;</span><br><span class="line">    <span class="keyword">const</span> header = buffer.slice(<span class="number">0</span>, <span class="keyword">this</span>.packageHeader); <span class="comment">// 获取包头</span></span><br><span class="line">    <span class="keyword">const</span> body = buffer.slice(<span class="keyword">this</span>.packageHeaderLen); <span class="comment">// 获取包尾部</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      serialNumber: header.readInt16BE(),</span><br><span class="line">      bodyLength: header.readInt16BE(<span class="keyword">this</span>.packageSerialNumberLen), <span class="comment">// 因为编码阶段跳过两位，所以解码也需要跳过</span></span><br><span class="line">      body: body.toString(),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取包长度两种情况</span></span><br><span class="line"><span class="comment">   * 1. 如果当前buffer长度数据小于包头，肯定不是一个完整的数据包，因此直接返回0不做处理（可能数据还没有接收完）</span></span><br><span class="line"><span class="comment">   * 2. 否则返回这个完整的数据包长度</span></span><br><span class="line"><span class="comment">   * @param &#123;*&#125; buffer</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  getPackageLength(buffer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer.length &lt; <span class="keyword">this</span>.packageHeaderLen) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.packageHeaderLen + buffer.readInt16BE(<span class="keyword">this</span>.packageSerialNumberLen)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Transcoder;</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> Transcoder = <span class="built_in">require</span>(<span class="string">'./transcoder'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> transcoder = <span class="keyword">new</span> Transcoder();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = net.createConnection(&#123;</span><br><span class="line">  host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">  port: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> overageBuffer = <span class="literal">null</span>; <span class="comment">//上一次Buffer剩下的数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client.on(<span class="string">'data'</span>, buffer =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (overageBuffer) &#123;</span><br><span class="line">    buffer = Buffer.concat([overageBuffer, buffer])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> packageLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// eslint-disable-next-line no-cond-assign</span></span><br><span class="line">  <span class="keyword">while</span> (packageLength = transcoder.getPackageLength(buffer)) &#123;</span><br><span class="line">    <span class="keyword">const</span> packageData = buffer.slice(<span class="number">0</span>, packageLength); <span class="comment">// 取出整个数据包</span></span><br><span class="line">    buffer = buffer.slice(packageLength); <span class="comment">// 删除已经取出的数据包，这里采用的方法是把缓冲区（buffer）已取出的包给截掉</span></span><br><span class="line">    <span class="keyword">const</span> result = transcoder.decode(packageData); <span class="comment">// 解码</span></span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  overageBuffer = buffer; <span class="comment">// 记录剩余不完整的包</span></span><br><span class="line">&#125;).on(<span class="string">'error'</span>, err =&gt; &#123; <span class="comment">// 监听一个未开启的端口就会报 ECONNREFUSED错误</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`服务器异常: <span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">&#125;).on(<span class="string">'close'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`客户链接断开！， <span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">client.write(transcoder.encode(<span class="string">'Nodejs 技术栈'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  <span class="string">'1 JavaScript '</span>,</span><br><span class="line">  <span class="string">'2 TypeScript '</span>,</span><br><span class="line">  <span class="string">'3 Python '</span>,</span><br><span class="line">  <span class="string">'4 Java '</span>,</span><br><span class="line">  <span class="string">'5 C '</span>,</span><br><span class="line">  <span class="string">'6 PHP '</span>,</span><br><span class="line">  <span class="string">'7 ASP.NET '</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">    client.write(transcoder.encode(arr[i]))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> Transcoder = <span class="built_in">require</span>(<span class="string">'./transcoder'</span>);</span><br><span class="line"><span class="keyword">const</span> transcoder = <span class="keyword">new</span> Transcoder();</span><br><span class="line"><span class="keyword">const</span> HOST = <span class="string">'127.0.0.1'</span>;</span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">let</span> overageBuffer = <span class="literal">null</span>; <span class="comment">// 上一次善剩余数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个TCP服务实例</span></span><br><span class="line"><span class="keyword">const</span> server = net.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">server.listen(PORT, HOST)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'listening'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`服务已经开启在<span class="subst">$&#123;HOST&#125;</span>:<span class="subst">$&#123;PORT&#125;</span>`</span>)</span><br><span class="line">&#125;).on(<span class="string">'connection'</span>, socket =&gt; &#123;</span><br><span class="line">  <span class="comment">// data事件就是读取数据</span></span><br><span class="line">  socket.on(<span class="string">'data'</span>, buffer =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (overageBuffer) &#123;</span><br><span class="line">      buffer = Buffer.concat([overageBuffer, buffer])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> packageLength = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line no-cond-assign</span></span><br><span class="line">    <span class="keyword">while</span> (packageLength = transcoder.getPackageLength(buffer)) &#123;</span><br><span class="line">      <span class="keyword">const</span> packageData = buffer.slice(<span class="number">0</span>, packageLength); <span class="comment">//取出整个数据包</span></span><br><span class="line">      buffer = buffer.slice(packageLength); <span class="comment">// 删除取出的数据包，这里采用的方法是把缓冲区buffer已取出的包截掉</span></span><br><span class="line">      <span class="keyword">const</span> result = transcoder.decode(packageData); <span class="comment">// 解码</span></span><br><span class="line">      <span class="built_in">console</span>.log(result);</span><br><span class="line">      socket.write(transcoder.encode(result.body, result.serialNumber))</span><br><span class="line">    &#125;</span><br><span class="line">    overageBuffer = buffer; <span class="comment">// 记录不完整的包  </span></span><br><span class="line">  &#125;).on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'socket end'</span>)</span><br><span class="line">  &#125;).on(<span class="string">'error'</span>, error =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'socket error'</span>, error)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).on(<span class="string">'close'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Server Close!'</span>)</span><br><span class="line">&#125;).on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err.code === <span class="string">'EADDRINUSE'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'地址正被使用，重试中......'</span>)</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      server.close();</span><br><span class="line">      server.listen(PORT.HOST)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`服务器异常: <span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS模块是基于UDP协议来实现的，在Nodejs中可以通过<code>require(&#39;dns&#39;)</code>实现域名的解析查询，Nodejs DNS模块分成两大类：</p><ol><li>底层操作系统工具进行域名解析</li><li>链接到一个DNS网络服务器执行域名解析</li></ol><h3 id="底层操作工具域名解析"><a href="#底层操作工具域名解析" class="headerlink" title="底层操作工具域名解析"></a>底层操作工具域名解析</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Nodejs DNS模块的 dns.lookup()方法使用底层操作系统进行域名解析，是不需要经过网络通信的</span></span><br><span class="line"><span class="keyword">const</span> dns = <span class="built_in">require</span>(<span class="string">'dns'</span>);</span><br><span class="line"></span><br><span class="line">dns.lookup(<span class="string">'laibh.top'</span>,(err,address,family)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`地址: <span class="subst">$&#123;address&#125;</span>,地址族：<span class="subst">$&#123;family&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="链接到DNS服务器执行域名解析"><a href="#链接到DNS服务器执行域名解析" class="headerlink" title="链接到DNS服务器执行域名解析"></a>链接到DNS服务器执行域名解析</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dns 模块除了 dns.lookup之外的函数，都会连接到实际DNS服务器以执行名称解析并始终使用网络执行DNS查询</span></span><br><span class="line"><span class="keyword">const</span> dns = <span class="built_in">require</span>(<span class="string">'dns'</span>);</span><br><span class="line">dns.lookup(<span class="string">'laibh.top'</span>,(err,records)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(records)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>dns.lookup与dns.resolve</code>不同</p><p>虽然用异步的角度来使用dns.lookup，但是内部的libuv底层线程池中确实同步的调用 getaddrinfo(3)，所以可能有由于一些不确定的因素造成Node进程阻塞</p><p>与dns.lookup不同的是dns.resolve没有使用getaddrinfo(3)，而通过网络执行的DNS查询，始终保持异步不会对其他进程产生负面影响</p><h3 id="DNS域名解析过程"><a href="#DNS域名解析过程" class="headerlink" title="DNS域名解析过程"></a>DNS域名解析过程</h3><ol><li>浏览器DNS缓存。访问一个URL优先查找浏览器的DNS缓存，命中就返回。未命中就继续下一步，查找操作系统的缓存。当修改了本地hosts域名指向发现浏览器缓存没有变化是因为每个浏览器有一个固定值。</li><li>系统（OS）缓存。查看操作系统中是否有域名对应的IP,位于操作系统的hosts文件。</li><li>路由器缓存。当浏览器DNS与系统OS缓存均没有映射的时候，则请求会发送到路由器缓存中检查</li><li>ISP DNS缓存。ISP为互联网服务提供商。</li></ol><p>DNS本地解析指的是系统缓存这一阶段，在浏览器缓存没有命中的情况下， 会从本地系统的一个hosts文件中寻找对应的IP</p><h2 id="Cluster-（集群）"><a href="#Cluster-（集群）" class="headerlink" title="Cluster （集群）"></a>Cluster （集群）</h2><p>在PM2的配置文件中可以设置<code>exec_model:&#39;cluster</code>和<code>instance</code>两个属性来设置开启多个进程，PM2其实就是利用Nodejs Cluster这个模块来实现的，还有eggJs中的egg-cluster模块在启用Worker进程也是用到这个模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> numCPUs = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus().length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Master 进程 <span class="subst">$&#123;process.pid&#125;</span> 正在运行`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCPUs; i++) &#123;</span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cluster.on(<span class="string">'exit'</span>, (worker, code, signal) =&gt; &#123; <span class="built_in">console</span>.log(<span class="string">`Worker <span class="subst">$&#123;worker.process.pid&#125;</span> 已退出`</span>) &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">`你好，哈哈哈 <span class="subst">$&#123;process.pid&#125;</span>`</span>)</span><br><span class="line">  &#125;).listen(<span class="number">8000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Worker 进程 <span class="subst">$&#123;process.pid&#125;</span> 已启用`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="采用了哪种集群方式"><a href="#采用了哪种集群方式" class="headerlink" title="采用了哪种集群方式"></a>采用了哪种集群方式</h3><p>集群模式通常实现有两种：</p><ol><li>1个Node实例开启多个端口，通过反向代理服务器向各端口服务进行转发</li><li>1个Node实例开启多个进程监听同一个端口，通过负载均衡技术分配请求（Master-&gt;Worker）</li></ol><p>第一个方案存在的一个问题就是占用多个端口，造成资源浪费，由于多个实例是独立运行的，进程间通信不太好做。好处是稳定性高，各实例之间没有影响。</p><p>第二个方案多个Node进程去监听同一个端口，好处是进程间通信相对简单，减少了端口的资源浪费，但是这个时候需要保证服务进程的稳定性，特别是对Master进程稳定性要求会更高，编码也会复杂。</p><p>Nodejs中自带的Cluster模块正是采用了第二种方案。</p><h3 id="多个进程为什么可以监听同一个端口"><a href="#多个进程为什么可以监听同一个端口" class="headerlink" title="多个进程为什么可以监听同一个端口"></a>多个进程为什么可以监听同一个端口</h3><p>端口不是被所有的进程全部监听，仅仅受到Master进程的监听。Master进程创建一个Socket并绑定监听到目标端口，通过子进程之间建立IPC通道之后，通过调用子进程的send方法，将Socket（链接句柄）传递过去。（Master通过cluster.fork方法创建的，本质上还是使用了child_process.fork这个方法）</p><p>使用 child_process.fork()创建的子进程，进行Socket传递的示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.js</span></span><br><span class="line"><span class="keyword">const</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</span><br><span class="line"><span class="keyword">const</span> cpus = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus();</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer().listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;cpus.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> worker = fork(<span class="string">'worker.js'</span>);</span><br><span class="line">      <span class="comment">// 将 Master 的 server 传递给子进程</span></span><br><span class="line">    worker.send(<span class="string">'server'</span>, server);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'worker process created, pid: %s ppid: %s'</span>, worker.pid, process.pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">'I am worker, pid: '</span> + process.pid + <span class="string">', ppid: '</span> + process.ppid);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> worker;</span><br><span class="line"><span class="comment">// 第二个参数 sendHandle 就是句柄，可以是 TCP套接字、TCP服务器、UDP套接字等</span></span><br><span class="line">process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">message, sendHandle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message === <span class="string">'server'</span>) &#123;</span><br><span class="line">        worker = sendHandle;</span><br><span class="line">        worker.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">            server.emit(<span class="string">'connection'</span>, socket);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>端口会被主进程绑定监听一次，但是主进程和子进程在建立IPC通信之后，发送Socket到子进程实现端口共享，在之后Master接受到新的客户端链接后，通过负载均衡技术再转发到各Worker进程。</p><h3 id="多个进程之间如何通信"><a href="#多个进程之间如何通信" class="headerlink" title="多个进程之间如何通信"></a>多个进程之间如何通信</h3><p>由于cluster.fork本质上还是使用child_process.fork()这个方法来创建子进程，进程间通信无非几种：pipe（管道）、消息队列、信号量、Domain Socket。Nodejs中是通过pipe(管道)实现的，pipe作用于之间有血缘关系的进程，通过fork传递，其本身也是一个进程，将一个进程的输出作为另外一个进程的输入。</p><h3 id="如何对多个Worker进行请求转发"><a href="#如何对多个Worker进行请求转发" class="headerlink" title="如何对多个Worker进行请求转发"></a>如何对多个Worker进行请求转发</h3><p>在Nodejs中使用了RoundRobin负载均衡策略，简称RP,它的实现原理是一种无状态的轮询策略，假定每台服务器的硬件资源、处理性能都是相同的，根据进程的数量，依次分配，直到所有进程处理完了，再开始重新计算分配。优点是实现起来简洁也易用，缺点是如果出现某个请求占用的时间较长，就会导致负载不会太均衡。</p><p>RP这种负载均衡技术适用于同一组服务器拥有相同的软硬件配置且平均的服务请求响应</p><p>RP是一种常见的复杂均衡技术，Nginx中也有使用，另外在RP的基础上还衍生了一个Weighted Round-Robin权重负载均衡轮询算法，简称WRR,同样也是使用轮询的技术，但是在基础上考虑了服务器的处理能力，实现时为服务器加上权重，这种负载均衡算法能够确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。</p><h3 id="Nodejs负载均衡策略设置"><a href="#Nodejs负载均衡策略设置" class="headerlink" title="Nodejs负载均衡策略设置"></a>Nodejs负载均衡策略设置</h3><ul><li>RoundRobin,RR。设置时要使用cluster.SCHED_RR,如果通过环境变量设置要使用rr,如果用cluster对象获取 schedulingPolicy数字表示为2</li><li>Shared Socket，SS,设置时要用cluster.SCHED_NONE，如果通过环境变量设置要用node,如果用cluster对象获取schedulingPolicy数字表示为1</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cluster对象的schedulingPolicy属性设置</span></span><br><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略一：一种轮询的策略，默认值</span></span><br><span class="line">cluster.schedulingPolicy = cluster.SHCED_RR;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略二:由操作系统调度的策略</span></span><br><span class="line">cluster.schedulingPolicy = cluster.SCHED_NONE;</span><br><span class="line"></span><br><span class="line">cluster.fork();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者通过环境变量 NODE_CLUSTER_SCHED_POLICY设置：</span></span><br><span class="line">env NODE_CLUSTER_SCHED_POLICY = <span class="string">'none'</span> node app.js</span><br></pre></td></tr></table></figure><h2 id="基于Stream实现多文件合并"><a href="#基于Stream实现多文件合并" class="headerlink" title="基于Stream实现多文件合并"></a>基于Stream实现多文件合并</h2><h3 id="一个简单的Stream操作"><a href="#一个简单的Stream操作" class="headerlink" title="一个简单的Stream操作"></a>一个简单的Stream操作</h3><p>创建一个可读流readable一个可写流writeable，通过管道pipe将可写流绑到可读流，一个简单的Stream操作就可以完成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> readable = fs.createReadStream(<span class="string">'./log/read.txt'</span>);</span><br><span class="line"><span class="keyword">const</span> writeable = fs.createWriteStream(<span class="string">'./log/write.txt'</span>);</span><br><span class="line"></span><br><span class="line">readable.pipe(writeable)</span><br><span class="line"></span><br><span class="line"><span class="comment">// readable.pip(destionation[,option])</span></span><br><span class="line"><span class="comment">// destionation：是一个可写流对象，也就是一个数据写入的目标对象</span></span><br><span class="line"><span class="comment">// options:end,读取结束时终止写入流，默认值是true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认情况下不需要手动调用写入流的end方法关闭的，更改end为false写入的目标将会处于一直打开状态，此时就需要监听可读流的end时间，结束之后手动调用可写流的end事件。</span></span><br><span class="line"></span><br><span class="line">readable.pipe(writeable,&#123;</span><br><span class="line">    end:<span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readable.on(<span class="string">'end'</span>,()=&gt;&#123;</span><br><span class="line">    writeable.end(<span class="string">'结束'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果可读流期间发什么什么错误，则写入的目标流将不会关闭，所以需要监听错误事件，手动关闭可写流，防止内存泄露。</p><h3 id="多个文件通过Stream合并成一个文件"><a href="#多个文件通过Stream合并成一个文件" class="headerlink" title="多个文件通过Stream合并成一个文件"></a>多个文件通过Stream合并成一个文件</h3><p>设置可读流的end为false可以保持写入流一直处于打开状态，通过这种方式，一开始可写流处于打开状态，知道所有的可读流结束，我们再将可写流关闭。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stream 合并</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; sourceFiles 源文件目录名</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; targetFile 目标文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">streamMerge</span>(<span class="params">sourceFiles, targetFile</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> scripts = fs.readdirSync(path.resolve(__dirname, sourceFiles)); <span class="comment">// 获取源文件目录下的所有文件</span></span><br><span class="line">  <span class="keyword">const</span> fileWriteStream = fs.createWriteStream(path.resolve(__dirname, targetFile)); <span class="comment">// 创建一个可写流</span></span><br><span class="line">  streamMergeRecursive(scripts, fileWriteStream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stream 合并的递归调用</span></span><br><span class="line"><span class="comment"> * @param &#123;Array&#125; scripts</span></span><br><span class="line"><span class="comment"> * @param &#123;Stream&#125; fileWriteStream</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">streamMergeRecursive</span>(<span class="params">scripts = [], fileWriteStream</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归到尾 的情况判断</span></span><br><span class="line">  <span class="keyword">if</span> (!scripts.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> fileWriteStream.end(<span class="string">"console.log('Stream 合并完成')"</span>) <span class="comment">// 最后关闭可写流，防止内存泄露</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> currentFile = path.resolve(__dirname, <span class="string">'scripts/'</span>, scripts.shift());</span><br><span class="line">  <span class="keyword">const</span> currentReadStream = fs.createReadStream(currentFile); <span class="comment">// 获取当前的可读流</span></span><br><span class="line"></span><br><span class="line">  currentReadStream.pipe(fileWriteStream, &#123; <span class="attr">end</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  currentReadStream.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    streamMergeRecursive(scripts, fileWriteStream)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  currentReadStream.on(<span class="string">'error'</span>, (error) =&gt; &#123; <span class="comment">// 监听错误事件，关闭可读流，防止内存泄露</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">    fileWriteStream.close()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">streamMerge(<span class="string">'./scripts'</span>, <span class="string">'./script.js'</span>)</span><br></pre></td></tr></table></figure><h2 id="Stream-pipe的使用与实现原理"><a href="#Stream-pipe的使用与实现原理" class="headerlink" title="Stream pipe的使用与实现原理"></a>Stream pipe的使用与实现原理</h2><p>通过流我们可以将一大块数据拆分称为一小部分一点一点的流动起来，不需要一次性全部读入，在Linux下可以通过<code>|</code>符号实现，类似的在Nodejs的Stream模块中同样也为我们提供了 pipe方法来实现</p><h3 id="未使用Stream-pipe的情况"><a href="#未使用Stream-pipe的情况" class="headerlink" title="未使用Stream pipe的情况"></a>未使用Stream pipe的情况</h3><p>在Nodejs中I/O操作都是异步的，先用util模块的promiseify方法将fs.readFile的callback形式转换为Promise形式</p><p>，它将数据一次性读入内存然后再进行返回，当数据文件很大的时候也是对内存的一种消耗，不推荐</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// koa 的例子</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> &#123;promisify&#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;resolve&#125; = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx=&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ctx.body = <span class="keyword">await</span> readFile(resolve(__dirname,<span class="string">'test.json'</span>)))</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        ctx.body = err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><h3 id="使用Steam-pipe"><a href="#使用Steam-pipe" class="headerlink" title="使用Steam pipe"></a>使用Steam pipe</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx=&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> readable = fs.createReadStream(resolve(__dirname,<span class="string">'test.json'</span>));</span><br><span class="line">        ctx.body = readable;       </span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        ctx.body = err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 在Koa中直接创建一个可读流赋值给ctx.body，框架内封装好了pipe方法，下面为源码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">respond</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> body = ctx.body;</span><br><span class="line">    <span class="keyword">if</span>(body <span class="keyword">instanceof</span> Stream) <span class="keyword">return</span> body.pipe(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用与不使用Stream"><a href="#使用与不使用Stream" class="headerlink" title="使用与不使用Stream"></a>使用与不使用Stream</h3><p>使用了可读流，通过pipe接口监听data与end事件，把data的可读流拆分称为一小块一小块的数据（chunks），像流水一样源源不断吐给客户端，而不再需要等待整个文件都加载到内存后才发送数据。pipe可以视为流的管道/通道方法，任何类型的流都会有这个方法来处理流的输入与输出。</p><p>总体来说，使用流可以大大提升响应时间，又能有效减轻服务器内存的压力</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>在应用层调用 fs.createReadStream 方法，找到这个方法创建的可读流对象pipe的方法实现</p><h4 id="lib-fs-js"><a href="#lib-fs-js" class="headerlink" title="/lib/fs.js"></a>/lib/fs.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出一个createReadStream方法，在这个方法里面创建一个ReadSream可读流对象，且ReadStream来自internal/fs/streams</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒加载，主要在用到的时候用来实例化 ReadStream/WriteStream等对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyLoadStreams</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!ReadStream)&#123;</span><br><span class="line">        (&#123;ReadStream,WriteStream&#125;) = <span class="built_in">require</span>(<span class="string">'internal/fs/streams'</span>);</span><br><span class="line">        [FileReadStream,FileWriteStream] = [ReadStream,WriteStream];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReadStream</span>(<span class="params">path,options</span>)</span>&#123;</span><br><span class="line">   lazyLoadStreams();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReadStream(path,options); <span class="comment">// 创建一个可读流</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = fs = &#123;</span><br><span class="line">    createReadStream, <span class="comment">// 导出 createReadStream 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lib-internal-fs-streams-js"><a href="#lib-internal-fs-streams-js" class="headerlink" title="/lib/internal/fs/streams.js"></a>/lib/internal/fs/streams.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法定义了构造函数 ReadStream，且在原型上定义了 open、_read、_destroy等方法，没有pipe方法，通过ObjectSetPrototypeOf方法实现了继承，ReadStream继承了Readable在原型中定义的函数，继续查找Readable的实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;Readable,Writeable&#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReadStream</span>(<span class="params">path,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> ReadStream)) <span class="keyword">return</span> <span class="keyword">new</span> ReadStream(path,options)</span><br><span class="line">    </span><br><span class="line">    Readable.call(<span class="keyword">this</span>,options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjectSetPrototypeOf(ReadStream.prototype,Readable.prototype);</span><br><span class="line">ObjectStreamProtptypeOf(ReadStream,Readable);</span><br><span class="line"></span><br><span class="line">ReadStream.prototype.open = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">ReadStream.prototype._read = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;&#125;</span><br><span class="line">ReadStream.prototype._destroy = <span class="function"><span class="keyword">function</span>(<span class="params">err,cb</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">module</span>.<span class="title">exports</span> = </span>&#123;</span><br><span class="line">    ReadStream,</span><br><span class="line">    WriteStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lib-stream-js"><a href="#lib-stream-js" class="headerlink" title="/lib/stream.js"></a>/lib/stream.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// to avoid cross-reference(require) issue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Stream = <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'internal/streams/legacy'</span>);</span><br><span class="line"></span><br><span class="line">Stream.Readable = <span class="built_in">require</span>(<span class="string">'_stream_readable'</span>);</span><br><span class="line">Stream.Writable = <span class="built_in">require</span>(<span class="string">'_stream_writable'</span>)</span><br><span class="line">Stream.Duplex = <span class="built_in">require</span>(<span class="string">'_stream_duplex'</span>);</span><br><span class="line">Stream.Transform = requier(<span class="string">'_stream_transform'</span>);</span><br><span class="line">Stream.PassThrough = <span class="built_in">require</span>(<span class="string">'_stream_passthrough'</span>);</span><br></pre></td></tr></table></figure><h4 id="lib-internal-streams-legacy-js"><a href="#lib-internal-streams-legacy-js" class="headerlink" title="/lib/internal/streams/legacy.js"></a>/lib/internal/streams/legacy.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承了Events 模块，然后在原型上定义了pipe方法，而_stream_readable继承了Stream之后又自己实现了pipe方法</span></span><br><span class="line"><span class="keyword">const</span> &#123;ObjectSetPrototypeOf&#125; = primordials;</span><br><span class="line"><span class="keyword">const</span> EE = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stream</span>(<span class="params">opts</span>)</span>&#123;</span><br><span class="line">   EE.call(<span class="keyword">this</span>,opts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjectSetPrototypeOf(Stream.prototype,EE.prototype);</span><br><span class="line">ObjectSetPrototypeOf(Stream,EE);</span><br><span class="line"></span><br><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Stream;</span><br></pre></td></tr></table></figure><h4 id="lib-stream-readable-js"><a href="#lib-stream-readable-js" class="headerlink" title="/lib/_stream_readable.js"></a>/lib/_stream_readable.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了Readable构造函数，且继承于lib/stream.js的Stream，然后重写pipe方法</span></span><br><span class="line"><span class="built_in">module</span>.exports = Readable;</span><br><span class="line">Readable.ReadableState = ReadableState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EE = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> Stream = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"></span><br><span class="line">ObjectSetPrototypeOf(Readable.prototype,Stream.prototype)</span><br><span class="line">ObjectSetPrototypeOf(Readable,Stream);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Readable</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Readable)) <span class="keyword">return</span> <span class="keyword">new</span> Readable(options)</span><br><span class="line">    </span><br><span class="line">    Stream.call(<span class="keyword">this</span>,options); <span class="comment">// 继承自 Stream构造函数的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="stream-readable-js实现分析"><a href="#stream-readable-js实现分析" class="headerlink" title="_stream_readable.js实现分析"></a>_stream_readable.js实现分析</h5><p>1.声明构造函数Readable，继承Stream的构造函数和原型。</p><p>文件继承了events事件，拥有了events在原型中定义的属性，例如on、emit</p><p>2.声明pipe方法，订阅data事件</p><p>在Stream原型上声明pipe方法，订阅data事件，src为可读对象，dest为可写流对象。在使用pipe方法的时候也是监听的data事件，一边读取一边写入数据。</p><p>ondata方法的几个核心的实现：</p><ul><li>dest.write(chunk):接受chunk写入数据，如果内部的缓冲小于创建流时配置的highWaterMark，则返回true（缓存未满）,否则返回false时应该停止向流写入数据，直到‘drain’（清空缓存）事件被触发</li><li>src.pause()：可读流会停止data事件，意味着此时暂停数据写入了</li></ul><p>调用src.pause是为了防止读入数据过快来不及写入，如果缓存未满即dest.write(chunk)，这个缓存是根据创建流时创建的highWaterMark属性，默认为16384（16k），对象模式的流默认为16</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> src = <span class="keyword">this</span>;</span><br><span class="line">    src.on(<span class="string">'data'</span>,ondata);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ondata</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> ret = dest.write(chunk);</span><br><span class="line">        <span class="keyword">if</span>(ret === <span class="literal">false</span>)&#123;</span><br><span class="line">            ...</span><br><span class="line">            src.pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.订阅drain事件，继续流动数据。继续写入事件到流时会触发drain事件，也就是dest.write(chunk)等于false(缓存满了)时，如果ondrain不存在则注册drain事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> src = <span class="keyword">this</span>;</span><br><span class="line">    src.on(<span class="string">'data'</span>,ondata);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ondata</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> ret = dest.write(chunk);</span><br><span class="line">        <span class="keyword">if</span>(ret === <span class="literal">false</span>)&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span>(!ondrain)&#123;</span><br><span class="line">        <span class="comment">// When the dest drains, it reduces the awaitDrain counter</span></span><br><span class="line">        <span class="comment">// on the source.  This would be more elegant with a .once()</span></span><br><span class="line">        <span class="comment">// handler in flow(), but adding and removing repeatedly is</span></span><br><span class="line">        <span class="comment">// too slow.    </span></span><br><span class="line">                ondrain = pipeOnDrain(src);</span><br><span class="line">                dest.on(<span class="string">'drain'</span>,ondrain);</span><br><span class="line">            &#125;</span><br><span class="line">            src.pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当写入流dest耗尽时，它将会在可读流对象 source上减少 awaitDrain计数器，为了确保所有需要缓存的写入都完成，即state.awaitDrain === 0和src可读流上的data事件存在，切换流到流动模式</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pipeOnDrain</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">pipeDrainFunctionResult</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> state = src._readableState;</span><br><span class="line">            debug(<span class="string">'pipeOnDrain'</span>,state.awaitDrain);</span><br><span class="line">            <span class="keyword">if</span>(state.awaitDrain)&#123;</span><br><span class="line">                state.awaitDrain--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(state.awaitDrain ===<span class="number">0</span> &amp;&amp; EE.listenerCount(src,<span class="string">'data'</span>))&#123;</span><br><span class="line">                state.flowing = <span class="literal">true</span>;</span><br><span class="line">                flow(src)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Stream.read() 从内部缓存拉取并返回数据，如果没有可读的数据，则返回null，在可读流上src还有一个readable属性，如果可以安全地调用readable,read(),则为true</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">slow</span>(<span class="params">stream</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> state = stream._readableState;</span><br><span class="line">        debug(<span class="string">'flow'</span>,state.flowing);</span><br><span class="line">        <span class="keyword">while</span>(state.flowing &amp;&amp; stream.read() !== <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.触发data事件。调用readable的resume方法，触发可读流的data事件，进入流动模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> src = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// start the flow if it hasnot been started already.</span></span><br><span class="line">    <span class="keyword">if</span>(!state.flowing)&#123;</span><br><span class="line">        debug(<span class="string">'pipe resume'</span>)</span><br><span class="line">        src.resume();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>resume方法内部又调用resume_()，最终执行了stream.read(0)读取了一次空数据（size设置为0），将会触发实例上的_read()方法，再触发data事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resume</span>(<span class="params">stream,state</span>)</span>&#123;</span><br><span class="line">    process.nextTick(resume_,stream,state)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resume_</span>(<span class="params">stream,state</span>)</span>&#123;</span><br><span class="line">    debug(<span class="string">'resume'</span>,state.reading);</span><br><span class="line">    <span class="keyword">if</span>(!state.reading)&#123;</span><br><span class="line">        stream.read(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.订阅end事件</p><p>end事件：当可读流中没有数据可供消费时触发，调用onend函数，执行dest.end()方法，表明已没有数据要被写入可写流，进行关闭（关闭可写流的id）,之后再调用stream.write会导致错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> doEnd = (!pipeOpts || pipeOpts.end !== <span class="literal">false</span>) &amp;&amp; dest !== process.stdout &amp;&amp;</span><br><span class="line">          dest !== process.stderr;</span><br><span class="line">    <span class="keyword">const</span> endFn = doEnd?onend:unpipe;</span><br><span class="line">    <span class="keyword">if</span>(state.endEmitted)&#123;</span><br><span class="line">        process.nestTick(endFn)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        src.once(<span class="string">'end'</span>,endFn)</span><br><span class="line">    &#125;</span><br><span class="line">    dest.on(<span class="string">'unpipe'</span>,onunpipe)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onend</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        debug(<span class="string">'onend'</span>);</span><br><span class="line">        dest.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.触发pipe事件，传入可读流对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> source = <span class="keyword">this</span>;</span><br><span class="line">    dest.emit(<span class="string">'pipe'</span>,src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在应用层使用但的时候可以在可写流上订阅pipe事件，做一些判断。</p><p>7.支持链式调用，最后返回dest</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.protptype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lib-internal-streams-legacy-js模块实现分析"><a href="#lib-internal-streams-legacy-js模块实现分析" class="headerlink" title="/lib/internal/streams/legacy.js模块实现分析"></a>/lib/internal/streams/legacy.js模块实现分析</h2><h3 id="声明构造函数Stream"><a href="#声明构造函数Stream" class="headerlink" title="声明构造函数Stream"></a>声明构造函数Stream</h3><p>声明构造函数Stream继承于事件events,此时就拥有了events在原型定义的属性，例如on/emit等方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;ObjectSetPrototypeOf&#125; = primordials;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EE = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stream</span>(<span class="params">opts</span>)</span>&#123;</span><br><span class="line">    EE.call(<span class="keyword">this</span>,opts)</span><br><span class="line">&#125;</span><br><span class="line">ObjectSetPrototypeOf(Stream.prototype,EE.prototype);</span><br><span class="line">ObjectSetPrototypeOf(Stream,EE)</span><br></pre></td></tr></table></figure><h3 id="声明pipe方法，订阅data事件"><a href="#声明pipe方法，订阅data事件" class="headerlink" title="声明pipe方法，订阅data事件"></a>声明pipe方法，订阅data事件</h3><p>在Stream原型上声明pipe方法，订阅data事件，source为可读流对象，dest为可写流对象</p><p>在使用pipe方法的时候也是监听的data事件，一边读取数据一边写入数据</p><p>ondata方法的几个API：</p><ul><li>dest.writable：如果调用writable.write()是安全的，则为true</li><li>dest.write(chunk)：接收chunk写入数据，如果内部的缓冲小于内部创建流时配置的highWaterMark，则返回true,否则返回false时应该停止向流写入数据，知道drain事件被触发。</li><li>source.pause()：可读流会停止data事件，意味着此时暂停数据写入了</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> source = <span class="keyword">this</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ondata</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dest.writable &amp;&amp; dest.write(chunk) === <span class="literal">false</span> &amp;&amp; source.pause)&#123;</span><br><span class="line">            source.pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    source.on(<span class="string">'data'</span>,ondata)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="订阅drain事件"><a href="#订阅drain事件" class="headerlink" title="订阅drain事件"></a>订阅drain事件</h3><p>如果调用dest.write(chunk)返回false,就会调用source.pause()停止数据流动，继续写入事件到流时会触发drain事件，ondrain方法的几个API：</p><ul><li>source.readable：如果可以安全地调用readable.read()，则为true,例如数据未读到末尾，则会返回true，表示可读的。</li><li>source.resume()：将被暂停的可读流恢复触发data事件，并将流切换流动模式</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ondrain</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(source.readable &amp;&amp; source.resume)&#123;</span><br><span class="line">            source.resume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dest.on(<span class="string">'drain'</span>,ondrain)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选项指定end属性，订阅end-close事件"><a href="#选项指定end属性，订阅end-close事件" class="headerlink" title="选项指定end属性，订阅end,close事件"></a>选项指定end属性，订阅end,close事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果end选项没有被提供，可读流订阅end或者close事件，后续将会触发该事件，指定dest.end方法，仅被调用一次，didOnEnd变量做了控制，主要是为了关闭可写流的id</span></span><br><span class="line"><span class="comment">// close:当流或者底层资源（比如文件描述符）被关闭时触发close事件</span></span><br><span class="line"><span class="comment">// end: 当可读流中没有数据可供消费的时候触发</span></span><br><span class="line"><span class="comment">// 可读流的end,destroy方法</span></span><br><span class="line"><span class="comment">// dest.end() 表明已经没有数据要被写入可写流，进行关闭，之后再调用stream.write会导致错误</span></span><br><span class="line"><span class="comment">// dest.destory() 销毁流</span></span><br><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dest._isStdio &amp;&amp; (!options || options.end !== <span class="literal">false</span>))&#123;</span><br><span class="line">        source.on(<span class="string">'end'</span>,onend);</span><br><span class="line">        source.on(<span class="string">'close'</span>,onclose);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> didOnEnd = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onend</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(didOnEnd) <span class="keyword">return</span>;</span><br><span class="line">        didOnEnd = <span class="literal">true</span>;</span><br><span class="line">        dest.end();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onclose</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(didOnEnd) <span class="keyword">return</span>;</span><br><span class="line">        didOnEnd = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> dest.destory === <span class="string">'function'</span>)&#123;</span><br><span class="line">            dest.destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="订阅可读流与可写流的error事件"><a href="#订阅可读流与可写流的error事件" class="headerlink" title="订阅可读流与可写流的error事件"></a>订阅可读流与可写流的error事件</h3><p>可读流、可写流发生错误时触发error事件，调用onerror方法，首先移除可读流，可写流订阅的所有事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onerror</span>(<span class="params">er</span>)</span>&#123;</span><br><span class="line">        cleanup();</span><br><span class="line">        <span class="keyword">if</span>(EE.listenerCount(<span class="keyword">this</span>,<span class="string">'error'</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> er;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    source.on(<span class="string">'error'</span>,onerror);</span><br><span class="line">    dest.on(<span class="string">'error'</span>,onerror);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        source.removeListener(<span class="string">'data'</span>,ondata);</span><br><span class="line">        dest.removeListener(<span class="string">'drain'</span>,ondrain);</span><br><span class="line">        </span><br><span class="line">        source.removeListener(<span class="string">'end'</span>,onend);</span><br><span class="line">        source.removelistener(<span class="string">'close'</span>,onclose);</span><br><span class="line">        </span><br><span class="line">        source.removeListener(<span class="string">'error'</span>,onerror);</span><br><span class="line">        dest.removelistener(<span class="string">'error'</span>,onerror);</span><br><span class="line">        </span><br><span class="line">        source.removeListener(<span class="string">'end'</span>,cleanup);</span><br><span class="line">        source.removelistener(<span class="string">'close'</span>,cleanup);     </span><br><span class="line">        </span><br><span class="line">        dest.removelistener(<span class="string">'close'</span>,cleanup);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="触发pipe事件"><a href="#触发pipe事件" class="headerlink" title="触发pipe事件"></a>触发pipe事件</h3><p>在pipe方法里面最后还会触发一个pipe事件，传入可读流对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> source = <span class="keyword">this</span>;</span><br><span class="line">    dest.emit(<span class="string">'pipe'</span>,source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="支持链式调用"><a href="#支持链式调用" class="headerlink" title="支持链式调用"></a>支持链式调用</h3><p>最后返回dest,支持<code>A.pipe(B).pipe(c)</code>的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="util-promisify如何将Callback转换为Promise"><a href="#util-promisify如何将Callback转换为Promise" class="headerlink" title="util.promisify如何将Callback转换为Promise"></a>util.promisify如何将Callback转换为Promise</h2><p>util模块提供了很多工具函数，其中promisify方法可以将callback转换为Promise对象，解决回调地狱的问题。</p><h3 id="简单实现版本"><a href="#简单实现版本" class="headerlink" title="简单实现版本"></a>简单实现版本</h3><h4 id="util-promisify基本使用"><a href="#util-promisify基本使用" class="headerlink" title="util promisify基本使用"></a>util promisify基本使用</h4><p>将callback转为promise对象，首先确保这个callback为一个错误优先的回调函数，即<code>(err,value)=&gt;err</code>指定一个错误参数，value为返回值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个text.txt文件，写入一些自定义内容，使用fs.readFile来读取这个文件进行测试</span></span><br><span class="line"><span class="comment">// 传统的Callback写法</span></span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line">fs.readFile(<span class="string">'text.txt'</span>,<span class="string">'utf8'</span>,(err,result)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Error'</span>,err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Result: '</span>,result)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise写法</span></span><br><span class="line"><span class="keyword">const</span> &#123;promisify&#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> readFilePromisify = util.promisify(fs.readFile); <span class="comment">// 转换为Promise</span></span><br><span class="line"></span><br><span class="line">readFilePromisify(<span class="string">'text.txt'</span>,<span class="string">'utf8'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span>=&gt;</span><span class="built_in">console</span>.log(result))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><p>自定义mayJunPromisify函数实现</p><p>自定义mayJunPromisify函数实现callback转换为promise，核心实现如下：</p><ul><li>校验传入的参数original是否为Function,不是则抛错</li><li>promisify(fs.readFile)执行之后会返回一个函数fn,定义待返回的函数后返回</li><li>fn返回的是一个Promise对象，在返回的Promise对象中执行callback函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mayJunPromisify</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> original !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The "original" argument must be of type Function,Received type undefined'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                original.call(<span class="keyword">this</span>,...args,(err,result)=&gt;&#123;</span><br><span class="line">                    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                        reject(err)</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        resolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">                resolve(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="util-promisify-custom基本使用"><a href="#util-promisify-custom基本使用" class="headerlink" title="util.promisify.custom基本使用"></a>util.promisify.custom基本使用</h4><p>另一个功能是可以使用util.promise.custom符号重写util.promisify返回值。</p><p>在fs.readFile上定义util.promisify.custom符号，其功能为禁止读取文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意顺序要在 util.promisify之前</span></span><br><span class="line">fs.readFile[util.promisify.custom] = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'该文件暂时禁止读取'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFilePromisify = util.promisify(fs.readFile);</span><br><span class="line">readFilePromisify(<span class="string">'text.txt'</span>,<span class="string">'utf8'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span>=&gt;</span><span class="built_in">console</span>.log(result))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(err)) <span class="comment">// 该文件暂时禁止读取</span></span><br></pre></td></tr></table></figure><p>自定义mayJunPromisify.custom实现</p><ul><li>定义一个Symbol变量kCustomPromisifiedSymbol赋予mayJunPromisify.custom</li><li>校验是否有自定义的promise函数</li><li>自定义的mayJunPromisified.custom也要保证是一个函数，否则抛错</li><li>直接返回自定义的mayJunPromisify.custom函数，后续的fn函数就不会执行了，所以在这里重写util.promisify返回值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所以说util.promisify.custom是一个符号</span></span><br><span class="line"><span class="keyword">const</span> kCustomPromisifiedSymbol = <span class="built_in">Symbol</span>(<span class="string">'util,promisify.custom'</span>);</span><br><span class="line">mayJunPromisify.custom = kCustomPromisifiedSymbol;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mayJunPromisify</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> original !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The "original" argument must be of type Function,Received type undefined'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(original[kCustomPromisifiedSymbol])&#123;</span><br><span class="line">        <span class="keyword">const</span> fn = original[kCustomPromisifiedSymbol];</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The "mayJunPromise.custom" property must be of the type Function,Received type number'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.defineProperty(fn,kCustomPromisifiedSymbol,&#123;</span><br><span class="line">            value:fn,</span><br><span class="line">            enumerable:<span class="literal">false</span>,</span><br><span class="line">            writable:<span class="literal">false</span>,</span><br><span class="line">            configurable:<span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">...args</span>)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="util-promisify回调函数多参转换"><a href="#util-promisify回调函数多参转换" class="headerlink" title="util.promisify回调函数多参转换"></a>util.promisify回调函数多参转换</h4><p>有些函数的回调形式是多个参数的，例如dns.lookup，它的回调形式是<code>(err,address,family)=&gt;...</code>拥有 三个参数，对这种情况也做兼容</p><p>基本使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dns = <span class="built_in">require</span>(<span class="string">'dns'</span>);</span><br><span class="line"><span class="keyword">const</span> lookupPromisify = util.promisify(dns.lookup);</span><br><span class="line"></span><br><span class="line">lookupPromisify(<span class="string">'laibh.top'</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">&#123;address,family&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'地址：'</span>,address,<span class="string">'地址族：'</span>,family)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure><p>实现解析：</p><p>为了支持util.promisify也都会在函数上定义一个customPromisifyArgs参数，value为回调的多个参数的名称，类型为数组，例如dns.lookup绑定的customPromisifyArgs的value为<code>[&#39;address&#39;,&#39;family&#39;]</code>，其主要目的也是为了适配util.promisify</p><p>dns.lookup支持util.promisify核心实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;customPromisifyArgs&#125; = <span class="built_in">require</span>(<span class="string">'internal/util'</span>);</span><br><span class="line"></span><br><span class="line">ObjectDefineProperty(lookup,customPromisifyArgs,&#123;</span><br><span class="line">    value:[<span class="string">'address'</span>,<span class="string">'family'</span>],</span><br><span class="line">    enumerable:<span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>customPromisifyArgs这个参数是从internal/util模块导出的，仅内部调用，在外部util.promisify是没有这个参数的。也就意味着只有Node模块中例如dns.lookup、fs.read等方法在多参数的时候可以使用util.promisify转换为Promise，如果自定义的callback存在多参数的情况，使用util.promisify则不行，不过可以基于util.promisify自己封装一个：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// Symbol used to customize promisify conversion</span></span><br><span class="line">    customPromisifyArgs:kCustomPromisifyArgsSymbol</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义Symbol变量kCustomPromisifyArgsSymbol</li><li>获取参数名称列表</li><li><code>(err,result)</code>改为<code>(err,...values)</code>,原先的result仅接受一个参数，改为<code>...values</code>接收多个参数</li><li>argumentNames存在且value&gt;1,则回调会存在多个参数名称，经常遍历，返回一个obj</li><li>否则values最多仅有一个参数名称，即数组values有且仅有一个元素</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> kCustomPromisifyArgsSymbol = <span class="built_in">Symbol</span>(<span class="string">'customPromisifyArgs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 获取多个回调函数的函数参数列表</span></span><br><span class="line">    <span class="keyword">const</span> argumentName = original[kCustomPromisifyArgsSymbol];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">..args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                original.call(<span class="keyword">this</span>,...args,(err,...values)=&gt;&#123;</span><br><span class="line">                    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                        reject(err)</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// argumentNames存在且values&gt;1,则回调会存在多个参数名称，进行遍历，返回一个obj</span></span><br><span class="line">                        <span class="keyword">if</span>(argumentNames !== <span class="literal">undefined</span> &amp;&amp; values.length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                            <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;argumentNames.length;i+=<span class="number">1</span>)&#123;</span><br><span class="line">                                obj[argumentNames[i]] = values[i];</span><br><span class="line">                                resolve(obj)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="comment">// 否则values最多只有一个参数名称，即数组values有且只有一个元素</span></span><br><span class="line">                            resolve(values[<span class="number">0</span>])</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于kCustomPromiseArgsSymbol使用Symbol声明（每次重新定义都会不一样），且没有对外提供。要实现这个功能，需要每次在cb重新定义kCustomPromisifyArgsSymbol属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> kCustomPromisifiedSymbol = <span class="built_in">Symbol</span>(<span class="string">'util.promisify.custom'</span>);</span><br><span class="line"><span class="keyword">const</span> kCustomPromisifyArgsSymbol = <span class="built_in">Symbol</span>(<span class="string">'customPromisifyArgs'</span>);</span><br><span class="line">mayJunPromisify.custom = kCustomPromisifiedSymbol;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mayJunPromisify</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> original !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The "original" argument must be of type Function,Received type undefined'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(original[kCustomPromisifiesSymbol])&#123;</span><br><span class="line">        <span class="keyword">const</span> fn = original[kCustomPromisifiesSymbol];</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The "util.promisify.custom" property must be of type Function.Received type number'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.defineProperty(fn,kCustomPromisifiedSymbol,&#123;</span><br><span class="line">            value:fn,</span><br><span class="line">            enumerable:<span class="literal">false</span>,</span><br><span class="line">            writable:<span class="literal">false</span>,</span><br><span class="line">            configurable:<span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 获取多个回调函数的参数列表</span></span><br><span class="line">        <span class="keyword">const</span> argumentNames = original[kCustomPromisifyArgsSymbol];</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    original.call(<span class="keyword">this</span>,...args,(err,...values)=&gt;&#123;</span><br><span class="line">                        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                            reject)(err);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="comment">// argumentName 存在且 values&gt;1,则回调会存在多个参数名称，进行遍历，返回一个obj</span></span><br><span class="line">                            <span class="keyword">if</span>(argumentNames !== <span class="literal">undefined</span> &amp;&amp; values.length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                                <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">                                <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;argumentNames.length;i+=<span class="number">1</span>)&#123;</span><br><span class="line">                                    obj[argumentNames[i]] = values[i]</span><br><span class="line">                                    resolve(obj)</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                <span class="comment">// 否则values最多仅有一个参数名称，即数组values有且仅有一个元素</span></span><br><span class="line">                                resolve(values[<span class="number">0</span>])</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mayJunPromisify,</span><br><span class="line">    kCustomPromisifyArgsSymbol</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;kCustomPromisifyArgsSymbol,mayJunPromisify&#125; = <span class="built_in">require</span>(<span class="string">'./may-jun-promisify'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mayJunPromisify.custom自定义Promise函数测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisifyCustomTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    fs.readFile[mayJunPromisify.custom]=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'该文件暂时禁止读取'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> readFilePromisify = mayJunPromisify(fs.readFile);</span><br><span class="line">    readFilePromisify(<span class="string">'text.txt'</span>,<span class="string">'utf8'</span>)</span><br><span class="line">        .then(<span class="function"><span class="params">result</span>=&gt;</span><span class="built_in">console</span>.log(result))</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(err)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义cb多参数转换promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cbConverPromiseTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getUserById</span>(<span class="params">id,cb</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> name = <span class="string">'laibh'</span>,</span><br><span class="line">              age = <span class="number">25</span>;</span><br><span class="line">        cb(<span class="literal">null</span>,name,age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(getUserById,kCustomPromisifyArgsSymbol,&#123;</span><br><span class="line">        value:[<span class="string">'name'</span>,<span class="string">'age'</span>],</span><br><span class="line">        enumerable:<span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> getUserByIdPromisify = mayJunPromisify(getUserById);</span><br><span class="line">    getUserByIdPromisify(<span class="number">1</span>)</span><br><span class="line">        .then(&#123;name,age&#125;=&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name,age);</span><br><span class="line">    &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(err))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">promisifyCustomTest();</span><br><span class="line">cbConverPromiseTest();</span><br></pre></td></tr></table></figure><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><p>I/O即Input/Output，输入输出端口，是信息处理系统与外部世界之间的通信，输入手是系统接收的信号或数据，输出的则是从其发送的信号或数据</p><p>一次I/O操作分为等待资源，使用资源两个阶段，常见的词网络I/O,磁盘I/O</p><h3 id="阻塞与非阻塞I-O"><a href="#阻塞与非阻塞I-O" class="headerlink" title="阻塞与非阻塞I/O"></a>阻塞与非阻塞I/O</h3><p>是对于操作系统内核而言的，发生在等待资源阶段，根据发起的I/O请求是否阻塞来判断</p><p>阻塞I/O：这种模式下一个用户进程在发起一个I/O操作之后，只有接收到响应或者超时时才可进行处理其他事情，否则I/O将会一直阻塞。以读取磁盘上的一段文件为例子，系统内核在完成磁盘寻道、读取数据、复制数据到内存之中之后，这个调用才算完成。阻塞的这段时间对CPU资源是浪费的。</p><p>非阻塞I/O：这种模式下一个用户进程发起一个I/O操作之后，如果数据没有就绪，会立刻返回（标志数据资源不可用），此时CPU时间片可以用来做一些其他事情。</p><h3 id="同步与异步I-O"><a href="#同步与异步I-O" class="headerlink" title="同步与异步I/O"></a>同步与异步I/O</h3><p>同步与异步I/O发生在使用资源阶段。</p><p>同步I/O：应用发送或接受数据后，如果不返回，继续等待（此处发生阻塞），直到数据成功或失败返回。</p><p>异步I/O：应用发送或接受数据后立刻返回，数据写入OS缓存，由OS完成数据发送或接收，并返回成功或者失败的信息给应用，NodeJs就是典型异步编程的例子。</p><h3 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h3><p>操作系统为了多个应用同时运行，需要保证不同进程相对独立、内核的安全。所以操作系统把内存空间划分为用户空、内核空间两部分。用户空间存放用户程序代码和数据，而内核空间则存放内核代码和数据。</p><p>OSI七层模型与网际网协议族图：传输层之上（会话层、表示层、应用层）为用户空间（Web客户端、浏览器、FTP），下四层（传输层，网络层，数据链路层，物理层）为内核空间，例如传输层的TCP/UDP就对应内核空间。</p><h3 id="操作系统I-O模型"><a href="#操作系统I-O模型" class="headerlink" title="操作系统I/O模型"></a>操作系统I/O模型</h3><h4 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h4><p>当进程调用 recvfrom() 函数的时候阻塞，<strong>应用程序</strong>开始系统调用，在<strong>系统内核</strong>数据就绪，将数据从内核中拷贝出来后结束。这个过程应用程序都处于等待状态，不能做其他事情，直到将数据拷贝到用户空间或出错才返回，我们称之为阻塞I/O模式。</p><h3 id="同步非阻塞I-O"><a href="#同步非阻塞I-O" class="headerlink" title="同步非阻塞I/O"></a>同步非阻塞I/O</h3><p>想对于同步非阻塞I/O模式，同步非阻塞I/O在 每次调用之后，如果数据没有就绪就会立即返回，之后重复调用检查I/O操作是否就绪，这对CPU资源非常浪费，直到数据就绪将数据从内核拷贝到用户空间，返回成功指示到应用程序。</p><h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p>链接（Socket）并发大的时候，上面的两种就不适合了，前面一个处理不完，后面的就只能干等。多路复用技术先进行select数据就绪后，调用recvfrom进行真正的I/O读写操作。高级之处在于能够一个线程同时处理多个Socket</p><p>多路复用中的I/O通常指的是网络I/O,多路指的是多个Socker链接，复用指操作系统进行运算调度最小单位线程，整体的意思就是多个网络I/O复用一个或少量线程来处理Socket</p><p>I/O多路复用的四种实现：select/poll/epoll/kqueue</p><ul><li>select，通过轮询检查在文件描述符上设置的标志位来进行判断，select的轮询相当于在数据库中查找一条记录没有建立索引，对所有的socket进行全部遍历，这对CPU是浪费的。另外select还有一个限制，对于单个线程所能打开的文件描述符最大只有1024，那么基于select的轮询技术最多也只能很好的处理1000并发的吞吐量</li><li>poll,poll和select在实现上没有什么本质上的区别，poll基于链表来实现，没有了最大链接1024的限制。当文件描述符多了之后，每次调用都会对链接进行线性遍历，性能也是十分低下的。</li><li>epoll。是linux下效率最高的I/O事件通知机制，没有最大链接限制，通过callback回调通知机制，不再是每次调用对链接进行线性遍历，这样就不会随着文件描述符的增加导致效率下降。1GB内存的机器上大概能监听10w个端口，远超过select1024的限制</li><li>kqueue，与epoll类似，仅存于FreeBSD(一种类UNIX操作系统)</li></ul><h3 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h3><p>仅在Unix上支持，与I/O多路复用相比避免了select的阻塞轮询，应用程序进行系统调用后立即返回，处理其他事情，在数据就绪之后系统会发送一个SIGIO信号到应用程序，应用程序开始读取数据</p><h3 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h3><p>目前最理想形式的一种，应用程序发起系统调用后无需等待直接返回当前调用状态，进行后续的其他任务，结果由内核完成I/O操作之后通过回调通知到应用程序，中间没有阻塞过程。Linux2.6增加了AIO，但是很少系统能够实现</p><h3 id="轮询技术Select-与-Epoll的区别"><a href="#轮询技术Select-与-Epoll的区别" class="headerlink" title="轮询技术Select 与 Epoll的区别"></a>轮询技术Select 与 Epoll的区别</h3><p><strong>操作方式上</strong></p><ul><li>select采用了线性遍历来查找，链接多了之后在一个庞大的数组中每次遍历来锁定一个链接，非常消耗性能</li><li>epoll则不需要遍历，采用的是回调机制，可以看作是一个HashTable，来锁定一个对象非常快。</li></ul><p><strong>文件描述符限制</strong></p><ul><li>对于文件描述符最大链接数select限制为1024</li><li>epoll则没有这个限制，通常在1GB内存的机器上所能支持的连接数为10W左右。</li></ul><p><strong>操作系统的支持</strong></p><p>目前高性能的Web服务器Nginx是基于epoll来实现高并发的</p><h3 id="Nodejs中的内存管理和V8垃圾回收机制"><a href="#Nodejs中的内存管理和V8垃圾回收机制" class="headerlink" title="Nodejs中的内存管理和V8垃圾回收机制"></a>Nodejs中的内存管理和V8垃圾回收机制</h3><p>在Nodejs中，关于垃圾回收、内存释放不需要像C语言创建一个对象之后需手动创建一个delete/free的一个操作之后进行GC,Nodejs与java一样，由虚拟机进行内存自动管理。</p><h3 id="NodeJs中的GC"><a href="#NodeJs中的GC" class="headerlink" title="NodeJs中的GC"></a>NodeJs中的GC</h3><p>node.js是基于Chrome v8引擎的javascript运行环境，V8就是虚拟机。</p><h3 id="垃圾回收内存管理实践"><a href="#垃圾回收内存管理实践" class="headerlink" title="垃圾回收内存管理实践"></a>垃圾回收内存管理实践</h3><h4 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h4><p>node提供process.memoryUsage方法来查看当前进程内存使用情况，单位为节</p><ul><li>ress(resident set size)：RAM中保存的进程占用的内存部分，包括代码本身、栈、堆</li><li>heapTotal：堆中总共申请到的内存量</li><li>heapUsed：堆中目前用到的内存量，判断内存泄露主要以这个字节为准</li><li>external：V8引擎内存C++对象占用的内存</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*单位字节格式为MB输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> format = <span class="function"><span class="keyword">function</span>(<span class="params">bytes</span>)</span></span><br><span class="line"><span class="function">    <span class="title">return</span> (<span class="params">bytes<span class="regexp">/1024/</span><span class="number">1024</span></span>).<span class="title">toFixed</span>(<span class="params"><span class="number">2</span></span>)+' <span class="title">MB</span>'</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">/*</span></span><br><span class="line"><span class="function">*封装<span class="title">print</span>方法输出内存占用信息</span></span><br><span class="line"><span class="function">*/</span></span><br><span class="line"><span class="function"><span class="title">const</span> <span class="title">print</span> = <span class="title">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> memoryUsage = process.memoryUsage();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">            res:format(memoryUsage.rss),</span><br><span class="line">            heapTotal:format(memoryUsage.heapTotal),</span><br><span class="line">            heapUsed:format(memoryUsage.heapUsed),</span><br><span class="line">            external:format(memoryUsage.external),</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内存泄露的例子"><a href="#内存泄露的例子" class="headerlink" title="内存泄露的例子"></a>内存泄露的例子</h4><p>堆用来存放对象引用类型，例如字符串、对象、在代码中创建一个Fruit存放在堆中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Quantity</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(num * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name,quantity</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.quantity = <span class="keyword">new</span> Quantity(quantity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> apple = <span class="keyword">new</span> Fruit(<span class="string">'apple'</span>);</span><br><span class="line">print();</span><br><span class="line"><span class="keyword">let</span> banane = <span class="keyword">new</span> Fruit(<span class="string">'banane'</span>,<span class="number">20</span>);</span><br><span class="line">print();</span><br><span class="line"><span class="comment">// 执行代码，aplle对象heapUsed使用仅有4.21M，而banana由于quantity属性创建了一个很大数组空间导致heapUsed飙升到164.21M。</span></span><br><span class="line"><span class="comment">// &#123;"rss":"19.94 MB","heapTotal":"6.83 MB","heapUsed":"4.21 MB","external":"0.01 MB"&#125;</span></span><br><span class="line"><span class="comment">// &#123;"rss":"180.04 MB","heapTotal":"166.84 MB","heapUsed":"164.24 MB","external":"0.01 MB"&#125;</span></span><br></pre></td></tr></table></figure><h4 id="手动执行垃圾回收内存释放"><a href="#手动执行垃圾回收内存释放" class="headerlink" title="手动执行垃圾回收内存释放"></a>手动执行垃圾回收内存释放</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">banana = <span class="literal">null</span>;</span><br><span class="line">global.gc();</span><br><span class="line">print(); </span><br><span class="line"><span class="comment">// 执行 node --expose-gc xxx.js --expose-gc参数表示运行手动执行垃圾回收机制，将banana对象赋值null进行GC</span></span><br><span class="line"><span class="comment">// &#123;"rss":"52.48 MB","heapTotal":"9.33 MB","heapUsed":"3.97 MB","external":"0.01 MB"&#125;</span></span><br><span class="line"><span class="comment">// heapUsed的使用已经降了下来</span></span><br></pre></td></tr></table></figure><h3 id="V8垃圾回收机制"><a href="#V8垃圾回收机制" class="headerlink" title="V8垃圾回收机制"></a>V8垃圾回收机制</h3><p>垃圾回收指的是回收那些在应用程序中不再引用的对象，当一个对象无法从根节点访问这个对象就会作为垃圾回收的候选对象。这里的根对象可以为全局对象、局部变量，无法从根节点访问指的也就是不会再被其他活动对象所引用。</p><h4 id="V8堆内存限制"><a href="#V8堆内存限制" class="headerlink" title="V8堆内存限制"></a>V8堆内存限制</h4><p>在V8中限制64位机制大约为1.4G，32位的大概是0.7G，对于一些大内存的操作需要谨慎否则超出V8内存限制会造成进程退出</p><p>内存溢出边界的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// overflow.js</span></span><br><span class="line"><span class="keyword">const</span> format = <span class="function"><span class="keyword">function</span>(<span class="params">bytes</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (bytes / <span class="number">1024</span> / <span class="number">1024</span>).toFixed(<span class="number">2</span>)+<span class="string">' MB'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> memoryUsage = process.memoryUsage();</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`heapTotal:<span class="subst">$&#123;format(memoryUsage.heapTotal)&#125;</span>,</span></span><br><span class="line"><span class="string"> heapUsed: <span class="subst">$&#123;format(memoryUsage.heapUsed)&#125;</span>`</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> total = [];</span><br><span class="line">setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    total.push(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>*<span class="number">1024</span>*<span class="number">1024</span>)) <span class="comment">// 大内存占用</span></span><br><span class="line">    print();</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>total为全局变量每次增长大概在160M左右且不会被回收，在接近V8边界时无法分配内存导致进程内存溢出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node overflow.js</span></span><br><span class="line">heapTotal: 166.84 MB, heapUsed: 164.23 MB</span><br><span class="line">heapTotal: 326.85 MB, heapUsed: 324.26 MB</span><br><span class="line">heapTotal: 487.36 MB, heapUsed: 484.27 MB</span><br><span class="line">heapTotal: 649.38 MB, heapUsed: 643.98 MB</span><br><span class="line">heapTotal: 809.39 MB, heapUsed: 803.98 MB</span><br><span class="line">heapTotal: 969.40 MB, heapUsed: 963.98 MB</span><br><span class="line">heapTotal: 1129.41 MB, heapUsed: 1123.96 MB</span><br><span class="line">heapTotal: 1289.42 MB, heapUsed: 1283.96 MB</span><br><span class="line"></span><br><span class="line">&lt;--- Last few GCs ---&gt;</span><br><span class="line"></span><br><span class="line">[87581:0x103800000]    11257 ms: Mark-sweep 1283.9 (1290.9) -&gt; 1283.9 (1290.9) MB, 512.1 / 0.0 ms  allocation failure GC in old space requested</span><br><span class="line">[87581:0x103800000]    11768 ms: Mark-sweep 1283.9 (1290.9) -&gt; 1283.9 (1287.9) MB, 510.7 / 0.0 ms  last resort GC in old space requested</span><br><span class="line">[87581:0x103800000]    12263 ms: Mark-sweep 1283.9 (1287.9) -&gt; 1283.9 (1287.9) MB, 495.3 / 0.0 ms  last resort GC in old space requested</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;--- JS stacktrace ---&gt;</span><br></pre></td></tr></table></figure><p>v8提供了两个参数仅在启用阶段调整内存限制大小，分别为调整老生代、新生代：</p><ul><li>–max-old-space-size=2048</li><li>–max-new-space-size=2048</li></ul><p>内存不是越大越好，一方面是服务器资源昂贵，另外是V8以1.5G的堆内存进行一次小的垃圾回收大约需要50毫秒以上时间，会导致JavaScript进程暂停，这也是最主要的一方面。</p><h4 id="新生代与老生代"><a href="#新生代与老生代" class="headerlink" title="新生代与老生代"></a>新生代与老生代</h4><p><strong>新生代空间</strong></p><p>由于新空间的垃圾回收机制很频繁，所以处理方式必须非常快，采用Scavenge算法，这是一种复制算法，新生代空间会被一分为二划分为两个相等大小的from-space和to-space工作方式是将from space中存活的对象复制出来，然后移动它们到to space 中或者被提升到老生代空间中，对于from space中没有存活的对象将会被释放，完成这些复制后再将from space和to space进行互换。</p><p>Scavenge算法适用少量内存的垃圾回收，但是有很大的空间开销，对于新生代少量内存是可以接受的</p><p><strong>老生代空间</strong></p><p>新生代空间在垃圾回收满足于一定的条件（是否经过Scavenge空间、to space内存占比）会被晋升到老生代空间中，在老生代空间中的对象都已经至少经历了一次或者多次的回收所以它们的存活概率会更大。在使用Scavenge算法会有两个缺点，一是将会重复的复制存活对象使得效率低下，二是对空间资源的浪费，所以在老生代空间中采用了 Mark-Sweep（标记清除）和Mark-Compact（标记整理）算法</p><p>Mark-Sweep处理时分为标记、清除两个步骤，与Scavenge算法只复制活对象相反的是在老生代空间中由于活对象占多数Mark-Sweep在标记阶段遍历堆中的所有对象仅标记活对象把未标记的死对象清除，这时一次标记清除就已经完成了。有一个问题是被清除的对象遍布于各内存地址，产生很多内存碎片</p><p>Mark-Compact(标记整理算法)为了解决内存碎片问题，在其工作过程中将活着的对象往一端移动，这时内存空间是紧凑的，移动完成之后，直接整理边界之外的内存。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>V8使用了不同的垃圾回收算法Scavenge/Mark-Sweep/Mark-Compact.这三种垃圾回收算法都避免不了在进行垃圾回收时需要将应用程序暂停，待垃圾回收完成之后在恢复应用逻辑，对于新生代空间来说由于很快所以影响不大，但是对于老生代空间由于存活对象较多，停顿还是会造成影响的，因此V8又新增了增量标记的方式减少停顿时间。</p><h3 id="内存泄露-1"><a href="#内存泄露-1" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>内存泄露（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统奔溃等严重后果。</p><p><strong>全局变量</strong>，未声明的变量或挂在全局global下的变量不会自动回收，将会常驻内存直到直到进程退出才会释放，除非通过delete或者重新赋值为undefined/null解决之间的引用关系，才会被回收。</p><p><strong>闭包</strong>，也是一个常见的内存泄露问题，闭包会引用父级函数中的变量，如果闭包得不到释放，闭包引用的父级变量也不会释放从而导致内存泄露</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> originalThing = theThing;</span><br><span class="line">    <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(originalThing)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        theThing = &#123;</span><br><span class="line">            longStr:<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'*'</span>),</span><br><span class="line">            someMethod:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(someMessage)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setInterval(replaceThing,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>代码运行时，每次执行replaceThing方法都会生成一个新的对象，但是之前的对象没有释放导致的内存泄露。</p><p><strong>慎将内存作为缓存</strong></p><p>通过内存来做缓存是最快的实现方式，缓存中的存储的键越多，长期存活的对象就越多，垃圾回收时将这些对象做无用功。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面一个获取用户Token的例子，memoryStore对象会随着用户数的增加而增长，当启动多个线程或者部署在多台机器会造成每个进程都保存一份，显然是资源的浪费，最好是通过Redis做共享</span></span><br><span class="line"><span class="keyword">const</span> memoryStore = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">exports.getUserToken = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> token = memoryStore.get(key);</span><br><span class="line">    <span class="keyword">if</span>(token &amp;&amp; <span class="built_in">Date</span>.now() - token.now &gt; <span class="number">2</span> * <span class="number">60</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> dbToken = db.get(key);</span><br><span class="line">    memoryStore.set(key,&#123;</span><br><span class="line">        now:<span class="built_in">Date</span>.now(),</span><br><span class="line">        val:dbToken</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>模块私有变量内存常驻</strong></p><p>加载一个模块代码之前，Nodejs会使用一个如下的函数封装器将其封装，保证了顶层的变量（var,const,let）在模块范围内，而不是全局对象。这个时候就会形成一个闭包，在require时会被加载一次，将exports对象保存在内存中，直到进程退出才会回收，这个将会导致的是内存常驻，所以避免一些没必要的模块加载，否则也会造成内存增加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">exports,require,module,__filename,__dirname</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 模块的代码实际上在这里</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 所以建议对模块的引用仅在头部初次加载之后用const缓存起来，而不是在使用时每次都去加载一起。</span></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'a.js'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'a.js'</span>).run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>事件反复监听</strong></p><p>NodeJs中对一个事件反复监听则会报下面的错误，实际上使用的EventEmitter类，包含一个listeners数组，默认为10个监听器超出这个数则会报警，用于发现内存泄露，也可以通过emitter.setMaxListeners()方法为指定的EventEmitter实例修改限制</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxListenersExceededWarning：Possible EventEmitter memory leak detected, 11 connect added.Use emitter.setMaxListeners() to increase limit</span><br></pre></td></tr></table></figure><p><strong>其他注意事项</strong></p><p>使用定时器setInterval时记得使用对应的clearInterval进行清除。因为setInterval执行完之后会返回一个值且不会自动释放，另外还有map/filter等对数组进行操作，每次操作之后都会创建一个新的数组，将会占用内存，如果单纯的遍历map可以用forEach。</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul><li><code>[Cache]</code> <a href="https://github.com/webpack/memory-fs">memory-fs 将文件写入内存</a></li><li><code>[Cache]</code> <a href="https://github.com/ptarjan/node-cache#readme">Memory Cache</a></li><li><code>[Cache]</code> <a href="https://github.com/mpneuried/nodecache">Node Cache</a></li></ul><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><ul><li><code>[Schedule]</code> <a href="https://github.com/node-schedule/node-schedule">node-schedule</a></li><li><code>[Schedule]</code> <a href="https://github.com/agenda/agenda">Agenda 将Node中的定时任务存储在数据库中（官方推荐MongoDB）</a></li><li><code>[Schedule]</code> <a href="https://www.nodejs.red/#/docs/microservice/rabbitmq-base?id=rabbitmq延迟队列实现定时任务">Node.js结合RabbitMQ延迟队列实现定时任务</a></li></ul><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><ul><li><code>[Template]</code> <a href="https://ejs.co/">Ejs</a></li><li><code>[Template]</code> <a href="https://handlebarsjs.com/">Handlebarsjs</a></li><li><code>[Template]</code> <a href="http://jade-lang.com/">Jade</a></li></ul><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><ul><li><code>[Framework]</code> <a href="http://www.expressjs.com.cn/">Express 中文版</a>、<a href="http://www.expressjs.com.cn/">Express of English Version</a></li><li><code>[Framework]</code> <a href="https://koajs.com/">Koa 中文版</a>、<a href="https://koajs.com/">Koa of English Version</a></li><li><code>[Framework]</code> <a href="https://eggjs.org/zh-cn/intro/quickstart.html">Egg 中文版</a>、<a href="https://eggjs.org/en/intro/quickstart.html">Egg of English Version</a></li><li><code>[Framework]</code> <a href="https://docs.nestjs.cn/">Nest.js 中文版</a>、<a href="https://docs.nestjs.com/">Nest.js</a></li></ul><h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><ul><li><code>[typeorm]</code> <a href="https://typeorm.io/">typeorm</a> 【右上角切换中文】</li><li><code>[sequelize]</code> <a href="http://docs.sequelizejs.com/">sequelize</a></li><li><code>[prisma]</code> <a href="https://www.prisma.io/docs">prisma</a></li></ul><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h3><p><strong>QPS</strong></p><p>QPS（Query Per Second）指每秒查询量，规定时间内所能处理的流量大小，通常QPS值越大服务器的吞吐量也就越大，相对服务器负荷也会越高</p><p>QPS=并发量/平均响应时间并发量 = QPS * 平均响应时间</p><p><strong>TPS</strong></p><p>TPS（TransactionPerSecond）指每秒事物处理量，每秒钟系统所能处理的交易或事务的数量，用来形容系统的性能。</p><p><strong>两者区别</strong></p><p>一次下单请求，访问一次创建接口产生一次TPS,对于服务器的请求可能会产生多次，比如查询用户地址信息、商品数据信息、商品报价信息，这些请求计入QPS,也就是产生了3次QPS</p><h3 id="系统扩容评价"><a href="#系统扩容评价" class="headerlink" title="系统扩容评价"></a>系统扩容评价</h3><p>根据二八法则来评估系统扩容需要多少台机器，二八法则即20%的时间承载80%的流量，把20%的时间称为峰值时间，换算公式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(总PV数 * 80%) / (每天描述 * 20%) = 峰值时间每秒请求数</span><br><span class="line">峰值时间内每秒请求数（QPS）/单台机器QPS = 需要的机器</span><br></pre></td></tr></table></figure><p>假设有1000wPV,总共需要的QPS为多少？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1000000 * 0.8) / (24 * 60 * 60 * 0.2) = 463(QPS)</span><br></pre></td></tr></table></figure><p>假设每台机器支撑100QPS，则共需要的机器为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">463</span>(总有QPS)/<span class="number">100</span>(单机QPS) = <span class="number">5</span>(约需要<span class="number">5</span>台机器)</span><br></pre></td></tr></table></figure><h2 id="Nodejs-CPU使用率"><a href="#Nodejs-CPU使用率" class="headerlink" title="Nodejs CPU使用率"></a>Nodejs CPU使用率</h2><h3 id="os-cups-数据指标"><a href="#os-cups-数据指标" class="headerlink" title="os.cups()数据指标"></a>os.cups()数据指标</h3><p>返回的对象数组中有一个times字段，包含了user/nice/sys/idle/irq几个指标数据，分别代表CPU在用户模式、良好模式、系统模式、空闲模式、中断模式下话费的毫秒数。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    model: <span class="string">'Intel(R) Core(TM) i5-4590 CPU @ 3.30GHz'</span>,</span><br><span class="line">    speed: <span class="number">3292</span>,</span><br><span class="line">    times: &#123;</span><br><span class="line">      user: <span class="number">151474100</span>,</span><br><span class="line">      nice: <span class="number">0</span>,</span><br><span class="line">      sys: <span class="number">95311197</span>,</span><br><span class="line">      idle: <span class="number">2258535287</span>,</span><br><span class="line">      irq: <span class="number">2136605</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    model: <span class="string">'Intel(R) Core(TM) i5-4590 CPU @ 3.30GHz'</span>,</span><br><span class="line">    speed: <span class="number">3292</span>,</span><br><span class="line">    times: &#123;</span><br><span class="line">      user: <span class="number">84900939</span>,</span><br><span class="line">      nice: <span class="number">0</span>,</span><br><span class="line">      sys: <span class="number">65104926</span>,</span><br><span class="line">      idle: <span class="number">2355314423</span>,</span><br><span class="line">      irq: <span class="number">874869</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    model: <span class="string">'Intel(R) Core(TM) i5-4590 CPU @ 3.30GHz'</span>,</span><br><span class="line">    speed: <span class="number">3292</span>,</span><br><span class="line">    times: &#123;</span><br><span class="line">      user: <span class="number">144337320</span>,</span><br><span class="line">      nice: <span class="number">0</span>,</span><br><span class="line">      sys: <span class="number">112618416</span>,</span><br><span class="line">      idle: <span class="number">2248364428</span>,</span><br><span class="line">      irq: <span class="number">699602</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    model: <span class="string">'Intel(R) Core(TM) i5-4590 CPU @ 3.30GHz'</span>,</span><br><span class="line">    speed: <span class="number">3292</span>,</span><br><span class="line">    times: &#123;</span><br><span class="line">      user: <span class="number">110066333</span>,</span><br><span class="line">      nice: <span class="number">0</span>,</span><br><span class="line">      sys: <span class="number">84988268</span>,</span><br><span class="line">      idle: <span class="number">2310265437</span>,</span><br><span class="line">      irq: <span class="number">897333</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>定义方法getCPUInfo用来获取系统CPU信息，提供了CPU利用率的实时监控，这个实时不是绝对的实时，会有时差，下面实现中默认设置的1秒钟，可以通过Options.ms进行调整</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>);</span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OSUtils</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.cpuUsageMSDefault = <span class="number">1000</span>; <span class="comment">// CPU 利用率默认时间段</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取CPU信息</span></span><br><span class="line"><span class="comment">   * @return &#123;Object&#125; CPU信息</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> _getCPUInfo() &#123;</span><br><span class="line">  <span class="keyword">const</span> cpus = os.cpus();</span><br><span class="line">  <span class="keyword">let</span> user = <span class="number">0</span>,</span><br><span class="line">    nice = <span class="number">0</span>,</span><br><span class="line">    sys = <span class="number">0</span>,</span><br><span class="line">    idle = <span class="number">0</span>,</span><br><span class="line">    irq = <span class="number">0</span>,</span><br><span class="line">    total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> cpu <span class="keyword">in</span> cpus) &#123;</span><br><span class="line">    <span class="keyword">const</span> times = cpus[cpu].times;</span><br><span class="line">    user += times.user;</span><br><span class="line">    nice += times.nice;</span><br><span class="line">    sys += times.sys;</span><br><span class="line">    idle += times.idle;</span><br><span class="line">    irq += times.irq;</span><br><span class="line">  &#125;</span><br><span class="line">  total += user + nice + sys + idle + irq;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    user,</span><br><span class="line">    sys,</span><br><span class="line">    idle,</span><br><span class="line">    total</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取某时间段CPU利用率</span></span><br><span class="line"><span class="comment">   * @param &#123;Number&#125; Options.ms [时间段，默认是1000ms，即1秒钟]</span></span><br><span class="line"><span class="comment">   * @param &#123;Boolean&#125; Options.percentage [true（以百分比结果返回）| false]</span></span><br><span class="line"><span class="comment">   * @return &#123;Promise&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">async</span> getCPUUsage(options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> &#123; cpuUsageMS, percentage &#125; = options;</span><br><span class="line">    cpuUsageMS = cpuUsageMS || that.cpuUsageMSDefault;</span><br><span class="line">    <span class="keyword">const</span> t1 = that._getCPUInfo(); <span class="comment">// t1时间点的 CPU信息</span></span><br><span class="line">    <span class="keyword">await</span> sleep(cpuUsageMS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> t2 = that._getCPUInfo(); <span class="comment">// t2时间点的 CPU信息</span></span><br><span class="line">    <span class="keyword">const</span> idle = t2.idle - t1.idle;</span><br><span class="line">    <span class="keyword">const</span> total = t2.total - t1.total;</span><br><span class="line">    <span class="keyword">let</span> usage = <span class="number">1</span> - idle / total;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (percentage) usage = (usage * <span class="number">100.0</span>).toFixed(<span class="number">2</span>) + <span class="string">'%'</span>;</span><br><span class="line">    <span class="keyword">return</span> usage;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> osUtils = <span class="keyword">new</span> OSUtils()</span><br><span class="line">osUtils.getCPUUsage(&#123; <span class="attr">percentage</span>: <span class="literal">true</span> &#125;).then(<span class="function"><span class="params">cpuUsage</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'CPU 利用率'</span>, cpuUsage)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="NodeJs与Event-Loop"><a href="#NodeJs与Event-Loop" class="headerlink" title="NodeJs与Event Loop"></a>NodeJs与Event Loop</h2><p>node之前的世界，多线程服务器中，Web应用程序是用一个client/server(客户端/服务端)模式所编写的，其中client将向server请求资源并且将会根据这个资源以响应，server仅在client请求时做出响应，并在每次响应后关闭连接。这种模式是有效的，因为对服务器的每一个请求都需要时间和资源（内存、CPU等等），服务器必须完成上一个请求，才能接受下一个请求。需要同时处理N个请求，服务器就需要N个线程，如果有N+1个请求，就必须等N个线程中的任何一个可用。</p><p>服务器中的线程不是唯一的问题，一个线程为什么不能同时处理2个或者更多请求，是因为阻塞了Input/Output操作。</p><table><thead><tr><th>操作</th><th>CPU时钟周期数(ticks)</th></tr></thead><tbody><tr><td>CPU寄存器</td><td>3</td></tr><tr><td>L1 Cache(一级缓存)</td><td>8</td></tr><tr><td>L2 Cache(二级缓存)</td><td>12</td></tr><tr><td>RAM(随机存取存储器)</td><td>150</td></tr><tr><td>Disk（磁盘）</td><td>30 000 000</td></tr><tr><td>NetWork（网络）</td><td>250 000 000</td></tr></tbody></table><p>时钟周期也称为tick/clock cycle/clock period等，指一个硬件在被使用过程中，被划分为多个时间周期，当我们需要比较不同硬件性能时，就在不同硬件上测试同一个软件，观察它们的时钟周期时间和周期指数，如果时钟周期越长、周期越多，就意味着这个硬件需要的性能较低。</p><h3 id="Event-Loop事件循环"><a href="#Event-Loop事件循环" class="headerlink" title="Event Loop事件循环"></a>Event Loop事件循环</h3><p>事件循环实际上是一个无限循环，并且线程里唯一可用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> StartNodeInstance(<span class="keyword">void</span>* arg)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#123;</span><br><span class="line">        SealHandleScope seal(isolate);</span><br><span class="line">        bool more;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            v8::platform::PumpMessageLoop(default_platform,isolate);</span><br><span class="line">            more = uv_run(env-&gt;event_loop(),UV_RUN_ONCE);</span><br><span class="line">            <span class="keyword">if</span>(mode == <span class="literal">false</span>)&#123;</span><br><span class="line">                v8::platform::PumpMessageLoop(default_platform,isolate);</span><br><span class="line">                EmitBeforeExit(env);</span><br><span class="line">                </span><br><span class="line">                more = uv_loop_alive(env-&gt;event_loop());</span><br><span class="line">                <span class="keyword">if</span>(uv_run(env-&gt;event_loop),UV_RUN_NOWAIT)!=<span class="number">0</span>)&#123;</span><br><span class="line">                    more = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(more == <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件循环经历6个阶段，所有阶段的执行被称为tick</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">timers-&gt;</span><span class="bash">pending callbacks -&gt;idle,prepare-&gt;poll-&gt;check-&gt;close callbacks</span></span><br></pre></td></tr></table></figure><ul><li>timers：这个阶段执行定时器setTimeout和setInterval的回调函数</li><li>pending callbacks：几乎所有的回调都在这里执行，除了close回调，定时器timers阶段的回调和setImmediate</li><li>idle,prepare：仅在内部使用</li><li>poll：检索新的I/O事件，适当时Node在此处阻塞</li><li>check：setImmediate回调函数将在这里执行</li><li>close callbacks：一些准备关闭的回调函数，如 socket.on(‘close’,…)</li></ul><p>当Event loop需要执行I/O操作时，它将从一个池（通过Libuv库）中使用系统线程，当这个作业完成时，回调将排队等待在pending callbacks阶段被执行</p><h3 id="CPU密集型任务问题"><a href="#CPU密集型任务问题" class="headerlink" title="CPU密集型任务问题"></a>CPU密集型任务问题</h3><p>设定一个函数，给定一个数，计算在一个数组中返回N个质数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primes.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>, s = <span class="built_in">Math</span>.sqrt(n); i &lt;= s; i++)</span><br><span class="line">    <span class="keyword">if</span> (n % i === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> n &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nthPrime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = n;</span><br><span class="line">  <span class="keyword">let</span> iterator = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (counter &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    isPrime(iterator) &amp;&amp; result.push(iterator) &amp;&amp; counter--;</span><br><span class="line">    iterator++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; isPrime, nthPrime &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> primes = <span class="built_in">require</span>(<span class="string">'./primes'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; pathname, query &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (pathname === <span class="string">'/primes'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = primes.nthPrime(query.n || <span class="number">0</span>);</span><br><span class="line">    res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>);</span><br><span class="line">    res.write(<span class="built_in">JSON</span>.stringify(result));</span><br><span class="line">    res.end()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.statusCode = <span class="number">404</span>;</span><br><span class="line">    res.write(<span class="string">'Not Found'</span>);</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(<span class="number">9898</span>);</span><br><span class="line"><span class="comment">// index.js 创建一个服务并在每次请求 /primes这个库，通过query传递参数，假设有3个客户端访问这个非阻塞API,第一个页面请求5个质数，第二个1000个，第三个100000000个，会发现，第三个请求时，客户端就会被阻塞，因为质数会占用大量的CPU,主线程忙于执行密集型的代码，将无法做其他事情，还有Node引入了工作线程</span></span><br></pre></td></tr></table></figure><h3 id="工作线程"><a href="#工作线程" class="headerlink" title="工作线程"></a>工作线程</h3><p>工作线程对于执行CPU密集型的javascript操作非常有用，在I/O密集型的工作中用途不大，NodeJs内置的异步I/O操作比工作线程效率更高</p><p>修改代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; workerData, parentPort &#125; = <span class="built_in">require</span>(<span class="string">'worker_threads'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>, s = <span class="built_in">Math</span>.sqrt(n); i &lt;= s; i++)</span><br><span class="line">    <span class="keyword">if</span> (n % i === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> n &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nthPrime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = n;</span><br><span class="line">  <span class="keyword">let</span> iterator = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (counter &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    isPrime(iterator) &amp;&amp; result.push(iterator) &amp;&amp; counter--;</span><br><span class="line">    iterator++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parentPort.postMessage(nthPrime(workerData.n))</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; Worker &#125; = <span class="built_in">require</span>(<span class="string">'worker_threads'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; pathname, query &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (pathname === <span class="string">'/primes'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(<span class="string">'./primes.js'</span>, &#123;</span><br><span class="line">      workerData: &#123;</span><br><span class="line">        n: query.n || <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    worker.on(<span class="string">'error'</span>, () =&gt; &#123;</span><br><span class="line">      res.statusCode = <span class="number">500</span>;</span><br><span class="line">      res.write(<span class="string">'Oops there was an error'</span>);</span><br><span class="line">      res.end();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line"></span><br><span class="line">    worker.on(<span class="string">'message'</span>, (message) =&gt; &#123;</span><br><span class="line">      result = message;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    worker.on(<span class="string">'exit'</span>, () =&gt; &#123;</span><br><span class="line">      res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>);</span><br><span class="line">      res.write(<span class="built_in">JSON</span>.stringify(result));</span><br><span class="line">      res.end()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.statusCode = <span class="number">404</span>;</span><br><span class="line">    res.write(<span class="string">'Not Found'</span>);</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(<span class="number">9898</span>);</span><br><span class="line"><span class="comment">// index.js在每个请求中创建一个Worker实例，在一个工作线程中加载并执行primes文件，当这个质数列表计算完成买这个message将会被触发，接受信息并赋值result，由于这个job已完成，将会再次触发exit事件，允许主线程发送数据到客户端</span></span><br><span class="line"><span class="comment">// primes导入 workerData(从主线程传递参数)，parentPort是向主线程发送消息的方式</span></span><br><span class="line"><span class="comment">// 主线程将不会再阻塞，但是生成工作线程并不是最佳实践，创建新线程并不便宜，一定要先创建一个线程池</span></span><br></pre></td></tr></table></figure><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis是一个免费开源、基于内存的高性能Key-Value数据库，具有速度快，数据持久化，多语言和多功能等特性。</p><p><strong>速度快</strong>：10w OPS能力，单线程模型，数据存于内存中，注意一次只能运行一次命令，使用过程拒绝使用慢命令，例如keys/flushall/flushdb/slow lua script/mutil/exec等</p><p><strong>持久化</strong>：基于内存模型，断电后或者服务重启会造成数据丢失，针对这个问题，提出两种数据持久化策略，分别为RDB和AOF,会将Redis在内存中的数据异步更新到磁盘中，实现数据的持久化功能。</p><p><strong>丰富的数据类型</strong>：除了常见的String/HashTable/List/Set/Zset之外还有BitMaps(位图)、HyperLogLog（超小内存唯一计数）</p><p><strong>多语言</strong>：基于TCP的通信方式，支持Node.Js/Python/Java/Ruby/Lua等。</p><p><strong>多功能</strong>：提供了发布订阅、简单的事务功能、pipeline提高客户端并发效率。另外在Redis中所有单个命令操作都是原子性的，如果想对多个命令一起操作，可以借助Lua脚本（实现自定义命令，保证原子性）</p><h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><ul><li><code>keys *</code> ：遍历所有key，生产环境不建议使用，时间复杂度O(n)</li><li><code>dbsize key</code>：计算key的总数，Redis内置了这个计数器，会实时更新key的总数，时间复杂度O(1)</li><li><code>exists key</code>：检查key是否存在，时间复杂度为O(1)</li><li><code>expire key seconds</code>：key在指定second后过期，时间复杂度O(1)</li><li><code>ttl key</code>：key剩余的过期时间，时间复杂度O(1)</li><li><code>persist key</code>: 去掉key的过期时间，时间复杂度O(1)</li><li><code>type key</code>：查看key的类型，时间复杂度O(1)</li></ul><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>最大限制512MB,适用于缓存、计算器、分布式锁等，字符串类型的值可以为简单的字符串、JSON、XML、数组甚至是二进制（视频）</p><h5 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h5><table><thead><tr><th>命令</th><th>含义</th><th>时间复杂度</th></tr></thead><tbody><tr><td>set get del</td><td>对key进行设置、读取、删除</td><td>O(1)</td></tr><tr><td>incr decr</td><td>计数</td><td>O(1)</td></tr><tr><td>incrby decrby</td><td>对计数设置增量</td><td>O(1)</td></tr><tr><td>setnx</td><td>key存在不做任何操作</td><td>O(1)</td></tr><tr><td>setex</td><td>key存在做操作与setnx相反</td><td>O(1)</td></tr><tr><td>getset</td><td>设置新值返回旧值 getset key newValue</td><td>O(1)</td></tr><tr><td>mset mget</td><td>多个key进行设置、读取</td><td>O(1)</td></tr></tbody></table><p><strong>set</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set key value [ex seconds] [px milliseconds] [nx|xx]</span><br><span class="line"><span class="comment">// seconds：单位(秒)</span></span><br><span class="line"><span class="comment">// milliseconds:单位（毫秒）</span></span><br><span class="line"><span class="comment">// nx:key 存在不做任何操作，等价于setnx</span></span><br><span class="line"><span class="comment">// xx:key 存在做操作与nx相反，相当于setex</span></span><br></pre></td></tr></table></figure><p><strong>mget mset</strong></p><p>mget/mset可以批量获取或设置值，如果使用get多次读取数据等价于n次网络时间+n次命令时间，这种方法可以用mget优化，等价于1次网络时间+n次命令时间，这是一个O(n)操作，避免命令过多客户端阻塞</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; mset key1 val1 key2 val2 key3 val3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; mget key1 key2 key3</span><br><span class="line">1) "val1"</span><br><span class="line">2) "val2"</span><br><span class="line">3) "val3"</span><br></pre></td></tr></table></figure><p><strong>incr decr incrby decrby </strong></p><ul><li>incr：自增</li><li>decr：自减</li><li>incrby：指定数字自增</li><li>decrby：指定数字自减</li><li>incrbyfloat：指定浮点数自增</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">incr key</span><br><span class="line">decr key</span><br><span class="line">incrby key increment</span><br><span class="line">decrby key decrement</span><br><span class="line">incrbyfloat key increment</span><br></pre></td></tr></table></figure><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>缓存，对城市列表数据进行缓存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cityList</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> redisKey = <span class="string">'city'</span>;</span><br><span class="line">    <span class="keyword">let</span> cities = redis.get(redisKey)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!cities)&#123;</span><br><span class="line">        cities = mongo.getCityList();</span><br><span class="line">        redis.set(redisKey,<span class="built_in">JSON</span>.stringify(cities));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cities;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分布式锁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value [EX seconds] [PX milliseconds] [NX|XX]</span><br></pre></td></tr></table></figure><p>计数器，网站的PV/UV统计，文章点赞、阅读量，视频网络的播放量，Redis提供的incr命令可实现计数器功能，性能好复杂度为O(1)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> incrPageViewsCounter = <span class="function"><span class="params">pageId</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">`page:views:<span class="subst">$&#123;pageId&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">return</span> redis.incr(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Session存储，Redis不会因为服务器重启导致Session数据丢失，具有数据持久化功能。</p><p>限流，短信发送为了避免接口被频繁调用，通常要在指定时间内避免重复发送</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SMSLimit = <span class="keyword">async</span> phone =&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">`sms:limit:<span class="subst">$&#123;phone&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> redis.set(key,<span class="number">1</span>,<span class="string">'EX'</span>,<span class="number">60</span>,<span class="string">'NX'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(result === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'60s 内无法再次发送验证码'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'可以发送'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SMSLimit(<span class="number">18800000000</span>)</span><br></pre></td></tr></table></figure><h4 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h4><p>哈希结构有一个特点，所有命令都是H开头，hash类型其值本身就由一个或多个filed-value构成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hashKey = &#123;</span><br><span class="line">    filed1:value1,</span><br><span class="line">    filed2:value2</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 优：节省空间，可以部分更新</span></span><br><span class="line"><span class="comment">// 缺：不支持TTL设置，Redis中过期时间只针对顶级Key,无法对Hash Key的field设置过期时间，只能对整个Key 通过expire设置</span></span><br><span class="line"><span class="comment">// 注意：在使用hgetall的时候注意，集合很大将会浪费性能</span></span><br></pre></td></tr></table></figure><h5 id="常见命令-1"><a href="#常见命令-1" class="headerlink" title="常见命令"></a>常见命令</h5><table><thead><tr><th>命令</th><th>含义</th><th>时间复杂度</th></tr></thead><tbody><tr><td>hset</td><td>对key的field进行设置</td><td>O(1)</td></tr><tr><td>hget</td><td>获取key指定的field</td><td>O(1)</td></tr><tr><td>hdel</td><td>删除key指定的field</td><td>O(1)</td></tr><tr><td>hincrby hincrbyfloat</td><td>类似于incrby incryfloat 这个操作的是field</td><td>O(1)</td></tr><tr><td>hmset hmget</td><td>对多个filed value 设置 读取</td><td>O(n)</td></tr><tr><td>hgetall</td><td>获取key的所有field value</td><td>O(n)</td></tr><tr><td>hvals</td><td>获取key的所有value</td><td>O(n)</td></tr><tr><td>hkeys</td><td>获取key的所有fields</td><td>O(n)</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset student name Jack</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; hget student name</span><br><span class="line">"Jack"</span><br><span class="line">127.0.0.1:6379&gt; hmset student age 18 sex man</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget student sex age</span><br><span class="line">1) "man"</span><br><span class="line">2) "18"</span><br><span class="line">127.0.0.1:6379&gt; hgetall student</span><br><span class="line">1) "name"</span><br><span class="line">2) "Jack"</span><br><span class="line">3) "age"</span><br><span class="line">4) "18"</span><br><span class="line">5) "sex"</span><br><span class="line">6) "man"</span><br></pre></td></tr></table></figure><h5 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h5><p>hash适合将一些数据存储在一起，例如缓存用户信息，与字符串不同的是，hash可以对用户信息结构中的每个字段单独存储，当需要获取信息时可以仅获取需要的部分字段。如果用字符串存储，两种方式，一种是将信息拆分为多个键（每个属性一个键）来存储，占用过的key同时占用空间；另外一种方式是序列化字符串存储，这种方式如果去数据只能全部取出并且还要进行反序列化，序列化/反序列化也有一定的内存开销</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存用户信息例子：</span></span><br><span class="line"><span class="comment">// 模拟查询Mongo数据</span></span><br><span class="line"><span class="keyword">const</span> mongo = &#123;</span><br><span class="line">    getUserInfoByUserId:<span class="function"><span class="params">userId</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">            name:<span class="string">'Jack'</span>,</span><br><span class="line">            age:<span class="number">19</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取用户信息</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getUserInfo</span>(<span class="params">userId</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">`user:<span class="subst">$&#123;userId&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">// 从缓存获取数据</span></span><br><span class="line">        <span class="keyword">const</span> userInfoCache = <span class="keyword">await</span> redis.hgetall(key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 userInfoCache为空，返回值为&#123;&#125;</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">Object</span>.keys(userInfoCache).length ===<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">const</span> userInfo = mongo.getUserInfoByUserId(userId);</span><br><span class="line">            <span class="keyword">await</span> redis.hmset(key,userInfo);</span><br><span class="line">            <span class="keyword">await</span> redis.expire(key,<span class="number">120</span>);</span><br><span class="line">            <span class="keyword">return</span> userinfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userInfoCache;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.error(err);</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getUserInfo(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>Redis的列表用来存储字符串元素的集合，基于Linked Lists实现，意味着插入、删除操作非常快，时间复杂度为O(1),索引很慢，时间复杂度为O(n)</p><p>Redis列表命令都是L开头，在实际运用中可以作为队列或者栈</p><ul><li>Stack（栈）：后进先出，实现命令<code>lpush+lpop</code></li><li>Queue（队列）：先进先出，实现命令<code>lpush+rpop</code></li><li>Capped Collection(有限集合)：<code>lpush+ltrim</code></li><li>Message Queue(消息队列)：<code>lpush+brpop</code></li></ul><h5 id="常见命令-2"><a href="#常见命令-2" class="headerlink" title="常见命令"></a>常见命令</h5><table><thead><tr><th>命令</th><th>含义</th><th>时间复杂度</th></tr></thead><tbody><tr><td>lpush rpush</td><td>列表左端/右端插入一个值</td><td>O(1~n)</td></tr><tr><td>linsert</td><td>列表指定的值前/后插入新值</td><td>O(n)</td></tr><tr><td>lpop rpop</td><td>列表左侧或者右侧弹出一个值</td><td>O(1)</td></tr><tr><td>blpop brpop</td><td>lpop rpop 的阻塞版本，需设置timeout</td><td>O(1)</td></tr><tr><td>ltrim</td><td>按照索引范围修剪列表</td><td>O(n)</td></tr><tr><td>lrange</td><td>获取指定范围内的元素列表</td><td>O(n)</td></tr><tr><td>llen</td><td>获取列表长度</td><td>O(1)</td></tr><tr><td>lset</td><td>设置列表指定索引值为新值</td><td>O(n)</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列表左侧加入三个元素</span></span><br><span class="line">127.0.0.1:6379&gt; lpush languages JavaScript Python Go</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取列表长度</span></span><br><span class="line">127.0.0.1:6379&gt; llen languages</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取指定范围内元素列表 从左到右 start/end-&gt;0/N-1 从右到左 start/end-&gt;-1/-N</span></span><br><span class="line">127.0.0.1:6379&gt; lrange languages 0 2</span><br><span class="line">1) "Go"</span><br><span class="line">2) "Python"</span><br><span class="line">3) "JavaScript"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列表右侧插入元素</span></span><br><span class="line">127.0.0.1:6379&gt; rpush languages TypeScript</span><br><span class="line">(integer) 4</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看列表的元素</span></span><br><span class="line">127.0.0.1:6379&gt; lrange languages 0 3</span><br><span class="line">1) "Go"</span><br><span class="line">2) "Python"</span><br><span class="line">3) "JavaScript"</span><br><span class="line">4) "TypeScript"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列表左端移除一个元素</span></span><br><span class="line">127.0.0.1:6379&gt; lpop languages</span><br><span class="line">"Go"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列表右端移除一个元素</span></span><br><span class="line">127.0.0.1:6379&gt; rpop languages</span><br><span class="line">"TypeScript"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 谁的那个列表指定索引值为新值</span></span><br><span class="line">127.0.0.1:6379&gt; lset languages 1 JS</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列表指定的值前/后插入新值</span></span><br><span class="line">127.0.0.1:6379&gt; linsert languages after JS Nodejs</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照索引范围修剪列表（元素截取）</span></span><br><span class="line">127.0.0.1:6379&gt; ltrim languages 1 2</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h5 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h5><p>消息队列，Redis List结构的lpush与brpop命令可实现消息队列，lpush命令是从左端插入数据，brpop命令是从右端阻塞式的读取数据，阻塞读过程中如果队列中没有数据，会立即进入休眠直到数据到来或超过设置的timeout时间，会立即醒过来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">'languages'</span>;</span><br><span class="line">    <span class="comment">// 阻塞读，timeout为5秒钟</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> redis.brpop(key,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>Redis集合类型可用来存储多个字符串元素，和列表不同，集合元素不允许重复，集合中的元素是无须的，也不能通过索引下标获取元素。Redis集合的命令都是S开头</p><h5 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h5><table><thead><tr><th>命令</th><th>含义</th><th>时间复杂度</th></tr></thead><tbody><tr><td>sadd</td><td>集合中添加元素，如果元素重复则添加失败</td><td>O(1)</td></tr><tr><td>srem</td><td>删除集合中的元素</td><td>O(1)</td></tr><tr><td>scard</td><td>计算集合中的元素个数</td><td>O(1)</td></tr><tr><td>sismember</td><td>判断集合中是否存在指定元素</td><td>O(count)</td></tr><tr><td>srandmember</td><td>随机从集合中返回指定元素</td><td>O(n)</td></tr><tr><td>sinter</td><td>求集合交集</td><td></td></tr><tr><td>sunion</td><td>求集合并集</td><td></td></tr><tr><td>sdiff</td><td>求集合差集</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 集合中添加元素</span></span><br><span class="line">127.0.0.1:6379&gt; sadd languages2 Nodejs JavaScript</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 计算集合中元素个数</span></span><br><span class="line">127.0.0.1:6379&gt; scard languages2</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断集合中是否存在指定元素 1 存在 0不存在</span></span><br><span class="line">127.0.0.1:6379&gt; sismember languages2 Nodejs</span><br><span class="line">(integer) 1</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; sismember languages2 Nodejs1</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 随机从集合中返回n个元素</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember languages2 2</span><br><span class="line">1) "JavaScript"</span><br><span class="line">2) "Nodejs"</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; srandmember languages2 3</span><br><span class="line">1) "JavaScript"</span><br><span class="line">2) "Nodejs"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置用户1 使用的语言</span></span><br><span class="line">127.0.0.1:6379&gt; sadd user:1 Nodejs JavaScript</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置用户2 使用的语言</span></span><br><span class="line">127.0.0.1:6379&gt; sadd user:2 Nodejs Python</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 求 user:1与 user:2 交集</span></span><br><span class="line">127.0.0.1:6379&gt; sinter user:1 user:2</span><br><span class="line">1) "Nodejs"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 求user:1 与 user:2 并集</span></span><br><span class="line">127.0.0.1:6379&gt; sunion user:1 user:2</span><br><span class="line">1) "JavaScript"</span><br><span class="line">2) "Nodejs"</span><br><span class="line">3) "Python"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 求user:1 与 user:2 差集</span></span><br><span class="line">127.0.0.1:6379&gt; sdiff user:1 user:2</span><br><span class="line">1) "JavaScript"</span><br></pre></td></tr></table></figure><h5 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h5><p>抽奖，Redis的结合有去重功能，一些抽奖类项目中可以存储中奖的用户Id,能够保证同一个用户Id不会中奖两次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">userId</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">'luck:users'</span>;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> redis.sadd(key,userId);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果元素存在，返回0表示未添加成功</span></span><br><span class="line">    <span class="keyword">if</span>(result === <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'您已中间一次，无法再次参与'</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'恭喜您中奖'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>计算用户共同感兴趣的商品，sadd与sinter可以用来统计用户共同感兴趣的商品，sadd保存每个用户喜欢的商品标签，使用sinter对每个用户感兴趣的商品标签求交集</p><h4 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h4><p>Redis有序集合zset保留了集合set元素不能重复的特征之外，在有序集合的元素中是可以排序的，与列表使用索引下标不同的是有序集合是有序集合给每个元素设置一个分值（score）作为排序的依据</p><p>Redis有序集合是Z开头的</p><h5 id="常见命令-3"><a href="#常见命令-3" class="headerlink" title="常见命令"></a>常见命令</h5><table><thead><tr><th>命令</th><th>含义</th><th>时间复杂度</th></tr></thead><tbody><tr><td>zadd</td><td>集合中添加元素</td><td>O(logN)</td></tr><tr><td>zrem</td><td>集合中删除元素</td><td>O(1)</td></tr><tr><td>zscore</td><td>返回集合的分数</td><td>O(1)</td></tr><tr><td>zincrby</td><td>增加或者减少集合的分数</td><td>O(1)</td></tr><tr><td>zcard</td><td>返回元素的个数</td><td>O(1)</td></tr></tbody></table><p><strong>zadd</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zadd key [NX|XX] [CH] [INCR] score member [sroce member ...]</span><br><span class="line"><span class="meta">#</span><span class="bash"> [NX|XX]：NX member必须不存在才添加成功，用户Create;XX,member 必须存在才能更新成功，用于UPDATE</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [CH]：返回此次操作后有序集合元素和分数发生的变化</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> [INCR]：对score做增加，相当于 zincrby</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> score：代表分数（排序）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> member：成员</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 有序集合 grages 中添加3个元素</span></span><br><span class="line">127.0.0.1:6379&gt; zadd grades NX 80 xiaoming 75 xiaozhang 85 xiaoli</span><br><span class="line">(integer) 3</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看成员 xiaozhang 分数</span></span><br><span class="line">127.0.0.1:6379&gt; zscore grades xiaozhang</span><br><span class="line">"75"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新成员 xiaozhang 分数</span></span><br><span class="line">127.0.0.1:6379&gt; zadd grades XX 90 xiaozhang</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次查看成员xiaozhang分数</span></span><br><span class="line">127.0.0.1:6379&gt; zscore grades xiaozhang</span><br><span class="line">"90"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看成员排名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分数从低到高</span></span><br><span class="line">127.0.0.1:6379&gt; zrank grades xiaozhang</span><br><span class="line">(integer) 2</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 分数从高到低</span></span><br><span class="line">127.0.0.1:6379&gt; zrevrank grades xiaozhang</span><br><span class="line">(integer) 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 增加成员分数</span></span><br><span class="line">127.0.0.1:6379&gt; zincrby grades 5 xiaozhang</span><br><span class="line">"95"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回指定范围成员排名，WITHSCORES可选参数，去掉则不返回分数</span></span><br><span class="line">127.0.0.1:6379&gt; zrange grades 0 2 WITHSCORES</span><br><span class="line">1) "xiaoming"</span><br><span class="line">2) "80"</span><br><span class="line">3) "xiaoli"</span><br><span class="line">4) "85"</span><br><span class="line">5) "xiaozhang"</span><br><span class="line">6) "95"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回指定分数范围内的成员列表</span></span><br><span class="line">127.0.0.1:6379&gt; zrangebyscore grades 85 100</span><br><span class="line">1) "xiaoli"</span><br><span class="line">2) "xiaozhang"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定成员</span></span><br><span class="line">127.0.0.1:6379&gt; zrem grades xiaoli</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure><h3 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h3><h4 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h4><p>Redis整个生命周期：发送命令-&gt;排队-&gt;执行命令-&gt;返回结果，慢查询通常发生在执行命令阶段，可以通过日志查询系统slowlog进行问题定位跟踪</p><p>在配置文件中<code>redis.conf</code>设置：</p><ul><li>slowlog-max-len：表示慢查询最大的条数，默认128，保存在内存中，当超过预先设置的值后会将最早的slowlog删除，是个先进先出队列</li><li>slow-log-slower-than：慢查询阀值，默认10000微妙，只有命令执行时间大于该阀值才会被slowlog记录，如果记录所有命令将阀值设置为0</li></ul><p>Redis是每秒万级别，设置阀值时候，默认为10000微秒（10毫秒），不要设置太大，建议1毫秒之下，才有意义。定期将慢查询持久化到其他数据库，便于排查。</p><p>慢查询命令：</p><ul><li>slowlog get [n]：获取慢查询队列</li><li>slowlog len：获取慢查询队列长度</li><li>slowlog reset：清空慢查询队列</li></ul><h4 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h4><p>核心1次网络请求处理n条命令，redis本身命令处理时间是微秒级别，pipeline主要减少网络传输要求</p><h4 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h4><p>角色：发布者（publisher）/订阅者（subscriber）/频道（channel）:</p><ul><li>发布消息<code>publish channel message</code></li><li>订阅消息 <code>subscribe [channel]</code>，可以订阅多个频道</li><li>取消订阅 <code>unsubscribe [channel]</code></li></ul><h4 id="BitMaps（位图）"><a href="#BitMaps（位图）" class="headerlink" title="BitMaps（位图）"></a>BitMaps（位图）</h4><h4 id="CEO"><a href="#CEO" class="headerlink" title="CEO"></a>CEO</h4><p>用于地理位置定位，基于zset实现的：</p><ul><li><code>geoadd key longitude latitude member</code>增加地理位置信息，例如：<code>geoadd cities: 163.31 39.99 beijing</code></li><li><code>geopos key member [member...]</code>,获取地理位置消息，例如<code>geopos cities: beijing</code></li><li><code>geodist key member1 member2 [unit]</code>：获取两地址位置距离，unit为单位（m/km/mi/ft）,例如：<code>geodist cities: beijing shanghai km</code></li></ul><h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>单机带来的问题机器故障、容量限制、QPS瓶颈，主从复制是一种一主多从的模式提供了数据副本，解决了单机带来的机器故障问题，另外主从分离模式还提供了Redis读的性能，也是高可用，分布式的基础。</p><p>所谓的主从复制就是一个Redis主节点拥有多个从节点，由主节点的数据单向复制到从节点，在一些读多写少的业务场景非常受用</p><h3 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h3><p>Redis数据存储都是内存里，对数据的更新异步的存储在磁盘里，在Redis中的数据持久化有两种策略，RDB快照，AOF日历</p><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>把当前内存中的数据集快照写入磁盘，恢复时将快照文件直接读到内存里。</p><h5 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h5><p>save和bgsave生成快照</p><p>save：使用save会造成客户端阻塞，它使用一种同步的方式生成RDB快照文件，因为Redis是单线程，如果save过程很长也会阻塞其他客户端的命令，在生产中是不建议使用的</p><p>bgsave：使用bgsave Redis会fork一个子进程来负责生成RDB文件，由于bgsave是异步进行的并不会阻塞其他客户端的命令，bgsave模式下阻塞阶段发生在fork过程中</p><h5 id="持久化配置"><a href="#持久化配置" class="headerlink" title="持久化配置"></a>持久化配置</h5><p>其中stop-writes-on-bgsave-error这个配置很重要，如果子进程(也就是备用经常)在后台生成快照失败，主经常会停止新的写入操作，也是为了保持数据一致性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 持久化默认时间策略</span></span><br><span class="line">save 900 1 # 如果仅有1-9次更改操作，那么要900s才写入硬盘一次</span><br><span class="line">save 300 10 # 如果仅有10-9999次更改操作，那么要300s才写入硬盘一次</span><br><span class="line">save 60 10000 # 如果超过10000次更改操作，那么60s才会写入硬盘一次</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> RBD 文件名称，建议 dump-6379.rdb</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 工作目录（上面 dump-6379.rdb 文件保存目录）</span></span><br><span class="line">dir /data/soft/redis-5.0.5/data/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 备份进程出错，主进程停止写入</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 是否压缩</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 导入时是否检查</span></span><br><span class="line">rdbchecksum yes</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; save</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; bgsave</span><br><span class="line">Background saving started</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务端</span></span><br><span class="line">[35856] 02 Jul 10:01:02.999 * 1 changes in 3600 seconds. Saving...</span><br><span class="line">[35856] 02 Jul 10:01:03.063 * Background saving started by pid 58172</span><br><span class="line">[35856] 02 Jul 10:01:03.263 # fork operation complete</span><br><span class="line">[35856] 02 Jul 10:01:03.263 * Background saving terminated with success</span><br><span class="line">[35856] 02 Jul 10:30:56.240 * DB saved on disk</span><br><span class="line">[35856] 02 Jul 10:31:03.565 * Background saving started by pid 53904</span><br><span class="line">[35856] 02 Jul 10:31:03.705 # fork operation complete</span><br><span class="line">[35856] 02 Jul 10:31:03.705 * Background saving terminated with success</span><br></pre></td></tr></table></figure><h5 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h5><p>性能、时间耗时，存在不稳定性</p><p>RDB生成的过程就是将Redis内存中的dump到硬盘生成一个RDB文件，其实就是生成一个内存快照，save会造成阻塞，不建议生产环境去使用。besave的fork也是一个重量级操作，遵循copy-on-write（写入时复制）策略，新fork出的子进程会继续共享父进程的物理空间，使用COW技术可以避免不必要的资源分配，父进程的代码段和只读数据段都不允许修改，所以无需复制，当父进程处理些请求时会把要修改的页创建副本，而子进程在fork过冲中会共享父进程的内存快照</p><blockquote><p>Copy on Write技术实现原理：fork之后，kernel把父进程中所有的内存页的权限都设为read-only,然后子进程的地址空间指向父进程。当父子进程都只读内存时，相安无事。当其中某个进程写入内存时，CPU硬件检测到内存页是read-only,于是触发页异常中间（page-fault），陷入kernel的一个终端例程。中断例程中，kernal就会把触发的异常的页复制一份，于是分子进程各自持有独立的一份</p><p>COW技术可以减少分配和复制大量资源时带来的瞬间延迟，减少不必要的资源分配。</p><p>如果在fork之后，父子进程还需要进行读写操作，那么会产生大量的分页错误（页异常中断page-fault），这样就得不偿失了</p></blockquote><p>Redis会根据自定义时间策略或者定时任务手动执行besave进行快照备份，如果某个出现宕机会丢失部分数据</p><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>以写日志的方式执行redis命令后，将数据写入AOF日志文件</p><h5 id="可靠性fsync"><a href="#可靠性fsync" class="headerlink" title="可靠性fsync"></a>可靠性fsync</h5><p>redis命令写入过程，是先写入硬盘的缓冲区，缓冲区根据选择的策略写入到系统中，linux的glibc提供了fsync（init fd）函数可以将指定文件的内容强制从内核写入至磁盘，只要redis进程实时调用了fsync函数就可以保证AOF日志不丢失，由于fsync是一个磁盘I/O操作，所以不能每条redis指令都执行一次fsync，这样redis高性能就没有保证，有三种策略，默认推荐everysec策略：</p><ul><li>always：每条命令都会写入AOF中，保证数据不会丢失，但是I/O开销会很大</li><li>everysec：以每秒钟为单位将缓冲区中的数据写入到硬盘，如果出现故障可能会丢失1秒钟的数据，这个也是Redis的默认值</li><li>no：这个策略根据操作系统定义的进行写入，不需要操作，但同时也是不可控的。</li></ul><h5 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h5><p>将那些过期、重复的命令进行压缩减少，从而达到减少硬盘占用量，提高数据恢复速度</p><p>实现方式：</p><ul><li>bgrewriteaof:类似于RDB中的bgsave</li><li>auto-aof-rewrite-min-size：配置AOF重写需要的最小尺寸</li><li>auto-aof-rewrite-percentage：配置AOF文件增长率</li></ul><p>配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 是否开启 aof</span></span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件名称</span></span><br><span class="line">appendfilename "appendonly-6379.aof"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 同步方式</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> aof 重写期间是否同步</span></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重写触发配置</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加载 aof 时如果有错如何处理</span></span><br><span class="line">aof-load-truncated yes</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件重写策略</span></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure><h5 id="数据损坏修复"><a href="#数据损坏修复" class="headerlink" title="数据损坏修复"></a>数据损坏修复</h5><p>“在过去曾经发现一些很罕见的 BUG 导致使用 AOF 重建的数据跟原数据不一致的问题。” 这句话来自 Redis 实践官方，为了应对这种罕见的 BUG 可以使用 redis-check-aof 命令修复原始的 AOF 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-check-aof --fix appendonly-6379.aof # appendonly-6379.aof 对应你的 aof 日志文件</span><br></pre></td></tr></table></figure><h4 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h4><ul><li>重放优先级：系统重启时优先重放AOF备份数据，随后是RDB,因为从数据备份的完整性考虑，AOF相比RDB可靠性更高些</li><li>恢复速度快：RDB采用二进制方式存储占用体积小，AOF是以日志形式存储，体积相比RDB要大，相比较来说，RDB的数据恢复速度要高于AOF</li><li>数据安全性：RDB采用快照形式，在一定时间内会丢失数据，AOF相对更安全些，主要有三种策略。</li></ul><p>一般来说，应该同时使用两种持久化功能，如果可以承受数分钟以内的数据丢失，可以只使用RDB持久化。很多用户都只使用AOF持久化，而定时生成RDB非常便于进行数据库备份，并且RDB恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用RDB还可以避免之前说过的AOFbug。</p><h3 id="哨兵高可用"><a href="#哨兵高可用" class="headerlink" title="哨兵高可用"></a>哨兵高可用</h3><p>主从复制如果主节点发生故障，Redis Sentinel功能可以自动提升而不是人工干预</p><p>Sentinel是一个分布式系统，类似于Cousul集群，一般由3~5个节点组成，使用Raft算法实现领导者选举因为故障转移只需要一个Sentinel节点来完成</p><h3 id="为什么Redis只适用于缓存而不能当做数据库来使用？"><a href="#为什么Redis只适用于缓存而不能当做数据库来使用？" class="headerlink" title="为什么Redis只适用于缓存而不能当做数据库来使用？"></a>为什么Redis只适用于缓存而不能当做数据库来使用？</h3><ul><li>性能：Redis是一个基于内存的数据库，通常用来计数器、Session存储、缓存设计等等</li><li>成本：假设百万条数据，仅1%是热点数据其余都是冷数据，这种情况全部都存在Redis里面，是资源的浪费，从缓存设计角度来说，所保存的也仅是热点数据</li><li>灵活性：Redis的数据结构是丰富的，支持String,HashTable,List,Set,Zset还有最新的BitMaps.GEO等，如果有很复杂的查询语句，关联查询等，还是SQL等数据库更加合适</li><li>数据可靠性：第一种方式是Redis+RDB，如果发生断电，自上次持久化到最次一次故障之间的数据丢失。第二种是Redis+AOF，AOF有三种策略将数据持久化到磁盘，其中everysec是相对折中的一种方案，everysec折中方案也会存在1秒钟数据丢失的问题。</li></ul><h3 id="实践1——计数器实现并发场景下的优惠券领取功能"><a href="#实践1——计数器实现并发场景下的优惠券领取功能" class="headerlink" title="实践1——计数器实现并发场景下的优惠券领取功能"></a>实践1——计数器实现并发场景下的优惠券领取功能</h3><p>计数器在实际中有很多需求：PV/UV、接口并发限制、抽奖、优惠券领取等</p><h4 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h4><p>业务需求方做优惠券发放活动，共优惠券10张，参与用户100人，先到先得，假设每次并发20用户同时访问，如何保证不超领取</p><h4 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h4><ul><li>exists：判断指定key是否存在</li><li>setnx：设置值，若值存在不做任何处理</li><li>incr：计数</li></ul><p>每发送一次领取请求，采用incr命令进行自增，由于redis单线程的原因，可以保证原子性，不会出现超领</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// luck.js</span></span><br><span class="line"><span class="keyword">const</span> Redis = <span class="built_in">require</span>(<span class="string">'redis'</span>);</span><br><span class="line"><span class="keyword">const</span> redis = <span class="keyword">new</span> Redis(<span class="number">6379</span>,<span class="string">'127.0.0.1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将日志写入指定文件</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;Console&#125; = <span class="built_in">require</span>(<span class="string">'console'</span>);</span><br><span class="line"><span class="keyword">const</span> output = fs.createWriteStream(<span class="string">'./stdout.js'</span>)</span><br><span class="line"><span class="keyword">const</span> errorOutput  fs.createWriteStream(<span class="string">'./stderr.js'</span>)</span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Console(output,errorOutput);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">luck</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">'counter:luck'</span>;</span><br><span class="line">    <span class="keyword">const</span> keyExists = <span class="keyword">await</span> redis.exists(key);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!keyExists)&#123;</span><br><span class="line">        <span class="comment">// 如果key不存在初始化设置</span></span><br><span class="line">        <span class="keyword">await</span> redis.setnx(key,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加领取数量</span></span><br><span class="line">    <span class="keyword">const</span> result =  <span class="keyword">await</span> redis.incr(key);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(result &gt; count)&#123;</span><br><span class="line">        <span class="comment">// 优惠券领取超限</span></span><br><span class="line">        logger.error(<span class="string">'luck failure'</span>,result);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    logger.info(<span class="string">'luck success'</span>,result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.export = luck;</span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> luck = <span class="built_in">require</span>(<span class="string">'./luck'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(req.url === <span class="string">'luck'</span>)&#123;</span><br><span class="line">        luck();</span><br><span class="line">        </span><br><span class="line">        res.end(<span class="string">'ok'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure><h3 id="实践2——Redis-Lua脚本"><a href="#实践2——Redis-Lua脚本" class="headerlink" title="实践2——Redis Lua脚本"></a>实践2——Redis Lua脚本</h3><p>Lua是一种轻量小巧的脚本语言，用标准c语言编写并以源代码形式开放，设计目的是为嵌入应用程序中，从而为应用程序提供灵活的扩张和定制功能。由于Lua语言具有原子性，其在执行过程中不会被其他程序打断，对于并发下的数据一致性有一定的帮助</p><h4 id="两种Lua脚本"><a href="#两种Lua脚本" class="headerlink" title="两种Lua脚本"></a>两种Lua脚本</h4><p>Redis支持两种运行Lua脚本，一种是直接Redis中输入Lua代码，适用于一些简单的脚本，另一种方式是编写Lua脚本文件，Redis使用SHA1算法支持对脚本签名和Script Load 预先缓存，需要运行的时候通过签名返回的标识符即可。</p><h4 id="EVAL"><a href="#EVAL" class="headerlink" title="EVAL"></a>EVAL</h4><p>通过内置的Lua解释器，可以使用EVAL命令对Lua脚本进行求值</p><ul><li>script：指定脚本</li><li>numkeys：指定键名餐参数个数</li><li>key：键名，可以多个key,通过KEYS[1]KEYS[2]的形式访问</li><li>atg：键值，可以多个val，通ARGS[1]ARGS[2]的形式访问</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EVAL script numkeys key[key...] arg[arg...]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过KEYS[] 数组的形式访问ARGV[],下标是从1开始，KEYS[1]对应的键名为name1,ARGV[2]对应的值为val2</span></span><br><span class="line">127.0.0.1:6379&gt; EVAL "return redis.call('SET',KEYS[1],ARGV[2])" 2 name1 name2 va</span><br><span class="line">l1 val2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name1</span><br><span class="line">"val2"</span><br></pre></td></tr></table></figure><p>redis.call何redis.pcall是两个不同的Lua函数来调用redis命令，区别是如果redis命令中出现错误异常，redis.call会直接返回一个错误信息给调用者，而redis.pcall会以Lua的形式对错误进行捕获并返回</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里执行了两条 Redis 命令，第一条故意写了一个 SET_ 这是一个错误的命令，可以看到出错后，错误信息被抛出给了调用者，同时你执行 get name2 会得到 (nil)，第二条命令也没有被执行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis.call</span></span><br><span class="line">127.0.0.1:6379&gt; EVAL "redis.call('SET_', KEYS[1], ARGV[2]); redis.call('SET', KEYS[2], ARGV[3])" 2 name1 name2 val1 val2 val3</span><br><span class="line">(error) ERR Error running script (call to f_bf814e38e3d98242ae0c62791fa299f04e757a7d): @user_script:1: @user_script: 1: Unknown Redis command called from Lua script </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> redis.pcall</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 一样的操作，可以看到输出结果为nil，它的错误被Lua捕获了，在执行get name2 会得到一个设置好的结果val3，这里第二条命令是被执行了的</span></span><br><span class="line">EVAL "redis.pcall('SET_', KEYS[1], ARGV[2]); redis.pcall('SET', KEYS[2], ARGV[3])" 2 name1 name2 val1 val2 val3</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure><h5 id="Nodejs实现"><a href="#Nodejs实现" class="headerlink" title="Nodejs实现"></a>Nodejs实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ioredis 支持所有脚本命令，比如EVAL/EVALSHA/SCRIPT,在现实场景中使用它是很繁琐的，要注意脚本缓存，并检测何时使用EVAL、EVALSHA.ioredis公开了一个defineCommand方法，使得脚本更容易使用</span></span><br><span class="line"><span class="keyword">const</span> Redis = require(<span class="string">'ioredis'</span>);</span><br><span class="line"><span class="keyword">const</span> redis = <span class="keyword">new</span> Redis(<span class="number">6379</span>,<span class="string">'127.0.0.1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> evalScript = <span class="string">"return redis.call('SET',KEYS[1],ARGV[2])"</span>;</span><br><span class="line">redis.defineCommand(<span class="string">'evalTest'</span>,&#123;</span><br><span class="line">    numberOfKeys:<span class="number">2</span>,</span><br><span class="line">    lua:evalScript</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function">async function <span class="title">eval</span><span class="params">()</span></span>&#123;</span><br><span class="line">    await redis.evalTest(<span class="string">'name1'</span>,<span class="string">'name2'</span>,<span class="string">'val1'</span>,<span class="string">'val2'</span>);</span><br><span class="line">    <span class="keyword">const</span> result = await redis.get(<span class="string">'name1'</span>);</span><br><span class="line">    console.log(result) <span class="comment">// val2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">eval();</span><br></pre></td></tr></table></figure><h4 id="EVALSHA"><a href="#EVALSHA" class="headerlink" title="EVALSHA"></a>EVALSHA</h4><p>EVAL命令要求每次执行脚本的时候都发送一次脚本主体script body。Redis有一个内部缓存机制，因此它不会每次都重新编译脚本，通过EVALSHA来实现，根据给定的SHA1校验码，对缓存在服务器中的脚本进行求值</p><ul><li>SCRIPT FLUSH：清除所有脚本缓存</li><li>SCRIPT EXISTS：检查指定的脚本是否存在于脚本缓存</li><li>SCRIPT LOAD：讲一个脚本转入脚本缓存，但不立即运行它</li><li>SCRIPT KILL：杀死当前正在运行的脚本</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">EVALSHA sha1 numkeys key [key...] arg[arg...]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 载入脚本缓存</span></span><br><span class="line">127.0.0.1:6379&gt; SCRIPT LOAD "redis.pcall('SET',KEYS[1],ARGV[2])"</span><br><span class="line">"3b2c59b4e98a20a3a9e631fb586218e7b70f1020"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成的SHA-1签名的标识字符串用于执行之后的脚本</span></span><br><span class="line">127.0.0.1:6379&gt; EVALSHA 3b2c59b4e98a20a3a9e631fb586218e7b70f1020 2 name11 name12</span><br><span class="line"> val11 val12</span><br><span class="line">(nil)</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; get name11</span><br><span class="line">"val12"</span><br></pre></td></tr></table></figure><h5 id="nodejs实现"><a href="#nodejs实现" class="headerlink" title="nodejs实现"></a>nodejs实现</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Redis = <span class="built_in">require</span>(<span class="string">'ioredis'</span>);</span><br><span class="line"><span class="keyword">const</span> redis = <span class="keyword">new</span> Redis(<span class="number">6379</span>,<span class="string">'127.0.0.1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> evalScript = <span class="string">"return redis.call('SET'，KEY1[1],ARGV[2])"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">evalSHA</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.缓存脚本获取sha1值</span></span><br><span class="line">    <span class="keyword">const</span> sha1 = <span class="keyword">await</span> redis.script(<span class="string">'load'</span>,evalScript);</span><br><span class="line">    <span class="comment">// 2.通过evalsha执行脚本</span></span><br><span class="line">    <span class="keyword">await</span> redis.evalsha(sha1,<span class="number">2</span>,<span class="string">'name1'</span>,<span class="string">'name2'</span>,<span class="string">'val1'</span>,<span class="string">'val2'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3.获取数据</span></span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> redis.get(<span class="string">'name1'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(result); <span class="comment">// val2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">evalSHA();</span><br></pre></td></tr></table></figure><h4 id="Lua脚本文件"><a href="#Lua脚本文件" class="headerlink" title="Lua脚本文件"></a>Lua脚本文件</h4><p>有逻辑运算的脚本，可以编写Lua脚本文件</p><p>下面是一个测试代码，通过读取两个值比较返回不同的值，通过lua脚本实现后可以多条redis命令原子性</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">---test.lua</span></span><br><span class="line"><span class="comment">-- 先SET</span></span><br><span class="line">redis.call(<span class="string">'SET'</span>,KEYS[<span class="number">1</span>],ARGV[<span class="number">1</span>])</span><br><span class="line">redis.call(<span class="string">'SET'</span>,KEYS[<span class="number">2</span>],ARGV[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">-- GET 取值</span></span><br><span class="line"><span class="keyword">local</span> key1 = <span class="built_in">tonumber</span>(redis.call(<span class="string">'GET'</span>,KEYS[<span class="number">1</span>]));</span><br><span class="line"><span class="keyword">local</span> key2 = <span class="built_in">tonumber</span>(redis.call(<span class="string">'GET'</span>,KEYS[<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果key1 小于 key2返回0 nil相当于false</span></span><br><span class="line"><span class="keyword">if</span>(key1 == <span class="literal">nil</span> <span class="keyword">or</span> key == <span class="literal">nil</span> <span class="keyword">or</span> key1 &lt; key2)</span><br><span class="line">    <span class="keyword">then</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><h5 id="nodejs加载lua脚本文件"><a href="#nodejs加载lua脚本文件" class="headerlink" title="nodejs加载lua脚本文件"></a>nodejs加载lua脚本文件</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Redis = <span class="built_in">require</span>(<span class="string">'ioredis'</span>);</span><br><span class="line"><span class="keyword">const</span> redis = <span class="keyword">new</span> Redis(<span class="number">6379</span>,<span class="string">'127.0.0.1'</span>)</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> redisLuaScript = fs.readFileSync(<span class="string">'./test.lua'</span>);</span><br><span class="line">    <span class="keyword">const</span> result1 = <span class="keyword">await</span> redis.eval(redisLuaScript,<span class="number">2</span>,<span class="string">'name1'</span>,<span class="string">'nam2'</span>,<span class="number">20</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">const</span> result2 = <span class="keyword">await</span> redis.eval(redisLuaScript,<span class="number">2</span>,<span class="string">'name1'</span>,<span class="string">'nam2'</span>,<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(result1,result2); <span class="comment">// 1 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure><h3 id="实践3——Redis分布式锁"><a href="#实践3——Redis分布式锁" class="headerlink" title="实践3——Redis分布式锁"></a>实践3——Redis分布式锁</h3><p>线程锁：单线程编程模式下请求是顺序的，一个好处不需要考虑线程安全、资源竞争问题</p><p>进程锁：一个服务部署于一台服务器，同时开启多个进程，nodejs中为了利用操作系统资源，根据CPU的核心数可以开启多程模式，这个时候如果对于一个共享资源操作还是会遇到资源竞争的问题，另外每一个进程都是相互独立，拥有自己独立的内存空间，关于进程锁通过java的synchronized也很难解决，它仅局限在同一个JVM中有效</p><p>分布式锁：一个服务无论是单线程还是多进程模式，当多机部署、处于分布式环境下对统一共享资源进行操作还是会面临同样的问题。由于先读数据在通过业务逻辑修改之后进行SET操作，这并不是一个原子操作，当多个客户端对同一个资源进行先读后写操作就会引发并发问题，这个时候就需要分布式锁去解决。</p><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>实现分布式锁的方式：数据库、redis、zookeeper，通过redis来实现一个分布式锁，保持三个特性：安全性、死锁、容错</p><p>安全性：上锁，在任意时刻保持仅有一个客户端持有该锁</p><p>死锁：造成死锁可能是由于某种原因，本该释放的锁没有被释放，因此在上锁的时候可以同步设置过期时间，由于客户端自己的原因没有被释放，也要保证锁能够自动释放</p><p>容错：容错是在多节点的模式下需要考虑的，只要保证N/2+1节点可用，客户端就可以成功获取、释放锁</p><h4 id="Redis但实力分布式锁实现"><a href="#Redis但实力分布式锁实现" class="headerlink" title="Redis但实力分布式锁实现"></a>Redis但实力分布式锁实现</h4><p>在Redis的单节点实例下实现一个简单的分布式锁，会借助简单lua脚本来实现原子性</p><h5 id="上锁"><a href="#上锁" class="headerlink" title="上锁"></a>上锁</h5><p>通过setnx命令占坑，为了防止死锁，通常在占坑之后还会设置一个过期时间expire:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setnx key value</span><br><span class="line">expire key seconds</span><br></pre></td></tr></table></figure><p>上面的操作不是一个原子性操作，原子性操作是指命令在执行过程中并不会被其他线程或者请求打断，如果setnx执行成功之后，出现网络闪断expire命令便不会得到执行，会导致死锁出现。</p><p>通过：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value [EX seconds] [PX milliseconds] [NX|XX]</span><br></pre></td></tr></table></figure><h5 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h5><p>释放锁的过程是将原来占有的坑删除，加锁的过程把value设置为一个随机值，在del key之前先判断这个key存在且value等于自己制定的值才执行删除操作，判断和删除不是一个原子性操作，借助Lua脚本实现</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">"get"</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">"del"</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="Node实践"><a href="#Node实践" class="headerlink" title="Node实践"></a>Node实践</h4><h5 id="初始化自定义redisLock"><a href="#初始化自定义redisLock" class="headerlink" title="初始化自定义redisLock"></a>初始化自定义redisLock</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RedisLock</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 初始化 RedisLock</span></span><br><span class="line"><span class="comment">   * @param &#123;*&#125; client</span></span><br><span class="line"><span class="comment">   * @param &#123;*&#125; option</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(client, options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!client) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'client 不存在'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (client.status !== <span class="string">'connecting'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'client 未正常链接'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.lockLeaseTime = options.lockLeaseTime || <span class="number">2</span>; <span class="comment">// 默认所过期时间 2 秒</span></span><br><span class="line">    <span class="keyword">this</span>.lockTimeout = options.lockTimeout || <span class="number">5</span>; <span class="comment">// 默认所过期时间 5 秒</span></span><br><span class="line">    <span class="keyword">this</span>.expireMode = options.expireMode || <span class="string">'EX'</span>;</span><br><span class="line">    <span class="keyword">this</span>.setMode = options.setMode || <span class="string">'NX'</span>;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 上锁，通过set 命令传入setnx/expire拓展参数，</span></span><br><span class="line"><span class="comment">   * 上锁成功返回，上锁失败进行重试，</span></span><br><span class="line"><span class="comment">   * 在lockTimeout 指定时间内仍未获取到锁，则获取锁失败</span></span><br><span class="line"><span class="comment">   * @param &#123;*&#125; key</span></span><br><span class="line"><span class="comment">   * @param &#123;*&#125; val</span></span><br><span class="line"><span class="comment">   * @param &#123;*&#125; expire</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">async</span> lock(key, val, expire) &#123;</span><br><span class="line">    <span class="keyword">const</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">intraneLock</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="keyword">await</span> self.client.set(key, val, self.expireMode, expire || self.lockLeaseTime, self.setMode);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上锁成功</span></span><br><span class="line">        <span class="keyword">if</span> (result === <span class="string">'OK'</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> <span class="subst">$&#123;val&#125;</span> 上锁成功`</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 锁超时</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Math</span>.floor((<span class="built_in">Date</span>.now() - start) / <span class="number">1000</span>) &gt; self.lockLeaseTime) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> <span class="subst">$&#123;val&#125;</span> 上锁重试超时结束`</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环等待重试</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> <span class="subst">$&#123;val&#125;</span> 等待重试`</span>)</span><br><span class="line">        <span class="keyword">await</span> sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;key&#125;</span> <span class="subst">$&#123;val&#125;</span> 开始重试`</span>)</span><br><span class="line">        <span class="keyword">return</span> intraneLock();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 释放锁,通过redis.eval(script)执行自定义redis lua脚本</span></span><br><span class="line"><span class="comment">   * @param &#123;*&#125; key</span></span><br><span class="line"><span class="comment">   * @param &#123;*&#125; val</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">async</span> unLock(key, val) &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> script = <span class="string">`</span></span><br><span class="line"><span class="string">   if redis.call('get',KEYS[1] == ARGV[1]) then </span></span><br><span class="line"><span class="string">    return redis.call('del',KEYS[1])</span></span><br><span class="line"><span class="string">   else </span></span><br><span class="line"><span class="string">    return 0</span></span><br><span class="line"><span class="string">   end</span></span><br><span class="line"><span class="string">   `</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> result = <span class="keyword">await</span> self.client.eval(script, <span class="number">1</span>, key, val);</span><br><span class="line">      <span class="keyword">if</span> (result === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Redis = <span class="built_in">require</span>(<span class="string">'ioredis'</span>);</span><br><span class="line"><span class="keyword">const</span> redis = <span class="keyword">new</span> Redis(<span class="number">6379</span>, <span class="string">'127.0.0.1'</span>);</span><br><span class="line"><span class="keyword">const</span> uuidv1 = <span class="built_in">require</span>(<span class="string">'uuid/v1'</span>);</span><br><span class="line"><span class="keyword">const</span> RedisLock = <span class="built_in">require</span>(<span class="string">'./redisLock'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redisLock = <span class="keyword">new</span> RedisLock(redis);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;, time || <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> id = uuidv1();</span><br><span class="line">    <span class="keyword">await</span> redisLock.lock(key, id, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> unLock = <span class="keyword">await</span> redisLock.unLock(key, id);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'unLock: '</span>, key, id, unlock);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'上锁失败'</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'name1'</span>);</span><br><span class="line">test(<span class="string">'name1'</span>)</span><br></pre></td></tr></table></figure><p>同时调用了两次test方法进行上锁，只有第一次是成功的，第二次name1 上锁的时候发现key=name1已被占坑，开始重试，由于以上的测试中设置了3秒之后自动释放，name1 在经过两次重试之后上锁成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name1 26e00260-0532-11ea-b978-2160dffafa30 上锁成功</span><br><span class="line">name1 26e02970-0532-11ea-b978-2160dffafa30 等待重试</span><br><span class="line">name1 26e02970-0532-11ea-b978-2160dffafa30 开始重试</span><br><span class="line">name1 26e02970-0532-11ea-b978-2160dffafa30 等待重试</span><br><span class="line">unLock:  name1 26e00260-0532-11ea-b978-2160dffafa30 true</span><br><span class="line">name1 26e02970-0532-11ea-b978-2160dffafa30 开始重试</span><br><span class="line">name1 26e02970-0532-11ea-b978-2160dffafa30 上锁成功</span><br><span class="line">unLock:  name1 26e02970-0532-11ea-b978-2160dffafa30 true</span><br></pre></td></tr></table></figure><h5 id="Redlock算法"><a href="#Redlock算法" class="headerlink" title="Redlock算法"></a>Redlock算法</h5><p>在Sentinel/Redis Cluster下，如果客户端A在主节点获取到锁之后，主节点还未来得及同步信息到从节点就挂掉了，这时候Sentinel 会选举另外一个从节点作为主节点，那么客户端B此时也申请相同的锁，就会出现同一个锁被多个客户端持有，对数据的最终一致性有很高的要求还不行。</p><p>鉴于这些问题，官方提供了一个使用Redis实现分布式锁的规范算法Redlock，在单实例或者多实例提供强有力的保障，本身具备容错能力，会从N个实例使用相同的key、随机值尝试<code>set ket value [EX seconds] [PX milliseconds] [NX|XX]</code>命令去获取所，在有效时间内至少 <code>N/2+1</code>个Redis实例取到所，否则取锁失败，失败情况下客户端应该在所有Redis实例上进行解锁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Redis = <span class="built_in">require</span>(<span class="string">'ioredis'</span>);</span><br><span class="line"><span class="keyword">const</span> client1 = <span class="keyword">new</span> Redis(<span class="number">6379</span>, <span class="string">'127.0.0.1'</span>);</span><br><span class="line"><span class="keyword">const</span> RedLock = <span class="built_in">require</span>(<span class="string">'redlock'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redlock = <span class="keyword">new</span> RedLock([client1], &#123;</span><br><span class="line">  retryDelay: <span class="number">200</span>, <span class="comment">// time in ms</span></span><br><span class="line">  retryCount: <span class="number">5</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个Redis 实例</span></span><br><span class="line"><span class="comment">// const redlock = new RedLock(</span></span><br><span class="line"><span class="comment">//   [new Redis(6379, '127.0.0.1')],</span></span><br><span class="line"><span class="comment">//   [new Redis(6379, '127.0.0.2')],</span></span><br><span class="line"><span class="comment">//   [new Redis(6379, '127.0.0.3')]</span></span><br><span class="line"><span class="comment">// )</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">key, ttl, client</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> loclk = <span class="keyword">await</span> redlock.lock(key, ttl);</span><br><span class="line">    <span class="built_in">console</span>.log(client, lock, value)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(client, err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'name1'</span>, <span class="number">10000</span>, <span class="string">'client1'</span>);</span><br><span class="line">test(<span class="string">'name1'</span>, <span class="number">10000</span>, <span class="string">'client2'</span>);</span><br></pre></td></tr></table></figure><p>对同一个key name1 两次上锁，由于client1 先取到了锁，client2 无法获取锁，重试5次之后报错：<code>LockError:Exceeded 5 attempts to lock the resource &#39;name1&#39;</code></p><h2 id="如何让秒杀、活动倒计时更加精确"><a href="#如何让秒杀、活动倒计时更加精确" class="headerlink" title="如何让秒杀、活动倒计时更加精确"></a>如何让秒杀、活动倒计时更加精确</h2><p>分析一下从获取服务器时间到前端显示倒计时的过程：</p><ol><li>客户端http请求服务器时间</li><li>服务器响应完成</li><li>服务器通过网络传输时间到客户端</li><li>客户端根据活动开始时间和服务器时间差做倒计时显示</li></ol><p>服务器响应完成的时间就是服务器时间，但是经过网络传输就会有误差，由网络环境决定误差大小，一般是几十ms或者几百ms。</p><p>可得出：<code>当前服务器时间=服务器系统返回时间+网络传输时间+前端渲染时间+常量（可选）</code></p><p>前端渲染时间，避免不同浏览器渲染快慢差异差异造成明显的时间不同步，可以在服务器返回当前时间和本地签单的时间的差值得出</p><p>获得服务器时间后，前端进入倒计时计算和计时器显示，要考虑js代码和线程阻塞造成计时器延时问题，思路是通过引入计数器，判断计时器延迟执行的时间来调整，尽量让误差缩小，不同浏览器不同时间段打开页面倒计时误差可控制在1s以内</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程占用</span></span><br><span class="line">setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j++ <span class="xml"><span class="tag">&lt; <span class="attr">100000000</span>);</span></span></span><br><span class="line"><span class="xml">&#125;,0)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 倒计时</span></span><br><span class="line"><span class="xml">let interval = 1000,</span></span><br><span class="line"><span class="xml">    ms = 50000, //从服务器和活动开始时间计算出的时间差，测试用50000ms</span></span><br><span class="line"><span class="xml">    count=0,</span></span><br><span class="line"><span class="xml">    startTime = new Date().getTime(),</span></span><br><span class="line"><span class="xml">    timeCounter = null;</span></span><br><span class="line"><span class="xml">if(ms &gt;=0)&#123;</span></span><br><span class="line"><span class="xml">    timeCounter = setTimeout(countDownStart,interval)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">function countDownStart()&#123;</span></span><br><span class="line"><span class="xml">    count++;</span></span><br><span class="line"><span class="xml">    const offset = new Date().getTime() - (startTime+count*interval);</span></span><br><span class="line"><span class="xml">    let nextTime = interval -offset;</span></span><br><span class="line"><span class="xml">    const daytohour = 0;</span></span><br><span class="line"><span class="xml">    if(nextTime <span class="tag">&lt; <span class="attr">0</span>)&#123;</span></span></span><br><span class="line"><span class="xml">        nextTime = 0;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    ms-=interval;</span></span><br><span class="line"><span class="xml">    console.log(`误差：$&#123;offset&#125;ms,下一次执行：$&#123;nextTime&#125;ms后，离活动结束还有：$&#123;ms&#125;ms`)</span></span><br><span class="line"><span class="xml">    </span></span><br><span class="line"><span class="xml">    if(ms <span class="tag">&lt; <span class="attr">0</span>)&#123;</span></span></span><br><span class="line"><span class="xml">        clearTimer(timeCount)</span></span><br><span class="line"><span class="xml">    &#125;else&#123;</span></span><br><span class="line"><span class="xml">        timeCounter = setTimeout(countDownStart,nextTime),</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;NodeJS&quot;&gt;&lt;a href=&quot;#NodeJS&quot; class=&quot;headerlink&quot; title=&quot;NodeJS&quot;&gt;&lt;/a&gt;NodeJS&lt;/h1&gt;&lt;h2 id=&quot;模块与文件&quot;&gt;&lt;a href=&quot;#模块与文件&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="NodeJs" scheme="http://laibh.top/categories/NodeJs/"/>
    
    
      <category term="NodeJs" scheme="http://laibh.top/tags/NodeJs/"/>
    
  </entry>
  
  <entry>
    <title>珠峰架构-函数</title>
    <link href="http://laibh.top/2019-12-07-%E7%8F%A0%E5%B3%B0%E6%9E%B6%E6%9E%84-Day1.html"/>
    <id>http://laibh.top/2019-12-07-珠峰架构-Day1.html</id>
    <published>2019-12-07T04:00:00.000Z</published>
    <updated>2020-07-11T03:24:57.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="珠峰架构-函数"><a href="#珠峰架构-函数" class="headerlink" title="珠峰架构-函数"></a>珠峰架构-函数</h1><p>知识点：</p><p><code>高阶函数，解决异步问题</code>、<code>发布订阅模式和观察者模式</code>、<code>promise核心应用，promise解决异步问题</code>、<code>实现一个完成的promise库</code>、<code>promise中常见的面试题</code>、<code>扩展promise中常见的方法</code>、<code>掌握 generator的使用以及co库的应用</code>、<code>异步方案 async+await</code></p><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><h3 id="AOP-面向切片编程"><a href="#AOP-面向切片编程" class="headerlink" title="AOP 面向切片编程"></a>AOP 面向切片编程</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 高阶函数 函数参数如果是函数，或者这个函数返回一个新的函数，我们就叫它高阶函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AOP 面向切片编程</span></span><br><span class="line"><span class="comment">// before函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params">who</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(who + <span class="string">' hello'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span> (<span class="params">beforeFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    beforeFn();</span><br><span class="line">    <span class="keyword">this</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span> (<span class="params">afterFn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>(...args);</span><br><span class="line">    afterFn();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> beforeSay = say.before(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'开始说话'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> afterSay = beforeSay.after(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'结束说话'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">afterSay(<span class="string">'laibh.top'</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">开始说话</span></span><br><span class="line"><span class="comment">laibh.top hello</span></span><br><span class="line"><span class="comment">结束说话</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="React事务简单模拟"><a href="#React事务简单模拟" class="headerlink" title="React事务简单模拟"></a>React事务简单模拟</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span>&#123;</span><br><span class="line">  perform(anyMethod, wrappers) &#123;</span><br><span class="line">    wrappers.forEach(<span class="function"><span class="params">wrapper</span> =&gt;</span> wrapper.initialize())</span><br><span class="line">    anyMethod();</span><br><span class="line">    wrappers.forEach(<span class="function"><span class="params">wrapper</span> =&gt;</span> wrapper.close())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> transaction = <span class="keyword">new</span> Transaction()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> oldFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'原有的逻辑'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">transaction.perform(oldFunc, [</span><br><span class="line">  &#123; <span class="comment">// wrapper1</span></span><br><span class="line">    initialize() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'初始化1'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    close() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'关闭1'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123; <span class="comment">// wrapper2</span></span><br><span class="line">    initialize() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'初始化2'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    close() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'关闭2'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">])</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">初始化1</span></span><br><span class="line"><span class="comment">初始化2</span></span><br><span class="line"><span class="comment">原有的逻辑</span></span><br><span class="line"><span class="comment">关闭1</span></span><br><span class="line"><span class="comment">关闭2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="判断类型"><a href="#判断类型" class="headerlink" title="判断类型"></a>判断类型</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// typeof instaceof constructor Object.prototype.toString.call</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isType</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">args</span>) =&gt;</span> <span class="built_in">Object</span>.prototype.toString.call(args) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> types = [<span class="string">'String'</span>, <span class="string">'Boolean'</span>, <span class="string">'Number'</span>, <span class="string">'Null'</span>, <span class="string">'Undefined'</span>, <span class="string">'Symbol'</span>, <span class="string">'Object'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> utils = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; types.length; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> type = types[i]</span><br><span class="line">  utils[<span class="string">`is<span class="subst">$&#123;type&#125;</span>`</span>] = isType(type)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(utils.isSymbol(<span class="built_in">Symbol</span>()))</span><br></pre></td></tr></table></figure><h3 id="异步并发-lodash-after"><a href="#异步并发-lodash-after" class="headerlink" title="异步并发 lodash after"></a>异步并发 lodash after</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lodash after 在执行多少次之后</span></span><br><span class="line"><span class="comment">// 做异步的并发处理</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">after</span>(<span class="params">times, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (--times == <span class="number">0</span>) &#123;</span><br><span class="line">      callback();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fn = after(<span class="number">3</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'执行三次后才执行'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fn()</span><br><span class="line">fn()</span><br><span class="line">fn()</span><br><span class="line"></span><br><span class="line"><span class="comment">// node 方法异步的 I/O</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> after = <span class="function">(<span class="params">times, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> website = &#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">key, value</span>) =&gt;</span> &#123;</span><br><span class="line">    website[key] = value</span><br><span class="line">    <span class="keyword">if</span> (--times === <span class="number">0</span>) &#123;</span><br><span class="line">      callback(website)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> out = after(<span class="number">2</span>, (website) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(website)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./name.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  out(<span class="string">'name'</span>, data)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./age.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  out(<span class="string">'age'</span>, data)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="发布订阅模式和观察者模式"><a href="#发布订阅模式和观察者模式" class="headerlink" title="发布订阅模式和观察者模式"></a>发布订阅模式和观察者模式</h2><h3 id="发布订阅解决异步"><a href="#发布订阅解决异步" class="headerlink" title="发布订阅解决异步"></a>发布订阅解决异步</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node 方法异步的 I/O</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 希望两次都完成后，分别打印最终结果，再打印一次已经处理完毕的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布emit 订阅 on 一种一对多的关系 [fn,fn,fn]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Events</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = []</span><br><span class="line">  &#125;</span><br><span class="line">  on(callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack.push(callback)</span><br><span class="line">  &#125;</span><br><span class="line">  emit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> events = <span class="keyword">new</span> Events();</span><br><span class="line"><span class="keyword">let</span> website = &#123;&#125;;</span><br><span class="line">events.on(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Object</span>.keys(website).length === <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(website)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'当前获取完毕'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./name.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  website.name = data</span><br><span class="line">  events.emit();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">'./age.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  website.age = data</span><br><span class="line">  events.emit();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="观察者模式简单模拟"><a href="#观察者模式简单模拟" class="headerlink" title="观察者模式简单模拟"></a>观察者模式简单模拟</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察者模式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123; <span class="comment">// 被观察者</span></span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = [];</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'happy'</span></span><br><span class="line">  &#125;</span><br><span class="line">  attach(observer) &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack.push(observer)</span><br><span class="line">  &#125;</span><br><span class="line">  setState(newState) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = newState</span><br><span class="line">    <span class="keyword">this</span>.stack.forEach(<span class="function"><span class="params">p</span> =&gt;</span> p.update(newState))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123; <span class="comment">// 观察者</span></span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  update(newState) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>,小宝宝<span class="subst">$&#123;newState&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> Observer(<span class="string">'爸爸'</span>)</span><br><span class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> Observer(<span class="string">'妈妈'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Subject(<span class="string">'小宝宝'</span>)</span><br><span class="line">c.attach(p1)</span><br><span class="line">c.attach(p2)</span><br><span class="line">c.setState(<span class="string">'unhappy'</span>)</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;珠峰架构-函数&quot;&gt;&lt;a href=&quot;#珠峰架构-函数&quot; class=&quot;headerlink&quot; title=&quot;珠峰架构-函数&quot;&gt;&lt;/a&gt;珠峰架构-函数&lt;/h1&gt;&lt;p&gt;知识点：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高阶函数，解决异步问题&lt;/code&gt;、&lt;code&gt;发布订阅模式和
      
    
    </summary>
    
      <category term="珠峰架构" scheme="http://laibh.top/categories/%E7%8F%A0%E5%B3%B0%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="珠峰架构" scheme="http://laibh.top/tags/%E7%8F%A0%E5%B3%B0%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>react hook实践</title>
    <link href="http://laibh.top/2019-10-26-react%20hook%E5%AE%9E%E8%B7%B5.html"/>
    <id>http://laibh.top/2019-10-26-react hook实践.html</id>
    <published>2019-10-26T04:00:00.000Z</published>
    <updated>2020-07-11T03:24:57.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="react-hook实践"><a href="#react-hook实践" class="headerlink" title="react hook实践"></a>react hook实践</h1><p>又到了跟着文档码字学习的阶段，<code>hook</code>从提案到现在已经很久了。在这之前但是还没有真正地去了解这个 react 新玩具。跟随<a href="https://react.docschina.org/docs/hooks-intro.html#gradual-adoption-strategy">文档</a>学习，并尝试重构一些项目</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>官方自带的视频已经很好地介绍了 <code>hook</code></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Hook 是 React.16.8 新增特征，可以让你在不编写 class的情况下使用 state 以及其他 React 特性</p><h3 id="State-Hook"><a href="#State-Hook" class="headerlink" title="State Hook"></a><code>State Hook</code></h3><p>简单的示例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;setCount(count+1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">                Click me</span></span><br><span class="line"><span class="regexp">            &lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>通过在函数组件里调用它来给组件添加一些内部的 <code>state</code>，React 会在渲染的时候保留这个 <code>state</code>。<code>useState</code>会返回一堆值：当前值和一个让你更新它的函数，可以在时间处理函数中或者其他一些地方调用这个函数。类似 <code>class</code>组件的 <code>this.setState</code>，但是它不会把新的 <code>state</code>和旧的 <code>state</code>进行合并。</p><p><code>useState</code> 唯一的参数就是初始的<code>state</code>。上面的例子中，计数器从零开始的，所有初始 <code>state</code>就是0。注意不同于 <code>this.state</code>，这里的 <code>state</code>不一定要是一个对象。</p><h4 id="声明多个变量"><a href="#声明多个变量" class="headerlink" title="声明多个变量"></a>声明多个变量</h4><p>在一个组件中声明多个变量</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ExampleWithManyStates</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [age,setAge] = useState(<span class="number">42</span>)</span><br><span class="line">    <span class="keyword">const</span> [fruit,setFruit] = useState(<span class="string">'banana'</span>)</span><br><span class="line">    <span class="keyword">const</span> [todos,setTodos] = useState(&#123;<span class="attr">text</span>:<span class="string">'Learn Hooks'</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Hook"><a href="#Hook" class="headerlink" title="Hook?"></a>Hook?</h4><p>Hook 是一些可以让你在函数组件里 钩入 <code>React state</code>以及生命周期函数等特性的函数。Hook 不能在 class 组件中使用。使得不用 class 也可以使用 React.</p><h3 id="Effect-Hook"><a href="#Effect-Hook" class="headerlink" title="Effect Hook"></a><code>Effect Hook</code></h3><p>React 组件中数据获取、订阅或者手动修改 DOM,都统称为副作用，或者称为作用</p><p><code>useEffect</code>就是 Effect Hook，给函数组件增加了操作副作用的能力，跟 class 组件的 <code>componentDid</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code>具有相同的用途，只不过被合并成了一个AOU</p><p>例子，在 React 更新 DOM 后设置一个页面的标题</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState, useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count, setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 相当于 componentDidMount 和 componentDidUpdate</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`laibh.top you check <span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You click &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;setCount(count+1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">                Click me</span></span><br><span class="line"><span class="regexp">            &lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>当调用 <code>useEffect</code>，就是在告诉 React 在完成对 DOM 的更改后运行副作用函数，由于副作用函数是在组件内声明的，所有可以访问到组件的 <code>props</code>或者 <code>state</code>。默认情况下，React 会在每次渲染后调用副作用函数——包括第一次渲染的时候</p><p>副作用函数还可以通过返回一个函数来指定清除副作用。例如，在下面的组件中使用副作用函数来订阅好友的在线状态，并通过取消订阅来进行清除操作：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [isOnline,setIsOnline] = useState(<span class="literal">null</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">        setIsOnline(status.isOnline)</span><br><span class="line">    &#125;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        ChatAPI.subscribeToFrinedStatus(props.friend.id,handleStatusChange)</span><br><span class="line">        <span class="keyword">return</span><span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            ChatAPI.unsubscribeFromFriendStatus(props.friend.id,handleStatusChange)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span>(isOnline === <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Loading ...'</span>   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实例中，React会在组件销毁或者后续渲染时重新执行副作用函数，取消对 <code>ChatAPI</code>的订阅。</p><p>跟 <code>useState</code>一样，可以在组件中多次使用 <code>useEffect</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatusWithCounter</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> [isOnline,setIsOnline] = useState(<span class="literal">null</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(props.friend.id,handleStatusChange)</span><br><span class="line">        <span class="keyword">return</span><span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            ChatAPI.subscribeFromFriendStatus(props.friend.id,handleStatusChange)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">        setIsOnline(status.isOnline)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用 Hook,可以把组件内相关的副作用组织在一起（例如创建订阅以及及时取消），而不要把它们拆分到不同的生命周期函数</p><h3 id="Hook使用规则"><a href="#Hook使用规则" class="headerlink" title="Hook使用规则"></a><code>Hook</code>使用规则</h3><p>Hook 就是 javascript 函数，但是使用它们会有两个额外的规则：</p><p>只能在函数最外层调用Hook。不要在循环、条件判断或者子函数中调用</p><p>只能在React 的函数组件中调用Hook。</p><h3 id="自定义-Hook"><a href="#自定义-Hook" class="headerlink" title="自定义 Hook"></a>自定义 <code>Hook</code></h3><p>在之前，组件之间复用一些状态逻辑，有两种主流方案：高阶组件、<code>render props</code>。自定义 <code>Hook</code>可以在不增加组件的情况下达到相同的目的</p><p><code>FriendStatus</code>组件，通过调用 <code>useState</code>和 <code>useEffect</code>的 Hook 来订阅一个好友的在线状态，假设我们想在另一个组件里复用这个订阅逻辑</p><p>首先，把逻辑提取到一个叫做 <code>useFriendStatus</code>的自定义 <code>Hook</code>里：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatus</span>(<span class="params">friendID</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [isOnline,setIsOnline] = useState(<span class="literal">null</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">        setIsOnline(status.isOnline)</span><br><span class="line">    &#125;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(friendID,handleStatusChange)</span><br><span class="line">        <span class="keyword">return</span><span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            ChatAPI.unsubscribeFromFriendStatus(friendID,handleStatusChange)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> isOnline</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它将 <code>friendID</code>作为参数，并返回该好友是否在线，我们可以在两个组件中用到它：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id)</span><br><span class="line">    <span class="keyword">if</span>(isOnline === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Loading'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendListItem</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isOnlie = useFriendStatus(props.friend.id)</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;li style=&#123;&#123;<span class="attr">color</span>:isOnline?<span class="string">'green'</span>:<span class="string">'black'</span>&#125;&#125;&gt;</span><br><span class="line">            &#123;props.friend.name&#125;</span><br><span class="line">        &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>两个组件中的 state 是完全独立的。Hook 是一种复用状态逻辑的方式，不复用 state 本身，事实上，Hook 每次调用都有一个完全独立的 state,因此可以在单个组件中多次调用同一个自定义 Hook</p><h3 id="其他Hook"><a href="#其他Hook" class="headerlink" title="其他Hook"></a>其他<code>Hook</code></h3><p>还有一些使用频率较低的但很有用的 <code>Hook</code>，比如使用 <code>useContext</code>可以不使用组件嵌套订阅 React 的 Context</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> locale = useContext(localeContext)</span><br><span class="line">    <span class="keyword">const</span> theme = useContext(ThemeContext)</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// useReducer 通过 reducer 来管理组件本地复杂的 state</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Todos</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [todos,dispatch] = useReducer(todosReducer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用-State-Hook"><a href="#使用-State-Hook" class="headerlink" title="使用 State Hook"></a>使用 <code>State Hook</code></h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class 示例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="comment">// 1. 构造函数中设置来初始化 count</span></span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            count:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p&gt;You click &#123;<span class="keyword">this</span>.state.count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;()=&gt;this.setState(&#123;count:this.state.count+1&#125;)&#125;&gt;</span></span><br><span class="line"><span class="regexp">                    Click me</span></span><br><span class="line"><span class="regexp">                &lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ hook示例</span></span><br><span class="line"><span class="regexp">import React,&#123;useState&#125; from 'react'</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Example()&#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 1. 函数组件中没有this,不能分配或者读取this.state,直接调用 useState</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 2. useState定义了一个 state变量。需要为一个参数初始state，参数可以是数字字符串或者对象。返回值为当前state以及更新state的函数。</span></span><br><span class="line"><span class="regexp">    const [count,setCount] = useState(0)</span></span><br><span class="line"><span class="regexp">    return(</span></span><br><span class="line"><span class="regexp">        &lt;div&gt;</span></span><br><span class="line"><span class="regexp">            &lt;p&gt;You click &#123;count&#125; times&lt;/</span>p&gt;</span><br><span class="line">            &lt;button onClick=&#123;()=&gt;setCount(count+<span class="number">1</span>)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Hook和函数组件"><a href="#Hook和函数组件" class="headerlink" title="Hook和函数组件"></a><code>Hook</code>和函数组件</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Example = <span class="function">(<span class="params">props</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 在这里可以使用 Hook</span></span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span>    </span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">function Example(props)&#123;</span></span><br><span class="line"><span class="xml">    // 这里可以使用 Hook</span></span><br><span class="line"><span class="xml">    return <span class="tag">&lt;<span class="name">div</span> /&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>Hook 在 class 内部是不起作用的，可以使用来替代 class</p><h2 id="使用-Effect-Hook"><a href="#使用-Effect-Hook" class="headerlink" title="使用 Effect Hook"></a>使用 <code>Effect Hook</code></h2><p><code>Effect Hook</code>可以让你在函数组件中执行副作用操作</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 类似于 componentDidMount 和 componentDidUpdate、componentWillUnmount</span></span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 用浏览器的api更新文档标题</span></span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You clicked &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;setCount(count+1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">                Click me</span></span><br><span class="line"><span class="regexp">            &lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用。在 React 组件中有两种常见副作用操作：需要清除的和不需要清除的。</p><h3 id="无需清除的-effect"><a href="#无需清除的-effect" class="headerlink" title="无需清除的 effect"></a>无需清除的 effect</h3><p>有时候，我们只想在 React 更新DOM 之后运行一些额外的代码，比如网络请求、手动变更 DOM,记录日志，这些都是常见的无需清除的操作。因为我们在执行完这些操作之后，就可以忽略他们了。</p><h4 id="使用class"><a href="#使用class" class="headerlink" title="使用class"></a>使用class</h4><p>在 React 的 class 组件中，<code>render</code>函数是不应该有任何副作用的，一般来说，在这里执行操作太早了，我们都希望在 React 更新 DOM 之后才执行我们的操作</p><p>这也是为什么把副作用放在 <code>componentDidMount</code>和<code>componentDidUpdate</code>函数中。</p><p>下面的示例，React 计数器的 class 组件，在 React 对 DOM 进行操作后，立即更新了 document 的 title 属性</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            count:<span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span> times`</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    componentDidUpdate()&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span> times`</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;p&gt;You clicked &#123;<span class="keyword">this</span>.state.count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">                &lt;button onClick=&#123;()=&gt;this.setState(&#123;count:this.state.count+1&#125;)&#125;&gt;</span></span><br><span class="line"><span class="regexp">                    Click me </span></span><br><span class="line"><span class="regexp">                &lt;/</span>button&gt;</span><br><span class="line">            &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 在 class 中，我们需要在两个声明周期函数中编写重复代码，很多情况下，我们希望在组件加载和更新时执行同样的操作。从概念上，我们希望每次渲染后执行-但是React的class组件没有提供这样的方法，即使我们提取出来，还是要在两个地方调用它</span></span><br></pre></td></tr></table></figure><h4 id="使用hook"><a href="#使用hook" class="headerlink" title="使用hook"></a>使用hook</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = useState(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You click <span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;p&gt;You click &#123;count&#125; times&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;setCount(count+1)&#125;&gt;</span></span><br><span class="line"><span class="regexp">                Click me</span></span><br><span class="line"><span class="regexp">            &lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 1. useEffect 告诉React 组件需要在渲染后执行某些操作。会保存传递的函数，并且在执行 DOM更新之后调用它。在这个 effect 中，我们设置了 document 的 title 属性，不过我们也可以执行数据获取或者调用其他命令的 API</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 2. 将 useEffect 放在组件内部让我们可以在 effect 中直接访问 count state 变量或者其他 props.我们不需要特殊的API来读取它，它已经保存在函数作用域中。Hook 使用了 js的闭包机制，而不用在js已经提供了解决方案的情况下，还引入特定的React API</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 3. useEffect会在每次渲染后都执行，默认情况下，它在第一次渲染之后和每次更新之后都会执行，不用去考虑挂载还是更新，React保证了每次运行 effect的同时，DOM都已经更新完毕了</span></span><br></pre></td></tr></table></figure><p>与 componentDidMount 和 componentDidUpdate不同，使用 useEffect 调度的 effect 不会阻塞浏览器更新屏幕，让应用看起来响应很快。大多数情况下，effect不需要同步地执行，在个别情况下（例如测试布局），有单独的 useLayoutEffect Hook 使用</p><h3 id="需要清除的-effect"><a href="#需要清除的-effect" class="headerlink" title="需要清除的 effect"></a>需要清除的 effect</h3><p>订阅外部数据源等一些副作用是需要清除的，可以防止内存泄露。</p><h4 id="使用class-1"><a href="#使用class-1" class="headerlink" title="使用class"></a>使用class</h4><p>通常会在 <code>componentDidMount</code>中设置订阅，在 <code>componentWillMount</code>中清除它。假设我们有一个 <code>ChatApI</code>模块，运行我们订阅好友的在线状态</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FriendStatus</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            isOnline:<span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.handleStatusChange = <span class="keyword">this</span>.handleStatusChange.bind(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        ChatAPI.subsribeToFriendStatus(</span><br><span class="line">            <span class="keyword">this</span>.props.friend.id,</span><br><span class="line">            <span class="keyword">this</span>.handleStatusChange</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillMount()&#123;</span><br><span class="line">        ChatAPI.unsubsribeToFriendStatue(</span><br><span class="line">            <span class="keyword">this</span>.props.friend.id,</span><br><span class="line">            <span class="keyword">this</span>.handleStatusChange</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    handleStatusChange(status)&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            isOnline:status.isOnline</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state.isOnline === <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Loading...'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.state.isOnline ? <span class="string">'ONline'</span> : <span class="string">'Offline'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用hook-1"><a href="#使用hook-1" class="headerlink" title="使用hook"></a>使用hook</h4><p>useEffect 设计在同一个地方执行添加和删除订阅，effect返回一个函数，React就会在指定清除的时候调用它</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [isOnline,setIsOnline] = useState(<span class="literal">null</span>)</span><br><span class="line">    </span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">            setIsOnline(status.isOnline)</span><br><span class="line">        &#125;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(props.friend.id,handleStatusChange)</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            ChatAPI.unsubscribeFromFriendStatus(props.friend.id,handleStatuChange)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(isOnline === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Loading...'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1. effect返回一个函数，这是 effect 可选的清除机制，每个 effect 都可以返回一个清除函数。所以可以将添加和订阅的逻辑放在一起，都属于 effect的一部分</span></span><br><span class="line"><span class="comment">// 2. React 会在组件卸载的时候执行清除操作，effect在每次渲染的时候都会执行。这就是为什么 React 会在执行当前 effect 之前对上一个 effect 进行清除</span></span><br><span class="line"><span class="comment">// 3.并不是必须为 effect 返回的函数命名，上面命令是为了表明此函数的目的，可以返回一个箭头函数或者另一个名字</span></span><br></pre></td></tr></table></figure><h3 id="使用多个Effect-实现关注点分离"><a href="#使用多个Effect-实现关注点分离" class="headerlink" title="使用多个Effect 实现关注点分离"></a>使用多个Effect 实现关注点分离</h3><p>使用hook其中一个目的就是要解决class 中声明周期函数经常包含不相关的逻辑，但又把相关逻辑分离到了几个不同方法中的问题。上面代码是示例中计数器和好友状态指示器逻辑组合在一起的组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FriendStatusWithCounter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            count:<span class="number">0</span>,</span><br><span class="line">            isOnline:<span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.handleStatusChange = <span class="keyword">this</span>.handleStatusChange.bind(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You click <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span> times`</span></span><br><span class="line">        ChatAPI.subscribeToFriendStatus(</span><br><span class="line">            <span class="keyword">this</span>.props.friend.id,</span><br><span class="line">            <span class="keyword">this</span>.handleStatusChange</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidUpdate()&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You click <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span> times`</span></span><br><span class="line">    &#125;</span><br><span class="line">    componentWillUnmount()&#123;</span><br><span class="line">        ChatAPI.unsubscibeFromFriendStatus(</span><br><span class="line">            <span class="keyword">this</span>.props.friend.id,</span><br><span class="line">            <span class="keyword">this</span>.handleStatusChange            </span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    handleStatusChange(status)&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            isOnline:status.inOnline</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以发现设置 documnet.title 的逻辑是如何被分割到 componentDidMount 和 componentDidUpdate中。订阅逻辑是被分割到 componentDidMount 和 componentWillUnmount 中。而且 componentDidMount 中包含了两个不同功能的代码</span></span><br></pre></td></tr></table></figure><p>而使用 hook,跟使用多个 state 的 hook一样，可以使用多个 effect将不相关逻辑分离到不同的 effect中</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatusWithCounter</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = useState(<span class="number">0</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> [isOnline,setIsOnline] = useState(<span class="literal">null</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">            setIsOnline(status.isOnline)</span><br><span class="line">        &#125;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(props.friend.id,handleStatusChange)</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            ChatAPI.unsubcribeFromFriendStatus(props.friend.id,handleStatusChange)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hook 允许我们按照代码的用途分离他们，而不是像生命周期函数那样，React 将按照 effect 声明的顺序依次调用组件中的每一个 effect</span></span><br></pre></td></tr></table></figure><h3 id="为什么每次更新的时候都要运行effect"><a href="#为什么每次更新的时候都要运行effect" class="headerlink" title="为什么每次更新的时候都要运行effect"></a>为什么每次更新的时候都要运行effect</h3><p>为什么 effect 在每次重渲染都会执行，而不是在卸载组件的时候执行一次。</p><p>上述用于显示好友是否在线的 FriendStatus 组件，从 class 中 props 读取 friend.id，然后在组件挂载后订阅好友状态，并在卸载组件的时候取消订阅</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(</span><br><span class="line">      <span class="keyword">this</span>.props.friend.id,</span><br><span class="line">      <span class="keyword">this</span>.handleStatusChange</span><br><span class="line">    );        </span><br><span class="line">&#125;</span><br><span class="line">componentWillUnmount()&#123;</span><br><span class="line">    ChatAPI.unsubscribeFromFriendStatus(</span><br><span class="line">      <span class="keyword">this</span>.props.friend.id,</span><br><span class="line">      <span class="keyword">this</span>.handleStatusChange</span><br><span class="line">    );    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里会有一个问题，当组件已经显示在屏幕上时，friend props发生变化，我们的组件将继续展示原来的好友状态，这是一个 bug,而且我们还会因为取消订阅时错误使用错误的好友 ID,导致内存泄露或者奔溃的问题</span></span><br><span class="line"><span class="comment">// 所以通过添加 componentDidUpdate 来解决这个问题</span></span><br><span class="line">componentDidUpdate(prevProps)&#123;</span><br><span class="line">    <span class="comment">// 取消之前的订阅的 friend.id</span></span><br><span class="line">    ChatAPI.unsubscibeFromFriendStatus(</span><br><span class="line">        prevProps.friend.id,</span><br><span class="line">        <span class="keyword">this</span>.handleStatusChange</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 订阅新的 friend.id</span></span><br><span class="line">    ChatAPI.subscribeToFriendStatus(</span><br><span class="line">        <span class="keyword">this</span>.props.friend.id,</span><br><span class="line">        <span class="keyword">this</span>.handleStatusChange</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Hook版本</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(props.friend.id,handleStatusChange)</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            ChatAPI.unsubscibeFromFriendStatus(props.friend.id,handleStatusChange)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要特定的代码来处理更新逻辑，useEffect默认就会处理。它会在调用一个新的 effect 之前对前一个 effect 进行清理。下面按时间列出一个可能会产生的订阅和取消订阅调用序列</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mount with &#123;friend:&#123;id:100&#125;&#125; props</span></span><br><span class="line">ChatAPI.subscibeToFriendStatus(<span class="number">100</span>,handleStatusChange) <span class="comment">// 运行第一个 effect</span></span><br><span class="line"><span class="comment">// Mount with &#123;friend:&#123;id:200&#125;&#125; props</span></span><br><span class="line">ChatAPI.unsubscribeFromFriendStatus(<span class="number">100</span>,handleStatusChange) <span class="comment">// 清除上一个 effect</span></span><br><span class="line">ChatAPI.subscibeToFriendStatus(<span class="number">200</span>,handleStatusChange) <span class="comment">// 运行下一个 effect</span></span><br><span class="line"><span class="comment">// Mount with &#123;friend:&#123;id:300&#125;&#125; props</span></span><br><span class="line">ChatAPI.unsubscribeFromFriendStatus(<span class="number">200</span>,handleStatusChange) <span class="comment">// 清除上一个 effect</span></span><br><span class="line">ChatAPI.subscibeToFriendStatus(<span class="number">300</span>,handleStatusChange) <span class="comment">// 运行下一个 effect</span></span><br><span class="line"><span class="comment">// unMount</span></span><br><span class="line">ChatAPI.unsubscribeFromFriendStatus(<span class="number">300</span>,handleStatusChange) <span class="comment">// 清除上一个 effect</span></span><br></pre></td></tr></table></figure><p>默认行为保证了一致性，避免了在 class 组件因为没有处理更新逻辑而导致常见 bug</p><h3 id="通过跳过-effect-进行性能优化"><a href="#通过跳过-effect-进行性能优化" class="headerlink" title="通过跳过 effect 进行性能优化"></a>通过跳过 effect 进行性能优化</h3><p>在某些情况下，每次渲染后都会执行清理或者执行 effect 可能会导致性能问题。在 class 组件中，可以通过 componentDidUpate 中添加 prevProps 或者 prevState 的比较逻辑解决：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps,prevState)&#123;</span><br><span class="line">    <span class="keyword">if</span>(prevState.count !== <span class="keyword">this</span>.state.count)&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;<span class="keyword">this</span>.state.count&#125;</span> times`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是很常见的需求，被内置到了 useEffect 的 hook api中，如果某些特定值在两次重渲染中没有发生变化，可以通过 React 跳过对 effect 的调用，只要传递数组作为 useEffect 的第二个参数即可：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.title = <span class="string">`You clicked <span class="subst">$&#123;count&#125;</span> times`</span></span><br><span class="line">&#125;,[count]) <span class="comment">// 仅在 count 更改的时候更新</span></span><br><span class="line"><span class="comment">// 对于有清除操作的 effect同样适用</span></span><br><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">        setIsOnline(status.isOnline)</span><br><span class="line">    &#125;</span><br><span class="line">    ChatAPI.subscibeToFriendStatus(props.friend.id,handleStatusChange)</span><br><span class="line">    <span class="keyword">return</span><span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        ChatAPI.unsubscibeFromFriendStatus(props.friend.id,handleStatusChange)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,[props.friend.id]) <span class="comment">// 仅在 props.friend.id 发生变化时，重新订阅</span></span><br></pre></td></tr></table></figure><p>注意：</p><p>如果要使用这种优化方法，确保数组中包含了所有外部作用域中会随着时间变化并且在 effect 中使用的变量，否则代码会引用到先前渲染中的旧变量。</p><p>如果想只执行一次 effect 仅在组件挂载或者卸载时执行，可以传递一个空数组（[]），作为第二个参数，告诉 React 的 effect 不依赖于props 或者 state 中的任何值，所以它永远都不需要被重复执行，这不属于特殊情况，依然遵循数组的工作方式。</p><p>如果传入了一个空数组，effect 内部的 props 和 state 就会一直拥有其初始值。尽管传入的空数组作为第二个参数更加接近熟悉的 componentDidMount 和 componentWillUnMount 思维方式。React 会等待浏览器完成画面渲染后才会延迟调用 useEffect，因此会使得额外操作很方便。</p><p> 启用 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation"><code>eslint-plugin-react-hooks</code></a> 中的 <a href="https://github.com/facebook/react/issues/14920"><code>exhaustive-deps</code></a> 规则。此规则会在添加错误依赖时发出警告并给出修复建议。 </p><h2 id="Hook-规则"><a href="#Hook-规则" class="headerlink" title="Hook 规则"></a><code>Hook</code> 规则</h2><p>Hook 本质就是 JS 函数，使用它需要遵循两条规则。 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks">linter 插件</a>来强制执行这些规则：</p><h3 id="只在顶层使用-Hook"><a href="#只在顶层使用-Hook" class="headerlink" title="只在顶层使用 Hook"></a>只在顶层使用 <code>Hook</code></h3><p>不要在循环，条件或者嵌套函数中调用 Hook，确保总是在 React 函数的最顶层调用它们。遵循这条规则，就能确保 hook 在每一次渲染中都按照同样的顺序被执行.</p><h3 id="只在-React-函数中使用-Hook"><a href="#只在-React-函数中使用-Hook" class="headerlink" title="只在 React 函数中使用 Hook"></a>只在 React 函数中使用 <code>Hook</code></h3><p>不要在普通的 JS 函数中调用 Hook，可以在React 函数组件中调用 Hook，在自定义 Hook 中调用其他 Hook</p><p>遵循以上规则，确保组件的状态逻辑在代码中清晰可见</p><h3 id="ESLINT-插件"><a href="#ESLINT-插件" class="headerlink" title="ESLINT 插件"></a>ESLINT 插件</h3><p>  <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks"><code>eslint-plugin-react-hooks</code></a> 的 ESLint 插件来强制执行这两条规则。如果你想尝试一下，可以将此插件添加到你的项目中： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install eslint-plugins-react-hooks --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ESLint 的配置</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">"plugins"</span>:[</span><br><span class="line">        //...</span><br><span class="line">        <span class="string">"react-hooks"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"rules"</span>:&#123;</span><br><span class="line">        //...</span><br><span class="line">        "react-hooks/rules-of-hooks":"error",// 检查 Hook 规则</span><br><span class="line">        "react-hooks/exhaustive-deps":"warn" // 检查 effect 的依赖</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>单个组件中使用多个 State Hook或者 Effect Hook</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Form</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [name,setName] = useState(<span class="string">'Mary'</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="keyword">function</span> <span class="title">persisForm</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        localStorage.setItem(<span class="string">'formData'</span>,name)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> [surname,setSurname] = useState(<span class="string">'Poppins'</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="keyword">function</span> <span class="title">updateTitle</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = name + <span class="string">' '</span> +surname</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React 怎么知道哪个state 对应哪个 useState，答案是React靠Hook调用的顺序。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首次渲染</span></span><br><span class="line">useState(<span class="string">'Mary'</span>) <span class="comment">// 1.使用 Mary 初始化变量名为 name 的 state</span></span><br><span class="line">useEffect(persistForm) <span class="comment">// 2.添加 effect 以保存 form 操作</span></span><br><span class="line">useState(<span class="string">'Poppings'</span>) <span class="comment">// 3.使用 Poppings 初始化变量名为 surname 的 state</span></span><br><span class="line">useEffect(updateTitle) <span class="comment">//4. 添加 effect 以更新标题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二次渲染</span></span><br><span class="line">useState(<span class="string">'Mary'</span>) <span class="comment">// 5.读取变量名为 name 的 state (参数被忽略)</span></span><br><span class="line">useEffect(persistForm) <span class="comment">// 6.替换保存 form 的 effect</span></span><br><span class="line">useState(<span class="string">'Poppings'</span>) <span class="comment">// 7.读取变量名为 surname 的 state(参数被忽略)</span></span><br><span class="line">useEffect(updateTitle) <span class="comment">//8. 替换更新标题的effect</span></span><br></pre></td></tr></table></figure><p>只要 Hook 的调用顺序在多次渲染中保持一致，React 就能正确将内部 state 和对应的 hook 进行关联。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 倘若将一个 hook 调用放入到一个条件语句中会发生什么</span></span><br><span class="line"><span class="keyword">if</span>(name !== <span class="string">''</span>)&#123;</span><br><span class="line">    useEffect(<span class="function"><span class="keyword">function</span> <span class="title">persistForm</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        localStorage.setItem(<span class="string">'formData'</span>,name)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在第一次渲染中 name!== ''条件为true,所以会执行这个 hook，但是下一次渲染我们可能清空了表单，表达式为 false,此时渲染会跳过该hook，hook的调用顺讯发生了变化</span></span><br><span class="line">useState(<span class="string">'Mary'</span>) <span class="comment">//1.读取变量名为 name 的 state(参数被忽略)</span></span><br><span class="line"><span class="comment">// useEffect(persistForm) // 此 hook 被忽略</span></span><br><span class="line">useState(<span class="string">'Poppins'</span>) <span class="comment">// 2.(之前为3)。读取变量名为 surname的state 失败</span></span><br><span class="line">useEffect(updateTitle) <span class="comment">// 3.(之前为4)，替换更新标题的 effect失败</span></span><br></pre></td></tr></table></figure><p>React 不知道第二个useState 的 Hook 应该返回什么，React 以为在该组件中第二个 Hook 的调用像上次渲染一样。对应的是 persistForm的 effect,但并非如此。从这里开始，后面的 Hook调用都被提前执行，导致了bug的产生。</p><p>这就是为什么 Hook 需要在我们组件的最顶层调用，如果要有条件地执行一个 effect，可以将判断放在 Hook 的内部</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="keyword">function</span> <span class="title">persistForm</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 将条件放置在 effect 中</span></span><br><span class="line">    <span class="keyword">if</span>(name === <span class="string">''</span>)&#123;</span><br><span class="line">        localStorage.setItem(<span class="string">'formData'</span>,name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="自定义-Hook-1"><a href="#自定义-Hook-1" class="headerlink" title="自定义 Hook"></a>自定义 <code>Hook</code></h2><p>通过自定义 Hook，可以将组件逻辑提取到可重用的函数中</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendState</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [isOnline,setIsOnline] = useState(<span class="literal">null</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">            setIsOnline(status.isOnline)</span><br><span class="line">        &#125;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">        &#125;;        </span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span>(isOnline === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Loading...'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设聊天应用中有一个联系人列表，当用户在线时需要把名字设置为 绿色，我们可以把上面类似的逻辑复制并粘贴到 FriendListItem 组件中，但这并不是理想的解决方案</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendListItem</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [isOnline,setIsOnline] = useState(<span class="literal">null</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">            setIsOnline(status.isOnline)</span><br><span class="line">        &#125;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);</span><br><span class="line">        &#125;;          </span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;li style=&#123;&#123;<span class="attr">color</span>:isOnline?<span class="string">'green'</span>:<span class="string">'black'</span>&#125;&#125;&gt;</span><br><span class="line">            &#123;props.friend.name&#125;</span><br><span class="line">        &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>我们希望在FriendStatus以及FriendListItem 之间共享逻辑。</p><h3 id="提取自定义-Hook"><a href="#提取自定义-Hook" class="headerlink" title="提取自定义 Hook"></a>提取自定义 <code>Hook</code></h3><p>当我们想在两个函数之间共享逻辑时，会把它提取到第三个函数中，而组件和Hook都是函数，所以也使用这种方式</p><p>自定义Hook 是一个函数，名称以 use 开头，函数内部可以调用其他 hook，下面 useFriendStatus 就是定义的 Hook</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;useState,useEffect&#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatus</span>(<span class="params">friendID</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [isOnline,setIsOnline] = useState(<span class="literal">null</span>)</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">handleStatusChange</span>(<span class="params">status</span>)</span>&#123;</span><br><span class="line">            setIsOnline(status.isOnline)</span><br><span class="line">        &#125;</span><br><span class="line">        ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</span><br><span class="line">        &#125;;          </span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> isOnline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 此处 <code>useFriendStatus</code> 的 Hook 目的是订阅某个好友的在线状态。这就是我们需要将 <code>friendID</code> 作为参数，并返回这位好友的在线状态的原因。 </p><h3 id="使用自定义-Hook"><a href="#使用自定义-Hook" class="headerlink" title="使用自定义 Hook"></a>使用自定义 <code>Hook</code></h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendStatus</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id)</span><br><span class="line">    <span class="keyword">if</span>(isOnline === <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Loading...'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isOnline ? <span class="string">'Online'</span> : <span class="string">'Offline'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FriendListItem</span>(<span class="params">props</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> isOnline = useFriendStatus(props.friend.id)</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;li style=&#123;&#123;<span class="attr">color</span>:isOnline?<span class="string">'green'</span>:<span class="string">'black'</span>&#125;&#125;&gt;</span><br><span class="line">            &#123;props.friend.name&#125;</span><br><span class="line">        &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>  <strong>代码等价于原来的示例代码</strong> ,<strong>自定义 Hook 是一种自然遵循 Hook 设计的约定，而并不是 React 的特性。</strong> </p><p> <strong>自定义 Hook 必须以 “<code>use</code>” 开头</strong> </p><p> <strong>在两个组件中使用相同的 Hook 不会共享 state</strong> </p><p> <strong>自定义 Hook  每次<em>调用</em>  都会获取独立的 state</strong></p><h3 id="多个-Hook之间传递信息"><a href="#多个-Hook之间传递信息" class="headerlink" title="多个 Hook之间传递信息"></a>多个 <code>Hook</code>之间传递信息</h3><p>由于 Hook 本身就是函数，因此我们可以在它们之间传递信息。</p><p>将使用聊天程序中的另一个组件来说明这一点，这是一个聊天消息接收者的选择器。会显示当前的好友是否在线</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> friendList = [</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">1</span>,<span class="attr">name</span>:<span class="string">'Phoebe'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">2</span>,<span class="attr">name</span>:<span class="string">'Rachel'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>:<span class="number">3</span>,<span class="attr">name</span>:<span class="string">'Ross'</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChatRecipientPicker</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [recipientID,setRecipientID] = useState(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">const</span> isRecipientOnline = useFriendStatus(recipientID)</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;&gt;</span><br><span class="line">        &lt;Circle color=&#123;isRecipientOnline ? <span class="string">'green'</span> : <span class="string">'red'</span>&#125;/&gt;</span><br><span class="line">        &lt;Select </span><br><span class="line">                value=&#123;recipientID&#125;</span><br><span class="line">                onChange=&#123;e=&gt;setRecipientID(<span class="built_in">Number</span>(e.target.value))&#125;</span><br><span class="line">             &gt;</span><br><span class="line">            &#123;friendList.map(<span class="function"><span class="params">friend</span>=&gt;</span>(</span><br><span class="line">                &lt;option key=&#123;friend.id&#125; value=&#123;friend.id&#125;&gt;</span><br><span class="line">                    &#123;friend.name&#125;</span><br><span class="line">                &lt;<span class="regexp">/option&gt;</span></span><br><span class="line"><span class="regexp">            ))&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>Select&gt;</span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>将当前选择的好友ID保存在 recepientID 状态变量中，并在用户从 Select 中选择其他好友时更新这个state</p><p>由于 useState 提供了 recipientID 状态变量的最新值，我们可以将它作为参数传递给自定义的 useFriendStatus Hook</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [recipientID,setRecipientID] = useState(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> isRecipientOnline = useFriendStatus(recipientID)</span><br></pre></td></tr></table></figure><p>当我们选择不同的好友并更新 recipientID 状态变量时，useFriendStatusHook 将会取消订阅之前选中的好友，并订阅新选中的好友状态</p><h2 id="Hook-API索引"><a href="#Hook-API索引" class="headerlink" title="Hook API索引"></a><code>Hook API</code>索引</h2><h3 id="基本Hook"><a href="#基本Hook" class="headerlink" title="基本Hook"></a>基本<code>Hook</code></h3><h4 id="useState"><a href="#useState" class="headerlink" title="useState"></a><strong>useState</strong></h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state,setState] = useState(initialState)</span><br></pre></td></tr></table></figure><p>返回一个state,以及更新 state 的函数。在初始渲染期间，返回的状态（state）与传入的第一个参数(initialState)值相同。</p><p><code>setState</code>函数用于更新state,它接收一个新的state值并将组件的一次重新渲染加入队列</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setState(newState);</span><br></pre></td></tr></table></figure><p>后续渲染中，useState 返回的第一个值始终是更新后最新的 state。React会确保 setState 函数的标识是稳定的，并且不会在组件重新渲染时发生变化，这就是为什么可以安全地从 useEffect 或 useCallback 的依赖列表中省略 setState</p><p><strong>函数式更新</strong></p><p>如果新的state需要通过使用先前的 state计算得出，那么可以将函数传递给 setState,该函数将接收先前的 state,并返回一个更新后的值，下面的例子展示了 setState 的两种用法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;initialCount&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [count,setCount] = useState(initialCount);</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;&gt;</span><br><span class="line">        Count:&#123;count&#125;</span><br><span class="line">&lt;button onClick=&#123;()=&gt;setCount(initialCount)&#125;&gt;Reset&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;()=&gt;setCount(prevCount=&gt;prevCount+1)&#125;&gt;=&lt;/</span>button&gt;</span><br><span class="line">            &lt;button onClick=&#123;()=&gt;setCount(<span class="function"><span class="params">prevCount</span>=&gt;</span>prevCount<span class="number">-1</span>)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><code>+</code>和<code>-</code>采用函数式形式，因为被更新的的 state 需要基于之前的 state,但是重置按钮则采用普通形式，因为它总是把 count 设置回初始值</p><p>与 class 组件的 setState 方法不一致，useState 不会自动合并更新对象，使用函数式的 setState 结合展开运算符达到合并更新对象的效果</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setState(<span class="function"><span class="params">prevState</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// Object.assign</span></span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        ...prevState,...updateValues</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// useReducer 是另一种可选方案，更适合用于管理包含多个子值的 state 对象</span></span><br></pre></td></tr></table></figure><p><strong>惰性初始 state</strong></p><p>initialState 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。如果初始 state 需要通过复杂计算获得，则可以传入一个函数，在函数计算并返回初始 state,次函数只在初始渲染被调用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state,setState] = useState(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> initialState = someExpensiveComputation(props)</span><br><span class="line">    <span class="keyword">return</span> initialState</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>跳过state 更新</strong></p><p>调用 State Hook 的更新函数并传入当前的 state ，React 将跳过子组件的渲染以及 effect 的执行，React 使用Object.is 比较算法来比较state</p><p>需要注意的是，React可能仍需要在跳过渲染前渲染该组件，不过由于React不会对组件数的深层节点进行不必要的渲染，所以不用担心。如果在渲染期间执行了高开销的计算，则可以使用 useMemo 优化。</p><h4 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useEffect(didUpdate)</span><br></pre></td></tr></table></figure><p>该hook 接收一个包含命令式、并且可能有副作用代码的函数。</p><p>在函数组件主体内改变 DOM,添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性</p><p>使用 <code>useEffect</code>完成副作用操作，赋值给 <code>useEffect</code>的函数会在组件渲染到屏幕之后执行。默认情况下，effect 将在每轮渲染结束后执行，可以渲染让它在只有某些值的时候才执行。</p><p><strong>清除effect</strong></p><p>通常，组件卸载时需要清除 effect 创建的诸如订阅或者定时器ID 等资源，要实现这一点，需要返回一个清除函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> subsciption = props.source.subscibe()</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 清除订阅</span></span><br><span class="line">        subscription.unsubscribe()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>为了防止内存泄露，清除函数会在组件卸载前执行，另外，如果组件多次渲染，则在执行下一个 effect 之前，上一个 effect 就已经被清除。上面的例子意味着组件的每一次更新都会创建新的订阅，若想避免每次更新都触发 effect 的。</p><p><strong>effect的执行时机</strong></p><p>与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会被延迟调用。这使得它适用于很多常见的副作用场景，如设置订阅和事件处理等情况，因为不应该在函数中执行阻塞浏览器更新屏幕的操作。</p><p>然后不是所有的 effect 都可以被延迟执行的，例如在浏览器执行 下一次绘制前，用户可见的 DOM变更就必须同步执行，这样永不才不会感觉到视觉上的不一致。React 提供了 useLayoutEffect Hook 来处理这类 effect，和 useEffect 结构相同，但是调用时机不同。</p><p>虽然 useEffect 会在浏览器绘制后延迟执行，但会保证在任何渲染前执行，React 将在组件更新前刷新上一轮的渲染的 effect </p><p><strong>effect的条件执行</strong></p><p>默认情况下，effect 会在每轮组件渲染完成后执行，一旦 effect 的依赖发生变化，它就会被重新创建。但我们不需要再每次更新时都创建新的订阅，而仅在 props 改变的时候重新创建，可以给 useEffect 传递第二个参数，它是 effect 依赖的值数组</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> subscription = props.source.subscribe()</span><br><span class="line">    <span class="keyword">return</span><span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        subscription.unsubscribe();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,[props.source])</span><br><span class="line"><span class="comment">// 此时只有props.source 改变后才会重新创建订阅</span></span><br></pre></td></tr></table></figure><h4 id="useContext"><a href="#useContext" class="headerlink" title="useContext"></a>useContext</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> value = useContext(myContext);</span><br></pre></td></tr></table></figure><p>接收一个 context 对象（React.createContext的返回值）并返回该 context 的当前值。当前 context 值由上层组件中距离当前组件最新的 <code>&lt;MyContext.Provider&gt;</code>的 value prop 决定。</p><p>当上层最近的 <code>&lt;MyContext.Provider&gt;</code>更新时，该Hook 会触发重新渲染，并使用最新传递给 MyContext provider 的 context  value 值</p><p>别忘记 <code>useContext</code> 的参数必须是 <em>context 对象本身</em>：</p><ul><li><strong>正确：</strong> <code>useContext(MyContext)</code></li><li><strong>错误：</strong> <code>useContext(MyContext.Consumer)</code></li><li><strong>错误：</strong> <code>useContext(MyContext.Provider)</code></li></ul><p>调用了 useContext的组件总会在 context 值变化时重新渲染，如果重新渲染组件开销比较大的话，可以通过 memoization 优化</p><p><code>useContext(MyContext)</code>只是能够读取 context 的值以及订阅 context 的变化，仍然需要在上层组件树中使用 <code>&lt;MyContext.Provider&gt;</code>来为下层组件提供 context</p><h3 id="额外的-Hook"><a href="#额外的-Hook" class="headerlink" title="额外的 Hook"></a>额外的 Hook</h3><h4 id="useReducer"><a href="#useReducer" class="headerlink" title="useReducer"></a>useReducer</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state,dispatch] = useReducer(reducer,initialArg,init)</span><br></pre></td></tr></table></figure><p>它接受一个 <code>(state,action)=&gt; newState</code>的 reducer，并返回一个当前的 state以及与其配套的 <code>dispatch</code>方法。</p><p>在某些场景下，useReducer 比 useState更适用。例如 state 逻辑复杂且包含多个子值，或者下一个 state 依赖之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为可以向子组件传递 dispatch 而不是回调函数。</p><p>reducer 重写 useState 的计数器</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> initialState = &#123;<span class="attr">count</span>:<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state,action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>:state.count+<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>:state.count<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [state,dispatch] = useReducer(reducer,initialState)</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;&gt;</span><br><span class="line">        Count:&#123;state.count&#125;</span><br><span class="line">        &lt;button onClick=&#123;()=&gt;dispatch(&#123;<span class="attr">type</span>:<span class="string">'increment'</span>&#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;button onClick=&#123;()=&gt;dispatch(&#123;<span class="attr">type</span>:<span class="string">'decrement'</span>&#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">        &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>指定初始state</strong></p><p>有两种初始化 useReducer state 的方式，可以根据使用场景选择其中的一种。将初始 state 作为第二个参数传入 useReducer 是最简单的方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [state,dispatch] = useReducer(</span><br><span class="line">    reducer,</span><br><span class="line">    &#123;<span class="attr">count</span>:initialCount&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>惰性初始化</strong></p><p>选择惰性地创建初始化 state,为此需要将 init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg)</p><p>这样做，可以将用于计算 state 的逻辑提取到 reducer 外部，这也为将来对重置 state 的 action 做处理提供了便利：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params">initialCount</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">count</span>:initialCount&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state,action</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'increment'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>:state.count+<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'decrement'</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>:state.count<span class="number">-1</span>&#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'reset'</span>:</span><br><span class="line">            <span class="keyword">return</span> init(action.payload);            </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params">&#123;initialCount&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [state,dispatch] = useReducer(reducer,initialCount,init)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>(</span><br><span class="line">    &lt;&gt;</span><br><span class="line">    Count:&#123;state.count&#125;</span><br><span class="line">    &lt;button onClick=&#123;()=&gt;dispatch(&#123;<span class="attr">type</span>:<span class="string">'reset'</span>,<span class="attr">payload</span>:initialCount&#125;)&#125;&gt;<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;button onClick=&#123;()=&gt;dispatch(&#123;<span class="attr">type</span>:<span class="string">'increment'</span>&#125;)&#125;&gt;+<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;button onClick=&#123;()=&gt;dispatch(&#123;<span class="attr">type</span>:<span class="string">'decrement'</span>&#125;)&#125;&gt;-<span class="xml"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br></pre></td></tr></table></figure><p><strong>跳过 dispatch</strong></p><p>如果 Reducer Hook  的返回值与当前 state 相同，React 将跳过子组件的渲染以及副作用的执行。需要注意的是，React 可能仍需要跳过渲染前再次渲染该组件。不过由于React 不会对组件树的深层节点进行不必要的渲染，所以不用担心。如果在渲染期间执行了高开销的计算，则可以使用 <code>useMemo</code>来进行优化</p><h4 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoziedCallback = useCallBack(</span><br><span class="line">    ()=&gt;&#123;</span><br><span class="line">        dosomething(a,b);</span><br><span class="line">    &#125;,</span><br><span class="line">    [a,b]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>返回一个 memoized 回调函数</p><p>把内联回调函数以及依赖数组作为参数传入 useCallback ，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会跟新。当你把回调函数给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件，它将非常有用</p><p><code>useCallback(fn,deps)</code>相当于 <code>useMemo(()=&gt;fn,deps)</code></p><h4 id="useMemo"><a href="#useMemo" class="headerlink" title="useMemo"></a>useMemo</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = useMemo(<span class="function"><span class="params">()</span>=&gt;</span>computeExpensiveValue(a,b),[a,b])</span><br></pre></td></tr></table></figure><p>返回一个 memoized值。</p><p>把创建函数和依赖项作为参数传入 useMemo,它仅会在某个依赖项改变时才重新计算 memoized值，这种优化有助于避免在每次渲染时都进行高开销计算。</p><p>传入 useMemo 的函数会在渲染期间执行，不要在这个函数内部执行于渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo</p><p>如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值</p><h4 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> refContainer = useRef(initialValue)</span><br></pre></td></tr></table></figure><p>useRef 返回一个可变的 ref 对象，其 <code>.current</code>属性被初始化为传入的参数 initialValue 。返回的 ref 对象在组件的整个生命周期内保持不变。</p><p>命令式访问子组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TextInputWithFocusButton</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> inputEl = useRef(<span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">const</span> onButtonClick = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// current 指向已经挂载到 DOM 上的文本输入元素</span></span><br><span class="line">        inputEl.current.focus();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;&gt;</span><br><span class="line">        &lt;input ref=&#123;inputEl&#125; type=<span class="string">"text"</span>/&gt;</span><br><span class="line">        &lt;button onClick=&#123;onButtonClick&#125;&gt;Focus the input&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="useImperativeHandle"><a href="#useImperativeHandle" class="headerlink" title="useImperativeHandle"></a>useImperativeHandle</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useImperativeHandle(ref,createHandle,[deps])</span><br></pre></td></tr></table></figure><p><code>useImperativeHandle</code>可以让你在使用 <code>ref</code>时自定义暴露给父组件的实例值。<code>useImperativeHandle</code>应当与 <code>forwardRef</code>一起使用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FancyInput</span>(<span class="params">props,ref</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> inputRef = useRef();</span><br><span class="line">    useImperativeHandle(red,()=&gt;&#123;</span><br><span class="line">        focus:<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            inputRef.current.focus()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;inputRef&#125;</span> <span class="attr">...</span>/&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">FancyInput = forwardRef(FancyInput)</span></span><br><span class="line">// 渲染 &lt;FancyInput ref=&#123;fancyInputRef&#125; /&gt; 的父组件可以调用 fancyInputRef.current.focus();</span><br></pre></td></tr></table></figure><h4 id="useLayoutEffect"><a href="#useLayoutEffect" class="headerlink" title="useLayoutEffect"></a>useLayoutEffect</h4><p>其函数签名与 useEffect 相同，但它会在所有的DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。在浏览器执行绘制之前，useLayoutEffect 内部的更新计划会被同步刷新。尽可能使用 标准的 useEffect 以避免阻塞视觉更新</p><p>注意：</p><p>useLayoutEffect 与 componentDidMount、componentDIdUpdate的调用阶段是一样的。</p><p>如果使用服务端渲染，无论是 useLayoutEffect 或者 useEffect 都无法在 JS 代码加载完成之前执行。这就是为什么在服务端渲染组件中引入 useLayoutEffect 代码会触发React 警告。解决这个问题，需要将代码逻辑移到 useEffect 中（如果首次渲染不需要这段逻辑的情况下），或是将该组件延迟到客户端渲染完成后再显示（直到 useLayoutEffect执行之前HTML 都显示错误的情况下）</p><p>若要从服务端渲染的 HTML 中排除依赖布局 effect 的组件，可以通过使用 <code>showChild &amp;&amp; &lt;Child&gt;</code>进行条件渲染，并使用 <code>useEffect(()=&gt;{setShowChild(true)},[])</code>延迟展示组件。这样在客户单渲染完成之前，UI就不会像之前那样显示错乱了。</p><h4 id="useDebugValue"><a href="#useDebugValue" class="headerlink" title="useDebugValue"></a>useDebugValue</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useDebugValue(value)</span><br></pre></td></tr></table></figure><p><code>useDebugValue</code>可用于 React 开发工具中显示自定义 hook 标签</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFriendStatus</span>(<span class="params">friendID</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> [isOnline,setIsOnline] = useState(<span class="literal">null</span>)</span><br><span class="line">    useDebugValue(isOnline?<span class="string">'Online'</span>:<span class="string">'Offline'</span>)</span><br><span class="line">    <span class="keyword">return</span> isOnline</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>延迟格式化 debug值</strong></p><p>某些情况下，格式化值的显示可能是一项开销很大的操作，除非检查 Hook，否则没有必要这么做。因此，useDebugValue 接受一个格式化函数作为可选的第二个参数。该函数只有在 hook 检查才会被调用。它接受 debug 值作为参数，并且会返回一个格式化的显示值。</p><p>例如，一个返回 Date 值的自定义 Hook 可以通过格式化函数来避免不必要的 toDateString 函数调用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useDebugValue(date,date=&gt;date.toDateString())</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;react-hook实践&quot;&gt;&lt;a href=&quot;#react-hook实践&quot; class=&quot;headerlink&quot; title=&quot;react hook实践&quot;&gt;&lt;/a&gt;react hook实践&lt;/h1&gt;&lt;p&gt;又到了跟着文档码字学习的阶段，&lt;code&gt;hook&lt;/cod
      
    
    </summary>
    
      <category term="react" scheme="http://laibh.top/categories/react/"/>
    
    
      <category term="react" scheme="http://laibh.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>基于ts重构axios</title>
    <link href="http://laibh.top/2019-09-03-%E5%9F%BA%E4%BA%8Ets%E9%87%8D%E6%9E%84axios.html"/>
    <id>http://laibh.top/2019-09-03-基于ts重构axios.html</id>
    <published>2019-09-03T06:19:54.000Z</published>
    <updated>2020-07-11T03:24:57.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于ts重构axios"><a href="#基于ts重构axios" class="headerlink" title="基于ts重构axios"></a>基于ts重构axios</h1><p><strong>ustbhuangyi</strong> 老师的 <a href="https://coding.imooc.com/class/330.html">基于TypeScript从零重构axios</a>学习记录。</p><p><strong>知识点</strong></p><p>TypeScript 常用语法：</p><p><code>基础类型</code> 、 <code>函数</code> 、 <code>变量声明</code> 、 <code>接口</code> 、 <code>类</code> 、 <code>泛型</code> 、 <code>类型推新</code> 、 <code>高级类型</code> </p><p>axios js库：</p><p><code>项目脚手架</code> 、 <code>基础功能实现</code> 、 <code>异常情况处理</code> 、 <code>接口扩展</code> 、 <code>拦截器实现</code> 、 <code>配置化实现</code> 、 <code>取消功能实现</code> 、 <code>其他功能实现等等</code> </p><p>主要工具：<br><code>Jest</code> 、 <code>TSLint</code> 、 <code>Commitizen</code> 、 <code>Prettier</code> 、 <code>RollupJS</code> 、 <code>Semantic release</code> </p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><a href="http://laibh.top/2018-11-28-TypeScript.html">点我</a></p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ul><li>在浏览器使用 XMLHttpRequest 对象通讯</li><li>支持 Promise API</li><li>支持请求和响应的拦截器</li><li>支持请求数据和响应数据的转换</li><li>支持请求的取消</li><li>JSON数据的自动转换</li><li>客户端防止 XSRF</li></ul><h2 id="基于-XMLHttpRequest-编写基本请求代码"><a href="#基于-XMLHttpRequest-编写基本请求代码" class="headerlink" title="基于 XMLHttpRequest 编写基本请求代码"></a>基于 XMLHttpRequest 编写基本请求代码</h2><h3 id="处理请求数据：url-body-headers"><a href="#处理请求数据：url-body-headers" class="headerlink" title="处理请求数据：url/body/headers"></a>处理请求数据：url/body/headers</h3><p><strong>src/types/index.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export type Method = &apos;get&apos; | &apos;GET&apos; | &apos;delete&apos; | &apos;Delete&apos; | &apos;head&apos; | &apos;HEAD&apos; | &apos;options&apos; | &apos;OPTIONS&apos; | &apos;post&apos; | &apos;POST&apos; | &apos;put&apos; | &apos;PUT&apos; | &apos;patch&apos; | &apos;PATCH&apos;</span><br><span class="line">export interface AxiosRequestConfig &#123;</span><br><span class="line">  url: string</span><br><span class="line">  method?: Method</span><br><span class="line">  data?: any</span><br><span class="line">  params?: any</span><br><span class="line">  headers?: any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>src/xhr.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; AxiosRequestConfig &#125; from &apos;./types&apos;</span><br><span class="line"></span><br><span class="line">export default function xhr(config: AxiosRequestConfig): void &#123;</span><br><span class="line">  const &#123; data = null, url, method = &apos;get&apos;, headers &#125; = config</span><br><span class="line">  const request = new XMLHttpRequest()</span><br><span class="line">  // method,url,async</span><br><span class="line">  request.open(method.toUpperCase(), url, true)</span><br><span class="line">  Object.keys(headers).forEach(name =&gt; &#123;</span><br><span class="line">    if (data === null &amp;&amp; name.toLowerCase() === &apos;content-type&apos;) &#123;</span><br><span class="line">      delete headers[name]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      request.setRequestHeader(name, headers[name])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  request.send(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>src/index.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import &#123; AxiosRequestConfig &#125; from &apos;./types&apos;</span><br><span class="line">import &#123; buildURL &#125; from &apos;./helpers/url&apos;;</span><br><span class="line">import &#123; transformRequest &#125; from &apos;./helpers/data&apos;;</span><br><span class="line">import xhr from &apos;./xhr&apos;</span><br><span class="line">import &#123; processHeaders &#125; from &apos;./helpers/header&apos;;</span><br><span class="line"></span><br><span class="line">function axios(config: AxiosRequestConfig): void &#123;</span><br><span class="line">  processConfig(config)</span><br><span class="line">  xhr(config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function processConfig(config: AxiosRequestConfig): void &#123;</span><br><span class="line">  config.url = transformURL(config)</span><br><span class="line">  config.data = transformRequestData(config)</span><br><span class="line">  config.headers = transformHeaders(config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transformHeaders(config: AxiosRequestConfig): void &#123;</span><br><span class="line">  const &#123; headers = &#123;&#125;, data &#125; = config</span><br><span class="line">  return processHeaders(headers, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transformRequestData(config: AxiosRequestConfig): void &#123;</span><br><span class="line">  return transformRequest(config.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transformURL(config: AxiosRequestConfig): string &#123;</span><br><span class="line">  const &#123; url, params &#125; = config;</span><br><span class="line">  return buildURL(url, params)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default axios</span><br></pre></td></tr></table></figure><h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><p><strong>data.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; isPlainObject &#125; from &quot;./util&quot;;</span><br><span class="line"></span><br><span class="line">export function transformRequest(data: any): any &#123;</span><br><span class="line">  if (isPlainObject(data)) &#123;</span><br><span class="line">    return JSON.stringify(data)</span><br><span class="line">  &#125;</span><br><span class="line">  return data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>headers.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &#123; isPlainObject &#125; from &quot;./util&quot;</span><br><span class="line"></span><br><span class="line">function normalizeHeaderName(headers: any, normalizedName: string): void &#123;</span><br><span class="line">  if (!headers) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  Object.keys(headers).forEach(name =&gt; &#123;</span><br><span class="line">    if (name !== normalizedName &amp;&amp; name.toUpperCase() === normalizedName.toUpperCase()) &#123;</span><br><span class="line">      headers[normalizedName] = headers[name]</span><br><span class="line">      delete headers[name]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function processHeaders(headers: any, data: any): any &#123;</span><br><span class="line">  normalizeHeaderName(headers, &apos;Content-Type&apos;)</span><br><span class="line">  if (isPlainObject(data)) &#123;</span><br><span class="line">    if (headers &amp;&amp; !headers[&apos;Content-Type&apos;]) &#123;</span><br><span class="line">      headers[&apos;Content-Type&apos;] = &apos;application/json;charset=utf-8&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return headers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>url.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123; isDate, isPlainObject &#125; from &apos;./util&apos;</span><br><span class="line"></span><br><span class="line">function encode(val: string): string &#123;</span><br><span class="line">  return encodeURIComponent(val)</span><br><span class="line">    .replace(/%40/g, &apos;@&apos;)</span><br><span class="line">    .replace(/%3A/ig, &apos;:&apos;)</span><br><span class="line">    .replace(/%24/g, &apos;**util.ts**</span><br><span class="line"></span><br><span class="line">​```tsx</span><br><span class="line">const toString = Object.prototype.toString</span><br><span class="line"></span><br><span class="line">export function isDate(val: any): val is Date &#123;</span><br><span class="line">  return toString.call(val) === &apos;[object Date]&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function isPlainObject(val: any): val is Object &#123;</span><br><span class="line">  return toString.call(val) === &apos;[object Object]&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理响应数据"><a href="#处理响应数据" class="headerlink" title="处理响应数据"></a>处理响应数据</h3><p>定义响应接口</p><p><strong>types/index</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AxiosResponse &#123;</span><br><span class="line">  data: <span class="built_in">any</span></span><br><span class="line">  status: <span class="built_in">number</span></span><br><span class="line">  statusText: <span class="built_in">string</span></span><br><span class="line">  headers: <span class="built_in">any</span></span><br><span class="line">  config: AxiosRequestConfig</span><br><span class="line">  request: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AxiosPromise <span class="keyword">extends</span> Promise&lt;AxiosResponse&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理 headers 的数据</p><p><strong>helpers/header.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">export function processHeaders(headers: any, data: any): any &#123;</span><br><span class="line">  normalizeHeaderName(headers, &apos;Content-Type&apos;)</span><br><span class="line">  if (isPlainObject(data)) &#123;</span><br><span class="line">    if (headers &amp;&amp; !headers[&apos;Content-Type&apos;]) &#123;</span><br><span class="line">      headers[&apos;Content-Type&apos;] = &apos;application/json;charset=utf-8&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return headers</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function parseHeaders(headers: string): any &#123;</span><br><span class="line">  let parsed = Object.create(null)</span><br><span class="line">  if (!headers) &#123;</span><br><span class="line">    return headers</span><br><span class="line">  &#125;</span><br><span class="line">  headers.split(&apos;\r\n&apos;).forEach(line =&gt; &#123;</span><br><span class="line">    let [key, val] = line.split(&apos;:&apos;)</span><br><span class="line">    key = key.trim().toLowerCase()</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    if (val) &#123;</span><br><span class="line">      val = val.trim();</span><br><span class="line">    &#125;</span><br><span class="line">    parsed[key] = val</span><br><span class="line">  &#125;)</span><br><span class="line">  return parsed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理 响应data</p><p><strong>helpers/data.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export function transformResponse(data: any): any &#123;</span><br><span class="line">  if (typeof data === &apos;string&apos;) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      data = JSON.parse(data)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      // do nothing</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 xhr, 返回一个 Promise</p><p><strong>xhr.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import &#123; AxiosRequestConfig, AxiosPromise, AxiosResponse &#125; from &apos;./types&apos;</span><br><span class="line">import &#123; parseHeaders &#125; from &apos;./helpers/headers&apos;</span><br><span class="line"></span><br><span class="line">export default function xhr(config: AxiosRequestConfig): AxiosPromise &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    const &#123; data = null, url, method = &apos;get&apos;, headers, responseType &#125; = config</span><br><span class="line">    const request = new XMLHttpRequest()</span><br><span class="line">    if (responseType) &#123;</span><br><span class="line">      request.responseType = responseType</span><br><span class="line">    &#125;</span><br><span class="line">    // method,url,async</span><br><span class="line">    request.open(method.toUpperCase(), url, true)</span><br><span class="line"></span><br><span class="line">    request.onreadystatechange = function handleLoad() &#123;</span><br><span class="line">      if (request.readyState !== 4) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const responseHeaders = parseHeaders(request.getAllResponseHeaders())</span><br><span class="line">      const responseData = responseType &amp;&amp; responseType !== &apos;text&apos; ? request.response : request.responseText</span><br><span class="line">      const response: AxiosResponse = &#123;</span><br><span class="line">        data: responseData,</span><br><span class="line">        status: request.status,</span><br><span class="line">        statusText: request.statusText,</span><br><span class="line">        headers: responseHeaders,</span><br><span class="line">        config,</span><br><span class="line">        request</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(response)</span><br><span class="line">    &#125;</span><br><span class="line">    Object.keys(headers).forEach(name =&gt; &#123;</span><br><span class="line">      if (data === null &amp;&amp; name.toLowerCase() === &apos;content-type&apos;) &#123;</span><br><span class="line">        delete headers[name]</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        request.setRequestHeader(name, headers[name])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    request.send(data)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/LbhFront-end/ts-axios">具体代码地址</a></p><p>)</p><pre><code>.replace(/%2C/ig, &apos;,&apos;).replace(/%20/g, &apos;+&apos;).replace(/%5B/ig, &apos;[&apos;).replace(/%5D/ig, &apos;]&apos;)</code></pre><p>}</p><p>export function buildURL(url: string, params?: any): string {<br>  if (!params) {</p><pre><code>return url</code></pre><p>  }<br>  const parts: string[] = []<br>  Object.keys(params).forEach(key =&gt; {</p><pre><code>const val = params[key]if (val === null || typeof val === &apos;undefined&apos;) {  return}let values = []if (Array.isArray(val)) {  values = val  key += &apos;[]&apos;} else {  values = [val]}values.forEach(val =&gt; {  if (isDate(val)) {    val = val.toISOString()  } else if (isPlainObject(val)) {    val = JSON.stringify(val)  }  parts.push( `${encode(key)}=${encode(val)}` )})</code></pre><p>  })<br>  let serializedParams = parts.join(‘&amp;’)<br>  if (serializedParams) {</p><pre><code>const markIndex = url.indexOf(&apos;#&apos;)if (markIndex !== -1) {  url = url.slice(0, markIndex)}url += (url.indexOf(&apos;?&apos;) === -1 ? &apos;?&apos; : &apos;&amp;&apos;) + serializedParams</code></pre><p>  }<br>  return url<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**util.ts**</span><br><span class="line"></span><br><span class="line">​```tsx</span><br><span class="line">const toString = Object.prototype.toString</span><br><span class="line"></span><br><span class="line">export function isDate(val: any): val is Date &#123;</span><br><span class="line">  return toString.call(val) === &apos;[object Date]&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function isPlainObject(val: any): val is Object &#123;</span><br><span class="line">  return toString.call(val) === &apos;[object Object]&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理响应数据-1"><a href="#处理响应数据-1" class="headerlink" title="处理响应数据"></a>处理响应数据</h3><p>定义响应接口</p><p><strong>types/index</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AxiosResponse &#123;</span><br><span class="line">  data: <span class="built_in">any</span></span><br><span class="line">  status: <span class="built_in">number</span></span><br><span class="line">  statusText: <span class="built_in">string</span></span><br><span class="line">  headers: <span class="built_in">any</span></span><br><span class="line">  config: AxiosRequestConfig</span><br><span class="line">  request: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AxiosPromise <span class="keyword">extends</span> Promise&lt;AxiosResponse&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理 headers 的数据</p><p><strong>helpers/header.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">export function processHeaders(headers: any, data: any): any &#123;</span><br><span class="line">  normalizeHeaderName(headers, &apos;Content-Type&apos;)</span><br><span class="line">  if (isPlainObject(data)) &#123;</span><br><span class="line">    if (headers &amp;&amp; !headers[&apos;Content-Type&apos;]) &#123;</span><br><span class="line">      headers[&apos;Content-Type&apos;] = &apos;application/json;charset=utf-8&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return headers</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function parseHeaders(headers: string): any &#123;</span><br><span class="line">  let parsed = Object.create(null)</span><br><span class="line">  if (!headers) &#123;</span><br><span class="line">    return headers</span><br><span class="line">  &#125;</span><br><span class="line">  headers.split(&apos;\r\n&apos;).forEach(line =&gt; &#123;</span><br><span class="line">    let [key, val] = line.split(&apos;:&apos;)</span><br><span class="line">    key = key.trim().toLowerCase()</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    if (val) &#123;</span><br><span class="line">      val = val.trim();</span><br><span class="line">    &#125;</span><br><span class="line">    parsed[key] = val</span><br><span class="line">  &#125;)</span><br><span class="line">  return parsed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理 响应data</p><p><strong>helpers/data.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export function transformResponse(data: any): any &#123;</span><br><span class="line">  if (typeof data === &apos;string&apos;) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      data = JSON.parse(data)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      // do nothing</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 xhr, 返回一个 Promise</p><p><strong>xhr.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import &#123; AxiosRequestConfig, AxiosPromise, AxiosResponse &#125; from &apos;./types&apos;</span><br><span class="line">import &#123; parseHeaders &#125; from &apos;./helpers/headers&apos;</span><br><span class="line"></span><br><span class="line">export default function xhr(config: AxiosRequestConfig): AxiosPromise &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    const &#123; data = null, url, method = &apos;get&apos;, headers, responseType &#125; = config</span><br><span class="line">    const request = new XMLHttpRequest()</span><br><span class="line">    if (responseType) &#123;</span><br><span class="line">      request.responseType = responseType</span><br><span class="line">    &#125;</span><br><span class="line">    // method,url,async</span><br><span class="line">    request.open(method.toUpperCase(), url, true)</span><br><span class="line"></span><br><span class="line">    request.onreadystatechange = function handleLoad() &#123;</span><br><span class="line">      if (request.readyState !== 4) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const responseHeaders = parseHeaders(request.getAllResponseHeaders())</span><br><span class="line">      const responseData = responseType &amp;&amp; responseType !== &apos;text&apos; ? request.response : request.responseText</span><br><span class="line">      const response: AxiosResponse = &#123;</span><br><span class="line">        data: responseData,</span><br><span class="line">        status: request.status,</span><br><span class="line">        statusText: request.statusText,</span><br><span class="line">        headers: responseHeaders,</span><br><span class="line">        config,</span><br><span class="line">        request</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(response)</span><br><span class="line">    &#125;</span><br><span class="line">    Object.keys(headers).forEach(name =&gt; &#123;</span><br><span class="line">      if (data === null &amp;&amp; name.toLowerCase() === &apos;content-type&apos;) &#123;</span><br><span class="line">        delete headers[name]</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        request.setRequestHeader(name, headers[name])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    request.send(data)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/LbhFront-end/ts-axios">具体代码地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于ts重构axios&quot;&gt;&lt;a href=&quot;#基于ts重构axios&quot; class=&quot;headerlink&quot; title=&quot;基于ts重构axios&quot;&gt;&lt;/a&gt;基于ts重构axios&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;ustbhuangyi&lt;/strong&gt; 老师的 &lt;
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://laibh.top/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="http://laibh.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>前端必备的测试</title>
    <link href="http://laibh.top/2019-08-19-%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E7%9A%84%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://laibh.top/2019-08-19-前端必备的测试学习.html</id>
    <published>2019-08-19T00:33:54.000Z</published>
    <updated>2020-07-11T03:24:57.643Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端必备的测试"><a href="#前端必备的测试" class="headerlink" title="前端必备的测试"></a>前端必备的测试</h1><p>DellLee 老师的 <a href="https://coding.imooc.com/class/372.html">前端要学的测试课 从Jest入门到TDD/BDD双实战</a>学习记录。</p><p><strong>知识点</strong></p><p>Jest 基础</p><p><code>基础API</code>、<code>异步测试</code>、<code>Mock技巧</code>、<code>快照</code>、<code>timer测试</code>、<code>Dom测试</code></p><p>实现项目</p><p><code>Vue</code>、<code>Vue-test-utils</code>、<code>React</code>、<code>Enzyme</code>、<code>TDD+单元测试</code>、<code>BDD+集成测试</code></p><h2 id="初识测试"><a href="#初识测试" class="headerlink" title="初识测试"></a>初识测试</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minus</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  add,</span><br><span class="line">  minus</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// math.test.js</span></span><br><span class="line"><span class="comment">// 简陋测试</span></span><br><span class="line"><span class="keyword">import</span> &#123; add, minus &#125; <span class="keyword">from</span> <span class="string">'./math'</span></span><br><span class="line"><span class="keyword">let</span> result</span><br><span class="line"><span class="keyword">let</span> expected</span><br><span class="line">result = add(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line">expected = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result !== <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`3 + 7 应该等于 <span class="subst">$&#123;expected&#125;</span>,但结果却是 <span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = minus(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">expected = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result !== <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`3 - 3 应该等于 <span class="subst">$&#123;expected&#125;</span>,但结果却是 <span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 封装版</span></span><br><span class="line"><span class="keyword">import</span> &#123; add, minus &#125; <span class="keyword">from</span> <span class="string">'./math'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">expect</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    toBe: <span class="function"><span class="keyword">function</span> (<span class="params">actual</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (result !== actual) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`预期值与实际值不相等 预期<span class="subst">$&#123;actual&#125;</span> 结果却是 <span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">desc, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;desc&#125;</span>通过测试`</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;desc&#125;</span>没有通过测试 <span class="subst">$&#123;e&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">'测试加法3 + 7'</span>, () =&gt; &#123;</span><br><span class="line">  expect(add(<span class="number">3</span>, <span class="number">7</span>)).toBe(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br><span class="line">test(<span class="string">'测试减法6 - 3'</span>, () =&gt; &#123;</span><br><span class="line">  expect(minus(<span class="number">6</span>, <span class="number">3</span>)).toBe(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="自动化框架：Jest"><a href="#自动化框架：Jest" class="headerlink" title="自动化框架：Jest"></a>自动化框架：Jest</h2><p>优点：性能、功能、易用性、速度快、Api简单、易配置、隔离性好、监控模式、IDE整合、Snapshot、多项目并行、覆盖率、Mock丰富</p><h3 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 项目内部调用 jest</span></span><br><span class="line">npx jest --init </span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择 </span></span><br><span class="line">browser-like</span><br><span class="line"><span class="meta">#</span><span class="bash"> 随后选择自动生成报告，自动清除实例在每个<span class="built_in">test</span>之前，就会生成一下配置文件</span></span><br><span class="line">jest.config.js</span><br></pre></td></tr></table></figure><p><code>jest.config.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For a detailed explanation regarding each configuration property, visit:</span></span><br><span class="line"><span class="comment">// https://jestjs.io/docs/en/configuration.html</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// All imported modules in your tests should be mocked automatically</span></span><br><span class="line">  <span class="comment">// 自动模拟在测试用例中的所有导入模块，在 __mocks__ 文件夹中寻找</span></span><br><span class="line">  <span class="comment">// automock: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stop running tests after `n` failures</span></span><br><span class="line">  <span class="comment">// 默认情况下，Jest运行所有测试并在完成后将所有错误生成到控制台，bil 让 jest 在 n 失败后停止运行测试</span></span><br><span class="line">  <span class="comment">// bail: 0,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Respect "browser" field in package.json when resolving modules</span></span><br><span class="line">  <span class="comment">// false =&gt; browser | true =&gt; node</span></span><br><span class="line">  <span class="comment">// browser: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The directory where Jest should store its cached dependency information</span></span><br><span class="line">  <span class="comment">// 存放 jest 依赖信息缓存的目录</span></span><br><span class="line">  <span class="comment">// cacheDirectory: "C:\\Users\\Administrator\\AppData\\Local\\Temp\\jest",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Automatically clear mock calls and instances between every test</span></span><br><span class="line">  <span class="comment">// 自动清除模拟调用和实例在每次测试之间</span></span><br><span class="line">  clearMocks: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Indicates whether the coverage information should be collected while executing the test</span></span><br><span class="line">  <span class="comment">// 是否收集测试时的覆盖率信息，因为要带上覆盖率搜集语句访问所有执行过的文件，这可能会让测试执行速度明显减慢</span></span><br><span class="line">  <span class="comment">// collectCoverage: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of glob patterns indicating a set of files for which coverage information should be collected</span></span><br><span class="line">  <span class="comment">// 指示应收集覆盖率信息的全局模式一组文件，即使文件不存在测试，也将为其收集覆盖率信息，并且测试套件中不需要它</span></span><br><span class="line">  <span class="comment">// collectCoverageFrom: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The directory where Jest should output its coverage files</span></span><br><span class="line">  <span class="comment">// jest 输出测速覆盖率文件的目录</span></span><br><span class="line">  <span class="comment">// 运行 npx jest --coverage</span></span><br><span class="line">  coverageDirectory: <span class="string">"coverage"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of regexp pattern strings used to skip coverage collection</span></span><br><span class="line">  <span class="comment">// 忽略测试的文件路径的正则匹配</span></span><br><span class="line">  <span class="comment">// coveragePathIgnorePatterns: [</span></span><br><span class="line">  <span class="comment">//   "\\\\node_modules\\\\"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A list of reporter names that Jest uses when writing coverage reports</span></span><br><span class="line">  <span class="comment">// coverageReporters: [</span></span><br><span class="line">  <span class="comment">//   "json",</span></span><br><span class="line">  <span class="comment">//   "text",</span></span><br><span class="line">  <span class="comment">//   "lcov",</span></span><br><span class="line">  <span class="comment">//   "clover"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An object that configures minimum threshold enforcement for coverage results</span></span><br><span class="line">  <span class="comment">// coverageThreshold: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A path to a custom dependency extractor</span></span><br><span class="line">  <span class="comment">// dependencyExtractor: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make calling deprecated APIs throw helpful error messages</span></span><br><span class="line">  <span class="comment">// errorOnDeprecated: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Force coverage collection from ignored files using an array of glob patterns</span></span><br><span class="line">  <span class="comment">// forceCoverageMatch: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A path to a module which exports an async function that is triggered once before all test suites</span></span><br><span class="line">  <span class="comment">// globalSetup: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A path to a module which exports an async function that is triggered once after all test suites</span></span><br><span class="line">  <span class="comment">// globalTeardown: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A set of global variables that need to be available in all test environments</span></span><br><span class="line">  <span class="comment">// globals: &#123;&#125;,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The maximum amount of workers used to run your tests. Can be specified as % or a number. E.g. maxWorkers: 10% will use 10% of your CPU amount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2 workers.</span></span><br><span class="line">  <span class="comment">// maxWorkers: "50%",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of directory names to be searched recursively up from the requiring module's location</span></span><br><span class="line">  <span class="comment">// moduleDirectories: [</span></span><br><span class="line">  <span class="comment">//   "node_modules"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of file extensions your modules use</span></span><br><span class="line">  <span class="comment">// 模块使用文件扩展名数组，当你导入的文件没有扩展名的时候，它会在这个数组里面去自动匹配</span></span><br><span class="line">  <span class="comment">// moduleFileExtensions: [</span></span><br><span class="line">  <span class="comment">//   "js",</span></span><br><span class="line">  <span class="comment">//   "json",</span></span><br><span class="line">  <span class="comment">//   "jsx",</span></span><br><span class="line">  <span class="comment">//   "ts",</span></span><br><span class="line">  <span class="comment">//   "tsx",</span></span><br><span class="line">  <span class="comment">//   "node"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A map from regular expressions to module names that allow to stub out resources with a single module</span></span><br><span class="line">  <span class="comment">// 模块名映射，类 webpack alias 以及 jsconfig.js 的 compilerOptions.paths</span></span><br><span class="line">  <span class="comment">// moduleNameMapper: &#123;&#125;,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of regexp pattern strings, matched against all module paths before considered 'visible' to the module loader</span></span><br><span class="line">  <span class="comment">// modulePathIgnorePatterns: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Activates notifications for test results</span></span><br><span class="line">  <span class="comment">// notify: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An enum that specifies notification mode. Requires &#123; notify: true &#125;</span></span><br><span class="line">  <span class="comment">// notifyMode: "failure-change",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A preset that is used as a base for Jest's configuration</span></span><br><span class="line">  <span class="comment">// preset: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run tests from one or more projects</span></span><br><span class="line">  <span class="comment">// projects: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use this configuration option to add custom reporters to Jest</span></span><br><span class="line">  <span class="comment">// reporters: undefined,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Automatically reset mock state between every test</span></span><br><span class="line">  <span class="comment">// resetMocks: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reset the module registry before running each individual test</span></span><br><span class="line">  <span class="comment">// resetModules: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A path to a custom resolver</span></span><br><span class="line">  <span class="comment">// resolver: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Automatically restore mock state between every test</span></span><br><span class="line">  <span class="comment">// restoreMocks: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The root directory that Jest should scan for tests and modules within</span></span><br><span class="line">  <span class="comment">// rootDir: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A list of paths to directories that Jest should use to search for files in</span></span><br><span class="line">  <span class="comment">// roots: [</span></span><br><span class="line">  <span class="comment">//   "&lt;rootDir&gt;"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allows you to use a custom runner instead of Jest's default test runner</span></span><br><span class="line">  <span class="comment">// runner: "jest-runner",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The paths to modules that run some code to configure or set up the testing environment before each test</span></span><br><span class="line">  <span class="comment">// setupFiles: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A list of paths to modules that run some code to configure or set up the testing framework before each test</span></span><br><span class="line">  <span class="comment">// 运行做测试的时候使用某些垫片为运行环境做兼容</span></span><br><span class="line">  <span class="comment">// setupFilesAfterEnv: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A list of paths to snapshot serializer modules Jest should use for snapshot testing</span></span><br><span class="line">  <span class="comment">// 快照格式化</span></span><br><span class="line">  <span class="comment">// snapshotSerializers: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The test environment that will be used for testing</span></span><br><span class="line">  <span class="comment">// testEnvironment: "jest-environment-jsdom",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Options that will be passed to the testEnvironment</span></span><br><span class="line">  <span class="comment">// testEnvironmentOptions: &#123;&#125;,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Adds a location field to test results</span></span><br><span class="line">  <span class="comment">// testLocationInResults: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The glob patterns Jest uses to detect test files</span></span><br><span class="line">  <span class="comment">// 匹配测试文件</span></span><br><span class="line">  <span class="comment">// testMatch: [</span></span><br><span class="line">  <span class="comment">//   "**/__tests__/**/*.[jt]s?(x)",</span></span><br><span class="line">  <span class="comment">//   "**/?(*.)+(spec|test).[tj]s?(x)"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of regexp pattern strings that are matched against all test paths, matched tests are skipped</span></span><br><span class="line">  <span class="comment">// testPathIgnorePatterns: [</span></span><br><span class="line">  <span class="comment">//   "\\\\node_modules\\\\"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The regexp pattern or array of patterns that Jest uses to detect test files</span></span><br><span class="line">  <span class="comment">// testRegex: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// This option allows the use of a custom results processor</span></span><br><span class="line">  <span class="comment">// testResultsProcessor: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// This option allows use of a custom test runner</span></span><br><span class="line">  <span class="comment">// testRunner: "jasmine2",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// This option sets the URL for the jsdom environment. It is reflected in properties such as location.href</span></span><br><span class="line">  <span class="comment">// 模拟浏览器的地址</span></span><br><span class="line">  <span class="comment">// testURL: "http://localhost",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setting this value to "fake" allows the use of fake timers for functions such as "setTimeout"</span></span><br><span class="line">  <span class="comment">// timers: "real",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A map from regular expressions to paths to transformers</span></span><br><span class="line">  <span class="comment">// 不同文件类型对应不同的转换器</span></span><br><span class="line">  <span class="comment">// transform: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation</span></span><br><span class="line">  <span class="comment">// transformIgnorePatterns: [</span></span><br><span class="line">  <span class="comment">//   "\\\\node_modules\\\\"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them</span></span><br><span class="line">  <span class="comment">// unmockedModulePathPatterns: undefined,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Indicates whether each individual test should be reported during the run</span></span><br><span class="line">  <span class="comment">// verbose: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode</span></span><br><span class="line">  <span class="comment">// watchPathIgnorePatterns: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Whether to use watchman for file crawling</span></span><br><span class="line">  <span class="comment">// watchman: true,</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="babelrc"><a href="#babelrc" class="headerlink" title="babelrc"></a>babelrc</h3><p>jest 未配置转换时，默认只支持 commonjs 语法。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"targets"</span>: &#123;</span><br><span class="line">          <span class="attr">"node"</span>: <span class="string">"current"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jest转换（commonjs -&gt; es module）大概工作原理：</p><ol><li>npm run jest</li><li>jest（babel-jest）jest 内部的</li><li>检测是有 babel-core</li><li>拿到 .babelrc 配置</li><li>再运行测试之前，结合 babel  把代码做一次转化</li><li>运行转化过的测试用例</li></ol><h2 id="常用匹配器（Matchers）"><a href="#常用匹配器（Matchers）" class="headerlink" title="常用匹配器（Matchers）"></a>常用匹配器（Matchers）</h2><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><h4 id="toBe"><a href="#toBe" class="headerlink" title=".toBe()"></a>.toBe()</h4><h4 id="toEqual-value"><a href="#toEqual-value" class="headerlink" title=".toEqual(value)"></a>.toEqual(value)</h4><h4 id="toBeGreaterThan-number"><a href="#toBeGreaterThan-number" class="headerlink" title=".toBeGreaterThan(number)"></a>.toBeGreaterThan(number)</h4><h4 id="toBeGreaterThanOrEqual-number"><a href="#toBeGreaterThanOrEqual-number" class="headerlink" title=".toBeGreaterThanOrEqual(number)"></a>.toBeGreaterThanOrEqual(number)</h4><h4 id="toBeLessThan-number"><a href="#toBeLessThan-number" class="headerlink" title=".toBeLessThan(number)"></a>.toBeLessThan(number)</h4><h4 id="toBeLessThanOrEqual-number"><a href="#toBeLessThanOrEqual-number" class="headerlink" title=".toBeLessThanOrEqual(number)"></a>.toBeLessThanOrEqual(number)</h4><h4 id="toBeCloseTo-number-numDigits"><a href="#toBeCloseTo-number-numDigits" class="headerlink" title=".toBeCloseTo(number,numDigits?)"></a>.toBeCloseTo(number,numDigits?)</h4><p>第二个参数为精度，代表几位小数点，默认为2位</p><h4 id="toBeNaN"><a href="#toBeNaN" class="headerlink" title=".toBeNaN()"></a>.toBeNaN()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字相关</span></span><br><span class="line">test(<span class="string">'匹配器：toBe-数字相等'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBe 匹配器 matchers Object.is() ===</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">10</span></span><br><span class="line">  expect(a).toBe(<span class="number">10</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toEqual-内容相等'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toEqual 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = &#123; <span class="attr">one</span>: <span class="number">1</span> &#125;</span><br><span class="line">  expect(a).toEqual(&#123; <span class="attr">one</span>: <span class="number">1</span> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeGreaterThan-大于比较数'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeGreaterThan 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">4</span></span><br><span class="line">  expect(a).toBeGreaterThan(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeGreaterThanOrEqual-大于等于比较数'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeGreaterThanOrEqual 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">4</span></span><br><span class="line">  expect(a).toBeGreaterThanOrEqual(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeLessThan-小于比较数'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeLessThan 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">4</span></span><br><span class="line">  expect(a).toBeLessThan(<span class="number">5</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeLessThanOrEqual-小于等于比较数'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeLessThanOrEqual 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">4</span></span><br><span class="line">  expect(a).toBeLessThanOrEqual(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数</span></span><br><span class="line">test(<span class="string">'匹配器：toBeCloseTo-两个浮点数字相加'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeCloseTo 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> value = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line">  <span class="comment">// expect(value).toBe(0.3);   这句会报错，因为浮点数有舍入误差</span></span><br><span class="line">  expect(value).toBeCloseTo(<span class="number">0.3</span>); <span class="comment">// 这句可以运行</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line">test(<span class="string">'匹配器：toBeNaN-等于NaN'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="literal">NaN</span>).toBeNaN();</span><br><span class="line">  expect(<span class="number">1</span>).not.toBeNaN();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="真假"><a href="#真假" class="headerlink" title="真假"></a>真假</h3><ul><li><code>toBeNull</code>只匹配 <code>null</code></li><li><code>toBeUndefined</code>只匹配 <code>undefined</code></li><li><code>toBeDefined</code> 与 <code>toBeUndefined</code>相反</li><li><code>toBeTruthy</code> 匹配任何 <code>if</code> 语句为真</li><li><code>toBeFalsy</code>匹配任何 <code>if</code> 语句为假</li></ul><h4 id="toBeNull"><a href="#toBeNull" class="headerlink" title=".toBeNull()"></a>.toBeNull()</h4><h4 id="toBeUndefined"><a href="#toBeUndefined" class="headerlink" title=".toBeUndefined()"></a>.toBeUndefined()</h4><h4 id="toBeDefined"><a href="#toBeDefined" class="headerlink" title=".toBeDefined()"></a>.toBeDefined()</h4><h4 id="toBeTruthy"><a href="#toBeTruthy" class="headerlink" title=".toBeTruthy()"></a>.toBeTruthy()</h4><h4 id="toBeFalsy"><a href="#toBeFalsy" class="headerlink" title=".toBeFalsy()"></a>.toBeFalsy()</h4><p>在JavaScript中，有六个falsy值：<code>false</code>，<code>0</code>，<code>&#39;&#39;</code>，<code>null</code>，<code>undefined</code>，和<code>NaN</code>。其他一切都是真实的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真假相关</span></span><br><span class="line">test(<span class="string">'匹配器：toBeNull-与null相等'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeNull 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="literal">null</span></span><br><span class="line">  expect(a).toBeNull()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeUndefined-与undefined相等'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeUndefined 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="literal">undefined</span></span><br><span class="line">  expect(a).toBeUndefined()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeDefined-被定义过的,非 undefined 的，可为 null'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeDefined 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="literal">null</span></span><br><span class="line">  expect(a).toBeDefined()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeTruthy-真值或者隐藏为true的'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeTruthy 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">  expect(a).toBeTruthy()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeFalsy-真值或者隐藏为false的'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeFalsy 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="literal">null</span></span><br><span class="line">  expect(a).toBeFalsy()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="否定"><a href="#否定" class="headerlink" title="否定"></a>否定</h3><h4 id="not"><a href="#not" class="headerlink" title=".not"></a>.not</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'匹配器：not-不是xx'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// not 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">  expect(a).not.toBeFalsy()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-not-arrayContaining-array"><a href="#expect-not-arrayContaining-array" class="headerlink" title="expect.not.arrayContaining(array)"></a>expect.not.arrayContaining(array)</h4><p>匹配不是接收值的子集</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'not.arrayContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = [<span class="number">1</span>];</span><br><span class="line">  it(<span class="string">'如果接收的数组不包含1就通过测试'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).toEqual(</span><br><span class="line">      expect.not.arrayContaining(expected)</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-not-objectContaining-object"><a href="#expect-not-objectContaining-object" class="headerlink" title="expect.not.objectContaining(object)"></a>expect.not.objectContaining(object)</h4><p>匹配不包含某个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'not.objectContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = &#123; <span class="attr">haha</span>: <span class="string">'laibh.top'</span> &#125;;</span><br><span class="line">  it(<span class="string">'如果接收的对象不包含&#123; haha: laibh.top &#125;就通过测试'</span>, () =&gt; &#123;</span><br><span class="line">    expect(&#123; <span class="attr">haha</span>: <span class="string">'laibh.top1'</span> &#125;).toEqual(</span><br><span class="line">      expect.not.objectContaining(expected)</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-not-stringContaining-string"><a href="#expect-not-stringContaining-string" class="headerlink" title="expect.not.stringContaining(string)"></a>expect.not.stringContaining(string)</h4><p>匹配不包含某个字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'not.stringContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = <span class="string">'赖同学'</span>;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'如果接收的字符串不完全等于赖同学就通过测试'</span>, () =&gt; &#123;</span><br><span class="line">    expect(<span class="string">'赖'</span>).toEqual(expect.not.stringContaining(expected));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="expect-not-stringMatching-string-regexp"><a href="#expect-not-stringMatching-string-regexp" class="headerlink" title="expect.not.stringMatching(string|regexp)"></a>expect.not.stringMatching(string|regexp)</h4><p>同上，不过参数可以是正则表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'not.stringMatching'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = <span class="regexp">/赖同学/</span>;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'如果接收的字符串赖同学就通过测试'</span>, () =&gt; &#123;</span><br><span class="line">    expect(<span class="string">'赖'</span>).toEqual(expect.not.stringMatching(expected));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="toMatch-regexpOrString"><a href="#toMatch-regexpOrString" class="headerlink" title=".toMatch(regexpOrString)"></a>.toMatch(<code>regexpOrString</code>)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">test(<span class="string">'匹配器：toMatch-正则字符串匹配'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toMatch 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> str = <span class="string">'http://laibh.top'</span></span><br><span class="line">  expect(str).toMatch(<span class="string">'laibh'</span>)</span><br><span class="line">  <span class="comment">// 使用正则</span></span><br><span class="line">  expect(str).toMatch(<span class="regexp">/laibh/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-stringContaining-string"><a href="#expect-stringContaining-string" class="headerlink" title="expect.stringContaining(string)"></a>expect.stringContaining(string)</h4><p>匹配包含某个字符串</p><h4 id="expect-stringMatching-string-regexp"><a href="#expect-stringMatching-string-regexp" class="headerlink" title="expect.stringMatching(string|regexp)"></a>expect.stringMatching(string|regexp)</h4><p>匹配字符串，可用正则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'stringMatching in arrayContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = [</span><br><span class="line">    expect.stringMatching(<span class="regexp">/^Alic/</span>),</span><br><span class="line">    expect.stringMatching(<span class="regexp">/^[BR]ob/</span>),</span><br><span class="line">  ];</span><br><span class="line">  it(<span class="string">'matches even if received contains additional elements'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'Alicia'</span>, <span class="string">'Roberto'</span>, <span class="string">'Evelina'</span>]).toEqual(</span><br><span class="line">      expect.arrayContaining(expected),</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'does not match if received does not contain expected elements'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'Roberto'</span>, <span class="string">'Evelina'</span>]).not.toEqual(</span><br><span class="line">      expect.arrayContaining(expected),</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="expect-toContain"><a href="#expect-toContain" class="headerlink" title="expect.toContain()"></a>expect.toContain()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line">test(<span class="string">'匹配器：toContain-数组包含某项'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toContain 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> arr = [<span class="string">'lai'</span>, <span class="string">'bin'</span>, <span class="string">'hong'</span>]</span><br><span class="line">  <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(arr)</span><br><span class="line">  expect(set).toContain(<span class="string">'lai'</span>)</span><br><span class="line">  expect(arr).toContain(<span class="string">'lai'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-arrayContaining-array"><a href="#expect-arrayContaining-array" class="headerlink" title="expect.arrayContaining(array)"></a>expect.arrayContaining(array)</h4><p>匹配子集</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'arrayContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = [<span class="string">'1'</span>, <span class="string">'2'</span>];</span><br><span class="line">  it(<span class="string">'即使接收值包含其他参数也匹配'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]).toEqual(expect.arrayContaining(expected));</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'只要接收值不包含期望的值就不匹配'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'2'</span>, <span class="string">'4'</span>]).not.toEqual(expect.arrayContaining(expected));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="objectContaining-object"><a href="#objectContaining-object" class="headerlink" title="objectContaining(object)"></a>objectContaining(object)</h4><p>匹配任何递归预期属性的接收对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'测试onPress函数回调参数匹配对象'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> onPress = jest.fn();</span><br><span class="line">  simulatePresses(onPress)</span><br><span class="line">  expect(onPress).toBeCalledWith(</span><br><span class="line">    expect.objectContaining(&#123;</span><br><span class="line">      x: expect.any(<span class="built_in">Number</span>),</span><br><span class="line">      y: expect.any(<span class="built_in">Number</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="toHaveProperty-keyPath-value"><a href="#toHaveProperty-keyPath-value" class="headerlink" title=".toHaveProperty(keyPath,value?)"></a>.toHaveProperty(keyPath,value?)</h4><p>检查对象中各种属性存在和值，第二个参数是可选的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object containing house features to be tested</span></span><br><span class="line"><span class="keyword">const</span> houseForSale = &#123;</span><br><span class="line">  bath: <span class="literal">true</span>,</span><br><span class="line">  bedrooms: <span class="number">4</span>,</span><br><span class="line">  kitchen: &#123;</span><br><span class="line">    amenities: [<span class="string">'oven'</span>, <span class="string">'stove'</span>, <span class="string">'washer'</span>],</span><br><span class="line">    area: <span class="number">20</span>,</span><br><span class="line">    wallColor: <span class="string">'white'</span>,</span><br><span class="line">    <span class="string">'nice.oven'</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'ceiling.height'</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'this house has my desired features'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// Simple Referencing</span></span><br><span class="line">  expect(houseForSale).toHaveProperty(<span class="string">'bath'</span>);</span><br><span class="line">  expect(houseForSale).toHaveProperty(<span class="string">'bedrooms'</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  expect(houseForSale).not.toHaveProperty(<span class="string">'pool'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 嵌套深层用 .</span></span><br><span class="line">  expect(houseForSale).toHaveProperty(<span class="string">'kitchen.area'</span>, <span class="number">20</span>);</span><br><span class="line">  expect(houseForSale).toHaveProperty(<span class="string">'kitchen.amenities'</span>, [</span><br><span class="line">    <span class="string">'oven'</span>,</span><br><span class="line">    <span class="string">'stove'</span>,</span><br><span class="line">    <span class="string">'washer'</span>,</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  expect(houseForSale).not.toHaveProperty(<span class="string">'kitchen.open'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 嵌套深层用 []</span></span><br><span class="line">  expect(houseForSale).toHaveProperty([<span class="string">'kitchen'</span>, <span class="string">'area'</span>], <span class="number">20</span>);</span><br><span class="line">  expect(houseForSale).toHaveProperty(</span><br><span class="line">    [<span class="string">'kitchen'</span>, <span class="string">'amenities'</span>],</span><br><span class="line">    [<span class="string">'oven'</span>, <span class="string">'stove'</span>, <span class="string">'washer'</span>],</span><br><span class="line">  );</span><br><span class="line">  expect(houseForSale).toHaveProperty([<span class="string">'kitchen'</span>, <span class="string">'amenities'</span>, <span class="number">0</span>], <span class="string">'oven'</span>);</span><br><span class="line">  expect(houseForSale).toHaveProperty([<span class="string">'kitchen'</span>, <span class="string">'nice.oven'</span>]);</span><br><span class="line">  expect(houseForSale).not.toHaveProperty([<span class="string">'kitchen'</span>, <span class="string">'open'</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Referencing keys with dot in the key itself</span></span><br><span class="line">  expect(houseForSale).toHaveProperty([<span class="string">'ceiling.height'</span>], <span class="string">'tall'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toMatchObject-object"><a href="#toMatchObject-object" class="headerlink" title=".toMatchObject(object)"></a>.toMatchObject(object)</h4><p>检查对象的属性的子集相匹配</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> houseForSale = &#123;</span><br><span class="line">  bath: <span class="literal">true</span>,</span><br><span class="line">  bedrooms: <span class="number">4</span>,</span><br><span class="line">  kitchen: &#123;</span><br><span class="line">    amenities: [<span class="string">'oven'</span>, <span class="string">'stove'</span>, <span class="string">'washer'</span>],</span><br><span class="line">    area: <span class="number">20</span>,</span><br><span class="line">    wallColor: <span class="string">'white'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> desiredHouse = &#123;</span><br><span class="line">  bath: <span class="literal">true</span>,</span><br><span class="line">  kitchen: &#123;</span><br><span class="line">    amenities: [<span class="string">'oven'</span>, <span class="string">'stove'</span>, <span class="string">'washer'</span>],</span><br><span class="line">    wallColor: expect.stringMatching(<span class="regexp">/white|yellow/</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'the house has my desired features'</span>, () =&gt; &#123;</span><br><span class="line">  expect(houseForSale).toMatchObject(desiredHouse);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="toBeInstanceOf-Class"><a href="#toBeInstanceOf-Class" class="headerlink" title=".toBeInstanceOf(Class)"></a>.toBeInstanceOf(Class)</h4><p>检查对象是一个类的实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">expect(<span class="keyword">new</span> A()).toBeInstanceOf(A);</span><br><span class="line">expect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;).toBeInstanceOf(<span class="built_in">Function</span>);</span><br><span class="line">expect(<span class="keyword">new</span> A()).toBeInstanceOf(<span class="built_in">Function</span>); <span class="comment">// throws</span></span><br></pre></td></tr></table></figure><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="toThrow-error"><a href="#toThrow-error" class="headerlink" title=".toThrow(error?)"></a>.toThrow(error?)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> throwNewErrorFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'this is a new error'</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常</span></span><br><span class="line">test(<span class="string">'匹配器：toThrow-测试抛出异常'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toThrow 匹配器 matchers</span></span><br><span class="line">  expect(throwNewErrorFunc).toThrow()</span><br><span class="line">  <span class="comment">// 测试抛出的内容</span></span><br><span class="line">  expect(throwNewErrorFunc).toThrow(<span class="string">'this is a new error'</span>)</span><br><span class="line">  <span class="comment">// 表达式也行</span></span><br><span class="line">  expect(throwNewErrorFunc).toThrow(<span class="regexp">/this is a new error/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="任意"><a href="#任意" class="headerlink" title="任意"></a>任意</h3><h4 id="expect-anything"><a href="#expect-anything" class="headerlink" title="expect.anything()"></a>expect.anything()</h4><p>匹配除了 <code>null</code>、<code>undefined</code>的任意值，可以它使用在 <code>toEqual</code>或者 <code>toBeCalledWith</code>里面替代文字值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'map 遍历一个非空的参数'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> mock = jest.fn();</span><br><span class="line">    [<span class="number">1</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> mock(x))</span><br><span class="line">    expect(mock).toBeCalledWith(expect.anything())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-any-constructor"><a href="#expect-any-constructor" class="headerlink" title="expect.any(constructor)"></a>expect.any(constructor)</h4><p>匹配任意构造器生成的实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randocall</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">6</span> + <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">'测试 randocall的回调函数调用了一个数字'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> mock = jest.fn();</span><br><span class="line">    randocall(mock)</span><br><span class="line">    expect(mock).toBeCalledWith(expect.any(<span class="built_in">Number</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="toHaveLength-number"><a href="#toHaveLength-number" class="headerlink" title=".toHaveLength(number)"></a>.toHaveLength(number)</h4><p>检查对象有个 length 属性并将设为某一数值。这对于检查数组或字符串大小特别有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).toHaveLength(<span class="number">3</span>);</span><br><span class="line">expect(<span class="string">'abc'</span>).toHaveLength(<span class="number">3</span>);</span><br><span class="line">expect(<span class="string">''</span>).not.toHaveLength(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h4 id="toContain-item"><a href="#toContain-item" class="headerlink" title=".toContain(item)"></a>.toContain(item)</h4><p>检查项目在数组或者字符串是否是另一个字符串的子串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'the flavor list contains lime'</span>, () =&gt; &#123;</span><br><span class="line">  expect(getAllFlavors()).toContain(<span class="string">'lime'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toContainEqual-item"><a href="#toContainEqual-item" class="headerlink" title=".toContainEqual(item)"></a>.toContainEqual(item)</h4><p>检查具有特定结构和值的元素是否包含在数据中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'test contain'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> testValue = &#123; <span class="attr">bol</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  expect([&#123; <span class="attr">bol</span>: <span class="literal">true</span> &#125;, &#123; <span class="attr">sour</span>: <span class="literal">false</span> &#125;]).toContainEqual(testValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="异步相关"><a href="#异步相关" class="headerlink" title="异步相关"></a>异步相关</h3><h4 id="expect-assertions"><a href="#expect-assertions" class="headerlink" title="expect.assertions()"></a>expect.assertions()</h4><p>匹配在测试用例里面使用断言的次数。确保在异步函数为了确保在回调函数里面断言被调用特别有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'异步调用所有回调'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="comment">// 确保有两个断言被调用</span></span><br><span class="line">    expect.assertions(<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback1</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        expect(data).toBeTruthy()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback2</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        expect(data).toBeTruthy();</span><br><span class="line">    &#125;</span><br><span class="line">    doAsync(callback1,callback2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-hasAssertions"><a href="#expect-hasAssertions" class="headerlink" title="expect.hasAssertions()"></a>expect.hasAssertions()</h4><p>匹配在测试用例里面至少使用一次断言</p><h4 id="resolves"><a href="#resolves" class="headerlink" title=".resolves"></a>.resolves</h4><p>使用 <code>resolves</code>解开 fulfilled promise，如果 reject promise，则断言失败</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'resolves to lemon'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// make sure to add a return statement</span></span><br><span class="line">  <span class="keyword">return</span> expect(<span class="built_in">Promise</span>.resolve(<span class="string">'lemon'</span>)).resolves.toBe(<span class="string">'lemon'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>测试是异步的，需要告诉 jest 等待返回解开的断言</p><p>也可以用 <code>async/await</code>结合 <code>.resolves</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'resolves to lemon'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="built_in">Promise</span>.resolve(<span class="string">'lemon'</span>)).resolves.toBe(<span class="string">'lemon'</span>);</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="built_in">Promise</span>.resolve(<span class="string">'lemon'</span>)).resolves.not.toBe(<span class="string">'octopus'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="rejects"><a href="#rejects" class="headerlink" title=".rejects"></a>.rejects</h4><p>使用 <code>rejects</code>解开 rejected  promise,如果 fulfilled promise,则断言失败</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'rejects to octopus'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// make sure to add a return statement</span></span><br><span class="line">  <span class="keyword">return</span> expect(<span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'octopus'</span>))).rejects.toThrow(<span class="string">'octopus'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>测试是异步的，需要告诉 jest 等待返回解开的断言</p><p>同样使用  <code>async/await</code>结合 <code>.rejects</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'rejects to octopus'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'octopus'</span>))).rejects.toThrow(<span class="string">'octopus'</span>);</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'octopus'</span>))).rejects.not.toThrow(<span class="string">'lemon'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><h4 id="toHaveBeenCalled-toBeCalled"><a href="#toHaveBeenCalled-toBeCalled" class="headerlink" title=".toHaveBeenCalled()|.toBeCalled()"></a>.toHaveBeenCalled()|.toBeCalled()</h4><p>确保模拟功能得到调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drinkAll</span>(<span class="params">cb, flavour</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (flavour !== <span class="string">'octopus'</span>) &#123;</span><br><span class="line">    cb(flavour)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'test drinkAll function'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'drink somthing lemon-flavour'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">    drinkAll(drink, <span class="string">'lemon'</span>)</span><br><span class="line">    expect(drink).toBeCalled();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'test drinkAll function'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'does not drink somthing octopus-flavour'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">    drinkAll(drink, <span class="string">'octopus'</span>)</span><br><span class="line">    expect(drink).not.toBeCalled();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'test drinkAll function'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'drink somthing lemon-flavour'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">    drinkAll(drink, <span class="string">'lemon'</span>)</span><br><span class="line">    expect(drink).toHaveBeenCalled();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'test drinkAll function'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'does not drink somthing octopus-flavour'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">    drinkAll(drink, <span class="string">'octopus'</span>)</span><br><span class="line">    expect(drink).not.toHaveBeenCalled();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="toHaveBeenCallTimes-number-toBeCalledTimes-number"><a href="#toHaveBeenCallTimes-number-toBeCalledTimes-number" class="headerlink" title=".toHaveBeenCallTimes(number)|.toBeCalledTimes(number)"></a>.toHaveBeenCallTimes(number)|.toBeCalledTimes(number)</h4><p>确保模拟功能得到调用次数与指定数字一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drinkEach drinks each drink'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">  drinkEach(drink, [<span class="string">'lemon'</span>, <span class="string">'octopus'</span>]);</span><br><span class="line">  expect(drink).toHaveBeenCalledTimes(<span class="number">2</span>);</span><br><span class="line">  expect(drink).toBeCalledTimes(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toHaveBeenCalledWith-arg1-arg2-…-toBeCalledWith-arg1-arg2-…"><a href="#toHaveBeenCalledWith-arg1-arg2-…-toBeCalledWith-arg1-arg2-…" class="headerlink" title=".toHaveBeenCalledWith(arg1,arg2,…)|.toBeCalledWith(arg1,arg2,…)"></a>.toHaveBeenCalledWith(arg1,arg2,…)|.toBeCalledWith(arg1,arg2,…)</h4><p>确保模拟功能被调用的具体参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calledWithArg</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  cb(<span class="string">'Arg'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'test calledWithArg'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line">  calledWithArg(fn);</span><br><span class="line">  expect(fn).toBeCalledWith(<span class="string">'Arg'</span>);</span><br><span class="line">  expect(fn).toHaveBeenCalledWith(<span class="string">'Arg'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toHaveBeenLastCalledWith-arg1-arg2-…-lastCalledWith-arg1-arg2-…"><a href="#toHaveBeenLastCalledWith-arg1-arg2-…-lastCalledWith-arg1-arg2-…" class="headerlink" title=".toHaveBeenLastCalledWith(arg1,arg2,…)|.lastCalledWith(arg1, arg2, …)"></a>.toHaveBeenLastCalledWith(arg1,arg2,…)|.lastCalledWith(arg1, arg2, …)</h4><p>确保模拟功能被最后一次调用的具体参数</p><h4 id="toHaveBeenNthCalledWith-nthCall-arg1-arg2-…-nthCalledWith-nthCall-arg1-arg2-…"><a href="#toHaveBeenNthCalledWith-nthCall-arg1-arg2-…-nthCalledWith-nthCall-arg1-arg2-…" class="headerlink" title=".toHaveBeenNthCalledWith(nthCall, arg1, arg2, ….)|.nthCalledWith(nthCall, arg1, arg2, ….)"></a>.toHaveBeenNthCalledWith(nthCall, arg1, arg2, ….)|.nthCalledWith(nthCall, arg1, arg2, ….)</h4><p>确保模拟功能多次调用的顺序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drinkEach drinks each drink'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">  drinkEach(drink, [<span class="string">'lemon'</span>, <span class="string">'octopus'</span>]);</span><br><span class="line">  expect(drink).toHaveBeenNthCalledWith(<span class="number">1</span>, <span class="string">'lemon'</span>);</span><br><span class="line">  expect(drink).toHaveBeenNthCalledWith(<span class="number">2</span>, <span class="string">'octopus'</span>);</span><br><span class="line">  expect(drink).nthCalledWith(<span class="number">1</span>, <span class="string">'lemon'</span>);</span><br><span class="line">  expect(drink).nthCalledWith(<span class="number">2</span>, <span class="string">'octopus'</span>);    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>n 必须是从 1开始的正整数</p><h4 id="toHaveReturned-toReturn"><a href="#toHaveReturned-toReturn" class="headerlink" title=".toHaveReturned()|.toReturn()"></a>.toHaveReturned()|.toReturn()</h4><p>测试模拟函数成功返回(即没有抛出错误)至少一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'test calledWithArg'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line">  calledWithArg(fn);</span><br><span class="line">  expect(fn).toHaveReturned();</span><br><span class="line">  expect(fn).toReturn();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toHaveReturnedTimes-number-toReturnTimes-number"><a href="#toHaveReturnedTimes-number-toReturnTimes-number" class="headerlink" title=".toHaveReturnedTimes(number)|.toReturnTimes(number)"></a>.toHaveReturnedTimes(number)|.toReturnTimes(number)</h4><p>确保模拟函数返回成功的次数,抛出错误的模拟函数的任何调用都不计入函数返回的次数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drink returns twice'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  drink();</span><br><span class="line">  drink();</span><br><span class="line"></span><br><span class="line">  expect(drink).toHaveReturnedTimes(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toHaveReturnedWith-value-toReturnWith-value"><a href="#toHaveReturnedWith-value-toReturnWith-value" class="headerlink" title=".toHaveReturnedWith(value)|.toReturnWith(value)"></a>.toHaveReturnedWith(value)|.toReturnWith(value)</h4><p>确保模拟函数返回特定的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'test Return 123'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">123</span>);</span><br><span class="line">  calledWithArg(fn);</span><br><span class="line">  expect(fn).toHaveReturnedWith(<span class="number">123</span>)</span><br><span class="line">  expect(fn).toReturnWith(<span class="number">123</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toHaveLastReturnedWith-value-lastReturnedWith-value"><a href="#toHaveLastReturnedWith-value-lastReturnedWith-value" class="headerlink" title=".toHaveLastReturnedWith(value)|.lastReturnedWith(value)"></a>.toHaveLastReturnedWith(value)|.lastReturnedWith(value)</h4><p>确保模拟函数最后一次返回特定的值</p><h4 id="toHaveNthReturnedWith-nthCall-value-nthReturnedWith-nthCall-value"><a href="#toHaveNthReturnedWith-nthCall-value-nthReturnedWith-nthCall-value" class="headerlink" title=".toHaveNthReturnedWith(nthCall, value)|.nthReturnedWith(nthCall, value)"></a>.toHaveNthReturnedWith(nthCall, value)|.nthReturnedWith(nthCall, value)</h4><p>确保模拟函数第n次调用返回特定的值</p><p>第n个参数必须是从1开始的正整数。</p><h3 id="自定义扩展"><a href="#自定义扩展" class="headerlink" title="自定义扩展"></a>自定义扩展</h3><h4 id="expect-extend"><a href="#expect-extend" class="headerlink" title="expect.extend()"></a>expect.extend()</h4><p><code>pass</code>表示是否有匹配，<code>message</code>提供一个没有参数的函数，在出现错误的情况下返回消息。当<code>pass:false</code>，<code>message</code>返回 <code>expect(x).matcher()</code>失败的错误信息，<code>pass:true</code>，<code>message</code>返回当<code>expect(x).not.matcher()</code>失败时的错误消息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expect.extend(matchers)</span></span><br><span class="line">expect.extend(&#123;</span><br><span class="line">  toBeWithinRange(reveived, floor, ceiling) &#123;</span><br><span class="line">    <span class="keyword">const</span> pass = reveived &gt;= floor &amp;&amp; reveived &lt;= ceiling;</span><br><span class="line">    <span class="keyword">if</span> (pass) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        message: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`期待 <span class="subst">$&#123;reveived&#125;</span> 不在范围<span class="subst">$&#123;floor&#125;</span>-<span class="subst">$&#123;ceiling&#125;</span>内`</span>,</span><br><span class="line">        pass,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        message: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`期待 <span class="subst">$&#123;reveived&#125;</span> 在范围<span class="subst">$&#123;floor&#125;</span>-<span class="subst">$&#123;ceiling&#125;</span>内`</span>,</span><br><span class="line">        pass,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'测试范围'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">100</span>).toBeWithinRange(<span class="number">90</span>, <span class="number">100</span>)</span><br><span class="line">  expect(<span class="number">101</span>).not.toBeWithinRange(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">  expect(&#123; <span class="attr">apples</span>: <span class="number">6</span>, <span class="attr">bananas</span>: <span class="number">3</span> &#125;).toEqual(&#123;</span><br><span class="line">    apples: expect.toBeWithinRange(<span class="number">1</span>, <span class="number">10</span>),</span><br><span class="line">    bananas: expect.not.toBeWithinRange(<span class="number">11</span>, <span class="number">20</span>),</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>异步扩展,需要结合 <code>async</code>和 <code>await</code>函数来使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">expect.extend(&#123;</span><br><span class="line">    <span class="keyword">async</span> toBeDivisibleByExternalValue(reveived)&#123;</span><br><span class="line">        <span class="comment">// 异步获取的除数</span></span><br><span class="line">        <span class="keyword">const</span> externalValue = <span class="keyword">await</span> getExternalValueFromRemoteSource();</span><br><span class="line">        <span class="keyword">const</span> pass = received % externalValue == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(pass)&#123;</span><br><span class="line">            <span class="keyword">return</span>&#123;</span><br><span class="line">                message:<span class="function"><span class="params">()</span>=&gt;</span><span class="string">`期待<span class="subst">$&#123;received&#125;</span>不被<span class="subst">$&#123;externalValue&#125;</span>整除`</span>,</span><br><span class="line">                pass</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>&#123;</span><br><span class="line">                message:<span class="function"><span class="params">()</span>=&gt;</span><span class="string">`期待<span class="subst">$&#123;received&#125;</span>被<span class="subst">$&#123;externalValue&#125;</span>整除`</span>,</span><br><span class="line">                pass</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://jestjs.io/docs/zh-Hans/expect">更多</a></p><h3 id="测试异步代码"><a href="#测试异步代码" class="headerlink" title="测试异步代码"></a>测试异步代码</h3><p>回调形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetchData.js</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'@/utils/request'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchData = <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">  request(<span class="string">'http://www.dell-lee.com/react/api/demo.json'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.data) cb(res.data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fetchData</span><br><span class="line"><span class="comment">// fetchData.test.js</span></span><br><span class="line"><span class="keyword">import</span> fetchData <span class="keyword">from</span> <span class="string">'./fetchData'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">test(<span class="string">'fetch 返回结果为 &#123;success: true&#125;'</span>, () =&gt; &#123;</span><br><span class="line">  fetchData(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    expect(data).toEqual(&#123;</span><br><span class="line">      success: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调类型异步函数</span></span><br><span class="line">test(<span class="string">'fetch 返回结果为 &#123;success: true&#125;'</span>, (done) =&gt; &#123;</span><br><span class="line">  fetchData(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    expect(data).toEqual(&#123;</span><br><span class="line">      success: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    done();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetchData.js</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'@/utils/request'</span>;</span><br><span class="line"><span class="keyword">const</span> fetchData = <span class="function"><span class="params">()</span> =&gt;</span> request(<span class="string">'http://www.dell-lee.com/react/api/demo.json'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fetchData</span><br><span class="line"></span><br><span class="line"><span class="comment">//fetchData.test.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fetchData <span class="keyword">from</span> <span class="string">'./fetchData'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line">test(<span class="string">'fetch 返回结果为 &#123;success: true&#125;'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    expect(res.data).toEqual(&#123; <span class="attr">success</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 测试404</span></span><br><span class="line">test(<span class="string">'fetchData 返回结果为404'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 要求至少跑一次 expect</span></span><br><span class="line">  expect.assertions(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> fetchData().catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    expect(e.toString().indexOf(<span class="string">'404'</span>) &gt; <span class="number">-1</span>).toBe(<span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// .resolves / .rejects</span></span><br><span class="line">test(<span class="string">'fetch 返回结果为 &#123;success: true&#125;'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> expect(fetchData()).resolves.toMatchObject(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      success: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'fetchData 返回结果为404'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> expect(fetchData()).rejects.toThrow()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Async/Await</span></span><br><span class="line">test(<span class="string">'fetch 返回结果为 &#123;success: true&#125;'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(fetchData()).resolves.toMatchObject(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      success: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'fetchData 返回结果为404'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(fetchData()).rejects.toThrow()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 另一种 Async/Await</span></span><br><span class="line">test(<span class="string">'fetch 返回结果为 &#123;success: true&#125;'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetchData()</span><br><span class="line">  expect(res.data).toEqual(&#123;</span><br><span class="line">    success: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'fetchData 返回结果为404'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  expect.assertions(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> fetchData()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">await</span> expect(e.toString()).toEqual(<span class="string">'Error: Request failed with status code 404'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Couter.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.number = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addOne() &#123;</span><br><span class="line">    <span class="keyword">this</span>.number += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addTwo() &#123;</span><br><span class="line">    <span class="keyword">this</span>.number += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  minusOne() &#123;</span><br><span class="line">    <span class="keyword">this</span>.number -= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  minusTwo() &#123;</span><br><span class="line">    <span class="keyword">this</span>.number -= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter;</span><br><span class="line"><span class="comment">// Couter.test.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'./Couter'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'测试 Counter'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">let</span> couter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有测试开始之前</span></span><br><span class="line">  beforeAll(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    couter = <span class="keyword">new</span> Counter();</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 每个测试用例开始之前</span></span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 每次测试都会生成一个新的 couter</span></span><br><span class="line">    couter = <span class="keyword">new</span> Counter();</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 每个测试用例结束之后</span></span><br><span class="line">  afterEach(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;)</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 所有测试结束之后</span></span><br><span class="line">  afterAll(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  describe(<span class="string">'测试增加相关代码'</span>,()=&gt;&#123;</span><br><span class="line">    test(<span class="string">'测试 Conter 中的 addOne 方法'</span>, () =&gt; &#123;</span><br><span class="line">      couter.addOne();</span><br><span class="line">      expect(couter.number).toBe(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    test(<span class="string">'测试 Conter 中的 addTwo 方法'</span>, () =&gt; &#123;</span><br><span class="line">      couter.addTwo();</span><br><span class="line">      expect(couter.number).toBe(<span class="number">2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  describe(<span class="string">'测试减少相关代码'</span>,()=&gt;&#123;</span><br><span class="line">    test(<span class="string">'测试 Conter 中的 minusOne 方法'</span>, () =&gt; &#123;</span><br><span class="line">      couter.minusOne();</span><br><span class="line">      expect(couter.number).toBe(<span class="number">-1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  </span><br><span class="line">    test(<span class="string">'测试 Conter 中的 minusTwo 方法'</span>, () =&gt; &#123;</span><br><span class="line">      couter.minusTwo();</span><br><span class="line">      expect(couter.number).toBe(<span class="number">-2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>describe 里面就是一个作用域，嵌套作用域可以有多个钩子函数，钩子函数执行顺序由外到内</p><p><code>test.only</code>，只执行某个测试用例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'测试减少相关代码'</span>,()=&gt;&#123;</span><br><span class="line">  test.only(<span class="string">'测试 Conter 中的 minusOne 方法'</span>, () =&gt; &#123;</span><br><span class="line">    couter.minusOne();</span><br><span class="line">    expect(couter.number).toBe(<span class="number">-1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'测试 Conter 中的 minusTwo 方法'</span>, () =&gt; &#123;</span><br><span class="line">    couter.minusTwo();</span><br><span class="line">    expect(couter.number).toBe(<span class="number">-2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h3><ol><li>捕获函数的调用，this 指向，调用顺序</li><li>自由设置返回结果</li><li>改变内部函数的实现</li></ol><h4 id="基本模拟-导入函数"><a href="#基本模拟-导入函数" class="headerlink" title="基本模拟-导入函数"></a>基本模拟-导入函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo</span></span><br><span class="line"><span class="keyword">const</span> runCallback = <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> runCallback</span><br><span class="line"></span><br><span class="line"><span class="comment">//demo.test.js</span></span><br><span class="line"><span class="keyword">import</span> runCallback <span class="keyword">from</span> <span class="string">'./demo'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'测试 runCallback 方法'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'runCallback被调用,并只调用了一次'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="comment">// mock 函数，捕获函数的调用</span></span><br><span class="line">    <span class="keyword">const</span> func = jest.fn();</span><br><span class="line">    <span class="comment">// 方法返回一次 值 Haha，mockReturnValue则是都返回，也可以在 jest.fn(()=&gt;&#123;return 'Haha'&#125;)定义</span></span><br><span class="line">    func.mockReturnValueOnce(<span class="string">'Haha'</span>)</span><br><span class="line">    runCallback(func)</span><br><span class="line">    expect(func).toBeCalled()</span><br><span class="line">    expect(func.mock.calls.length).toBe(<span class="number">1</span>)</span><br><span class="line">    expect(func.mock.results[<span class="number">0</span>].value).toBe(<span class="string">'Haha'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(func.mock)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  ● Console</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    console.log src/lesson2/demo.test.js:14</span></span><br><span class="line"><span class="comment">      &#123; calls: [ [] ],</span></span><br><span class="line"><span class="comment">        instances: [ undefined ],</span></span><br><span class="line"><span class="comment">        invocationCallOrder: [ 1 ],</span></span><br><span class="line"><span class="comment">        results: [ &#123; type: 'return', value: 'Haha' &#125; ] &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="修改原来函数的返回"><a href="#修改原来函数的返回" class="headerlink" title="修改原来函数的返回"></a>修改原来函数的返回</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xx.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchData = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    axios.get(<span class="string">'/'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>res.data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (function()&#123;return '123' &#125;)()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fetchData;</span><br><span class="line"><span class="comment">// xx.test.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fetchData <span class="keyword">from</span> <span class="string">'./xx.js'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">ject.mock(<span class="string">'axios'</span>)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'fetchData 测试'</span>,()=&gt;&#123;</span><br><span class="line">    axios.get.mockResolvedValue(&#123;</span><br><span class="line">        data:<span class="string">"(function()&#123;return '123' &#125;)()"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">        expect(<span class="built_in">eval</span>(data)).toEqual(<span class="string">'123'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="mocks-文件夹"><a href="#mocks-文件夹" class="headerlink" title="__mocks__文件夹"></a><code>__mocks__</code>文件夹</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __mock__/xx.js</span></span><br><span class="line"><span class="keyword">const</span> fetchData = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">"(function()&#123;return '123' &#125;)()"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着改测试，模拟函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xx.test.js</span></span><br><span class="line">jest.mock(<span class="string">'./xx'</span>)</span><br><span class="line"><span class="keyword">import</span> fetchData <span class="keyword">from</span> <span class="string">'./xx.js'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'fetchData 测试'</span>,()=&gt;&#123;</span><br><span class="line">    axios.get.mockResolvedValue(&#123;</span><br><span class="line">        data:<span class="string">"(function()&#123;return '123' &#125;)()"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">        expect(<span class="built_in">eval</span>(data)).toEqual(<span class="string">'123'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述函数顶部那步模拟也可以通过在 jest.config.js 中修改配置 <code>automock：true</code> 改为自动模拟，那么引入对应的函数的时候就会自动去 <code>__mocks__</code>文件夹里面去寻找对应的模拟函数。注意一旦开启这个配置，需要启动才会生效，另外也会导致很多测试需要重新修改。</p><h4 id="同时存在-mocks-以及导入函数"><a href="#同时存在-mocks-以及导入函数" class="headerlink" title="同时存在__mocks__以及导入函数"></a>同时存在<code>__mocks__</code>以及导入函数</h4><p>在原来 xx.js 基础上面新增 一个 <code>getNumber</code>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">xx.js</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchData = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    axios.get(<span class="string">'/'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>res.data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (function()&#123;return '123' &#125;)()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getNumber = <span class="function"><span class="params">()</span>=&gt;</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">fetchData,</span><br><span class="line">    getNumber</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着修改测试用例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xx.test.js</span></span><br><span class="line">jest.mock(<span class="string">'./xx'</span>)</span><br><span class="line"><span class="keyword">import</span> fetchData <span class="keyword">from</span> <span class="string">'./xx.js'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'fetchData 测试'</span>,()=&gt;&#123;</span><br><span class="line">    axios.get.mockResolvedValue(&#123;</span><br><span class="line">        data:<span class="string">"(function()&#123;return '123' &#125;)()"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">        expect(<span class="built_in">eval</span>(data)).toEqual(<span class="string">'123'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">test(<span class="string">'getNumber 测试'</span>,()=&gt;&#123;</span><br><span class="line">expect(getNumber()).toBe(<span class="number">123</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述代码会报错，<code>getNumebr</code> 找不到对应的函数，因为测试用例还是会去<code>__mocks__</code> 文件夹去寻找 <code>getNumber</code>。但是我们只希望模拟异步的函数，对于同步函数希望通过导入的方式来测试，那么就从原来的js文件中导入 <code>getNumber</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xx.test.js</span></span><br><span class="line">jest.mock(<span class="string">'./xx'</span>)</span><br><span class="line"><span class="keyword">import</span> fetchData <span class="keyword">from</span> <span class="string">'./xx.js'</span></span><br><span class="line"><span class="keyword">const</span> &#123; getNumber &#125; = jest.requireActual(<span class="string">'./xx'</span>)</span><br><span class="line">test(<span class="string">'fetchData 测试'</span>,()=&gt;&#123;</span><br><span class="line">    axios.get.mockResolvedValue(&#123;</span><br><span class="line">        data:<span class="string">"(function()&#123;return '123' &#125;)()"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">        expect(<span class="built_in">eval</span>(data)).toEqual(<span class="string">'123'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">test(<span class="string">'getNumber 测试'</span>,()=&gt;&#123;</span><br><span class="line">expect(getNumber()).toBe(<span class="number">123</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Mock-Timer"><a href="#Mock-Timer" class="headerlink" title="Mock Timer"></a>Mock Timer</h3><p>写一个 setTimeout 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timer.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (cb)=&gt;&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    cb()</span><br><span class="line">  &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timer.test.js</span></span><br><span class="line"><span class="keyword">import</span> timer <span class="keyword">from</span> <span class="string">'./timer'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'timer 测试'</span>,(done)=&gt;&#123;</span><br><span class="line">  timer(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    expect(<span class="number">2</span>).toBe(<span class="number">1</span>)</span><br><span class="line">    done();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的测试用例会直接通过， <code>timer</code>是一个异步函数，并不会执行函数体内的内容，需要像之前的异步函数一样，加个 done 参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timer <span class="keyword">from</span> <span class="string">'./timer'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'timer 测试'</span>,(done)=&gt;&#123;</span><br><span class="line">  timer(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    expect(<span class="number">2</span>).toBe(<span class="number">1</span>)</span><br><span class="line">    done();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接着测试用例便会运行，并报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">FAIL  src/lesson3/timer.test.js (7.997s)</span><br><span class="line"> ● Console</span><br><span class="line"></span><br><span class="line">   console.error node_modules/_jsdom@11.12.0@jsdom/lib/jsdom/virtual-console.js:29</span><br><span class="line">     Error: Uncaught [Error: expect(received).toBe(expected) // Object.is equality</span><br><span class="line">     </span><br><span class="line">     Expected: 1</span><br><span class="line">     Received: 2]</span><br><span class="line">         at reportException (F:\赖彬鸿\git-project\usual\Egret-Project\FontendTest\node_modules\_jsdom@11.12.0@jsdom\lib\jsdom\living\helpers\runtime-script-errors.js:66:24)</span><br><span class="line">         at Timeout.callback [as _onTimeout] (F:\赖彬鸿\git-project\usual\Egret-Project\FontendTest\node_modules\_jsdom@11.12.0@jsdom\lib\jsdom\browser\Window.js:680:7)</span><br><span class="line">         at ontimeout (timers.js:436:11)</span><br><span class="line">         at tryOnTimeout (timers.js:300:5)</span><br><span class="line">         at listOnTimeout (timers.js:263:5)</span><br><span class="line">         at Timer.processTimers (timers.js:223:10) &#123; Error: expect(received).toBe(expected) // Object.is equality</span><br><span class="line">     </span><br><span class="line">     Expected: 1</span><br><span class="line">     Received: 2</span><br><span class="line">         at toBe (F:\赖彬鸿\git-project\usual\Egret-Project\FontendTest\src\lesson3\timer.test.js:5:15)</span><br><span class="line">         at cb (F:\赖彬鸿\git-project\usual\Egret-Project\FontendTest\src\lesson3\timer.js:3:5)</span><br><span class="line">         at Timeout.callback [as _onTimeout] (F:\赖彬鸿\git-project\usual\Egret-Project\FontendTest\node_modules\_jsdom@11.12.0@jsdom\lib\jsdom\browser\Window.js:678:19)</span><br><span class="line">         at ontimeout (timers.js:436:11)</span><br><span class="line">         at tryOnTimeout (timers.js:300:5)</span><br><span class="line">         at listOnTimeout (timers.js:263:5)</span><br><span class="line">         at Timer.processTimers (timers.js:223:10)</span><br><span class="line">       matcherResult:</span><br><span class="line">        &#123; actual: 2,</span><br><span class="line">          expected: 1,</span><br><span class="line">          message: [Function],</span><br><span class="line">          name: 'toBe',</span><br><span class="line">          pass: false &#125; &#125;</span><br></pre></td></tr></table></figure><p>也可以通过模拟 timer 这类异步函数，来达到目的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timer.test.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> timer <span class="keyword">from</span> <span class="string">'./timer'</span></span><br><span class="line"><span class="comment">// mock timer</span></span><br><span class="line">jest.useFakeTimers()</span><br><span class="line">test(<span class="string">'timer 测试'</span>,()=&gt;&#123;    </span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line">  timer(fn)</span><br><span class="line">  <span class="comment">// 快速运行所有Timer</span></span><br><span class="line">  jest.runAllTimers();</span><br><span class="line">  expect(fn).toHaveBeenCalledTimes(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于嵌套 timer 异步函数，<code>jest.runOnlyPendingTimers</code>可以让只最外层的第一个 timer 运行。</p><p>另外还有快进时间的api,<code>jest.advanceTimersByTime(n)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timer.test.js</span></span><br><span class="line"><span class="keyword">import</span> timer <span class="keyword">from</span> <span class="string">'./timer'</span></span><br><span class="line"></span><br><span class="line">jest.useFakeTimers()</span><br><span class="line">test(<span class="string">'timer 测试'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line">  timer(fn)</span><br><span class="line">  jest.advanceTimersByTime(<span class="number">3000</span>)</span><br><span class="line">  expect(fn).toHaveBeenCalledTimes(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>嵌套 timer 的测试用例结合 钩子<code>beforeEach</code>以及两个上面讲的api的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timer.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (cb)=&gt;&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    cb()</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      cb()</span><br><span class="line">    &#125;,<span class="number">3000</span>)    </span><br><span class="line">  &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// timer.test.js</span></span><br><span class="line"><span class="keyword">import</span> timer <span class="keyword">from</span> <span class="string">'./timer'</span></span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  jest.useFakeTimers()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test(<span class="string">'timer 测试-runAllTimers'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line">  timer(fn)</span><br><span class="line">  jest.runAllTimers();</span><br><span class="line">  expect(fn).toHaveBeenCalledTimes(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">test(<span class="string">'timer 测试-advanceTimersByTime'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line">  timer(fn)</span><br><span class="line">  jest.advanceTimersByTime(<span class="number">3000</span>)</span><br><span class="line">  expect(fn).toHaveBeenCalledTimes(<span class="number">1</span>)</span><br><span class="line">  jest.advanceTimersByTime(<span class="number">3000</span>)</span><br><span class="line">  expect(fn).toHaveBeenCalledTimes(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Mock-Funtions"><a href="#Mock-Funtions" class="headerlink" title="Mock Funtions"></a>Mock Funtions</h3><p>Mock 函数可以轻松测试代码之间的连接——实现方式包括：擦除函数实际实现、捕获对函数的调用（以及在这些调用中传递的参数）、在使用 <code>new</code> 实例化时捕获构造函数的实例，允许测试时配置返回值</p><h4 id="模拟函数"><a href="#模拟函数" class="headerlink" title="模拟函数"></a>模拟函数</h4><p>测试函数 <code>forEach</code>的内部实现，这个函数为传入的数组中的每个元素调用一次回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">items,callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> index=<span class="number">0</span>;index&lt;items.length;index+=<span class="number">1</span>)&#123;</span><br><span class="line">        callback(item[index])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了测试此函数，可以使用一个 mock 函数，然后检查 mock 函数的状态来确保回调函数如期调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockCallback = jest.fn(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">42</span> + x);</span><br><span class="line">forEach([<span class="number">0</span>, <span class="number">1</span>], mockCallback)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此mock函数被调用了两次</span></span><br><span class="line">expect(mockCallback.mock.calls.length).toBe(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(mockCallback)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      &#123; </span></span><br><span class="line"><span class="comment">      [Function: mockConstructor]</span></span><br><span class="line"><span class="comment">        _isMockFunction: true,</span></span><br><span class="line"><span class="comment">        getMockImplementation: [Function],</span></span><br><span class="line"><span class="comment">        mock: [Getter/Setter],</span></span><br><span class="line"><span class="comment">        mockClear: [Function],</span></span><br><span class="line"><span class="comment">        mockReset: [Function],</span></span><br><span class="line"><span class="comment">        mockRestore: [Function],</span></span><br><span class="line"><span class="comment">        mockReturnValueOnce: [Function],</span></span><br><span class="line"><span class="comment">        mockResolvedValueOnce: [Function],</span></span><br><span class="line"><span class="comment">        mockRejectedValueOnce: [Function],</span></span><br><span class="line"><span class="comment">        mockReturnValue: [Function],</span></span><br><span class="line"><span class="comment">        mockResolvedValue: [Function],</span></span><br><span class="line"><span class="comment">        mockRejectedValue: [Function],</span></span><br><span class="line"><span class="comment">        mockImplementationOnce: [Function],</span></span><br><span class="line"><span class="comment">        mockImplementation: [Function],</span></span><br><span class="line"><span class="comment">        mockReturnThis: [Function],</span></span><br><span class="line"><span class="comment">        mockName: [Function],</span></span><br><span class="line"><span class="comment">        getMockName: [Function] </span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用函数时的第一个参数是 0</span></span><br><span class="line">expect(mockCallback.mock.calls[<span class="number">0</span>][<span class="number">0</span>]).toBe(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(mockCallback.mock)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      &#123; </span></span><br><span class="line"><span class="comment">      calls: [ [ 0 ], [ 1 ] ],</span></span><br><span class="line"><span class="comment">        instances: [ undefined, undefined ],</span></span><br><span class="line"><span class="comment">        invocationCallOrder: [ 1, 2 ],</span></span><br><span class="line"><span class="comment">        results:</span></span><br><span class="line"><span class="comment">         [ &#123; type: 'return', value: 42 &#125;, &#123; type: 'return', value: 43 &#125; ] </span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 第二次调用函数时的第一个参数是1</span></span><br><span class="line">expect(mockCallback.mock.calls[<span class="number">1</span>][<span class="number">0</span>]).toBe(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次函数调用的返回值是 42</span></span><br><span class="line">expect(mockCallback.mock.results[<span class="number">0</span>].value).toBe(<span class="number">42</span>)</span><br></pre></td></tr></table></figure><h4 id="mock属性"><a href="#mock属性" class="headerlink" title=".mock属性"></a><code>.mock</code>属性</h4><p>所有 mock 函数都有这个特殊的 <code>.mock</code>属性，它保存了关于此函数如何调用、调用时的返回值的信息。<code>.mock</code>属性还追踪每次调用时 <code>this</code>的值，所以我们同样也可以检视（inspect）<code>this</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMock = jest.fn();</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> myMock();</span><br><span class="line"><span class="keyword">const</span> b = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> bound = myMock.bind(b)</span><br><span class="line">bound();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myMock.mock.instances)</span><br><span class="line"><span class="comment">// [ mockConstructor &#123;&#125;, &#123;&#125; ]</span></span><br></pre></td></tr></table></figure><h4 id="模拟返回值"><a href="#模拟返回值" class="headerlink" title="模拟返回值"></a>模拟返回值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMock = jest.fn();</span><br><span class="line"><span class="built_in">console</span>.log(myMock())</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">myMock</span><br><span class="line">    .mockReturnValueOnce(<span class="number">10</span>)</span><br><span class="line">.mockReturnValueOnce(<span class="string">'x'</span>)</span><br><span class="line">.mockReturnValue(<span class="literal">true</span>)</span><br><span class="line"><span class="built_in">console</span>.log(myMock(), myMock(), myMock(), myMock());</span><br><span class="line"><span class="comment">// 10, 'x', true, true</span></span><br></pre></td></tr></table></figure><p>结合一些函数灵活模拟</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filterTestFn = jest.fn();</span><br><span class="line"></span><br><span class="line">filterTestFn.mockReturnValueOnce(<span class="literal">true</span>).mockReturnValueOnce(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = [<span class="number">11</span>,<span class="number">12</span>].filter(filterTestFn)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="comment">// [11]</span></span><br><span class="line"><span class="built_in">console</span>.log(filterTestFn.mock.calls)</span><br><span class="line"><span class="comment">// [[11],[12]]</span></span><br></pre></td></tr></table></figure><h4 id="模拟模块"><a href="#模拟模块" class="headerlink" title="模拟模块"></a>模拟模块</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// users.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Users</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> call()&#123;</span><br><span class="line">        <span class="keyword">return</span> axios.get(<span class="string">'/user.json'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>res.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Users</span><br></pre></td></tr></table></figure><p>模拟 axios.get 返回一个假的 response</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// users.test.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">import</span> Users <span class="keyword">from</span> <span class="string">'./users'</span>;</span><br><span class="line"></span><br><span class="line">jest.mock(axios);</span><br><span class="line">test(<span class="string">'should fetch users'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> users = [&#123;<span class="attr">name</span>:<span class="string">'Bob'</span>&#125;]</span><br><span class="line">    <span class="keyword">const</span> res = &#123;<span class="attr">data</span>:users&#125;</span><br><span class="line">    axios.get.mockResolvedValue(res)</span><br><span class="line">    <span class="keyword">return</span> Users.all().then(<span class="function"><span class="params">data</span>=&gt;</span>expect(data).toEqual(users))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h4><p>通过模拟函数 <code>jest.fn</code>或者<code>mockImplementationOnce</code>方法来完成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMockFn = jest.fn(<span class="function"><span class="params">cb</span>=&gt;</span> cb(<span class="literal">null</span>,<span class="literal">true</span>))</span><br><span class="line"></span><br><span class="line">myMockFn(<span class="function">(<span class="params">err,val</span>)=&gt;</span><span class="built_in">console</span>.log(val))</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>mockImplementation</code>当您需要定义从另一个模块创建的模拟函数的默认实现时，该方法很有用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// some implementation</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test.js</span></span><br><span class="line"></span><br><span class="line">jest.mock(<span class="string">'../foo'</span>) <span class="comment">//  这个会自动模拟</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">'../foo'</span>)</span><br><span class="line"></span><br><span class="line">foo.mockImplementation(<span class="function"><span class="params">()</span>=&gt;</span><span class="number">42</span>)</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>当需要重新创建模拟函数的复杂行为，以便多个函数调用产生不同的结果时，可以使用 <code>mockImplementationOnce</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMockFn = jest</span><br><span class="line">.fn()</span><br><span class="line">.mockImplementationOnce(<span class="function"><span class="params">cb</span> =&gt;</span> cb(<span class="literal">null</span>,<span class="literal">true</span>))</span><br><span class="line">.mockImplementationOnce(<span class="function"><span class="params">cb</span> =&gt;</span> cb(<span class="literal">null</span>,fase))</span><br><span class="line">myMockFn(<span class="function">(<span class="params">err, val</span>) =&gt;</span> <span class="built_in">console</span>.log(val));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">myMockFn(<span class="function">(<span class="params">err, val</span>) =&gt;</span> <span class="built_in">console</span>.log(val));</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>.mockReturnThis()</code>返回 this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123;</span><br><span class="line">    myMethod: jest.fn().mockReturnThis(),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 与下面实现相同</span></span><br><span class="line"><span class="keyword">const</span> otherObj = &#123;</span><br><span class="line">    myMethod: jest.fn(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模拟函数名称"><a href="#模拟函数名称" class="headerlink" title="模拟函数名称"></a>模拟函数名称</h4><p>选择为模拟函数提供一个名称，改名称将在测试错误输出中显示，而不是 <code>jest.fn()</code>，使用这个可以快速识别在测试输出中报告错误的模拟函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMockFn = jest</span><br><span class="line">.fn()</span><br><span class="line">.mockReturnValue(<span class="string">'default'</span>)</span><br><span class="line">.mockImplementation(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">42</span>)</span><br><span class="line">.mockName(<span class="string">'add42'</span>)</span><br></pre></td></tr></table></figure><h3 id="Snapshot快照"><a href="#Snapshot快照" class="headerlink" title="Snapshot快照"></a>Snapshot快照</h3><p>适合测试配置文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xx.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> generateConfig = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    server:<span class="string">'http://localhost'</span>,</span><br><span class="line">    port:<span class="number">8080</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//xx.test.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; generateConfig &#125; <span class="keyword">from</span> <span class="string">'./snopshot'</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'测试 generateConfig 函数'</span>,()=&gt;&#123;</span><br><span class="line">  expect(generateConfig()).toMatchSnapshot();</span><br><span class="line">  expect(generateConfig()).toEqual(&#123;</span><br><span class="line">    server:<span class="string">'http://localhost'</span>,</span><br><span class="line">    port:<span class="number">8080</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>jest --watchAll</code>里面出现了 <code>u</code>、<code>i</code>模式分别对应 更新所有的快照跟更新单个快照</p><p>安装 <code>prettier</code>,运行 <code>toMatchInlineSnapshot</code>，会将 快照自动存到代码下面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'测试 generateConfig 函数'</span>, () =&gt; &#123;</span><br><span class="line">  expect(generateConfig()).toMatchInlineSnapshot(</span><br><span class="line">    &#123;</span><br><span class="line">      time: expect.any(<span class="built_in">Date</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 下面是自动生成的</span></span><br><span class="line">    <span class="string">`</span></span><br><span class="line"><span class="string">    Object &#123;</span></span><br><span class="line"><span class="string">      "port": 8080,</span></span><br><span class="line"><span class="string">      "server": "http://localhost",</span></span><br><span class="line"><span class="string">      "time": Any&lt;Date&gt;,</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="ES6-类"><a href="#ES6-类" class="headerlink" title="ES6 类"></a>ES6 类</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util.js</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">  init()&#123;&#125;</span><br><span class="line">  a()&#123;</span><br><span class="line">    <span class="comment">// 异常复杂</span></span><br><span class="line">  &#125;</span><br><span class="line">  b()&#123;</span><br><span class="line">    <span class="comment">// 异常复杂</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Util;</span><br></pre></td></tr></table></figure><p>在别的函数里面使用这个类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useUtil.js</span></span><br><span class="line"><span class="keyword">import</span> Util <span class="keyword">from</span> <span class="string">'./util'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useUtil = <span class="function">(<span class="params">a,b</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> util = <span class="keyword">new</span> Util()</span><br><span class="line">  util.a(a)</span><br><span class="line">  util.b(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useUtil;</span><br></pre></td></tr></table></figure><p>写这个使用类的函数的测试用例的时候，我们会发现这个函数因为使用到了类里面的函数，而函数又很复杂，直接调用会损耗性能。所以这里我们用几种方法来模拟</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useUtil.test.js</span></span><br><span class="line">jest.mock(<span class="string">'./util'</span>)</span><br><span class="line"><span class="comment">// jest.mock 发现 util 是一个类，会自动把类的构造函数方法变成 jest.fn()</span></span><br><span class="line"><span class="comment">// const Util = jest.fn();</span></span><br><span class="line"><span class="comment">// Util.a = jest.fn()</span></span><br><span class="line"><span class="comment">// Util.b = jest.fn()</span></span><br><span class="line"><span class="keyword">import</span> Util <span class="keyword">from</span> <span class="string">'./util'</span></span><br><span class="line"><span class="keyword">import</span> useUtil <span class="keyword">from</span> <span class="string">'./useUtil'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'测试 useUtil'</span>,()=&gt;&#123;</span><br><span class="line">  useUtil();</span><br><span class="line">  expect(Util).toHaveBeenCalled();</span><br><span class="line">  <span class="built_in">console</span>.log(Util.mock)</span><br><span class="line">  expect(Util.mock.instances[<span class="number">0</span>].a).toHaveBeenCalled()</span><br><span class="line">  expect(Util.mock.instances[<span class="number">0</span>].b).toHaveBeenCalled()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  ● Console</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    console.log src/lesson3/useUtil.test.js:12</span></span><br><span class="line"><span class="comment">      &#123; calls: [ [] ],</span></span><br><span class="line"><span class="comment">        instances: [ Util &#123; init: [Function], a: [Function], b: [Function] &#125; ],</span></span><br><span class="line"><span class="comment">        invocationCallOrder: [ 1 ],</span></span><br><span class="line"><span class="comment">        results: [ &#123; type: 'return', value: undefined &#125; ] &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>另一种方法就是通过在 <code>__mocks__</code>文件夹中模拟</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __mocks__/util.js</span></span><br><span class="line"><span class="keyword">const</span> Util = jest.fn();</span><br><span class="line">Util.prototype = jest.fn();</span><br><span class="line">Util.prototype = jest.fn();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Util</span><br></pre></td></tr></table></figure><p>还有一种写法，是在原来的测试用例修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useUtil.test.js</span></span><br><span class="line">jest.mock(<span class="string">'./util'</span>,()=&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> Util = jest.fn();</span><br><span class="line">    Util.prototype = jest.fn();</span><br><span class="line">    Util.prototype = jest.fn();</span><br><span class="line">    <span class="keyword">return</span> Util;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dom.js</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addDivToBody = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">    $(<span class="string">'body'</span>).append(<span class="string">'&lt;div/&gt;'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> addDivToBody</span><br><span class="line"></span><br><span class="line"><span class="comment">// dom.test.js</span></span><br><span class="line"><span class="comment">// node 本身不具备 dom</span></span><br><span class="line"><span class="comment">// jest 在 node 环境下模拟了一套 dom 的 api,jsDom</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span></span><br><span class="line"><span class="keyword">import</span> addDivToBody <span class="keyword">from</span> addDivToBody;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'测试 addDivToBody'</span>,()=&gt;&#123;</span><br><span class="line">    addDivToBody();</span><br><span class="line">    expect($(<span class="string">'body'</span>).find(<span class="string">'div'</span>).length).toBe(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="TDD（测试驱动开发）"><a href="#TDD（测试驱动开发）" class="headerlink" title="TDD（测试驱动开发）"></a>TDD（测试驱动开发）</h2><p>全称：Test Driven Development</p><h3 id="开发流程（Red-Green-Development）"><a href="#开发流程（Red-Green-Development）" class="headerlink" title="开发流程（Red-Green Development）"></a>开发流程（Red-Green Development）</h3><ol><li>编写测试用例</li><li>运行测试，测试用例无法通过测试</li><li>编写代码，使测试用例通过测试</li><li>优化代码，完成开发</li><li>重复上述步骤</li></ol><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li>长期减少回归 bug</li><li>代码质量更好（组织、可维护性）</li><li>测试覆盖率高</li><li>错误测试代码不容易出现</li></ol><h3 id="Vue-TDD"><a href="#Vue-TDD" class="headerlink" title="Vue TDD"></a>Vue TDD</h3><p>开始</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装脚手架</span></span><br><span class="line">npm i @vue/cli@3.8.4 -g</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装vue,可以选择默认配置，也可以自定义配置</span></span><br><span class="line">vue create vue-jest</span><br></pre></td></tr></table></figure><h4 id="vue-test-utils"><a href="#vue-test-utils" class="headerlink" title="@vue/test-utils"></a>@vue/test-utils</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorld.test.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; shallowMount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'@/components/HelloWorld.vue'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'HelloWorld.vue'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">/** 如果不使用 @vue/test-utils</span></span><br><span class="line"><span class="comment">   * import Vue from 'vue'</span></span><br><span class="line"><span class="comment">   *   it('renders props.msg when passed', () =&gt; &#123;</span></span><br><span class="line"><span class="comment">  const root = document.createElement('div')</span></span><br><span class="line"><span class="comment">  root.className = 'root'</span></span><br><span class="line"><span class="comment">  document.body.appendChild(root)</span></span><br><span class="line"><span class="comment">  new Vue(&#123;</span></span><br><span class="line"><span class="comment">    render: h =&gt; h(HelloWorld, &#123;</span></span><br><span class="line"><span class="comment">      props: &#123;</span></span><br><span class="line"><span class="comment">        msg: 'laibh'</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;)</span></span><br><span class="line"><span class="comment">  &#125;).$mount('.root')</span></span><br><span class="line"><span class="comment">  expect(document.getElementsByClassName('hello').length).toBe(1)</span></span><br><span class="line"><span class="comment">  &#125;)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">const</span> msg = <span class="string">'new message'</span></span><br><span class="line">  <span class="keyword">const</span> wrapper = shallowMount(HelloWorld, &#123;</span><br><span class="line">    propsData: &#123; msg &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  expect(wrapper.text()).toMatch(msg)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>shallowMount</code>浅层渲染，只渲染第一层，不渲染子组件，适合单元测试</p><p><code>mount</code>则会渲染子组件，适合集成测试</p><h4 id="开发-Header-组件"><a href="#开发-Header-组件" class="headerlink" title="开发 Header 组件"></a>开发 Header 组件</h4><p>测试用例先行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Header.test.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; shallowMount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'@/components/Header/Header.vue'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'测试 Header 组件'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'Header 包含 Input 框'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(Header)</span><br><span class="line">    <span class="keyword">const</span> input = wrapper.find(<span class="string">'[data-test="input"]'</span>)</span><br><span class="line">    expect(input.exists()).toBe(<span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">'Header 中 Input 初始内容为空'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(Header)</span><br><span class="line">    <span class="keyword">const</span> inputValue = wrapper.vm.$data.inputValue</span><br><span class="line">    expect(inputValue).toBe(<span class="string">''</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'Header 中 Input 框值发生变化，值应该也跟着改变'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(Header)</span><br><span class="line">    <span class="keyword">const</span> input = wrapper.find(<span class="string">'[data-test="input"]'</span>)</span><br><span class="line">    input.setValue(<span class="string">'laibh'</span>)</span><br><span class="line">    <span class="keyword">const</span> inputValue = wrapper.vm.$data.inputValue</span><br><span class="line">    expect(inputValue).toBe(<span class="string">'laibh'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'Header 中 Input 框输入回车，无内容时无反应'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(Header)</span><br><span class="line">    <span class="keyword">const</span> input = wrapper.find(<span class="string">'[data-test="input"]'</span>)</span><br><span class="line">    input.setValue(<span class="string">''</span>)</span><br><span class="line">    input.trigger(<span class="string">'keyup.enter'</span>)</span><br><span class="line">    expect(wrapper.emitted().add).toBeFalsy()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'Header 中 Input 框输入回车，有内容时向外触发事件,同时清空 inputValue'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(Header)</span><br><span class="line">    <span class="keyword">const</span> input = wrapper.find(<span class="string">'[data-test="input"]'</span>)</span><br><span class="line">    input.setValue(<span class="string">'laibh'</span>)</span><br><span class="line">    input.trigger(<span class="string">'keyup.enter'</span>)</span><br><span class="line">    expect(wrapper.emitted().add).toBeTruthy()</span><br><span class="line">    expect(wrapper.vm.$data.inputValue).toBe(<span class="string">''</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>根据测试用例写代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// Header.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input data-test=&quot;input&quot; v-model=&quot;inputValue&quot; @keyup.enter=&quot;addTodoItem&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Header&quot;,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      inputValue: &quot;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addTodoItem() &#123;</span><br><span class="line">      if (this.inputValue) &#123;</span><br><span class="line">        this.$emit(&quot;add&quot;, this.inputValue);</span><br><span class="line">        this.inputValue = &quot;&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang=&quot;less&quot;&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jest.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    collectCoverageFrom: [<span class="string">'**/*.&#123;js,vue&#125;'</span>, <span class="string">'!**/node_modules/**'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test:cov"</span>: <span class="string">"vue-cli-service test:unit --coverage"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="React-TDD"><a href="#React-TDD" class="headerlink" title="React TDD"></a>React TDD</h3><h4 id="Enzyme"><a href="#Enzyme" class="headerlink" title="Enzyme"></a>Enzyme</h4><p><a href="https://github.com/airbnb/enzyme">github</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 </span></span><br><span class="line">npm i --save-dev enzyme enzyme-adapter-react-16</span><br></pre></td></tr></table></figure><p>同样，<code>shallow</code>适合单元测试，<code>mount</code>则是集成测试</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.je</span></span><br><span class="line"><span class="keyword">import</span> React from <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">     <span class="comment">// 使用的data-test=xxx 等属性可以做到解耦，不会因为改变样式名而发生改变，另外也不会被hash掉</span></span><br><span class="line">    &lt;div className=<span class="string">"app-container"</span> title=<span class="string">"laibh"</span> data-test=<span class="string">"container"</span>&gt;</span><br><span class="line">      hello world</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> App;</span><br><span class="line"><span class="comment">// App.test.js</span></span><br><span class="line"><span class="keyword">import</span> React from <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> App from <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> Enzyme, &#123; shallow &#125; from <span class="string">'enzyme'</span>;</span><br><span class="line"><span class="keyword">import</span> Adapter from <span class="string">'enzyme-adapter-react-16'</span>;</span><br><span class="line">Enzyme.configure(&#123; adapter: <span class="keyword">new</span> Adapter() &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">it(<span class="string">'renders without crashing'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = shallow(&lt;App /&gt;)</span><br><span class="line">  <span class="comment">// 输出整个内容字符串</span></span><br><span class="line">  console.log(wrapper.debug())</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    &lt;div className="app-container" title="laibh" data-test="container"&gt;</span></span><br><span class="line"><span class="comment">      hello world</span></span><br><span class="line"><span class="comment">    &lt;/div&gt;  </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  expect(wrapper.find(<span class="string">'[data-test="container"]'</span>).length).toBe(<span class="number">1</span>)</span><br><span class="line">  expect(wrapper.find(<span class="string">'[data-test="container"]'</span>).prop(<span class="string">'title'</span>)).toBe(<span class="string">'laibh'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>另外它海域一些扩展 API，例如 <a href="https://github.com/FormidableLabs/enzyme-matchers/tree/master/packages/jest-enzyme">jest-enzyme</a>，让语法易懂简洁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.test.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> Enzyme, &#123; shallow &#125; <span class="keyword">from</span> <span class="string">'enzyme'</span>;</span><br><span class="line"><span class="keyword">import</span> Adapter <span class="keyword">from</span> <span class="string">'enzyme-adapter-react-16'</span>;</span><br><span class="line">Enzyme.configure(&#123; <span class="attr">adapter</span>: <span class="keyword">new</span> Adapter() &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">it(<span class="string">'renders without crashing'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>)</span></span><br><span class="line"><span class="xml">  console.log(wrapper.debug())</span></span><br><span class="line"><span class="xml">  const container = wrapper.find('[data-test="container"]')</span></span><br><span class="line"><span class="xml">  expect(container.length).toBe(1)</span></span><br><span class="line"><span class="xml">  expect(container.prop('title')).toBe('laibh')</span></span><br><span class="line"><span class="xml">  // 等同上面两句</span></span><br><span class="line"><span class="xml">  expect(container).toExist()</span></span><br><span class="line"><span class="xml">  expect(container).toHaveProp('title', 'laibh')</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure><p>别忘记在 <code>jest.config.js</code>里面进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    setupFilesAfterEnv: [<span class="string">'./node_modules/jest-enzyme/lib/index.js'</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开发-Header-组件-1"><a href="#开发-Header-组件-1" class="headerlink" title="开发 Header 组件"></a>开发 Header 组件</h4><p>同样测试先行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'../../index'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; shallow &#125; <span class="keyword">from</span> <span class="string">'enzyme'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapper;</span><br><span class="line"><span class="keyword">let</span> inputElem;</span><br><span class="line">describe(<span class="string">'测试 Header 组件'</span>, () =&gt; &#123;</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span>)</span></span><br><span class="line"><span class="xml">    inputElem = wrapper.find('[data-test="input"]')</span></span><br><span class="line"><span class="xml">  &#125;)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('正常渲染', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    expect(wrapper).toMatchSnapshot()</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('包含一个 input', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    expect(inputElem).toExist()</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('input初始化内容应该为空', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    expect(inputElem.prop('value')).toBe('')</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('当用户输入时，input内容会跟着变化', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    const value = '哈哈哈'</span></span><br><span class="line"><span class="xml">    inputElem.simulate('change', &#123;</span></span><br><span class="line"><span class="xml">      target: &#123;</span></span><br><span class="line"><span class="xml">        value</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml">    expect(wrapper.state('value')).toBe(value)</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('当用户输入后，键入回车，如果 input 没有内容，则不操作', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    const fn = jest.fn();</span></span><br><span class="line">    const wrapper = shallow(&lt;Header addUndoItem=&#123;fn&#125; /&gt;)</span><br><span class="line">    wrapper.setState(&#123; value: '' &#125;)</span><br><span class="line">    const inputElem = wrapper.find('[data-test="input"]')</span><br><span class="line">    inputElem.simulate('keyUp', &#123;</span><br><span class="line">      keyCode: 13</span><br><span class="line">    &#125;)</span><br><span class="line">    expect(fn).not.toBeCalled()</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it('当用户输入后，键入回车，如果 input 有内容，addUndoItem应该被调用,然后input被清空', () =&gt; &#123;</span><br><span class="line">    const fn = jest.fn();</span><br><span class="line">    const wrapper = shallow(&lt;Header addUndoItem=&#123;fn&#125; /&gt;)</span><br><span class="line">    const value = 'haha';</span><br><span class="line">    wrapper.setState(&#123; value &#125;)</span><br><span class="line">    const inputElem = wrapper.find('[data-test="input"]')</span><br><span class="line">    inputElem.simulate('keyUp', &#123;</span><br><span class="line">      keyCode: 13</span><br><span class="line">    &#125;)</span><br><span class="line">    expect(fn).toBeCalled()</span><br><span class="line">    expect(fn).toBeCalledWith(value)</span><br><span class="line">    const newInputElem = wrapper.find('[data-test="input"]')</span><br><span class="line">    expect(newInputElem.prop('value')).toBe('')</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>根据测试写代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./index.less'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputKeyUp = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">const</span> &#123; addUndoItem &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">if</span> (e.keyCode === <span class="number">13</span> &amp;&amp; value) &#123;</span><br><span class="line">      addUndoItem(value)</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">value</span>: <span class="string">''</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">value</span>: e.target.value &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;styles.header&#125;&gt;</span><br><span class="line">        &lt;div className=&#123;styles.headerContent&#125;&gt;</span><br><span class="line">          TodoList</span><br><span class="line">        &lt;input</span><br><span class="line">            className=&#123;styles.headerInput&#125;</span><br><span class="line">            data-test=<span class="string">'input'</span></span><br><span class="line">            value=&#123;value&#125;</span><br><span class="line">            onChange=&#123;<span class="keyword">this</span>.handleInputChange&#125;</span><br><span class="line">            onKeyUp=&#123;<span class="keyword">this</span>.handleInputKeyUp&#125;</span><br><span class="line">            placeholder=<span class="string">'Add Todo'</span></span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Header;</span><br></pre></td></tr></table></figure><h3 id="TDD-小结"><a href="#TDD-小结" class="headerlink" title="TDD 小结"></a>TDD 小结</h3><p>优势：代码质量提高</p><p><code>单元测试</code></p><p>测试覆盖率高，业务耦合度高，代码量大，过于独立</p><h2 id="BDD（行为驱动开发）"><a href="#BDD（行为驱动开发）" class="headerlink" title="BDD（行为驱动开发）"></a>BDD（行为驱动开发）</h2><p>全称：Behavior Driven Development</p><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue integration/todoList </span></span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'../../TodoList'</span></span><br><span class="line"></span><br><span class="line">  it(<span class="string">`</span></span><br><span class="line"><span class="string">    1.用户会在 header输入框输入内容</span></span><br><span class="line"><span class="string">    2.用户会点击回车按钮</span></span><br><span class="line"><span class="string">    3.列表项应该增加用户输入内容的列表项</span></span><br><span class="line"><span class="string">  `</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">TodoList</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">      const inputElem = wrapper.findAll('[data-test="header-input"]').at(0)</span></span><br><span class="line"><span class="xml">      const content = 'haha'</span></span><br><span class="line"><span class="xml">      inputElem.setValue(content)</span></span><br><span class="line"><span class="xml">      inputElem.trigger('change')</span></span><br><span class="line"><span class="xml">      inputElem.trigger('keyup.enter')</span></span><br><span class="line"><span class="xml">      const listItems = wrapper.findAll('[data-test="list-item"]').at(0)</span></span><br><span class="line"><span class="xml">      expect(listItems.length).toBe(1)</span></span><br><span class="line"><span class="xml">      expect(listItems.at(0).text()).toContain(content)</span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// react integration/todoList </span></span><br><span class="line"><span class="xml">import React from 'react';</span></span><br><span class="line"><span class="xml">import &#123; mount &#125; from 'enzyme';</span></span><br><span class="line"><span class="xml">import TodoList from './../../index';</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">describe('集成测试：TodoList', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">  let wrapper;</span></span><br><span class="line"><span class="xml">  beforeEach(() =&gt; &#123;</span></span><br><span class="line"><span class="xml">    wrapper = mount(<span class="tag">&lt;<span class="name">TodoList</span> /&gt;</span>)</span></span><br><span class="line"><span class="xml">  &#125;)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it(`</span></span><br><span class="line"><span class="xml">  1.用户会在 header输入框输入内容</span></span><br><span class="line"><span class="xml">  2.用户会点击回车按钮</span></span><br><span class="line"><span class="xml">  3.列表项应该增加用户输入内容的列表项</span></span><br><span class="line"><span class="xml">  `, () =&gt; &#123;</span></span><br><span class="line"><span class="xml">      const value = 'haha'</span></span><br><span class="line"><span class="xml">      const headerInput = wrapper.find('[data-test="header-input"]')</span></span><br><span class="line"><span class="xml">      headerInput.simulate('change', &#123;</span></span><br><span class="line"><span class="xml">        target: &#123;</span></span><br><span class="line"><span class="xml">          value</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      &#125;)</span></span><br><span class="line"><span class="xml">      // 按下回车键，keyCode为13</span></span><br><span class="line"><span class="xml">      headerInput.simulate('keyUp', &#123;</span></span><br><span class="line"><span class="xml">        keyCode: 13</span></span><br><span class="line"><span class="xml">      &#125;)</span></span><br><span class="line"><span class="xml">      // undoListItem</span></span><br><span class="line"><span class="xml">      const listItems = wrapper.find('[data-test="list-item"]')</span></span><br><span class="line"><span class="xml">      expect(listItems.length).toBe(1)</span></span><br><span class="line"><span class="xml">      expect(listItems.at(0).text()).toContain(value)</span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml">&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="TDD-与-BDD-比较"><a href="#TDD-与-BDD-比较" class="headerlink" title="TDD 与 BDD 比较"></a>TDD 与 BDD 比较</h3><p><strong>TDD</strong></p><ol><li>先写测试再写代码</li><li>一般结合单元测试使用，是白盒测试</li><li>测试重点在代码</li><li>安全感低</li><li>速度快</li></ol><p><strong>BDD</strong></p><ol><li>先写代码再写测试</li><li>一般结合集成测试使用，是黑盒测试</li><li>测试重点在 UI (DOM)</li><li>安全感高</li><li>速度慢</li></ol><h3 id="Redux相关测试"><a href="#Redux相关测试" class="headerlink" title="Redux相关测试"></a>Redux相关测试</h3><p>增加 redux 在项目</p><p><code>createStore</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/store/createStore</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; reducer <span class="keyword">as</span> todoReducer &#125; <span class="keyword">from</span> <span class="string">'../containers/TodoList/store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  todo: todoReducer</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__());</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><p><code>store/actions.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CHANGE_INPUT_VALUE &#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> changeInputValue = <span class="function"><span class="params">value</span> =&gt;</span> (&#123;</span><br><span class="line">  type: CHANGE_INPUT_VALUE,</span><br><span class="line">  value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>store/constants.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CHANGE_INPUT_VALUE = <span class="string">'CHANGE_INPUT_VALUE'</span></span><br></pre></td></tr></table></figure><p><code>store/reducer.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CHANGE_INPUT_VALUE &#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  inputValue: <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = initialState, action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> CHANGE_INPUT_VALUE:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        inputValue: action.value</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>store/index.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./actions'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; reducer, actions &#125;</span><br></pre></td></tr></table></figure><p><code>TodoList/index.js</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'./../../components/Header/index'</span>;</span><br><span class="line"><span class="keyword">import</span> UndoList <span class="keyword">from</span> <span class="string">'./../../components/UndoList/index'</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./index.less'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      undoList: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handledeleteItem = <span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; undoList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">const</span> newList = undoList.filter(<span class="function">(<span class="params">item, itemIndex</span>) =&gt;</span> itemIndex !== index)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">undoList</span>: newList &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleStatusChange = <span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; undoList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="comment">// undoList.forEach((item, itemIndex) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   if (itemIndex === index) &#123;</span></span><br><span class="line">    <span class="comment">//     Object.assign(item, &#123; status: 'input' &#125;)</span></span><br><span class="line">    <span class="comment">//     return;</span></span><br><span class="line">    <span class="comment">//   &#125; Object.assign(item, &#123; status: 'div' &#125;)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="keyword">const</span> newList = undoList.map(<span class="function">(<span class="params">item, itemIndex</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (itemIndex === index) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          ...item,</span><br><span class="line">          status: <span class="string">'input'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">return</span> &#123;</span><br><span class="line">        ...item,</span><br><span class="line">        status: <span class="string">'div'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">undoList</span>: newList &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleBlur = <span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; undoList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">const</span> newList = undoList.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...item,</span><br><span class="line">        status: <span class="string">'div'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">undoList</span>: newList &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputValue = <span class="function">(<span class="params">index, value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; undoList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">const</span> newList = undoList.map(<span class="function">(<span class="params">item, itemIndex</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (itemIndex === index) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          ...item,</span><br><span class="line">          value</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">return</span> &#123;</span><br><span class="line">        ...item,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">undoList</span>: newList &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  addUndoItem = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; undoList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      undoList: [...undoList, &#123;</span><br><span class="line">        status: <span class="string">'div'</span>,</span><br><span class="line">        value</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; undoList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;styles.todoList&#125;&gt;</span><br><span class="line">        &lt;Header addUndoItem=&#123;<span class="keyword">this</span>.addUndoItem&#125; /&gt;</span><br><span class="line">        &lt;UndoList</span><br><span class="line">          list=&#123;undoList&#125;</span><br><span class="line">          deleteItem=&#123;<span class="keyword">this</span>.handledeleteItem&#125;</span><br><span class="line">          changeStatus=&#123;<span class="keyword">this</span>.handleStatusChange&#125;</span><br><span class="line">          changeBlur=&#123;<span class="keyword">this</span>.handleBlur&#125;</span><br><span class="line">          valueChange=&#123;<span class="keyword">this</span>.handleInputValue&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default TodoList;</span></span><br></pre></td></tr></table></figure><p><code>src/index.js</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/createStore'</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render((</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">), document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><p>然后修改集成测试的测试用例</p><p><code>src/containers/TodoList/__test__/integration/TodoList.test.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'enzyme'</span>;</span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'./../../index'</span>;</span><br><span class="line"><span class="comment">// 增加的内容</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./../../../../store/createStore'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'集成测试：TodoList'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> wrapper;</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    wrapper = mount(</span><br><span class="line">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;TodoList /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  it(`</span></span><br><span class="line"><span class="regexp">  1.用户会在 header输入框输入内容</span></span><br><span class="line"><span class="regexp">  2.用户会点击回车按钮</span></span><br><span class="line"><span class="regexp">  3.列表项应该增加用户输入内容的列表项</span></span><br><span class="line"><span class="regexp">  `, () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      const value = 'haha'</span></span><br><span class="line"><span class="regexp">      const headerInput = wrapper.find('[data-test="header-input"]')</span></span><br><span class="line"><span class="regexp">      headerInput.simulate('change', &#123;</span></span><br><span class="line"><span class="regexp">        target: &#123;</span></span><br><span class="line"><span class="regexp">          value</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">      &#125;)</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 按下回车键，keyCode为13</span></span><br><span class="line"><span class="regexp">      headerInput.simulate('keyUp', &#123;</span></span><br><span class="line"><span class="regexp">        keyCode: 13</span></span><br><span class="line"><span class="regexp">      &#125;)</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ undoListItem</span></span><br><span class="line"><span class="regexp">      const listItems = wrapper.find('[data-test="list-item"]')</span></span><br><span class="line"><span class="regexp">      expect(listItems.length).toBe(1)</span></span><br><span class="line"><span class="regexp">      expect(listItems.at(0).text()).toContain(value)</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="异步代码"><a href="#异步代码" class="headerlink" title="异步代码"></a>异步代码</h3><h4 id="compontDidMount"><a href="#compontDidMount" class="headerlink" title="compontDidMount"></a>compontDidMount</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        data:[</span></span><br><span class="line"><span class="comment">            &#123;status:'div',value:'haha'&#125;,</span></span><br><span class="line"><span class="comment">        ],</span></span><br><span class="line"><span class="comment">        success:true</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    axios.get(<span class="string">'/undoList.json'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            undoList:res.data</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 模拟函数</p><p><code>src/__mock__/axios.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockUndoList = &#123;</span><br><span class="line">    data:[&#123;</span><br><span class="line">        status:<span class="string">'div'</span>,<span class="attr">value</span>:<span class="string">'haha'</span></span><br><span class="line">    &#125;],</span><br><span class="line">    success:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    get(url)&#123;</span><br><span class="line">        <span class="keyword">if</span>(url === <span class="string">'/undoList.json'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">                resolve(mockUndoList)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">`</span></span><br><span class="line"><span class="string">1.用户打开页面</span></span><br><span class="line"><span class="string">2.应该展示接口返回的数据</span></span><br><span class="line"><span class="string">`</span>,(done)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(</span><br><span class="line">        &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">            &lt;TodoList /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 解决数据异步问题</span></span><br><span class="line"><span class="regexp">      setTimeout(()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">          wrapper.update();</span></span><br><span class="line"><span class="regexp">          const listItems = wrapper.find('[data-test="list-item"]')</span></span><br><span class="line"><span class="regexp">          expect(listItems.length).toBe(1)   </span></span><br><span class="line"><span class="regexp">          done()</span></span><br><span class="line"><span class="regexp">      &#125;,0)  </span></span><br><span class="line"><span class="regexp">        </span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ node的语法</span></span><br><span class="line"><span class="regexp">      process.nextTick(()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">          wrapper.update();</span></span><br><span class="line"><span class="regexp">          const listItems = wrapper.find('[data-test="list-item"]')</span></span><br><span class="line"><span class="regexp">          expect(listItems.length).toBe(1)   </span></span><br><span class="line"><span class="regexp">          done()        </span></span><br><span class="line"><span class="regexp">      &#125;)</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        data:[</span></span><br><span class="line"><span class="comment">            &#123;status:'div',value:'haha'&#125;,</span></span><br><span class="line"><span class="comment">        ],</span></span><br><span class="line"><span class="comment">        success:true</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        axios.get(<span class="string">'/undoList.json'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                undoList:res.data</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(e)</span><br><span class="line">        &#125;)        </span><br><span class="line">    &#125;,<span class="number">5000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">jest.useFakeTimers();</span><br><span class="line"></span><br><span class="line">it(<span class="string">`</span></span><br><span class="line"><span class="string">1.用户打开页面</span></span><br><span class="line"><span class="string">2.应该展示接口返回的数据</span></span><br><span class="line"><span class="string">`</span>,(done)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(</span><br><span class="line">        &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">            &lt;TodoList /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">        </span></span><br><span class="line"><span class="regexp">      expect(setTimeout).toHaveBeenCalledTimes(1);</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 跑完所有 setTimeout 的时间</span></span><br><span class="line"><span class="regexp">      jest.runAllTimers();</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 解决数据异步问题</span></span><br><span class="line"><span class="regexp">      setTimeout(()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">          wrapper.update();</span></span><br><span class="line"><span class="regexp">          const listItems = wrapper.find('[data-test="list-item"]')</span></span><br><span class="line"><span class="regexp">          expect(listItems.length).toBe(1)   </span></span><br><span class="line"><span class="regexp">          done()</span></span><br><span class="line"><span class="regexp">      &#125;,0)  </span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><h2 id="前端自动化测试的优势"><a href="#前端自动化测试的优势" class="headerlink" title="前端自动化测试的优势"></a>前端自动化测试的优势</h2><ol><li>更好的代码组织，项目的可维护性增强</li><li>更小的bug 出现概率，尤其是回归测试中的 Bug</li><li>修改工程质量差的项目，更加安全</li><li>项目具备潜在的文档特性</li><li>扩广前端的知识面</li></ol><h2 id="Enzyme-1"><a href="#Enzyme-1" class="headerlink" title="Enzyme"></a>Enzyme</h2><p>Enzyme 是 React 的 JavaScript 测试应用程序，可以轻松测试 React Components 的输出。还可以在给定输出的情况下，遍历以某种方式模拟运行。</p><p>主要通过模仿 Jq 用于 DOM 操作和遍历</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="at-index"><a href="#at-index" class="headerlink" title="at(index)"></a>at(index)</h4><p><code>.at(index) =&gt; shallowWrapper</code></p><p>返回当前 wrapper 中指定索引的节点</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>)</span></span><br><span class="line"><span class="xml">expect(wrapper.find(foo).at(0).props().foo).toEqual('bar')</span></span><br></pre></td></tr></table></figure><h4 id="first"><a href="#first" class="headerlink" title="first()"></a>first()</h4><p><code>.first() =&gt; ShallowWrapper</code></p><p>将匹配节点集合减少到集合中的第一个，就像<code>.at(0)</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(wrapper.find(Foo).first().props().foo).to.equal(<span class="string">'bar'</span>);</span><br></pre></td></tr></table></figure><h4 id="last"><a href="#last" class="headerlink" title="last()"></a>last()</h4><p><code>.last() =&gt; ShallowWrapper</code></p><p>将匹配节点集减少到集合中的最后一个，就像<code>.at(length - 1)</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find(Foo).last().props().foo).to.equal('bar');</span></span><br></pre></td></tr></table></figure><h4 id="childAt-index"><a href="#childAt-index" class="headerlink" title="childAt(index)"></a>childAt(index)</h4><p><code>.childAt(index) =&gt; ShallowWrapper</code></p><p>返回指定索引的子节点</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">TodoList</span> <span class="attr">items</span>=<span class="string">&#123;items&#125;/</span>&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('ul').childAt(0).type).toEqual('li')</span></span><br></pre></td></tr></table></figure><h4 id="children-selector"><a href="#children-selector" class="headerlink" title="children([selector])"></a>children([selector])</h4><p><code>.children([selector]) =&gt; ShallowWrapper</code></p><p>返回父节点某个元素的所有子节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">TodoList</span> <span class="attr">items</span>=<span class="string">&#123;items&#125;/</span>&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('ul').children.length).toEqual(items.length)</span></span><br></pre></td></tr></table></figure><h4 id="closest-selector"><a href="#closest-selector" class="headerlink" title="closest(selector)"></a>closest(selector)</h4><p><code>.closest(selector) =&gt; shallowWrapper</code></p><p>通过遍历节点祖先，返回第一个相匹配的节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find(Foo).closest('.bar')).to.have.lengthOf(1);</span></span><br></pre></td></tr></table></figure><h4 id="contains-nodeOrNodes"><a href="#contains-nodeOrNodes" class="headerlink" title="contains(nodeOrNodes)"></a>contains(nodeOrNodes)</h4><p><code>.contains(nodeOrNodes) =&gt; Boolean</code></p><p>返回所有给定的react元素是否与渲染树中的元素匹配。它将通过检查期望元素是否与包装器元素具有相同的 props 并共享相同的值来确定包装器中的元素是否与预期元素匹配。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wrapper;</span><br><span class="line">wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div data-foo=<span class="string">"foo"</span> data-bar=<span class="string">"bar"</span>&gt;Hello&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">expect(wrapper.contains(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"bar"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">expect(wrapper.contains(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">false</span>);</span><br><span class="line">expect(wrapper.contains(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"bar"</span> <span class="attr">data-baz</span>=<span class="string">"baz"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">false</span>);</span><br><span class="line">expect(wrapper.contains(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"Hello"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">false</span>);</span><br><span class="line">expect(wrapper.contains(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"bar"</span> /&gt;</span>)).to.equal(false);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">wrapper = shallow((</span></span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span&gt;Hello&lt;/span&gt;</span><br><span class="line">    &lt;div&gt;Goodbye&lt;/div&gt;</span><br><span class="line">    &lt;span&gt;Again&lt;/span&gt;</span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">));</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">expect(wrapper.contains([</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>Goodbye<span class="tag">&lt;/<span class="name">div</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">])).to.equal(true);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">expect(wrapper.contains([</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>World<span class="tag">&lt;/<span class="name">div</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">])).to.equal(false);</span></span><br></pre></td></tr></table></figure><h4 id="containsAllMatchingElements-patternNodes"><a href="#containsAllMatchingElements-patternNodes" class="headerlink" title="containsAllMatchingElements(patternNodes)"></a>containsAllMatchingElements(patternNodes)</h4><p><code>.containsAllMatchingElements(patternNodes) =&gt; Boolean</code></p><p>返回所有给定的react元素是否<code>patternNodes</code>与包装器的渲染树中的元素匹配。每个元素<code>patternNodes</code>必须匹配一次或多次。匹配遵循规则<code>containsMatchingElement</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> style = &#123; <span class="attr">fontSize</span>: <span class="number">13</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span className=<span class="string">"foo"</span>&gt;Hello&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div style=&#123;style&#125;&gt;Goodbye&lt;/</span>div&gt;</span><br><span class="line">    &lt;span&gt;Again&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">expect(wrapper.containsAllMatchingElements([</span><br><span class="line">  &lt;span&gt;Hello&lt;<span class="regexp">/span&gt;,</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;Goodbye&lt;/</span>div&gt;,</span><br><span class="line">])).to.equal(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="containsAnyMatchingElements-patternNodes"><a href="#containsAnyMatchingElements-patternNodes" class="headerlink" title="containsAnyMatchingElements(patternNodes)"></a>containsAnyMatchingElements(patternNodes)</h4><p><code>.containsAnyMatchingElements(patternNodes) =&gt; Boolean</code></p><p>返回至少一个给定的react元素是否<code>patternNodes</code>与包装器的渲染树中的元素匹配。一个或多个元素<code>patternNodes</code>必须匹配一次或多次。匹配遵循规则<code>containsMatchingElement</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> style = &#123; <span class="attr">fontSize</span>: <span class="number">13</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span className=<span class="string">"foo"</span>&gt;Hello&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div style=&#123;style&#125;&gt;Goodbye&lt;/</span>div&gt;</span><br><span class="line">    &lt;span&gt;Again&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">expect(wrapper.containsAnyMatchingElements([</span><br><span class="line">  &lt;span&gt;Bonjour&lt;<span class="regexp">/span&gt;,</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;Goodbye&lt;/</span>div&gt;,</span><br><span class="line">])).to.equal(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="containsMatchingElement-patternNode"><a href="#containsMatchingElement-patternNode" class="headerlink" title="containsMatchingElement(patternNode)"></a>containsMatchingElement(patternNode)</h4><p><code>.containsMatchingElement(patternNode) =&gt; Boolean</code></p><p>返回<code>patternNode</code>react元素是否与渲染树中的任何元素匹配。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div data-foo=<span class="string">"foo"</span> data-bar=<span class="string">"bar"</span>&gt;Hello&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">expect(wrapper.containsMatchingElement(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"bar"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">true</span>);</span><br><span class="line">expect(wrapper.containsMatchingElement(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">expect(wrapper.containsMatchingElement(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"bar"</span> <span class="attr">data-baz</span>=<span class="string">"baz"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">false</span>);</span><br><span class="line">expect(wrapper.containsMatchingElement(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"Hello"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">false</span>);</span><br><span class="line">expect(wrapper.containsMatchingElement(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"bar"</span> /&gt;</span>)).to.equal(false);</span></span><br></pre></td></tr></table></figure><h4 id="context-key"><a href="#context-key" class="headerlink" title="context([key])"></a>context([key])</h4><p>返回包装器根节点的上下文哈希。可选地传入一个props，它将只返回该值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(</span><br><span class="line">  &lt;MyComponent /&gt;,</span><br><span class="line">  &#123; <span class="attr">context</span>: &#123; <span class="attr">foo</span>: <span class="number">10</span> &#125; &#125;,</span><br><span class="line">);</span><br><span class="line">expect(wrapper.context().foo).to.equal(<span class="number">10</span>);</span><br><span class="line">expect(wrapper.context(<span class="string">'foo'</span>)).to.equal(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="debug-options"><a href="#debug-options" class="headerlink" title="debug([options])"></a>debug([options])</h4><p><code>.debug([options]) =&gt; String</code></p><p>返回包装器的类似HTML的字符串，以便进行调试。当测试没有通过时，打印到控制台很有用。</p><p><code>options</code>（<code>Object</code>[可选]）：</p><ul><li><code>options.ignoreProps</code>：（<code>Boolean</code>[可选]）：是否应在结果字符串中省略props。默认情况下包含道具。</li><li><code>options.verbose</code>：（<code>Boolean</code>[可选]）：是否应该详细打印作为道具传递的数组和对象。</li></ul><h4 id="dive-options"><a href="#dive-options" class="headerlink" title="dive([options])"></a>dive([options])</h4><p><code>.dive([options]) =&gt; ShallowWrapper</code></p><p>浅呈现当前包装器的一个非DOM子项，并返回结果周围的包装器。它必须是单节点包装器，并且该节点必须是React组件。</p><p>注意：只能在单个非DOM组件元素节点的包装上调用，否则会引发错误。如果必须使用多个子节点对包装器进行浅包装，请使用<code>.shallow（）</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div className=<span class="string">"in-bar"</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function Foo() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Bar /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const wrapper = shallow(&lt;Foo /</span>&gt;);</span><br><span class="line">expect(wrapper.find(<span class="string">'.in-bar'</span>)).to.have.lengthOf(<span class="number">0</span>);</span><br><span class="line">expect(wrapper.find(Bar)).to.have.lengthOf(<span class="number">1</span>);</span><br><span class="line">expect(wrapper.find(Bar).dive().find(<span class="string">'.in-bar'</span>)).to.have.lengthOf(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="equals-node"><a href="#equals-node" class="headerlink" title="equals(node)"></a>equals(node)</h4><p><code>.equals(node) =&gt; Boolean</code></p><p>返回当前包装器根节点呈现树是否与传入的树相似</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line">expect(wrapper.equals(&lt;div className="foo bar" /&gt;)).to.equal(true);</span><br></pre></td></tr></table></figure><h4 id="every-selector"><a href="#every-selector" class="headerlink" title="every(selector)"></a>every(selector)</h4><p><code>.every(selector) =&gt; Boolean</code></p><p>返回包装器中的所有节点是否与提供的选择器匹配。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo qoo"</span> /&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo boo"</span> /&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo hoo"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp">expect(wrapper.find('.foo').every('.foo')).to.equal(true);</span></span><br><span class="line"><span class="regexp">expect(wrapper.find('.foo').every('.qoo')).to.equal(false);</span></span><br><span class="line"><span class="regexp">expect(wrapper.find('.foo').every('.bar')).to.equal(false);</span></span><br></pre></td></tr></table></figure><h4 id="everyWhere-fn"><a href="#everyWhere-fn" class="headerlink" title="everyWhere(fn)"></a>everyWhere(fn)</h4><p><code>.everyWhere(fn) =&gt; Boolean</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo qoo"</span> /&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo boo"</span> /&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo hoo"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp">expect(wrapper.find('.foo').everyWhere(n =&gt; n.hasClass('foo'))).to.equal(true);</span></span><br><span class="line"><span class="regexp">expect(wrapper.find('.foo').everyWhere(n =&gt; n.hasClass('qoo'))).to.equal(false);</span></span><br><span class="line"><span class="regexp">expect(wrapper.find('.foo').everyWhere(n =&gt; n.hasClass('bar'))).to.equal(false);</span></span><br></pre></td></tr></table></figure><h4 id="exists-selector"><a href="#exists-selector" class="headerlink" title="exists([selector])"></a>exists([selector])</h4><p><code>.exists([selector]) =&gt; Boolean</code></p><p>返回包装器中是否存在任何节点。或者，如果传入选择器，则该选择器是否在包装器中具有任何匹配项。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"some-class"</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.exists('.some-class')).to.equal(true);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('.other-class').exists()).to.equal(false);</span></span><br></pre></td></tr></table></figure><h4 id="filter-selector"><a href="#filter-selector" class="headerlink" title="filter(selector)"></a>filter(selector)</h4><p><code>.filter(selector) =&gt; ShallowWrapper</code></p><p>返回一个新的包装器，其中只包含与提供的选择器匹配的当前包装器的节点。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('.foo').filter('.bar')).to.have.lengthOf(1);</span></span><br></pre></td></tr></table></figure><h4 id="filterWhere-fn"><a href="#filterWhere-fn" class="headerlink" title="filterWhere(fn)"></a>filterWhere(fn)</h4><p><code>.filterWhere(fn) =&gt; ShallowWrapper</code></p><p>返回一个新的包装器，它只包含当前包装器的节点，当传递给提供的谓词函数时，返回true</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">const complexFoo = wrapper.find('.foo').filterWhere(n =&gt; typeof n.type() !== 'string');</span></span><br><span class="line"><span class="xml">expect(complexFoo).to.have.lengthOf(4);</span></span><br></pre></td></tr></table></figure><h4 id="find-selector"><a href="#find-selector" class="headerlink" title="find(selector)"></a>find(selector)</h4><p><code>.find(selector) =&gt; ShallowWrapper</code></p><p>查找当前包装器的呈现树中与提供的选择器匹配的每个节点。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'../components/Foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('.foo')).to.have.lengthOf(1);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('.bar')).to.have.lengthOf(3);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// compound selector</span></span><br><span class="line"><span class="xml">expect(wrapper.find('div.some-class')).to.have.lengthOf(3);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// CSS id selector</span></span><br><span class="line"><span class="xml">expect(wrapper.find('#foo')).to.have.lengthOf(1);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 组件</span></span><br><span class="line"><span class="xml">expect(wrapper.find(Foo)).to.have.lengthOf(1);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 组件显示名称</span></span><br><span class="line"><span class="xml">expect(wrapper.find('Foo')).to.have.lengthOf(1);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 对象属性选择器</span></span><br><span class="line"><span class="xml">expect(wrapper.find(&#123; prop: 'value' &#125;)).to.have.lengthOf(1);</span></span><br></pre></td></tr></table></figure><h4 id="findWhere-fn"><a href="#findWhere-fn" class="headerlink" title="findWhere(fn)"></a>findWhere(fn)</h4><p><code>.findWhere(fn) =&gt; ShallowWrapper</code></p><p>查找渲染树中为提供的谓词函数返回true的每个节点。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">const complexComponents = wrapper.findWhere(n =&gt; n.type() !== 'string');</span></span><br><span class="line"><span class="xml">expect(complexComponents).to.have.lengthOf(8);</span></span><br></pre></td></tr></table></figure><h4 id="forEach-fn"><a href="#forEach-fn" class="headerlink" title="forEach(fn)"></a>forEach(fn)</h4><p><code>.forEach(fn) =&gt; Self</code></p><p>迭代当前包装器的每个节点，并使用围绕作为第一个参数传入的相应节点的包装器执行提供的函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo bax"</span> /&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo bar"</span> /&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo baz"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">wrapper.find('.foo').forEach((node) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  expect(node.hasClass('foo')).to.equal(true);</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure><h4 id="get-index"><a href="#get-index" class="headerlink" title="get(index)"></a>get(index)</h4><p><code>.get(index) =&gt; ReactElement</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find(Foo).get(0).props.foo).to.equal('bar');</span></span><br></pre></td></tr></table></figure><h4 id="getWrappingComponent"><a href="#getWrappingComponent" class="headerlink" title="getWrappingComponent()"></a>getWrappingComponent()</h4><p><code>.getWrappingComponent() =&gt; ShallowWrapper</code></p><p>如果<code>wrappingComponent</code>传入了a <code>options</code>，则此方法返回<code>ShallowWrapper</code>渲染的周围<code>wrappingComponent</code>。这<code>ShallowWrapper</code>可以用来更新<code>wrappingComponent</code> props，state等。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Router &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./my/app/store'</span>;</span><br><span class="line"><span class="keyword">import</span> mockStore <span class="keyword">from</span> <span class="string">'./my/app/mockStore'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyProvider</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; children, customStore &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;customStore || store&#125;&gt;</span><br><span class="line">      &lt;Router&gt;</span><br><span class="line">        &#123;children&#125;</span><br><span class="line">      &lt;<span class="regexp">/Router&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">MyProvider.propTypes = &#123;</span><br><span class="line">  children: PropTypes.node,</span><br><span class="line">  customStore: PropTypes.shape(&#123;&#125;),</span><br><span class="line">&#125;;</span><br><span class="line">MyProvider.defaultProps = &#123;</span><br><span class="line">  children: <span class="literal">null</span>,</span><br><span class="line">  customStore: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>, &#123;</span></span><br><span class="line"><span class="xml">  wrappingComponent: MyProvider,</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line"><span class="xml">const provider = wrapper.getWrappingComponent();</span></span><br><span class="line"><span class="xml">provider.setProps(&#123; customStore: mockStore &#125;);</span></span><br></pre></td></tr></table></figure><h4 id="getElement"><a href="#getElement" class="headerlink" title="getElement()"></a>getElement()</h4><p><code>.getElement() =&gt; ReactElement</code></p><p>返回包装的ReactElement。如果当前包装器正在包装根组件，则返回根组件的最新呈现输出。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span /&gt;</span><br><span class="line">    &lt;span /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function MyComponent() &#123;</span></span><br><span class="line"><span class="regexp">  return element;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const wrapper = shallow(&lt;MyComponent /</span>&gt;);</span><br><span class="line">expect(wrapper.getElement()).to.equal(element);</span><br></pre></td></tr></table></figure><h4 id="getElements"><a href="#getElements" class="headerlink" title="getElements()"></a>getElements()</h4><p><code>.getElements() =&gt; Array&lt;ReactElement&gt;</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="xml"><span class="tag">&lt;<span class="name">span</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">const two = <span class="tag">&lt;<span class="name">span</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function Test() &#123;</span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;one&#125;</span><br><span class="line">      &#123;two&#125;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  );</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const wrapper = shallow(<span class="tag">&lt;<span class="name">Test</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('span').getElements()).to.deep.equal([one, two]);</span></span><br></pre></td></tr></table></figure><h4 id="hasClass-className"><a href="#hasClass-className" class="headerlink" title="hasClass(className)"></a>hasClass(className)</h4><p><code>.hasClass(className) =&gt; Boolean</code></p><p>返回包装节点是否具有<code>className</code>包含传入的类名称的prop。它必须是单节点包装器。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('.my-button').hasClass('disabled')).to.equal(true);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 正则</span></span><br><span class="line"><span class="xml">expect(wrapper.find('.my-button').hasClass(/(ComponentName)-(other)-(\d+)/)).to.equal(true);</span></span><br></pre></td></tr></table></figure><h4 id="hostNodes"><a href="#hostNodes" class="headerlink" title="hostNodes()"></a>hostNodes()</h4><p><code>.hostNodes() =&gt; ShallowWrapper</code></p><p>返回仅包含主机节点的新包装器。当使用<code>react-dom</code>，主机节点是HTML元素，而不是定制反应的组分</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;MyComponent className=<span class="string">"foo"</span> /&gt;</span><br><span class="line">    &lt;span className=<span class="string">"foo"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp">const twoNodes = wrapper.find('.foo');</span></span><br><span class="line"><span class="regexp">expect(twoNodes.hostNodes()).to.have.lengthOf(1);</span></span><br></pre></td></tr></table></figure><h4 id="html"><a href="#html" class="headerlink" title="html()"></a>html()</h4><p><code>.html() =&gt; String</code></p><p>返回整个当前渲染树（不仅仅是浅渲染部分）的渲染HTML标记的字符串。只能在单个节点的包装器上调用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"in-foo"</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function Bar() &#123;</span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line">    &lt;div className="in-bar"&gt;</span><br><span class="line">      &lt;Foo /&gt;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  );</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const wrapper = shallow(<span class="tag">&lt;<span class="name">Bar</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.html()).to.equal('<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"in-bar"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"in-foo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>');</span></span><br><span class="line"><span class="xml">expect(wrapper.find(Foo).html()).to.equal('<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"in-foo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>');</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const wrapper = shallow(<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>important<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.html()).to.equal('<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>important<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>');</span></span><br></pre></td></tr></table></figure><h4 id="instance"><a href="#instance" class="headerlink" title="instance()"></a>instance()</h4><p><code>.instance() =&gt; ReactComponent</code></p><p>返回单节点包装器节点的底层类实例; <code>this</code>在它的方法。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stateless</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Stateless<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stateful</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Stateful<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'shallow wrapper instance should be null'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">Stateless</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">  const instance = wrapper.instance();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  expect(instance).to.equal(null);</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">test('shallow wrapper instance should not be null', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">  const wrapper = shallow(<span class="tag">&lt;<span class="name">Stateful</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">  const instance = wrapper.instance();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  expect(instance).to.be.instanceOf(Stateful);</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure><h4 id="is-selector"><a href="#is-selector" class="headerlink" title="is(selector)"></a>is(selector)</h4><p><code>.is(selector) =&gt; Boolean</code></p><p>返回单个包装节点是否与提供的选择器匹配。它必须是单节点包装器。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"some-class other-class"</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.is('.some-class')).to.equal(true);</span></span><br></pre></td></tr></table></figure><h4 id="isEmptyRender"><a href="#isEmptyRender" class="headerlink" title="isEmptyRender()"></a>isEmptyRender()</h4><p><code>.isEmptyRender() =&gt; Boolean</code></p><p>返回包装器是否最终只呈现允许的假值：<code>false</code>或<code>null</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">Foo</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.isEmptyRender()).to.equal(true);</span></span><br></pre></td></tr></table></figure><h4 id="key"><a href="#key" class="headerlink" title="key()"></a>key()</h4><p><code>.key() =&gt; String</code></p><p>返回当前包装器节点的键值。它必须是单节点包装器。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &#123;[<span class="string">'foo'</span>, <span class="string">'bar'</span>].map(<span class="function"><span class="params">s</span> =&gt;</span> &lt;li key=&#123;s&#125;&gt;&#123;s&#125;&lt;<span class="regexp">/li&gt;)&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/u</span>l&gt;</span><br><span class="line">)).find(<span class="string">'li'</span>);</span><br><span class="line">expect(wrapper.at(<span class="number">0</span>).key()).to.equal(<span class="string">'foo'</span>);</span><br><span class="line">expect(wrapper.at(<span class="number">1</span>).key()).to.equal(<span class="string">'bar'</span>);</span><br></pre></td></tr></table></figure><h4 id="map-fn"><a href="#map-fn" class="headerlink" title="map(fn)"></a>map(fn)</h4><p><code>.map(fn) =&gt; Array&lt;Any&gt;</code></p><p>将当前节点数组映射到另一个数组。每个节点作为a传递<code>ShallowWrapper</code> 给map函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo"</span>&gt;bax&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div className="foo"&gt;bar&lt;/</span>div&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo"</span>&gt;baz&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> texts = wrapper.find(<span class="string">'.foo'</span>).map(<span class="function"><span class="params">node</span> =&gt;</span> node.text());</span><br><span class="line">expect(texts).to.eql([<span class="string">'bax'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>]);</span><br></pre></td></tr></table></figure><h4 id="matchesElement-patternNode"><a href="#matchesElement-patternNode" class="headerlink" title="matchesElement(patternNode)"></a>matchesElement(patternNode)</h4><p><code>.matchesElement(patternNode) =&gt; Boolean</code></p><p>回给定的react元素是否<code>patternNode</code>与包装器的渲染树匹配。它必须是单节点包装器，并且仅检查根节点。</p><p>这些<code>patternNode</code>行为就像一张通配符。为了匹配包装器中的节点：</p><ul><li>标签名称必须匹配</li><li>内容必须匹配：在文本节点中，前导和尾随空格被忽略，但中间空间不被忽略。子元素必须根据这些规则以递归方式匹配。</li><li><code>patternNode</code>props（attributes）必须出现在包装器的节点中，而不是相反。如果它们出现，它们的值必须匹配。</li><li><code>patternNode</code>样式CSS属性必须出现在包装器节点的样式中，而不是相反。如果它们出现，它们的值必须匹配。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button type=<span class="string">"button"</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125; className=<span class="string">"foo bar"</span>&gt;Hello&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const wrapper = shallow(&lt;MyComponent /</span>&gt;);</span><br><span class="line">expect(wrapper.matchesElement(<span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>)).to.equal(<span class="literal">true</span>);</span><br><span class="line">expect(wrapper.matchesElement(<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">"foo bar"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>)).to.equal(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="name"><a href="#name" class="headerlink" title="name()"></a>name()</h4><p><code>.name() =&gt; String|null</code></p><p>返回此包装器的当前节点的名称。如果它是复合组件，则这将是最顶层渲染组件的名称。如果它是本机DOM节点，则它将是标记名称的字符串。如果是的话<code>null</code>，那就是<code>null</code>。</p><p>返回名称的优先顺序是：<code>type.displayName</code>- &gt; <code>type.name</code>- &gt; <code>type</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.name()).to.equal('div');</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function SomeWrappingComponent() &#123;</span></span><br><span class="line"><span class="xml">  return <span class="tag">&lt;<span class="name">Foo</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">const wrapper = shallow(<span class="tag">&lt;<span class="name">SomeWrappingComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.name()).to.equal('Foo');</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">Foo.displayName = 'A cool custom name';</span></span><br><span class="line"><span class="xml">function SomeWrappingComponent() &#123;</span></span><br><span class="line"><span class="xml">  return <span class="tag">&lt;<span class="name">Foo</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">const wrapper = shallow(<span class="tag">&lt;<span class="name">SomeWrappingComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.name()).to.equal('A cool custom name');</span></span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li><a href="https://coding.imooc.com/class/372.html">前端要学的测试课 从Jest入门到TDD/BDD双实战</a></li><li><a href="https://jestjs.io/en/">jest 官方文档</a></li><li><a href="https://airbnb.io/enzyme/">enzyme官方文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端必备的测试&quot;&gt;&lt;a href=&quot;#前端必备的测试&quot; class=&quot;headerlink&quot; title=&quot;前端必备的测试&quot;&gt;&lt;/a&gt;前端必备的测试&lt;/h1&gt;&lt;p&gt;DellLee 老师的 &lt;a href=&quot;https://coding.imooc.com/clas
      
    
    </summary>
    
      <category term="测试" scheme="http://laibh.top/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试" scheme="http://laibh.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>工欲善其事，必先利其器(eslint+prettier)</title>
    <link href="http://laibh.top/2019-08-08-%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%EF%BC%8C%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8(eslint+prettier).html"/>
    <id>http://laibh.top/2019-08-08-工欲善其事，必先利其器(eslint+prettier).html</id>
    <published>2019-08-08T01:30:54.000Z</published>
    <updated>2020-07-11T03:24:57.643Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工欲善其事，必先利其器-eslint-prettier"><a href="#工欲善其事，必先利其器-eslint-prettier" class="headerlink" title="工欲善其事，必先利其器(eslint+prettier)"></a>工欲善其事，必先利其器(eslint+prettier)</h2><h3 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h3><p><a href="https://prettier.io/docs/en/index.html">官网</a></p><h4 id="什么叫Prettier？"><a href="#什么叫Prettier？" class="headerlink" title="什么叫Prettier？"></a>什么叫Prettier？</h4><p>Prettier是一个固定的代码格式化程序，支持：</p><ul><li>JavaScript，包括<a href="https://github.com/tc39/proposals/blob/master/finished-proposals.md">ES2017</a></li><li><a href="https://facebook.github.io/jsx/">JSX</a></li><li><a href="https://angular.io/">Angular</a></li><li><a href="https://vuejs.org/">Vue</a></li><li><a href="https://flow.org/">Flow</a></li><li><a href="https://www.typescriptlang.org/">TS</a></li><li>CSS，<a href="http://lesscss.org/">Less</a>和<a href="http://sass-lang.com/">SCSS</a></li><li><a href="https://en.wikipedia.org/wiki/HTML">HTML</a></li><li><a href="http://json.org/">JSON</a></li><li><a href="http://graphql.org/">GraphQL</a></li><li><a href="http://commonmark.org/">Markdown</a>，包括<a href="https://github.github.com/gfm/">GFM</a>和<a href="https://mdxjs.com/">MDX</a></li><li><a href="http://yaml.org/">YAML</a></li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> yarn</span><br><span class="line">yarn add prettier --dev --exact</span><br><span class="line"><span class="meta">#</span> 全局</span><br><span class="line">yarn global add prettier</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> npm</span><br><span class="line">npm install --save-dev --save-exact prettier</span><br><span class="line"><span class="meta">#</span> 全局</span><br><span class="line">npm install --global prettier</span><br></pre></td></tr></table></figure><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 排版宽度,即每行最大宽度，默认值是80</span><br><span class="line">  "printWidth":100,</span><br><span class="line">  // 制表符宽度，每个层级缩进几个空格，默认值为2</span><br><span class="line">  "tabWidth": 2,</span><br><span class="line">  // 是否使用 tab 替代 space 为单位缩进，默认值为false</span><br><span class="line">  "useTabs": false,</span><br><span class="line">  // 分号，句尾是否自动补全分号，默认为true</span><br><span class="line">  "semi": true,</span><br><span class="line">  // 启用双引号，不启用单引号,默认为true</span><br><span class="line">  "singleQuote": true,</span><br><span class="line">  // 在 JSX 文件中使用单引号替代双引号，默认为 false</span><br><span class="line">  "jsxSingleQuote": true,</span><br><span class="line">  // 为多行数组的非末尾添加逗号（单行数组不需要逗号），数值：none(不添加逗号)、es5(在ES5中生效的逗号，对象数组等)，all(任何可以添加逗号的地方)</span><br><span class="line">  "trailingComma": "es5",</span><br><span class="line">  // 括号空格，在对象字面量和括号之间添加空格，默认为 true</span><br><span class="line">  "bracketSpacing": true,</span><br><span class="line">  // 将多行 JSX 元素的 &gt; 放置于最后一行的末尾，而非换行。默认为 false</span><br><span class="line">  "jsxBracketSameLine": false,</span><br><span class="line">  // 箭头函数圆括号，默认为 avoid(在可以消除的情况下，消除括号)，always(一直保留括号)</span><br><span class="line">  "arrowParens": "avoid",</span><br><span class="line">  "overrides": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"files"</span>: <span class="string">".prettierrc"</span>,</span><br><span class="line">      <span class="attr">"options"</span>: &#123; <span class="attr">"parser"</span>: <span class="string">"json"</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h3><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><p>命名必须传递足够的信息。<code>fetchUserInfoAsync</code>比<code>getData</code>更加具体</p><p><strong>命名基础</strong></p><h3 id="半自动构建"><a href="#半自动构建" class="headerlink" title="半自动构建"></a>半自动构建</h3><h4 id="husky"><a href="#husky" class="headerlink" title="husky"></a>husky</h4><p>Husky 可以阻止无效的 <code>git commit</code>、<code>git push</code>以及其他woff行为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install husky --save-dev</span><br></pre></td></tr></table></figure><h4 id="lint-staged"><a href="#lint-staged" class="headerlink" title="lint-staged"></a>lint-staged</h4><p>针对暂存的git文件运行linters并且不要让💩滑入你的代码库！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install lint-staged --save-dev</span><br></pre></td></tr></table></figure><h4 id="commitlint"><a href="#commitlint" class="headerlink" title="commitlint"></a>commitlint</h4><p>规范 <code>commit message</code>,便于自动生成 <code>CHANGELOG</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install commitlint @commitlint/cli @commitlint/config-conventional --save-dev</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commitlint.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  extends: [<span class="string">"@commitlint/config-conventional"</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">"type-enum"</span>: [</span><br><span class="line">      <span class="number">2</span>,</span><br><span class="line">      <span class="string">"always"</span>,</span><br><span class="line">      [<span class="string">"feat"</span>, <span class="string">"fix"</span>, <span class="string">"docs"</span>, <span class="string">"style"</span>, <span class="string">"refactor"</span>, <span class="string">"test"</span>, <span class="string">"chore"</span>, <span class="string">"revert"</span>]</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"subject-full-stop"</span>: [<span class="number">0</span>, <span class="string">"never"</span>],</span><br><span class="line">    <span class="string">"subject-case"</span>: [<span class="number">0</span>, <span class="string">"never"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * feat：新功能（feature）</span></span><br><span class="line"><span class="comment"> * fix：修补bug</span></span><br><span class="line"><span class="comment"> * docs：文档（documentation）</span></span><br><span class="line"><span class="comment"> * style： 格式（不影响代码运行的变动）</span></span><br><span class="line"><span class="comment"> * refactor：重构（即不是新增功能，也不是修改bug的代码变动）</span></span><br><span class="line"><span class="comment"> * test：增加测试</span></span><br><span class="line"><span class="comment"> * chore：构建过程或辅助工具的变动</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="conventional-changelog"><a href="#conventional-changelog" class="headerlink" title="conventional-changelog"></a>conventional-changelog</h4><p>自动生成 <code>CHANGELOG</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install conventional-changelog conventional-changelog-cli --save-dev</span><br></pre></td></tr></table></figure><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"concurrently \"node scripts/start.js\" \"npm run mock\""</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"node scripts/build.js"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"node scripts/test.js"</span>,</span><br><span class="line">    <span class="attr">"eslint"</span>: <span class="string">"eslint --fix **/*.js"</span>,</span><br><span class="line">    <span class="attr">"prettier"</span>: <span class="string">"prettier --write ./src/**/**/**/*"</span>,</span><br><span class="line">    <span class="attr">"mock"</span>: <span class="string">"json-server --watch db.json --port 3004"</span>,</span><br><span class="line">    <span class="attr">"changelog"</span>: <span class="string">"conventional-changelog -p angular -i CHANGELOG.md -s -r 0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"husky"</span>: &#123;</span><br><span class="line">    <span class="attr">"hooks"</span>: &#123;</span><br><span class="line">      <span class="attr">"pre-commit"</span>: <span class="string">"lint-staged"</span>,</span><br><span class="line">      <span class="attr">"commit-msg"</span>: <span class="string">"commitlint -E HUSKY_GIT_PARAMS"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"lint-staged"</span>: &#123;</span><br><span class="line">    <span class="attr">"src/**/*.&#123;jsx,txs,ts,js,json,css,md&#125;"</span>: [</span><br><span class="line">      <span class="string">"prettier --write ./src/**/**/**/*"</span>,</span><br><span class="line">      <span class="string">"eslint --fix **/*.js"</span>,</span><br><span class="line">      <span class="string">"git add"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"config"</span>: &#123;</span><br><span class="line">    <span class="attr">"commitizen"</span>: &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"cz-customizable"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="commit-amp-push"><a href="#commit-amp-push" class="headerlink" title="commit&amp;push"></a>commit&amp;push</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 当有新的改变</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 提交，输入不规范的提交信息，先校验代码， 提示不规范，并且不通过</span><br><span class="line">git commit -m "test"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 输入规范信息，规范自行百度，也可以从 commitlint.config.js中看出。运行钩子自动prettier，接着运行 eslint,没有报错则 git add，并开始校验提交信息是否规范，无误后顺利提交</span><br><span class="line">git commit -m "feat: add semi-automatic construction"</span><br><span class="line">husky &gt; pre-commit (node v10.15.3)</span><br><span class="line">Stashing changes... [started]</span><br><span class="line">Stashing changes... [skipped]</span><br><span class="line">→ No partially staged files found...</span><br><span class="line">Running tasks... [started]</span><br><span class="line">Running tasks for src/**/*.&#123;jsx,txs,ts,js,json,css,md&#125; [started]</span><br><span class="line">prettier --write ./src/**/**/**/* [started]</span><br><span class="line">prettier --write ./src/**/**/**/* [completed]</span><br><span class="line">eslint --fix **/*.js [started]</span><br><span class="line">eslint --fix **/*.js [completed]</span><br><span class="line">git add [started]</span><br><span class="line">git add [completed]</span><br><span class="line">Running tasks for src/**/*.&#123;jsx,txs,ts,js,json,css,md&#125; [completed]</span><br><span class="line">Running tasks... [completed]</span><br><span class="line">husky &gt; commit-msg (node v10.15.3)</span><br><span class="line">[master 9afdd76] test: lint-staged</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span> 推送到 orgin</span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 生成 changelog</span><br><span class="line">npm run changelog</span><br><span class="line"><span class="meta">&gt;</span> conventional-changelog -p angular -i CHANGELOG.md -s -r 0</span><br></pre></td></tr></table></figure><h3 id="CSS样式顺序"><a href="#CSS样式顺序" class="headerlink" title="CSS样式顺序"></a>CSS样式顺序</h3><p>相关属性应该为一组，可以以下面的样式为编写顺序</p><ul><li>Positioning</li><li>Box model</li><li>Typographic</li><li>Visual</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.declaration-order&#123;</span><br><span class="line">    <span class="comment">/* Positioning */</span></span><br><span class="line">    position: absolute;</span><br><span class="line">    top: <span class="number">0</span>;</span><br><span class="line">    right: <span class="number">0</span>;</span><br><span class="line">    bottom: <span class="number">0</span>;</span><br><span class="line">    left: <span class="number">0</span>;</span><br><span class="line">    z-index: <span class="number">100</span>;    </span><br><span class="line">    <span class="comment">/* Box model */</span></span><br><span class="line">    display:block;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">    width: <span class="number">100</span>px;</span><br><span class="line">    height: <span class="number">100</span>px;</span><br><span class="line">    padding: <span class="number">10</span>px;</span><br><span class="line">    border: 1px solid #666;</span><br><span class="line">    border-radius: <span class="number">5</span>px;</span><br><span class="line">    margin: <span class="number">10</span>px;</span><br><span class="line">    float: right;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    <span class="comment">/* Typographic */</span></span><br><span class="line">    font: normal <span class="number">12</span>px <span class="string">'Helvetica Neue'</span>,sans-serif;</span><br><span class="line">    line-height: <span class="number">1.5</span>;</span><br><span class="line">    text-align: center;</span><br><span class="line">    <span class="comment">/* Visual */</span></span><br><span class="line">    background-color: #333;</span><br><span class="line">    color: #fff;</span><br><span class="line">    opacity: <span class="number">0.8</span>;</span><br><span class="line">    <span class="comment">/* Other */</span></span><br><span class="line">    cursor: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ol><li><a href="http://taobaofed.org/blog/2017/01/05/writing-readable-code/">编写「可读」代码的实践</a></li><li><a href="https://imweb.io/topic/5a5cc753a192c3b460fce3fc">前端开发规范之命名规范、html规范、css规范、js规范</a></li><li><a href="https://prettier.io/docs/en/install.html">Prettier</a></li><li><a href="http://eslint.cn/docs/rules/">eslint</a></li><li><a href="https://github.com/airbnb/javascript">airbnb规范</a></li><li><a href="https://github.com/yannickcr/eslint-plugin-react/tree/1aab93d0e3e91f73accdfc3a59afbdaf97c0d08e/docs/rules">eslint-plugin-react</a></li><li><a href="https://github.com/AlloyTeam/eslint-config-alloy">eslint-config-alloy</a></li><li><a href="https://github.com/evcohen/eslint-plugin-jsx-a11y/tree/master/docs/rules">eslint-plugin-jsx-a11y</a></li><li><a href="https://www.npmjs.com/package/husky">husky</a></li><li><a href="https://www.npmjs.com/package/lint-staged">lint-staged</a></li><li><a href="https://commitlint.js.org/#/concepts-commit-conventions">commitlint</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工欲善其事，必先利其器-eslint-prettier&quot;&gt;&lt;a href=&quot;#工欲善其事，必先利其器-eslint-prettier&quot; class=&quot;headerlink&quot; title=&quot;工欲善其事，必先利其器(eslint+prettier)&quot;&gt;&lt;/a&gt;工欲善其
      
    
    </summary>
    
      <category term="规范" scheme="http://laibh.top/categories/%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="规范" scheme="http://laibh.top/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>从leetCode学习JavaScript数据结构与基础算法</title>
    <link href="http://laibh.top/2019-07-03-%E4%BB%8EleetCode%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.html"/>
    <id>http://laibh.top/2019-07-03-从leetCode学习JavaScript数据结构与基础算法.html</id>
    <published>2019-07-03T01:30:54.000Z</published>
    <updated>2020-07-11T03:24:57.639Z</updated>
    
    <content type="html"><![CDATA[<p>循序渐进，保持空杯</p><h2 id="从leetCode学习JavaScript数据结构与基础算法"><a href="#从leetCode学习JavaScript数据结构与基础算法" class="headerlink" title="从leetCode学习JavaScript数据结构与基础算法"></a>从leetCode学习JavaScript数据结构与基础算法</h2><p>简单算法：</p><p><code>字符串</code>、<code>数组</code>、<code>正则</code>、<code>排序</code>、<code>递归</code></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>反转字符串中的单词③</strong></p><p>给定一个字符串，需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序</p><p>实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入："Let's take LeetCode contest"</span><br><span class="line">输出："s'teL ekat edoCteeL tsetnoc"</span><br></pre></td></tr></table></figure><p>注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment">* @return &#123;string&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.字符串按空格进行分隔，数组的元素的先后顺序就是单词的顺序</span></span><br><span class="line">    <span class="comment">// 2.遍历数组的元素，也就是每个单词String，通过 split分隔转Array 同时用Array 自带的 reverse方法将每个单词数组分隔后产生的数组反转</span></span><br><span class="line">    <span class="comment">// 3.接着用join('')将单词数组中的每个数组拼凑成字符串</span></span><br><span class="line">    <span class="comment">// 4.最后将字符串单词数组拼凑为最终的字符串</span></span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">' '</span>).map(<span class="function"><span class="params">i</span>=&gt;</span>i.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)).join(<span class="string">' '</span>)</span><br><span class="line">    <span class="comment">// 或者用正则，匹配空格</span></span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="regexp">/\s/g</span>).map(<span class="function"><span class="params">i</span>=&gt;</span>i.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)).join(<span class="string">' '</span>)</span><br><span class="line">    <span class="comment">// 匹配单词(match)</span></span><br><span class="line">    <span class="keyword">return</span> s.match(<span class="regexp">/[\w']+/g</span>).map(<span class="function"><span class="params">i</span>=&gt;</span>i.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)).join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reverseByWord <span class="keyword">from</span> <span class="string">'../../code/string/lession1'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'reverseByWord:Let\'s take LeetCode contest'</span>, () =&gt; &#123;</span><br><span class="line">  expect(reverseByWord(<span class="string">"Let's take LeetCode contest"</span>)).toBe(<span class="string">"s'teL ekat edoCteeL tsetnoc"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>知识点：</p><p><code>String.prototype.split</code>、<code>String.prototype.match</code>、<code>Array.prototype.map</code>、<code>Array.prototype.reverse</code>、<code>Array.prototype.join</code></p><p>扩展：上面讲的是单个空格隔开，那如果不是当个空格呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样可以使用正则的贪婪匹配来解决</span></span><br><span class="line"><span class="keyword">const</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 或者用正则，匹配空格</span></span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="regexp">/\s+/g</span>).map(<span class="function"><span class="params">i</span>=&gt;</span>i.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)).join(<span class="string">' '</span>)</span><br><span class="line">    <span class="comment">// 匹配单词(match)</span></span><br><span class="line">    <span class="keyword">return</span> s.match(<span class="regexp">/[\w']+/g</span>).map(<span class="function"><span class="params">i</span>=&gt;</span>i.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)).join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>计数二进制子串</strong></p><p>给定一个字符串 <code>s</code>，计算具有相同数量 0 和 1的非空（连续）子符串的数量，并且这些子字符串中的所有 0 和 1 都是组合在一起的。</p><p>重复出现的子串要计算它们出现的次数。</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入："00110011"</span><br><span class="line">输出：6</span><br><span class="line">解释：有6个子串具有相同数量的连续1和0："0011","01","1100","10","0011"和"01"</span><br><span class="line">请注意，一些重复出现的子串要计算它们出现的次数</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; str</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (str) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 创建数据结构堆栈保存数据</span></span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">const</span> match = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> j = str.match(<span class="regexp">/^(0+|1+)/</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// j=(n个)0-&gt;o=(n个)1;j=(n个)1-&gt;o=(n个)0;</span></span><br><span class="line">    <span class="keyword">let</span> o = (j[<span class="number">0</span>] ^ <span class="number">1</span>).toString().repeat(j.length)</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`^(<span class="subst">$&#123;j&#125;</span><span class="subst">$&#123;o&#125;</span>)`</span>)</span><br><span class="line">    <span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">RegExp</span>.$<span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = str.length - <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 简单递归</span></span><br><span class="line">    <span class="keyword">let</span> sub = match(str.slice(i))</span><br><span class="line">    <span class="keyword">if</span> (sub) &#123;</span><br><span class="line">      result.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'countBinarySubstring(00110011)'</span>, () =&gt; &#123;</span><br><span class="line">  expect(countBinarySubstring(<span class="string">'00110011'</span>)).toEqual([<span class="string">'0011'</span>, <span class="string">'01'</span>, <span class="string">'1100'</span>, <span class="string">'10'</span>, <span class="string">'0011'</span>, <span class="string">'01'</span>])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'countBinarySubstring(10101)'</span>, () =&gt; &#123;</span><br><span class="line">  expect(countBinarySubstring(<span class="string">'10101'</span>)).toEqual([<span class="string">'10'</span>, <span class="string">'01'</span>, <span class="string">'10'</span>, <span class="string">'01'</span>])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>知识点：</p><p><code>发现规律</code>，<code>RegExp</code></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>电话号码的组合</strong></p><p>给定一个仅包含 <code>2-9</code>的字符串，返回它能表示的字母组合。给出数字到字母的映射如下（与电话按钮相同）。注意1不对应任何字母</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1[] 2[abc] 3[def]</span><br><span class="line">4[ghi] 5[jkl] 6[mno]</span><br><span class="line">7[pqrs] 8[tuv] 9[wxyz]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： "23"</span><br><span class="line">输出： ["ad","ae","af","bd","be","bf","cd","ce","cf"]</span><br></pre></td></tr></table></figure><p>说明：上面的答案是按字典排序的，可以任意选择答案输出的顺序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; digits</span></span><br><span class="line"><span class="comment"> * @return &#123;string[]&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (digits) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (digits.length &lt; <span class="number">1</span>) <span class="keyword">return</span> []</span><br><span class="line">  <span class="comment">// 建立电话号码键盘映射</span></span><br><span class="line">  <span class="keyword">const</span> map = [<span class="string">''</span>, <span class="number">1</span>, <span class="string">'abc'</span>, <span class="string">'def'</span>, <span class="string">'ghi'</span>, <span class="string">'jkl'</span>, <span class="string">'mno'</span>, <span class="string">'pqrs'</span>, <span class="string">'tuv'</span>, <span class="string">'wxyz'</span>]</span><br><span class="line">  <span class="keyword">if</span> (digits.length &lt; <span class="number">2</span>) <span class="keyword">return</span> map[digits].split(<span class="string">''</span>)</span><br><span class="line">  <span class="comment">// 将输入的digits 分隔成数组，234=&gt;[2,3,4]</span></span><br><span class="line">  <span class="keyword">const</span> num = digits.split(<span class="string">''</span>)</span><br><span class="line">  <span class="comment">// 保存键盘映射后的字母内容，如 23=&gt;['abc','def']</span></span><br><span class="line">  <span class="keyword">const</span> code = []</span><br><span class="line">  num.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    code.push(map[item])</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> comb = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 临时变量用来保存两个组合的结果</span></span><br><span class="line">    <span class="keyword">const</span> temp = []</span><br><span class="line">    <span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, ilen = arr[<span class="number">0</span>].length; i &lt; ilen; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, jlen = arr[<span class="number">1</span>].length; j &lt; jlen; j++) &#123;</span><br><span class="line">        temp.push(<span class="string">`<span class="subst">$&#123;arr[<span class="number">0</span>][i]&#125;</span><span class="subst">$&#123;arr[<span class="number">1</span>][j]&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去掉一开始遍历的前两个，替换为这两个循环后的结果</span></span><br><span class="line">    arr.splice(<span class="number">0</span>, <span class="number">2</span>, temp)</span><br><span class="line">    <span class="comment">// 当数组的长度大于1时递归</span></span><br><span class="line">    <span class="keyword">if</span> (arr.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      comb(arr)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回真正的结果</span></span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 开始递归运算</span></span><br><span class="line">  <span class="keyword">return</span> comb(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'letterCombinations(23)'</span>, () =&gt; &#123;</span><br><span class="line">  expect(letterCombinations(<span class="string">'23'</span>)).toEqual([<span class="string">'ad'</span>, <span class="string">'ae'</span>, <span class="string">'af'</span>, <span class="string">'bd'</span>, <span class="string">'be'</span>, <span class="string">'bf'</span>, <span class="string">'cd'</span>, <span class="string">'ce'</span>, <span class="string">'cf'</span>])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'letterCombinations(234)'</span>, () =&gt; &#123;</span><br><span class="line">  expect(letterCombinations(<span class="string">'234'</span>)).toEqual([</span><br><span class="line">    <span class="string">'adg'</span>, <span class="string">'adh'</span>, <span class="string">'adi'</span>,</span><br><span class="line">    <span class="string">'aeg'</span>, <span class="string">'aeh'</span>, <span class="string">'aei'</span>,</span><br><span class="line">    <span class="string">'afg'</span>, <span class="string">'afh'</span>, <span class="string">'afi'</span>,</span><br><span class="line">    <span class="string">'bdg'</span>, <span class="string">'bdh'</span>, <span class="string">'bdi'</span>,</span><br><span class="line">    <span class="string">'beg'</span>, <span class="string">'beh'</span>, <span class="string">'bei'</span>,</span><br><span class="line">    <span class="string">'bfg'</span>, <span class="string">'bfh'</span>, <span class="string">'bfi'</span>,</span><br><span class="line">    <span class="string">'cdg'</span>, <span class="string">'cdh'</span>, <span class="string">'cdi'</span>,</span><br><span class="line">    <span class="string">'ceg'</span>, <span class="string">'ceh'</span>, <span class="string">'cei'</span>,</span><br><span class="line">    <span class="string">'cfg'</span>, <span class="string">'cfh'</span>, <span class="string">'cfi'</span></span><br><span class="line">  ])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>知识点：</p><p><code>公式运算</code></p><p><strong>卡牌分组</strong></p><p>给定一副牌，每张牌上都写着一个整数。</p><p>此时，需要选定一个数字 <code>x</code>，使得可以将整部牌按下述规则分成 1 组或者更多：</p><ul><li>每组都有 <code>x</code> 张牌</li><li>组内所有的牌上都写着相同的整数</li></ul><p>仅当可选的 <code>x&gt;=2</code>时返回 <code>true</code></p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,4,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1],[2,2],[3,3],[4,4]</span><br></pre></td></tr></table></figure><p>提示：</p><ol><li><code>1 &lt;= deck.length &lt;= 10000</code></li><li><code>0 &lt;= deck[i] &lt; 10000</code></li></ol><p>知识点：</p><p><code>归并运算</code></p><p><strong>种花问题</strong></p><p>知识点：</p><p><code>筛选运算</code></p><p><strong>格雷编码</strong></p><p>知识点：</p><p><code>二进制运算</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;循序渐进，保持空杯&lt;/p&gt;
&lt;h2 id=&quot;从leetCode学习JavaScript数据结构与基础算法&quot;&gt;&lt;a href=&quot;#从leetCode学习JavaScript数据结构与基础算法&quot; class=&quot;headerlink&quot; title=&quot;从leetCode学习Java
      
    
    </summary>
    
      <category term="javaScript相关" scheme="http://laibh.top/categories/javaScript%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="javaScript数据结构与算法" scheme="http://laibh.top/tags/javaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>React源码浅析</title>
    <link href="http://laibh.top/2019-06-29-React%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90.html"/>
    <id>http://laibh.top/2019-06-29-React源码浅析.html</id>
    <published>2019-06-29T01:30:54.000Z</published>
    <updated>2020-07-11T03:24:57.639Z</updated>
    
    <content type="html"><![CDATA[<p>知其然知其所以然，框架工的自我尝试进阶</p><h2 id="React源码浅析"><a href="#React源码浅析" class="headerlink" title="React源码浅析"></a>React源码浅析</h2><p>知识点：</p><p><strong>React Api</strong></p><p><code>createElement</code>、<code>createContext</code>、<code>JSX=&gt;JS</code>、<code>ConcurrentMode</code>、<code>Ref</code>、<code>Component</code>、<code>Suspense</code>、<code>Hooks</code></p><p><strong>React 中的更新创建</strong></p><p><code>ReactDOM.render</code>、<code>Fiber</code>、<code>UpdateQueue</code>、<code>FiberRoot</code>、<code>Update</code>、<code>expirationTime</code></p><p><strong>Fiber Scheduler</strong></p><p><code>scheduleWork</code>、<code>batchedUpdates</code>、<code>performWork</code>、<code>performUnitOfWork</code>、<code>requestWork</code>、<code>react scheduler</code>、<code>renderRoot</code></p><p><strong>开始更新</strong></p><p><code>beginWork以及优化</code>、<code>各类组件的更新过程</code>、<code>调节子节点的过程</code></p><p><strong>完成各个节点的更新</strong></p><p><code>completeUnitOfWork</code>、<code>虚拟DOM对比</code>、<code>completeWork</code>、<code>错误捕获处理</code>、<code>unwindwork</code>、<code>完成整棵树更新</code></p><p><strong>提交更新</strong></p><p><code>commitRoot整体流程</code>、<code>开发时的帮助方法</code>、<code>提交快照</code>、<code>提交DOM插入</code>、<code>提交DOM更新</code>、<code>提交DOM删除</code>、<code>提交所有生命周期</code></p><p><strong>各功能的实现功能</strong></p><p><code>context的实现过程</code>、<code>ref的实现过程</code>、<code>hydrate的实现过程</code>、<code>React的事件体系</code></p><p><strong>Suspense</strong></p><p><code>更新优先级的概念</code>、<code>更新挂起的概念</code>、<code>Suspense组件更新</code>、<code>timeout处理</code>、<code>retry重新尝试渲染</code>、<code>lazy组件更新</code></p><p><strong>Hooks</strong></p><p><code>核心原理</code>、<code>useState</code>、<code>useEffect</code>、<code>useContent</code>、<code>其他Hooks API</code></p><h3 id="React-Api-相关"><a href="#React-Api-相关" class="headerlink" title="React Api 相关"></a>React Api 相关</h3><h4 id="React-js"><a href="#React-js" class="headerlink" title="React.js"></a>React.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const React = &#123;</span><br><span class="line">    Children:&#123;</span><br><span class="line">        map,</span><br><span class="line">        forEach,</span><br><span class="line">        count,</span><br><span class="line">        toArray,</span><br><span class="line">        only</span><br><span class="line">    &#125;,</span><br><span class="line">    createRef,</span><br><span class="line">    Component,</span><br><span class="line">    PureComponent,</span><br><span class="line">    createContext,</span><br><span class="line">    forWardRef,</span><br><span class="line">    lazy,</span><br><span class="line">    memo,</span><br><span class="line">    Fragment:REACT_FRAGMENT_TYPE,</span><br><span class="line">    StrictMode:REACT_STRICT_MODE_TYPE,</span><br><span class="line">    SuspenseLREACT_SUSPENSE_TYPE,</span><br><span class="line">    createElement:__DEV__?createElementWithValidation:createElement,</span><br><span class="line">    cloneElement:__DEV__?cloneElementWithValidation:cloneElement,</span><br><span class="line">    isValidElement:isValidElement,</span><br><span class="line">    version:ReactVersion,</span><br><span class="line">    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:ReactSharedInternals,</span><br><span class="line">&#125;</span><br><span class="line">if (enableStableConcurrentModeAPIs) &#123;</span><br><span class="line">  React.ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;</span><br><span class="line">  React.Profiler = REACT_PROFILER_TYPE;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  React.unstable_ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;</span><br><span class="line">  React.unstable_Profiler = REACT_PROFILER_TYPE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default React;</span><br></pre></td></tr></table></figure><h4 id="ReactElement-js"><a href="#ReactElement-js" class="headerlink" title="ReactElement.js"></a>ReactElement.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br></pre></td><td class="code"><pre><span class="line">// hasOwnProperty 方法返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是知否有指定的键）</span><br><span class="line">const hasOwnProperty = Object.prototype.hasOwnProperty;</span><br><span class="line">// 内建的props</span><br><span class="line">const RESERVED_PROPS = &#123;</span><br><span class="line">  key: true,</span><br><span class="line">  ref: true,</span><br><span class="line">  __self: true,</span><br><span class="line">  __source: true,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let specialPropKeyWarningShown, specialPropRefWarningShown;</span><br><span class="line">// 判断是否是合法的 ref</span><br><span class="line">function hasValidRef(config) &#123;</span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    if (hasOwnProperty.call(config, &apos;ref&apos;)) &#123;</span><br><span class="line">      /**</span><br><span class="line">      * getOwnPropertyDescriptor 返回指定对象上自有属性描述符（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</span><br><span class="line">      * get 方法。获取该属性的访问器函数（getter）。如果没有访问器，该值为 undefined</span><br><span class="line">      */</span><br><span class="line">      const getter = Object.getOwnPropertyDescriptor(config, &apos;ref&apos;).get;</span><br><span class="line">      if (getter &amp;&amp; getter.isReactWarning) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return config.ref !== undefined;</span><br><span class="line">&#125;</span><br><span class="line">// 判断是否是合法的 key</span><br><span class="line">function hasValidKey(config) &#123;</span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    if (hasOwnProperty.call(config, &apos;key&apos;)) &#123;</span><br><span class="line">      const getter = Object.getOwnPropertyDescriptor(config, &apos;key&apos;).get;</span><br><span class="line">      if (getter &amp;&amp; getter.isReactWarning) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return config.key !== undefined;</span><br><span class="line">&#125;</span><br><span class="line">// 定义了 key 不合法抛出的警告</span><br><span class="line">function defineKeyPropWarningGetter(props, displayName) &#123;</span><br><span class="line">  const warnAboutAccessingKey = function() &#123;</span><br><span class="line">    if (!specialPropKeyWarningShown) &#123;</span><br><span class="line">      specialPropKeyWarningShown = true;</span><br><span class="line">      warningWithoutStack(</span><br><span class="line">        false,</span><br><span class="line">        &apos;%s: `key` is not a prop. Trying to access it will result &apos; +</span><br><span class="line">          &apos;in `undefined` being returned. If you need to access the same &apos; +</span><br><span class="line">          &apos;value within the child component, you should pass it as a different &apos; +</span><br><span class="line">          &apos;prop. (https://fb.me/react-special-props)&apos;,</span><br><span class="line">        displayName,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  warnAboutAccessingKey.isReactWarning = true;</span><br><span class="line">  Object.defineProperty(props, &apos;key&apos;, &#123;</span><br><span class="line">    get: warnAboutAccessingKey,</span><br><span class="line">    configurable: true,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">// 定义了 ref 不合法抛出的警告</span><br><span class="line">function defineRefPropWarningGetter(props, displayName) &#123;</span><br><span class="line">  const warnAboutAccessingRef = function() &#123;</span><br><span class="line">    if (!specialPropRefWarningShown) &#123;</span><br><span class="line">      specialPropRefWarningShown = true;</span><br><span class="line">      warningWithoutStack(</span><br><span class="line">        false,</span><br><span class="line">        &apos;%s: `ref` is not a prop. Trying to access it will result &apos; +</span><br><span class="line">          &apos;in `undefined` being returned. If you need to access the same &apos; +</span><br><span class="line">          &apos;value within the child component, you should pass it as a different &apos; +</span><br><span class="line">          &apos;prop. (https://fb.me/react-special-props)&apos;,</span><br><span class="line">        displayName,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  warnAboutAccessingRef.isReactWarning = true;</span><br><span class="line">  Object.defineProperty(props, &apos;ref&apos;, &#123;</span><br><span class="line">    get: warnAboutAccessingRef,</span><br><span class="line">    configurable: true,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Factory method to create a new React element. This no longer adheres to</span><br><span class="line"> * the class pattern, so do not use new to call it. Also, no instanceof check</span><br><span class="line"> * will work. Instead test $$typeof field against Symbol.for(&apos;react.element&apos;) to check</span><br><span class="line"> * if something is a React Element.</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;*&#125; type</span><br><span class="line"> * @param &#123;*&#125; key</span><br><span class="line"> * @param &#123;string|object&#125; ref</span><br><span class="line"> * @param &#123;*&#125; self A *temporary* helper to detect places where `this` is</span><br><span class="line"> * different from the `owner` when React.createElement is called, so that we</span><br><span class="line"> * can warn. We want to get rid of owner and replace string `ref`s with arrow</span><br><span class="line"> * functions, and as long as `this` and owner are the same, there will be no</span><br><span class="line"> * change in behavior.</span><br><span class="line"> * @param &#123;*&#125; source An annotation object (added by a transpiler or otherwise)</span><br><span class="line"> * indicating filename, line number, and/or other information.</span><br><span class="line"> * @param &#123;*&#125; owner</span><br><span class="line"> * @param &#123;*&#125; props</span><br><span class="line"> * @internal</span><br><span class="line"> */</span><br><span class="line">const ReactElement = function(type, key, ref, self, source, owner, props) &#123;</span><br><span class="line">  const element = &#123;</span><br><span class="line">    // This tag allows us to uniquely identify this as a React Element</span><br><span class="line">    $$typeof: REACT_ELEMENT_TYPE,</span><br><span class="line"></span><br><span class="line">    // Built-in properties that belong on the element</span><br><span class="line">    type: type,</span><br><span class="line">    key: key,</span><br><span class="line">    ref: ref,</span><br><span class="line">    props: props,</span><br><span class="line"></span><br><span class="line">    // Record the component responsible for creating this element.</span><br><span class="line">    _owner: owner,</span><br><span class="line">  &#125;;</span><br><span class="line"> // 开发环境的一些内容</span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    // The validation flag is currently mutative. We put it on</span><br><span class="line">    // an external backing store so that we can freeze the whole object.</span><br><span class="line">    // This can be replaced with a WeakMap once they are implemented in</span><br><span class="line">    // commonly used development environments.</span><br><span class="line">    element._store = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // To make comparing ReactElements easier for testing purposes, we make</span><br><span class="line">    // the validation flag non-enumerable (where possible, which should</span><br><span class="line">    // include every environment we run tests in), so the test framework</span><br><span class="line">    // ignores it.</span><br><span class="line">    Object.defineProperty(element._store, &apos;validated&apos;, &#123;</span><br><span class="line">      configurable: false,</span><br><span class="line">      enumerable: false,</span><br><span class="line">      writable: true,</span><br><span class="line">      value: false,</span><br><span class="line">    &#125;);</span><br><span class="line">    // self and source are DEV only properties.</span><br><span class="line">    Object.defineProperty(element, &apos;_self&apos;, &#123;</span><br><span class="line">      configurable: false,</span><br><span class="line">      enumerable: false,</span><br><span class="line">      writable: false,</span><br><span class="line">      value: self,</span><br><span class="line">    &#125;);</span><br><span class="line">    // Two elements created in two different places should be considered</span><br><span class="line">    // equal for testing purposes and therefore we hide it from enumeration.</span><br><span class="line">    Object.defineProperty(element, &apos;_source&apos;, &#123;</span><br><span class="line">      configurable: false,</span><br><span class="line">      enumerable: false,</span><br><span class="line">      writable: false,</span><br><span class="line">      value: source,</span><br><span class="line">    &#125;);</span><br><span class="line">    if (Object.freeze) &#123;</span><br><span class="line">      Object.freeze(element.props);</span><br><span class="line">      Object.freeze(element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return element;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 创建并返回给定类型的新ReactElement。</span><br><span class="line"> * See https://reactjs.org/docs/react-api.html#createelement</span><br><span class="line"> */</span><br><span class="line">export function createElement(type, config, children) &#123;</span><br><span class="line">  let propName;</span><br><span class="line"></span><br><span class="line">  // Reserved names are extracted</span><br><span class="line">  const props = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  let key = null;</span><br><span class="line">  let ref = null;</span><br><span class="line">  let self = null;</span><br><span class="line">  let source = null;</span><br><span class="line"></span><br><span class="line">  if (config != null) &#123;</span><br><span class="line">    if (hasValidRef(config)) &#123;</span><br><span class="line">      ref = config.ref;</span><br><span class="line">    &#125;</span><br><span class="line">    if (hasValidKey(config)) &#123;</span><br><span class="line">      key = &apos;&apos; + config.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self = config.__self === undefined ? null : config.__self;</span><br><span class="line">    source = config.__source === undefined ? null : config.__source;</span><br><span class="line">    // 如果不是内建的props以及本身拥有的属性，将剩余的属性传入到新的props对象中</span><br><span class="line">    for (propName in config) &#123;        </span><br><span class="line">      if (</span><br><span class="line">        hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class="line">        !RESERVED_PROPS.hasOwnProperty(propName)</span><br><span class="line">      ) &#123;</span><br><span class="line">        props[propName] = config[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 子对象可以是多个参数，并且这些参数会传输到新分配的props对象上。</span><br><span class="line">  const childrenLength = arguments.length - 2;</span><br><span class="line">  if (childrenLength === 1) &#123;</span><br><span class="line">    props.children = children;</span><br><span class="line">  &#125; else if (childrenLength &gt; 1) &#123;</span><br><span class="line">    const childArray = Array(childrenLength);</span><br><span class="line">    for (let i = 0; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      childArray[i] = arguments[i + 2];</span><br><span class="line">    &#125;</span><br><span class="line">    if (__DEV__) &#123;</span><br><span class="line">      if (Object.freeze) &#123;</span><br><span class="line">        Object.freeze(childArray);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    props.children = childArray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 解析默认属性</span><br><span class="line">  if (type &amp;&amp; type.defaultProps) &#123;</span><br><span class="line">    const defaultProps = type.defaultProps;</span><br><span class="line">    for (propName in defaultProps) &#123;</span><br><span class="line">      if (props[propName] === undefined) &#123;</span><br><span class="line">        props[propName] = defaultProps[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    if (key || ref) &#123;</span><br><span class="line">      const displayName =</span><br><span class="line">        typeof type === &apos;function&apos;</span><br><span class="line">          ? type.displayName || type.name || &apos;Unknown&apos;</span><br><span class="line">          : type;</span><br><span class="line">      if (key) &#123;</span><br><span class="line">        defineKeyPropWarningGetter(props, displayName);</span><br><span class="line">      &#125;</span><br><span class="line">      if (ref) &#123;</span><br><span class="line">        defineRefPropWarningGetter(props, displayName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return ReactElement(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    ReactCurrentOwner.current,</span><br><span class="line">    props,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回一个生成给定类型的ReactElements的函数。（已废弃）</span><br><span class="line"> * See https://reactjs.org/docs/react-api.html#createfactory</span><br><span class="line"> */</span><br><span class="line">export function createFactory(type) &#123;</span><br><span class="line">  const factory = createElement.bind(null, type);</span><br><span class="line">  // Expose the type on the factory and the prototype so that it can be</span><br><span class="line">  // easily accessed on elements. E.g. `&lt;Foo /&gt;.type === Foo`.</span><br><span class="line">  // This should not be named `constructor` since this may not be the function</span><br><span class="line">  // that created the element, and it may not even be a constructor.</span><br><span class="line">  // Legacy hook: remove it</span><br><span class="line">  factory.type = type;</span><br><span class="line">  return factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function cloneAndReplaceKey(oldElement, newKey) &#123;</span><br><span class="line">  const newElement = ReactElement(</span><br><span class="line">    oldElement.type,</span><br><span class="line">    newKey,</span><br><span class="line">    oldElement.ref,</span><br><span class="line">    oldElement._self,</span><br><span class="line">    oldElement._source,</span><br><span class="line">    oldElement._owner,</span><br><span class="line">    oldElement.props,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  return newElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 以 element 元素为样板克隆并返回新的 React 元素</span><br><span class="line"> * See https://reactjs.org/docs/react-api.html#cloneelement</span><br><span class="line"> */</span><br><span class="line">export function cloneElement(element, config, children) &#123;</span><br><span class="line">  invariant(</span><br><span class="line">    !(element === null || element === undefined),</span><br><span class="line">    &apos;React.cloneElement(...): The argument must be a React element, but you passed %s.&apos;,</span><br><span class="line">    element,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  let propName;</span><br><span class="line"></span><br><span class="line">  // 复制原来的props</span><br><span class="line">  const props = Object.assign(&#123;&#125;, element.props);</span><br><span class="line"></span><br><span class="line">  // 提取内建props相关的值</span><br><span class="line">  let key = element.key;</span><br><span class="line">  let ref = element.ref;</span><br><span class="line">  // Self is preserved since the owner is preserved.</span><br><span class="line">  const self = element._self;</span><br><span class="line">  // Source is preserved since cloneElement is unlikely to be targeted by a transpiler, and the original source is probably a better indicator of the true owner.</span><br><span class="line">  const source = element._source;</span><br><span class="line"></span><br><span class="line">  // Owner will be preserved, unless ref is overridden</span><br><span class="line">  let owner = element._owner;</span><br><span class="line"></span><br><span class="line">  if (config != null) &#123;</span><br><span class="line">    if (hasValidRef(config)) &#123;</span><br><span class="line">      // Silently steal the ref from the parent.</span><br><span class="line">      ref = config.ref;</span><br><span class="line">      owner = ReactCurrentOwner.current;</span><br><span class="line">    &#125;</span><br><span class="line">    if (hasValidKey(config)) &#123;</span><br><span class="line">      key = &apos;&apos; + config.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Remaining properties override existing props</span><br><span class="line">    let defaultProps;</span><br><span class="line">    if (element.type &amp;&amp; element.type.defaultProps) &#123;</span><br><span class="line">      defaultProps = element.type.defaultProps;</span><br><span class="line">    &#125;</span><br><span class="line">    for (propName in config) &#123;</span><br><span class="line">      if (</span><br><span class="line">        hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class="line">        !RESERVED_PROPS.hasOwnProperty(propName)</span><br><span class="line">      ) &#123;</span><br><span class="line">        if (config[propName] === undefined &amp;&amp; defaultProps !== undefined) &#123;</span><br><span class="line">          // Resolve default props</span><br><span class="line">          props[propName] = defaultProps[propName];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          props[propName] = config[propName];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Children can be more than one argument, and those are transferred onto</span><br><span class="line">  // the newly allocated props object.</span><br><span class="line">  const childrenLength = arguments.length - 2;</span><br><span class="line">  if (childrenLength === 1) &#123;</span><br><span class="line">    props.children = children;</span><br><span class="line">  &#125; else if (childrenLength &gt; 1) &#123;</span><br><span class="line">    const childArray = Array(childrenLength);</span><br><span class="line">    for (let i = 0; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      childArray[i] = arguments[i + 2];</span><br><span class="line">    &#125;</span><br><span class="line">    props.children = childArray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return ReactElement(element.type, key, ref, self, source, owner, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 验证对象是否为ReactElement。</span><br><span class="line"> * See https://reactjs.org/docs/react-api.html#isvalidelement</span><br><span class="line"> * @param &#123;?object&#125; object</span><br><span class="line"> * @return &#123;boolean&#125; True if `object` is a ReactElement.</span><br><span class="line"> * @final</span><br><span class="line"> */</span><br><span class="line">export function isValidElement(object) &#123;</span><br><span class="line">  return (</span><br><span class="line">    typeof object === &apos;object&apos; &amp;&amp;</span><br><span class="line">    object !== null &amp;&amp;</span><br><span class="line">    object.$$typeof === REACT_ELEMENT_TYPE</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReactElement</code> 通过 <code>createElement</code> 创建的，传入三个参数：</p><ul><li><p>type（指代 <code>ReactElement</code>的类型）</p><ul><li>字符串。<code>&#39;div&#39;</code>等，被称为 <code>HostComponent</code></li><li>Class。继承自 <code>Component</code>或者 <code>PureComponent</code>的组件，称为 <code>ClassComponent</code></li><li>方法。<code>functinal Component</code></li><li>原生。<code>Fragment</code>、<code>AsyncModel</code>、<code>Symbol</code></li></ul></li><li><p>config</p></li><li>children</li></ul><p><code>ReactElement</code>只是一个用来承载信息的容器，里面有几个信息：</p><ul><li><code>type</code>，用来判断如何创建节点</li><li><code>key</code>和 <code>ref</code>这些特殊信息</li><li><code>props</code>新的属性内容</li><li><code>$$type</code>用于确定是否属于 <code>ReactElement</code></li></ul><h4 id="ReactBaseClasses-js"><a href="#ReactBaseClasses-js" class="headerlink" title="ReactBaseClasses.js"></a>ReactBaseClasses.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import ReactNoopUpdateQueue from &apos;./ReactNoopUpdateQueue&apos;;</span><br><span class="line">/**</span><br><span class="line"> * Base class helpers for the updating state of a component.</span><br><span class="line"> */</span><br><span class="line">const emptyObject = &#123;&#125;;</span><br><span class="line">function Component(props, context, updater) &#123;</span><br><span class="line">  this.props = props;</span><br><span class="line">  this.context = context;</span><br><span class="line">  // If a component has string refs, we will assign a different object later.</span><br><span class="line">  this.refs = emptyObject;</span><br><span class="line">  // We initialize the default updater but the real one gets injected by the renderer.</span><br><span class="line">  this.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Component.prototype.isReactComponent = &#123;&#125;;</span><br><span class="line">// 核心方法</span><br><span class="line">Component.prototype.setState = function(partialState, callback) &#123;</span><br><span class="line">  invariant(</span><br><span class="line">    typeof partialState === &apos;object&apos; ||</span><br><span class="line">      typeof partialState === &apos;function&apos; ||</span><br><span class="line">      partialState == null,</span><br><span class="line">    &apos;setState(...): takes an object of state variables to update or a &apos; +</span><br><span class="line">      &apos;function which returns an object of state variables.&apos;,</span><br><span class="line">  );</span><br><span class="line">  // DOM 实现的</span><br><span class="line">  this.updater.enqueueSetState(this, partialState, callback, &apos;setState&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">// 强制更新</span><br><span class="line">Component.prototype.forceUpdate = function(callback) &#123;</span><br><span class="line">  this.updater.enqueueForceUpdate(this, callback, &apos;forceUpdate&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function ComponentDummy() &#123;&#125;</span><br><span class="line">ComponentDummy.prototype = Component.prototype;</span><br><span class="line"></span><br><span class="line">function PureComponent(props, context, updater) &#123;</span><br><span class="line">  this.props = props;</span><br><span class="line">  this.context = context;</span><br><span class="line">  // If a component has string refs, we will assign a different object later.</span><br><span class="line">  this.refs = emptyObject;</span><br><span class="line">  this.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line">const pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());</span><br><span class="line">pureComponentPrototype.constructor = PureComponent;</span><br><span class="line">// Avoid an extra prototype jump for these methods.</span><br><span class="line">Object.assign(pureComponentPrototype, Component.prototype);</span><br><span class="line">// isPureComponent 属性便于 REACT-DOM 后面辨认是否是纯组件</span><br><span class="line">pureComponentPrototype.isPureReactComponent = true;</span><br><span class="line"></span><br><span class="line">export &#123;Component, PureComponent&#125;;</span><br></pre></td></tr></table></figure><h4 id="ReactCreateRef-js"><a href="#ReactCreateRef-js" class="headerlink" title="ReactCreateRef.js"></a>ReactCreateRef.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export function createRef()&#123;</span><br><span class="line">    const refObject = &#123;</span><br><span class="line">        current:null,</span><br><span class="line">    &#125;</span><br><span class="line">    return refObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Refs 提供了一种方式，允许我们访问 DOM 节点或者在 render 方法中创建的 React 元素。</p><p>使用 Refs 的情况：</p><ul><li>管理焦点，文本选择或者媒体播放</li><li>触发强制动画</li><li>集成第三方 DOM 库</li></ul><p>使用 Refs 的方法：</p><ul><li>string ref</li><li>function</li><li>createRef</li></ul><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">export default class RefDemo extends React.Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.objRef = React.createRef();</span><br><span class="line">    // &#123;current:null&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      this.refs.stringRef.textContent = &apos;string ref got&apos;</span><br><span class="line">      this.methodRef.textContent = &apos;method ref got&apos;</span><br><span class="line">      this.objRef.current.textContent = &apos;obj ref got&apos;</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;p ref=&quot;stringRef&quot;&gt;span1&lt;/p&gt;</span><br><span class="line">        &lt;p ref=&#123;ele =&gt; (this.methodRef = ele)&#125;&gt;span3&lt;/p&gt;</span><br><span class="line">        &lt;p ref=&#123;this.objRef&#125;&gt;span3&lt;/p&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="forwardRef-js"><a href="#forwardRef-js" class="headerlink" title="forwardRef.js"></a>forwardRef.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export default function forwardRef(render:(props,ref))&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">        $$typeof:REACT_FORWARD_REF_TYPE,</span><br><span class="line">        render,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React.forwardRef 会创建一个 React 组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。</p><p>主要使用的是：</p><ul><li>转发 refs 到 DOM 组件</li><li>在高阶组件中转发 refs</li></ul><p>React.forwardRef 接受渲染函数作为参数。React 将使用 props 和 refs 作为参数来调用此函数。此函数应该返回 React 节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// PureComponent</span><br><span class="line">const TargetComponent = React.forwardRef((props,ref)=&gt;&#123;</span><br><span class="line">    &lt;input type=&quot;text&quot; ref=&#123;ref&#125; /&gt;</span><br><span class="line">&#125;)</span><br><span class="line">        </span><br><span class="line">export default class Comp extends React.Component&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super();</span><br><span class="line">        this.ref = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        this.ref.current.value = &apos;ref get input&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;TargetComponent ref=&#123;this.ref&#125;/&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReactContext.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export function createContext(defaultValue,calculateChangedBits)&#123;</span><br><span class="line">    if(calculateChangedBits === undefined)&#123;</span><br><span class="line">        calculateChangedBits = null;</span><br><span class="line">    &#125;     </span><br><span class="line">    const context = &#123;</span><br><span class="line">        $$typeof:REACT_CONTEXT_TYPE,</span><br><span class="line">        _calculateChangedBits:calculateChangedBits,</span><br><span class="line">        _currentValue:defaultValue,</span><br><span class="line">        _currentValue2:defaultValue,</span><br><span class="line">        Provider:null,</span><br><span class="line">        Consumer:null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    context.Provider = &#123;</span><br><span class="line">        $$typeof:REACT_PROVIDER_TYPE,</span><br><span class="line">        _context:context</span><br><span class="line">    &#125;</span><br><span class="line">    if(__DEV__)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        context.Consumer = context;</span><br><span class="line">    &#125;    </span><br><span class="line">    return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReactLazy-js"><a href="#ReactLazy-js" class="headerlink" title="ReactLazy.js"></a>ReactLazy.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">lazy</span>(<span class="params">ctor:(</span>)=&gt;<span class="title">Thenable</span>&lt;<span class="title">T</span>,<span class="title">R</span>&gt;)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        $$<span class="keyword">typeof</span>:REACT_LAZY_TYPE,</span><br><span class="line">        <span class="comment">// 类 promise</span></span><br><span class="line">        _ctor:ctor,</span><br><span class="line">        _status:<span class="number">-1</span>,</span><br><span class="line">        <span class="comment">// 加载完返回的结果</span></span><br><span class="line">        _result:<span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h4><p>简单用法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState,useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> [name,setName] = useState(<span class="string">'lbh'</span>);</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'component update'</span>)</span><br><span class="line">        <span class="comment">// 解除绑定</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'unbind'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    &lt;&gt;</span><br><span class="line">        &lt;p&gt;My name is:&#123;name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="text" value=&#123;name&#125; onChange=&#123;e=&gt;setName(e.target.value)&#125;&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReactChildren-js"><a href="#ReactChildren-js" class="headerlink" title="ReactChildren.js"></a>ReactChildren.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line">const SEPARATOP = &apos;.&apos;;</span><br><span class="line">const SUBSEPARATOR = &apos;:&apos;;</span><br><span class="line">function escape(key)&#123;</span><br><span class="line">    const escapeRegex = /[=:]/g;</span><br><span class="line">    const escaperLookup = &#123;</span><br><span class="line">        &apos;=&apos;:&apos;=0&apos;,</span><br><span class="line">        &apos;:&apos;:&apos;=2&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    const escapedString = (&apos;&apos;+key).replace(escapeRegex,function(match)&#123;</span><br><span class="line">        return escapeLookup[match];</span><br><span class="line">    &#125;)</span><br><span class="line">    return &apos;$&apos; + escapedString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let didWarnAboutMaps = false;</span><br><span class="line">const userProviderKeyEscapeRegex = /\/+/g;</span><br><span class="line">function escapeUserProvidedKey(text)&#123;</span><br><span class="line">    return (&apos;&apos;+text).replace(userProviderKeyEscapeRegex,&apos;$&amp;/&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// 对象池</span><br><span class="line">const POOL_SIZE = 10;</span><br><span class="line">const traverseContextPool = [];</span><br><span class="line">function getPooledTraverseContext(mapResult,keyPrefix,mapFunction,mapContext)&#123;</span><br><span class="line">    if(traverseContextPool.length)&#123;</span><br><span class="line">        const traverseContext = traverseContextPool.pop();</span><br><span class="line">        traverseContext.result = mapResult;</span><br><span class="line">        traverseContext.keyPrefix = keyPrefix;</span><br><span class="line">        traverseContext.func = mapFunction;</span><br><span class="line">        traverseContext.context = mapContext;</span><br><span class="line">        traverseContext.count = 0;</span><br><span class="line">        return traverseContext;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            result:mapResult,</span><br><span class="line">            keyPrefix:keyPrefix,</span><br><span class="line">            func:mapFunction,</span><br><span class="line">            context:mapContext,</span><br><span class="line">            count:0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 释放对象属性，少于指定长度时，将对象push 对象池</span><br><span class="line">function releaseTravserContext(traverseContext)&#123;</span><br><span class="line">    traverseContext.result = null;</span><br><span class="line">    traverseContext.keyPrefix = null;</span><br><span class="line">    traverseContext.func = null;</span><br><span class="line">    traverseContext.context = null;</span><br><span class="line">    traverseContext.count = 0;</span><br><span class="line">    if(traverseContextPool.length &lt; POOL_SIZE)&#123;</span><br><span class="line">        traverseContextPool.push(traverseContext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 核心</span><br><span class="line">function traverseAllChildrenImpl(</span><br><span class="line">  children,</span><br><span class="line">  nameSoFar,</span><br><span class="line">  callback,</span><br><span class="line">  traverseContext,</span><br><span class="line">) &#123;</span><br><span class="line">  const type = typeof children;</span><br><span class="line"></span><br><span class="line">  if (type === &apos;undefined&apos; || type === &apos;boolean&apos;) &#123;</span><br><span class="line">    children = null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let invokeCallback = false;</span><br><span class="line"></span><br><span class="line">  if (children === null) &#123;</span><br><span class="line">    invokeCallback = true;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">      case &apos;string&apos;:</span><br><span class="line">      case &apos;number&apos;:</span><br><span class="line">        invokeCallback = true;</span><br><span class="line">        break;</span><br><span class="line">      case &apos;object&apos;:</span><br><span class="line">        switch (children.$$typeof) &#123;</span><br><span class="line">          case REACT_ELEMENT_TYPE:</span><br><span class="line">          case REACT_PORTAL_TYPE:</span><br><span class="line">            invokeCallback = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (invokeCallback) &#123;</span><br><span class="line">    callback(</span><br><span class="line">      traverseContext,</span><br><span class="line">      children,</span><br><span class="line">      nameSoFar === &apos;&apos; ? SEPARATOR + getComponentKey(children, 0) : nameSoFar,</span><br><span class="line">    );</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let child;</span><br><span class="line">  let nextName;</span><br><span class="line">  let subtreeCount = 0; </span><br><span class="line">  const nextNamePrefix =</span><br><span class="line">    nameSoFar === &apos;&apos; ? SEPARATOR : nameSoFar + SUBSEPARATOR;</span><br><span class="line"></span><br><span class="line">  if (Array.isArray(children)) &#123;</span><br><span class="line">    for (let i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">      child = children[i];</span><br><span class="line">      nextName = nextNamePrefix + getComponentKey(child, i);</span><br><span class="line">      subtreeCount += traverseAllChildrenImpl(</span><br><span class="line">        child,</span><br><span class="line">        nextName,</span><br><span class="line">        callback,</span><br><span class="line">        traverseContext,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    const iteratorFn = getIteratorFn(children);</span><br><span class="line">    if (typeof iteratorFn === &apos;function&apos;) &#123;</span><br><span class="line">      const iterator = iteratorFn.call(children);</span><br><span class="line">      let step;</span><br><span class="line">      let ii = 0;</span><br><span class="line">      while (!(step = iterator.next()).done) &#123;</span><br><span class="line">        child = step.value;</span><br><span class="line">        nextName = nextNamePrefix + getComponentKey(child, ii++);</span><br><span class="line">        subtreeCount += traverseAllChildrenImpl(</span><br><span class="line">          child,</span><br><span class="line">          nextName,</span><br><span class="line">          callback,</span><br><span class="line">          traverseContext,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (type === &apos;object&apos;) &#123;</span><br><span class="line">      let addendum = &apos;&apos;;</span><br><span class="line">      const childrenString = &apos;&apos; + children;</span><br><span class="line">      invariant(</span><br><span class="line">        false,</span><br><span class="line">        &apos;Objects are not valid as a React child (found: %s).%s&apos;,</span><br><span class="line">        childrenString === &apos;[object Object]&apos;</span><br><span class="line">          ? &apos;object with keys &#123;&apos; + Object.keys(children).join(&apos;, &apos;) + &apos;&#125;&apos;</span><br><span class="line">          : childrenString,</span><br><span class="line">        addendum,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return subtreeCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function traverseAllChildren(children,callback,traverseContext)&#123;</span><br><span class="line">    if(children === null)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return traverseAllChildrenImpl(children,&apos;&apos;,callback,traverseContext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getComponentKey(component,index)&#123;</span><br><span class="line">    if(</span><br><span class="line">        typeof component === &apos;object&apos; &amp;&amp; </span><br><span class="line">        component !== null &amp;&amp;</span><br><span class="line">        component.key != null</span><br><span class="line">    )&#123;</span><br><span class="line">        return escape(component.key);</span><br><span class="line">    &#125;</span><br><span class="line">    return index.toString(36);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function forEachSingleChild(bookKeeping,child,name)&#123;</span><br><span class="line">    const &#123; func, context &#125; = bookKeeping;</span><br><span class="line">    func.call(context,child,bookKeeping.count++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function forEachChildren(children, forEachFunc, forEachContext) &#123;</span><br><span class="line">  if (children == null) &#123;</span><br><span class="line">    return children;</span><br><span class="line">  &#125;</span><br><span class="line">  const traverseContext = getPooledTraverseContext(</span><br><span class="line">    null,</span><br><span class="line">    null,</span><br><span class="line">    forEachFunc,</span><br><span class="line">    forEachContext,</span><br><span class="line">  );</span><br><span class="line">  traverseAllChildren(children, forEachSingleChild, traverseContext);</span><br><span class="line">  releaseTraverseContext(traverseContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mapSingleChildIntoContext(bookKeeping, child, childKey) &#123;</span><br><span class="line">  const &#123;result, keyPrefix, func, context&#125; = bookKeeping;</span><br><span class="line"></span><br><span class="line">  let mappedChild = func.call(context, child, bookKeeping.count++);</span><br><span class="line">  if (Array.isArray(mappedChild)) &#123;</span><br><span class="line">    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c =&gt; c);</span><br><span class="line">  &#125; else if (mappedChild != null) &#123;</span><br><span class="line">    if (isValidElement(mappedChild)) &#123;</span><br><span class="line">      mappedChild = cloneAndReplaceKey(</span><br><span class="line">        mappedChild,</span><br><span class="line">        keyPrefix +</span><br><span class="line">          (mappedChild.key &amp;&amp; (!child || child.key !== mappedChild.key)</span><br><span class="line">            ? escapeUserProvidedKey(mappedChild.key) + &apos;/&apos;</span><br><span class="line">            : &apos;&apos;) +</span><br><span class="line">          childKey,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(mappedChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mapIntoWithKeyPrefixInternal(children,array,prefix,func,context)&#123;</span><br><span class="line">    let escapedPrefix = &apos;&apos;;</span><br><span class="line">    if(prefix != null)&#123;</span><br><span class="line">        escapedPrefix = escapeUserProvidedKey(prefix)+&apos;/&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    const traverseContext = getPooledTraverseContext(</span><br><span class="line">        array,</span><br><span class="line">        escapedPrefix,</span><br><span class="line">        func,</span><br><span class="line">        context</span><br><span class="line">    )</span><br><span class="line">    traverseAllChildren(children,mapSingleChildIntoContext,traverseContext);</span><br><span class="line">    releaseTraverseContext(traverseContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mapChildren(children,func,context)&#123;</span><br><span class="line">    if(children == null)&#123;</span><br><span class="line">        return children;</span><br><span class="line">    &#125;</span><br><span class="line">    const result = [];</span><br><span class="line">    mapIntoWithKeyPrefixInternal(children,result,null,func,context);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function countChildren(children)&#123;</span><br><span class="line">    return traverseAllChildren(children,()=&gt;null,null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function toArray(children)&#123;</span><br><span class="line">    const result = [];</span><br><span class="line">    mapIntoWithKeyPrefixInternal(children,result,null,child =&gt; child)</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function onlyChild(children) &#123;</span><br><span class="line">  invariant(</span><br><span class="line">    isValidElement(children),</span><br><span class="line">    &apos;React.Children.only expected to receive a single React element child.&apos;,</span><br><span class="line">  );</span><br><span class="line">  return children;</span><br><span class="line">&#125;</span><br><span class="line">export &#123;</span><br><span class="line">forEachChild as forEach,</span><br><span class="line">    mapChildren as map,</span><br><span class="line">    countChildren as count,</span><br><span class="line">    onlyChild as only,</span><br><span class="line">    toArray,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要方法流程图：</p><pre class="mermaid">graph TDA(开始)contextPool(contextPool)mapIntoWithKeyPrefixInternal(mapIntoWithKeyPrefixInternal)traverseAllChildren(traverseAllChildren)traverseAllChildrenImpl(traverseAllChildrenImpl)mapSingleChildrenContext(mapSingleChildrenContext)是否多个节点{是否多个节点}isArray{isArray}循环每个节点((循环每个节点))对每个节点调用mapFunc返回map之后的节点(对每个节点调用mapFunc返回map之后的节点)往result中推入clone节点并替换key(往result中推入clone节点并替换key)A --> mapIntoWithKeyPrefixInternalmapIntoWithKeyPrefixInternal -. 开始的时候获取 .-> contextPoolmapIntoWithKeyPrefixInternal -. 结束之后归还 .-> contextPoolmapIntoWithKeyPrefixInternal --> traverseAllChildrentraverseAllChildren --> traverseAllChildrenImpltraverseAllChildrenImpl --> 是否多个节点是否多个节点 --Y--> 循环每个节点是否多个节点 --N--> mapSingleChildrenContext循环每个节点 --> traverseAllChildrenImplmapSingleChildrenContext --> 对每个节点调用mapFunc返回map之后的节点对每个节点调用mapFunc返回map之后的节点 --> isArrayisArray --Y--> mapIntoWithKeyPrefixInternalisArray --N--> 往result中推入clone节点并替换key</pre><h4 id="ReactContext-js"><a href="#ReactContext-js" class="headerlink" title="ReactContext.js"></a>ReactContext.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export function createCOntext(defaultValue,calculateChangedBits)&#123;</span><br><span class="line">    if(calculateChangedBits === undefined)&#123;</span><br><span class="line">        calculateChangedBits = null;</span><br><span class="line">    &#125;</span><br><span class="line">    const context = &#123;</span><br><span class="line">        $$typeof:REACT_CONTEXT_TYPE,</span><br><span class="line">        _calculateChangeBits:calculateChangeBits,</span><br><span class="line">        _currentValue:defaultValue,</span><br><span class="line">        _currentValue2:defaultValue,</span><br><span class="line">        Provider:null,</span><br><span class="line">        Consumer:null</span><br><span class="line">    &#125;</span><br><span class="line">    context.Provider = &#123;</span><br><span class="line">        $$typeof:REACT_PROVIDER_TYPE,</span><br><span class="line">        _context:context,</span><br><span class="line">    &#125;</span><br><span class="line">    context.Consumer = context;</span><br><span class="line">    return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="memo-js"><a href="#memo-js" class="headerlink" title="memo.js"></a>memo.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">memo</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"> type: React$ElementType,</span></span></span><br><span class="line"><span class="function"><span class="params"> compare?: (oldProps: Props, newProps: Props</span>) =&gt; <span class="title">boolean</span>,</span></span><br><span class="line"><span class="function">    )</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        $$<span class="keyword">typeof</span>:REACT_MEMO_TYPE,</span><br><span class="line">        type,</span><br><span class="line">        compare:compare === <span class="literal">undefined</span> ? <span class="literal">null</span> : compare,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建更新的方式"><a href="#创建更新的方式" class="headerlink" title="创建更新的方式"></a>创建更新的方式</h3><p>主要是下面的知识点：</p><p><code>ReactDOM.render</code>、<code>ReactDOM.render</code>、<code>setState</code>、<code>forceUpdate</code></p><p>步骤：</p><ul><li>创建 ReactRoot</li><li>创建 FiberRoot 和 RootFiber</li><li>创建更新</li></ul><h4 id="ReactDOM-js"><a href="#ReactDOM-js" class="headerlink" title="ReactDOM.js"></a>ReactDOM.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// ReactDOM</span><br><span class="line">const ReactDOM = &#123;</span><br><span class="line">    createPortal,</span><br><span class="line">    findDOMNode(</span><br><span class="line">    componentOrElement,</span><br><span class="line">    )&#123;</span><br><span class="line">        if (componentOrElement == null) &#123;</span><br><span class="line">          return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (componentOrElement.nodeType === ELEMENT_NODE) &#123;</span><br><span class="line">          return componentOrElement;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // REACTElememt,DOM包裹节点，回调方法</span><br><span class="line">    hydrate(element,container,callback)&#123;</span><br><span class="line">        return legacyRenderSubtreeIntoContainer(</span><br><span class="line">        null,</span><br><span class="line">            element,</span><br><span class="line">            container,</span><br><span class="line">            // 协调更新的选项</span><br><span class="line">            true,</span><br><span class="line">            callback</span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">    render(element,container,callback)&#123;</span><br><span class="line">        return legacyRenderSubtreeIntoContainer(</span><br><span class="line">            null,</span><br><span class="line">            element,</span><br><span class="line">            container,</span><br><span class="line">            false,</span><br><span class="line">            callback</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>render 与 hydrate 方法都可以传入三个参数，包括 ReactElement、DOM包裹节点和渲染结束后执行的回调方法，返回 <code>legacyRenderSubtreeIntoContainer</code> 方法执行的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">function legacyRenderSubtreeIntoContainer(</span><br><span class="line"> parentComponent,</span><br><span class="line"> children,</span><br><span class="line"> container,</span><br><span class="line"> forceHydrate,</span><br><span class="line"> callback</span><br><span class="line">)&#123;</span><br><span class="line">     let root;</span><br><span class="line">     if(!root)&#123;</span><br><span class="line">         root = container._reactRootContainer = legacyCreateRootFromDOMContainer(</span><br><span class="line">             container,</span><br><span class="line">             forceHydrate,</span><br><span class="line">         )</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">function legacyCreateRootFromDOMContainer(</span><br><span class="line"> container,</span><br><span class="line"> forceHydrate,</span><br><span class="line">)&#123;</span><br><span class="line">     const shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);</span><br><span class="line">     // 没有ssr的情况</span><br><span class="line">     if(!shouldHydrate)&#123;</span><br><span class="line">         let rootSibling;</span><br><span class="line">         while((rootSibling = container.lastChild))&#123;</span><br><span class="line">             // 删除 container 下面的所有子节点</span><br><span class="line">             container.removeChild(rootSibling)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;     </span><br><span class="line">     const isConcurrent = false;</span><br><span class="line">     return new ReactRoot(container,isConcurrent,shouldHydrate)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function shouldHydrateDueToLegacyHeuristic()&#123;</span><br><span class="line">    const rootElement = getReactRootElementInContainer(container);</span><br><span class="line">    return !!(</span><br><span class="line">        rootElement &amp;&amp; </span><br><span class="line">        // 普通element节点</span><br><span class="line">        rootElement.nodeType === ELEMENT_NODE &amp;&amp; </span><br><span class="line">        // data-reactroot 老版本ssr的节点</span><br><span class="line">        rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getReactRootElementInContainer(container)&#123;</span><br><span class="line">    if(!container)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断节点</span><br><span class="line">    if(container.nodeType === DOCUMENT_NODE)&#123;</span><br><span class="line">        return container.documentElement;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return container.firstChild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断 root 是否不存在，不存在调用<code>legacyCreateRootFromDOMContainer</code>，传入 <code>container</code>,<code>forceHydrate</code>两个参数。<code>legacyCreateRootFromDOMContainer</code>函数创建了一个 <code>ReactRoot</code>，而 <code>forceHydrate</code>布尔类型参数在 <code>hydrate</code> 传入 <code>true</code>,在 <code>render</code> 里面传入 <code>false</code>。前者是服务器渲染，后者是客户端渲染。服务器渲染当服务器呈现标记的节点，React 会保留它并附加事件处理程序，从而具有高性能的首屏加载，客户端渲染当初始DOM与当前 DOM 存在差异，则可能会更改节点。可以看到 如果是 <code>false</code>会 <code>container.removeChild(rootSibling)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">function ReactRoot(</span><br><span class="line"> container,</span><br><span class="line"> isConcurrent,</span><br><span class="line"> hydrate</span><br><span class="line">)&#123;</span><br><span class="line">     const root = DOMRender.createContainer(container,isConcurrent,hydrate);</span><br><span class="line">     this._internalRoot = root;</span><br><span class="line"> &#125;</span><br><span class="line">// react-reconciler/inline.dom</span><br><span class="line">function createContainer(</span><br><span class="line"> containerInfo,</span><br><span class="line">  isConcurrent,</span><br><span class="line">  hydrate</span><br><span class="line">)&#123;</span><br><span class="line">     // 创建 FiberRoot</span><br><span class="line">     return createFiberRoot(container,isConcurrent,hydrate)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// ReactFiberRoot</span><br><span class="line">export function createFiberRoot(</span><br><span class="line">  containerInfo,</span><br><span class="line">  isConcurrent,</span><br><span class="line">  hydrate,</span><br><span class="line">): FiberRoot &#123;</span><br><span class="line">    // </span><br><span class="line">  const uninitializedFiber = createHostRootFiber(isConcurrent);</span><br><span class="line"></span><br><span class="line">  let root;</span><br><span class="line">  if (enableSchedulerTracing) &#123;</span><br><span class="line">    root = &#123;</span><br><span class="line">      current: uninitializedFiber,</span><br><span class="line">      containerInfo: containerInfo,</span><br><span class="line">      pendingChildren: null,</span><br><span class="line"></span><br><span class="line">      earliestPendingTime: NoWork,</span><br><span class="line">      latestPendingTime: NoWork,</span><br><span class="line">      earliestSuspendedTime: NoWork,</span><br><span class="line">      latestSuspendedTime: NoWork,</span><br><span class="line">      latestPingedTime: NoWork,</span><br><span class="line"></span><br><span class="line">      didError: false,</span><br><span class="line"></span><br><span class="line">      pendingCommitExpirationTime: NoWork,</span><br><span class="line">      finishedWork: null,</span><br><span class="line">      timeoutHandle: noTimeout,</span><br><span class="line">      context: null,</span><br><span class="line">      pendingContext: null,</span><br><span class="line">      hydrate,</span><br><span class="line">      nextExpirationTimeToWorkOn: NoWork,</span><br><span class="line">      expirationTime: NoWork,</span><br><span class="line">      firstBatch: null,</span><br><span class="line">      nextScheduledRoot: null,</span><br><span class="line"></span><br><span class="line">      interactionThreadID: unstable_getThreadID(),</span><br><span class="line">      memoizedInteractions: new Set(),</span><br><span class="line">      pendingInteractionMap: new Map(),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    root = &#123;</span><br><span class="line">      current: uninitializedFiber,</span><br><span class="line">      containerInfo: containerInfo,</span><br><span class="line">      pendingChildren: null,</span><br><span class="line"></span><br><span class="line">      earliestPendingTime: NoWork,</span><br><span class="line">      latestPendingTime: NoWork,</span><br><span class="line">      earliestSuspendedTime: NoWork,</span><br><span class="line">      latestSuspendedTime: NoWork,</span><br><span class="line">      latestPingedTime: NoWork,</span><br><span class="line"></span><br><span class="line">      didError: false,</span><br><span class="line"></span><br><span class="line">      pendingCommitExpirationTime: NoWork,</span><br><span class="line">      finishedWork: null,</span><br><span class="line">      timeoutHandle: noTimeout,</span><br><span class="line">      context: null,</span><br><span class="line">      pendingContext: null,</span><br><span class="line">      hydrate,</span><br><span class="line">      nextExpirationTimeToWorkOn: NoWork,</span><br><span class="line">      expirationTime: NoWork,</span><br><span class="line">      firstBatch: null,</span><br><span class="line">      nextScheduledRoot: null,</span><br><span class="line">    &#125;;</span><br><span class="line">    uninitializedFiber.stateNode = root;</span><br><span class="line">    return root;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;知其然知其所以然，框架工的自我尝试进阶&lt;/p&gt;
&lt;h2 id=&quot;React源码浅析&quot;&gt;&lt;a href=&quot;#React源码浅析&quot; class=&quot;headerlink&quot; title=&quot;React源码浅析&quot;&gt;&lt;/a&gt;React源码浅析&lt;/h2&gt;&lt;p&gt;知识点：&lt;/p&gt;
&lt;p&gt;&lt;st
      
    
    </summary>
    
      <category term="React" scheme="http://laibh.top/categories/React/"/>
    
    
      <category term="源码" scheme="http://laibh.top/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://laibh.top/2019-06-25-regExp.html"/>
    <id>http://laibh.top/2019-06-25-regExp.html</id>
    <published>2019-06-25T01:30:54.000Z</published>
    <updated>2020-07-11T03:24:57.639Z</updated>
    
    <content type="html"><![CDATA[<p>最近这段时间因为赶项目，一直没有更新博客。精通正则这本书一年前翻阅过过一些。用到的地方不多，便很快就忘记了。今忙里抽空复习一下正则，在项目中也会有所用到。主要是跟随<a href="http://deerchao.net/tutorials/regex/regex-1.htm">正则表达式30分钟入门教程</a>，再结合 JS 中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式</a>进行复习。</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>编写处理字符串的程序或者网页时候，经常会有查找符合复杂规则的字符串的需要。正则表达式就是用于描述这些规。即记录文本规则的代码。</p><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>在一篇英文小说中查找 <code>hi</code>，可以使用正则 <code>hi</code>。它可以精确匹配这样的字符串：由两个字符组成，前一个字符是 <code>h</code>，后一个字符串是 <code>i</code>。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，可以匹配 <code>hi</code>、<code>HI</code>、<code>Hi</code>、<code>hI</code>这四种情况中的任意的一种。</p><p><code>hi</code>这个正则表达式也会匹配 <code>him</code>、<code>history</code>、<code>high</code>等，如果要精确查找到 <code>hi</code>这个单词的话，应该使用正则表达式 <code>\bhi\b</code>。</p><p><code>\b</code>是正则表达式规定一个特殊代码（元字符），代表着单词的开头或者结尾，也就是单词的分界处。英文的单词一般是由空格，标点符号或者换行符来分隔的，但是 <code>\b</code>并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。</p><p>如果要找到是 <code>hi</code>后面不远处跟着一个 <code>Lucy</code>，就要使用正则表达式 <code>\bhi\b.*\bLucy\b</code>。这里的 <code>.</code>是一个元字符，匹配除了换行符外的任意字符。<code>*</code>同样是元字符，不过它代表的不是字符，也不是位置。而是数量，它指定 <code>*</code>前边的内容可以连续重复使用任意次以使整个正则表达式得到匹配。因此 <code>.*</code>连在一起就意味着任意数量的不包括换行的字符。现在 <code>\bhi\b.*\bLucy\b</code>的意思就是：先是一个单词<code>hi</code>，然后是任意个任意字符（但不能是换行），最后是 <code>Lucy</code>整个单词。</p><p>如果使用其他元字符，可以构造更强大的正则表达式，比如下面的例子</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>\d\d-\d\d\d\d\d\d\d\d</span><br><span class="line"><span class="comment"># 以 0 开头，然后是两个数字，然后是一个连字符'-'，最后是8个数字（也就是中国的电话号码，只能匹配区号是3位的情况）</span></span><br><span class="line"><span class="comment"># \d 是一个新的元字符。匹配一个数字。'-'不是元字符，只匹配它本身——连字符（或者减号，或者中横线等）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简化</span></span><br><span class="line"><span class="number">0</span>\d<span class="string">&#123;2&#125;</span>-d<span class="string">&#123;8&#125;</span></span><br><span class="line"><span class="comment"># \d 后面&#123;2&#125; 和 &#123;8&#125;的意思必须连续重复匹配2（8）次</span></span><br></pre></td></tr></table></figure><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>常用的元字符</p><table><thead><tr><th>代码</th><th>说明</th><th>相当于</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配换行符以外的任意字符</td><td></td></tr><tr><td><code>\w</code></td><td>匹配字母或数字或下划线或汉字</td><td></td></tr><tr><td><code>\s</code></td><td>匹配任意的空白符（包括空格、制表符（Tab）、换行符，中文全角空格）</td><td></td></tr><tr><td><code>\d</code></td><td>匹配数字</td><td></td></tr><tr><td><code>\b</code></td><td>匹配单词的开始或者结束</td><td></td></tr><tr><td><code>^</code></td><td>匹配字符串的开始</td><td></td></tr><tr><td><code>$</code></td><td>匹配字符串的结束</td></tr></tbody></table><p>元字符 <code>^</code>和 <code>$</code>都匹配一个位置，这和 <code>\b</code>有点类似。<code>^</code>匹配想要用来查找的字符串的开头，<code>$</code>匹配结尾。</p><p><code>\d+</code>匹配1个或者更多连续的数字。<code>+</code>是和 <code>*</code>类似的元字符，不同的是 <code>*</code>匹配重复任意次（可能是0次），而 <code>+</code>则匹配重复1次或者更多次。</p><p><code>\b\w{6}\b</code>匹配刚好 6个字符的单词</p><p><code>\d{5,12}</code> 表示匹配字符串里面包含 5 到 12 连续位数字，而不是整个字符串是 5 到 12 位数字</p><p><code>^\d{5,12}$</code>则是精确匹配整个字符串就是 5 到 12 位数字</p><h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h3><p>如果想要查找元字符本身的话，比如查找<code>.</code>或者 <code>*</code>就需要转义，<code>\</code>可以来取消这些字符的特殊意义</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找 .</span></span><br><span class="line">\.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找 *</span></span><br><span class="line">\*</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 查找 \</span></span><br><span class="line">\\</span><br></pre></td></tr></table></figure><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p>下面是正则表达式中所有限定符（指定数量的代码）</p><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复0次或者更多次</td></tr><tr><td>+</td><td>重复1次或者更多次</td></tr><tr><td>？</td><td>重复0次或者1次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n次到m次</td></tr></tbody></table><p><code>Windows\d+</code> 匹配 <code>Windows</code>后面跟1个或者跟多数字</p><p><code>^\w+</code>匹配一行的第一个单词（或者整个字符串的第一个单词）</p><h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><p>要想查找数字、字母或者数字，空白是很简单的，因为已经有对应的这些字符集合的元字符，但是想匹配没有预定字符的字符集合（比如元音字母 <code>a</code>/<code>e</code>/<code>i</code>/<code>o</code>/<code>u</code>）。</p><p>只需要在方括号中列出它们就可以了,<code>[aeiou]</code>就匹配任何一个英文元音字母，<code>[.?!]</code>匹配标点符号（<code>.</code>或<code>?</code>或<code>!</code>）</p><p>也可以轻松指定一个字符范围，<code>[0-9]</code>的含义和  <code>\d</code>是完全一致的：一个数字。</p><p><code>[a-z0-9A-Z]</code>也完全等同于 <code>\w</code>（如果值考虑英文的话）</p><p>思考：</p><p><code>\(?0\d{2}[) -]?\d{8}</code></p><p>上面的表达式，可以匹配几种格式的电话号码，像（010）88888888，或者010-88888888。它首先是一个转义字符，它能出现0次或者1次（？）,然后是一个0，后面跟着两个数字（d{2}），然后是<code>）</code>或者<code>-</code>或者空格中的一个，它出现1次或者不出现，最后是8个数字。</p><h3 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h3><p>上面思考题，其实也可以匹配 010)8888888或者 （010-88888888 这样不正确的格式。要解决这个问题，需要用到分枝条件。正则表达式里面的分枝条件是有几种规则的。如果满足其中任意一个规则应该都当成匹配，具体的方法是用 <code>|</code>把不同的规则都分隔开。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>\d<span class="string">&#123;2&#125;</span>-\d<span class="string">&#123;8&#125;</span>|<span class="number">0</span>\d<span class="string">&#123;3&#125;</span>-d<span class="string">&#123;7&#125;</span></span><br><span class="line"><span class="comment"># 这个表达式可以匹配两种连字符分隔的电话号码：一种是三位区号的，8位本地号。另一种是4位区号的，7个本地号的</span></span><br><span class="line">\(<span class="number">0</span>\d<span class="string">&#123;2&#125;</span>\)[- ]?\d<span class="string">&#123;8&#125;</span>|<span class="number">0</span>\d<span class="string">&#123;2&#125;</span>[- ]?\d<span class="string">&#123;8&#125;</span></span><br><span class="line"><span class="comment"># 这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。可以试试用分支条件把这个表达式扩展成支持4位区号的</span></span><br><span class="line">\d<span class="string">&#123;5&#125;</span>-\d<span class="string">&#123;4&#125;</span>|\d<span class="string">&#123;5&#125;</span></span><br><span class="line"><span class="comment"># 这个表达式用于匹配美国的邮政编码。它的规则是5位数字，或者用连字号间隔的9位数字。</span></span><br><span class="line"><span class="comment"># 这要需要注意，不能改成 \d&#123;5&#125;|\d&#123;5&#125;-d&#123;4&#125;，这样就只会匹配5位邮编（以及9位邮编的前5位）。原因是匹配分支条件时，会从左到右测试每个条件，如果满足了某个分支的话，就不会去管其他条件了。</span></span><br></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>重复单个字符，直接在字符后面加上限定符就好了。如果想要重复多个字符的话，可以用小括号来指定子表达式（分组），然后就可以指定这个子表达式的重复次数了，或者是其他的操作。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（\d&#123;<span class="number">1</span>,<span class="number">3</span>&#125;\.)<span class="string">&#123;3&#125;</span>\d&#123;<span class="number">1</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># 上面是一个简答的 ip地址匹配。\d&#123;1,3&#125;匹配1到3位数字</span></span><br><span class="line"><span class="comment"># (\d&#123;1,3&#125;\.)&#123;3&#125;匹配三位数字加上一个英文句号，这个整体也是这个分组重复了3次，最后再加上一个1到3位的数字 \d&#123;1,3&#125;</span></span><br><span class="line"><span class="comment"># 缺漏的地方在于它也会匹配 256.300.899.999 这种不存在的ip 地址。</span></span><br><span class="line"><span class="comment"># 正确的地址(ip地址中每个数字都不能大于255，可以有前导0)</span></span><br><span class="line">((<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>]\d|<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|[<span class="number">01</span>]?\d\d?)\.)<span class="string">&#123;3&#125;</span>(<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>]\d|<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|[<span class="number">01</span>]?\d\d?)</span><br></pre></td></tr></table></figure><h3 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h3><p>有时候需要查找的不是某个能简单定义的字符类的字符。比如想查找除了数字以外的，其他任意字符都行的情况，这时候就需要反义。</p><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td><code>\W</code></td><td>匹配任意不是字母、数字、下划线或者汉字的字符</td></tr><tr><td><code>\S</code></td><td>匹配任意不是空白符的字符</td></tr><tr><td><code>\D</code></td><td>匹配任意不是数字的字符</td></tr><tr><td><code>\B</code></td><td>匹配不是单词开头或者结束的位置</td></tr><tr><td><code>[^X]</code></td><td>匹配除了 X 以外的任意的字符</td></tr><tr><td><code>[^aeiou]</code></td><td>匹配除了 aeiou 这个字母与以外的任意字符</td></tr></tbody></table><p>例子：</p><p><code>\S+</code>匹配不包括空白符的字符串</p><p><code>&lt;a[^&gt;]+&gt;</code>匹配用尖括号括起来的以 <code>a</code>开头的字符串</p><h3 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h3><p>使用小括号指定一个子表达式后，匹配这个子表达式的文本（也就是此分组捕获的内容）可以在表达式或者其他程序中作进一步的处理。默认情况下，每个分组都会自动拥有一个组号，规则就是：从左到右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，依次类推。</p><p>分组0代表整个正则表达式，实际上组号分配过程是要从左向右扫描两遍的，第一遍只给未命名组分配，第二遍只给命名组分配，因为所有命名组的组号都大于未命名的组号。</p><p>可以使用 <code>(?:exp)这样的语法来剥夺一个分组对组号分配的参与权</code></p><p>后向引用，用于重复搜索前面的某个分组匹配的文本。例如，<code>\1</code>代表分组1匹配的文本。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\b(\w+)\b\<span class="keyword">s</span>+\<span class="number">1</span>\b</span><br><span class="line"><span class="comment"># 匹配重复的单词，这个表达式首先是一个单词，也就是单词开始处和单词结束处之间多于一个的字母或者数字（\b(\w+)\b），这个单词会被捕获到编码为1的分组中，然后是1个或者几个空白符(\s+)，最后分组1中捕获的内容（也就是前面匹配的那个单词）（\1）</span></span><br></pre></td></tr></table></figure><p>也可以自己指定子表达式的组名，要指定一个子表达式的组名，使用这样的语法:</p><p><code>(?&lt;Word&gt;\w+)</code>或者<code>(?&#39;Word&#39;\w+)</code>这样就把 <code>\w</code>的组名指定为 Word。要反向引用这个分组捕获的内容，可以使用<code>\k&lt;Word&gt;</code>，上面的例子也可以写成这样：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\b(?&lt;Word&gt;\w+)\b\<span class="keyword">s</span>+\k&lt;Word&gt;\b</span><br></pre></td></tr></table></figure><p>下表是常用分组语法：</p><table><thead><tr><th>分类</th><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>捕获</td><td>(exp)</td><td>匹配 exp,并捕获文本到自动命名的组里</td></tr><tr><td></td><td>(?\<name>exp)</td><td>匹配 exp，并捕获文本到名称为 name 的组里，也可以写成 <code>(?&#39;name&#39;exp)</code></td></tr><tr><td></td><td>(?:exp)</td><td>匹配 exp，不捕获匹配的文本，也不给此分组的分配组号</td></tr><tr><td>零宽断言</td><td>(?= exp)</td><td>匹配 exp 前面的位置</td></tr><tr><td></td><td>(?&lt;= exp)</td><td>匹配 exp 后面的位置</td></tr><tr><td></td><td>(?!exp)</td><td>匹配后面跟的不是 exp 的位置</td></tr><tr><td></td><td>(?&lt;!exp)</td><td>匹配前面不是 exp 的位置</td></tr><tr><td>注释</td><td>(?#comment)</td><td>这种类型的分组不对正则表达式的处理产生任何影响，用于注释让人阅读</td></tr></tbody></table><h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><p>断言用来声明一个应该为真的事实，正则表达式中只有当断言为真的时候才会继续进行匹配。</p><p>用于查找在某些内容前或者之后的东西，像 <code>\b</code>、<code>^</code>、<code>$</code>那样用于指定一个位置，这个位置应该满足一定的条件（断言），因此它们被称为零宽断言。</p><p><code>(?=exp)</code>也叫零宽度正预测先行断言（Zero-width positive lookahead），它断言自身出现的位置的后面能匹配表达式 exp。比如，<code>\b\w+(?=ing\b)</code>，匹配以 <code>ing</code>为结尾的单词的前面部分（除了 ing 以外的部分），如查找 <code>I&#39;m singing while you&#39;re dancing.</code>时，它会匹配 <code>sing</code>和 <code>danc</code></p><p><code>(?&lt;=exp)</code>也叫零宽度正回顾后发断言(Zero-width positive lookbehind)，它断言自身出现的为位置的前面能匹配表示达 exp，比如 <code>(?&lt;=\bre)\w+\b</code>会匹配以 <code>re</code>开头的单词的后半部分（除了re 以外的部分）。例如在查找 <code>reading a book</code>时，它匹配 <code>ading</code>。</p><p>假如想要给一个很长的数字中每三位加一个逗号，从右边加。可以这样查找前面和里面添加逗号的部分：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">((?&lt;=\d)\d<span class="string">&#123;3&#125;</span>)+\b</span><br><span class="line"><span class="comment"># 查找 1234567890 =&gt; 234567890</span></span><br><span class="line"></span><br><span class="line">（?&lt;=\<span class="keyword">s</span>）\d+(?=\<span class="keyword">s</span>)</span><br><span class="line"><span class="comment"># 匹配以空白符间隔的数字，不包括这些空白符</span></span><br><span class="line"><span class="comment"># 查找 1234 56 7890 =&gt; 56</span></span><br></pre></td></tr></table></figure><h3 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h3><p>前面提到怎么查找不是某个字符或者不在某个字符类里面的字符的方法（反义）。但是如果我们只是想确保某个字符没有出现，但不想去匹配它时，例如查找这样的单词——它里面的出现了字母q,但是q后面跟着的不是字母 u，我们可以尝试：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\b\w*<span class="string">q[^u]</span>\w*\b</span><br><span class="line"><span class="comment"># 匹配包含后面不是字母u 的字母q的单词。但是你可以发现 [^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]总要匹配一个字符，或者是句号或者是其他的什么。后面的 \w*\b 将会匹配下一个单词，于是 上面的表达式就可以匹配整个  Iraq fighting。</span></span><br><span class="line"><span class="comment"># 负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。</span></span><br><span class="line">\b\w*<span class="string">q(?!u)</span>\w*\b</span><br></pre></td></tr></table></figure><p>零宽度负预测先行断言(?!exp)(Zero-width negative lookahead)，断言此位置后面不能匹配表达式exp。</p><p>例如：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\d<span class="string">&#123;3&#125;</span>(?!\d)</span><br><span class="line"><span class="comment"># 匹配三位数字，而且这三位数字的后面不能是数字</span></span><br><span class="line">\b((?!abc)\w)+\b</span><br><span class="line"><span class="comment"># 匹配不包括连续字符串 abc 的单词</span></span><br></pre></td></tr></table></figure><p>同理可以用零宽度负回顾后发断言(?&lt;!exp)(Zero-width negative lookbehind)，来断言此位置的前面不能匹配表达式 <code>(?&lt;![a-z])\d{7}</code>,即前面不是小写字母的七位数字</p><p>一个更加复杂的例子：</p><p><code>(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)</code></p><p>匹配不包含属性的简单 html 标签内的内容。<code>(?&lt;=&lt;(\w+)&gt;)</code>指定了这样的前缀：被尖括号括起来的单词，然后是 <code>.*</code>(任意的字符串)，最后一个是后缀<code>(?=&lt;\/\1&gt;)</code>。<code>\/</code>转义了，<code>\1</code>反向引用，整个内容就是闭合标签之间的内容，不包括两个标签本身。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>小括号的另一种用途是通过语法<code>(?#comment)</code>来包含注释。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)</span><br></pre></td></tr></table></figure><p>要包含注释的话，最好是启用“忽略模式里面的空白符”选项。这样在编写表达式时能任意的添加空格/TAB/换行，而实际使用时这些都被忽略。启用这个选项后，在 <code>#</code>后面到这一行结束的所有文本都被当做注释忽略掉。例如，我们可以前面的一个表达式写成这样：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(?&lt;=<span class="comment"># 断言要匹配的文本的前缀</span></span><br><span class="line">&lt;(\w+)&gt; <span class="comment"># 查找尖括号括起来的字母或者数字（即HTML/XML标签）</span></span><br><span class="line">)       <span class="comment"># 前缀结束</span></span><br><span class="line">.*      <span class="comment"># 匹配任意文本</span></span><br><span class="line">(?=     <span class="comment"># 断言要匹配的文本的后缀</span></span><br><span class="line">&lt;\/\<span class="number">1</span>&gt;  <span class="comment"># 查找尖括号括起来的内容：前面是一个 '/'，后面是先前捕获的标签</span></span><br><span class="line">)       <span class="comment"># 后缀结束</span></span><br></pre></td></tr></table></figure><h3 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h3><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例子：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索 <code>aabab</code>的话，它就会匹配整个 <code>aabab</code>，这被称为贪婪匹配。</p><p>有时候，我们需要懒惰匹配，也就是尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 <code>?</code>。这样，<code>.?</code>这意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。</p><p><code>a.*?b</code>匹配最短的，以a开始，以b结束的字符串。如果把它应用于 <code>aabab</code>的话，它会匹配 <code>aab</code>和 <code>ab</code></p><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td><code>*?</code></td><td>重复任意次，但尽可能少重复</td></tr><tr><td><code>+?</code></td><td>重复 1次或者更多次，但尽可能少重复</td></tr><tr><td><code>??</code></td><td>重复 0 次或者 1 次，但尽可能少重复</td></tr><tr><td><code>{n,m}？</code></td><td>重复 n 到 m 次，但尽可能少重复</td></tr><tr><td><code>{n,}?</code></td><td>重复  n 次以上，但尽可能少重复</td></tr></tbody></table><h2 id="JS-中的正则表达式"><a href="#JS-中的正则表达式" class="headerlink" title="JS 中的正则表达式"></a>JS 中的正则表达式</h2><p>正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象，这些模式被用于 <code>RegExp</code>的<code>test</code>和 <code>exec</code>，以及 <code>String</code>的 <code>match</code>、<code>replace</code>、<code>search</code>和 <code>split</code>方法。</p><h3 id="创建一个正则表达式"><a href="#创建一个正则表达式" class="headerlink" title="创建一个正则表达式"></a>创建一个正则表达式</h3><p>1.使用一个正则表达式字面量，其由包含斜杠之间的模式组成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/ab+c/</span>;</span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^[a-zA-Z]+[0-9]*\W?_$/gi</span></span><br></pre></td></tr></table></figure><p>2.调用<code>RegExp</code>对象的构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ab+c'</span>);</span><br><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/^[a-zA-Z]+[0-9]*\W?_$/</span>,<span class="string">'gi'</span>)</span><br><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"^[a-zA-Z]+[0-9]*\\W?_$"</span>,<span class="string">"gi"</span>)</span><br></pre></td></tr></table></figure><h3 id="编写一个正则表达式的模式"><a href="#编写一个正则表达式的模式" class="headerlink" title="编写一个正则表达式的模式"></a>编写一个正则表达式的模式</h3><p>一个正则表达式的模式由简单的字符所构成，比如 <code>/abc/</code>，或是简单和特殊字符的组合，比如 <code>/ab*c/</code>或者 <code>/Chapter(\d+)\.\d*/</code>。后者用到了括号，它在正则表达中可以被当作是一个记忆设备。这一部分正则所匹配的字符会被记住，在后面可以利用。</p><p><strong>使用简单的模式</strong></p><p>简单的模式由找到的直接匹配所构成的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/abc/</span><br><span class="line"><span class="comment">// 匹配 Hi, do you know your abc's? </span></span><br><span class="line"><span class="comment">// 匹配 The latest airplane designs evolved from slabcraft.? </span></span><br><span class="line"><span class="comment">// 不匹配 Grab crab</span></span><br></pre></td></tr></table></figure><p><strong>使用特殊字符</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ab*c/</span><br><span class="line"><span class="comment">// 匹配 cbbabbbbcdebc =&gt; abbbbc</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td><code>\</code></td><td>在非特殊字符之前的反斜杆表示下一个字符是特殊的。<br>反斜杆也可以将其后的特殊字符，转义为字面量。<br>使用 <code>new RegExp(&#39;pattern&#39;)</code>的时候要将 <code>\</code>转义，因为 <code>\</code>在字符串里面也是一个转义字符</td></tr><tr><td><code>^</code></td><td>匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。</td></tr><tr><td><code>$</code></td><td>匹配输入的结束。如果多行标识符被设置为 true，那么也会匹配换行符之前的位置。0</td></tr><tr><td><code>*</code></td><td>匹配前一个表示0 次或者多次。等价于<code>{0,}</code></td></tr><tr><td><code>+</code></td><td>匹配前面一个表达式1次或者更多次，等价于 <code>{1,}</code></td></tr><tr><td><code>?</code></td><td>匹配前面一个表达式0次或者1次。等价于<code>{0,1}</code><br>如果紧跟在任何量词 <code>*</code>、<code>+</code>、<code>?</code>、<code>{}</code>后面，将会使得量词变成非贪婪（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反</td></tr><tr><td><code>.</code></td><td>（小数点）匹配除换行符之外面的任何单个字符</td></tr><tr><td><code>(x)</code></td><td>匹配 ‘x’并记住匹配项。括号被称为捕获括号。<br>模式<code>/(foo)(bar)\1\2/</code><br>在正式表达式的替换环节，使用 <code>$1</code>的语法，例如 <code>&#39;bar.foo&#39;.replace(/(..)(..)/,&#39;$2$1&#39;)</code></td></tr><tr><td><code>(?:x)</code></td><td>匹配‘x’但不记住匹配项。这种叫做非捕获括号，使得你能够定义与正则表达式运算符一起使用的子表达式。<br></td></tr><tr><td><code>x(?=y)</code></td><td>匹配‘x’仅仅当’x’后面跟着‘y’。这种叫先行断言。<br><code>/Jack(?=Spart)/</code>会匹配到 ‘Jack’仅当它后面跟着’Spart’。但是‘Spart’都不是匹配结果中的一部分</td></tr><tr><td><code>(?&lt;=y)x</code></td><td>匹配‘x’仅仅当’x’前面是‘y’,这种叫做后行断言。<br><code>/(?&lt;=Jack)Spart/</code>会匹配到 ‘Spart’仅仅当它前面是‘Jack’。<br>`/(?&lt;=Jack</td><td>Tom)Spart/`会匹配到 ’Spart‘仅仅当它前面是 ’Jack‘或者是 ‘Tom’。但是’Tom‘和’Jack‘都不是匹配结果的一部分</td></tr><tr><td><code>x(?！y)</code></td><td>匹配’x‘仅仅当’x‘后面不跟着’y‘,这个叫做正向否定查找。<br><code>/\d+(?!\.)/</code>匹配一个数字仅仅当这个数字后面没有跟小数点的时候。</td></tr><tr><td>`x</td><td>y`</td><td>匹配’x‘或者’y‘。</td></tr><tr><td><code>{n}</code></td><td>n是一个正整数，匹配了前面一个字符刚好发生了 n 次</td></tr><tr><td><code>{n,m}</code></td><td>n 和 m 都是整数。匹配前面的字符至少 n 次，最多 m 次。如果 n 或者 m 的值是0，这个值会被忽略。</td></tr><tr><td><code>[xyz]</code></td><td>一个字符的集合。匹配方括号中的任意字符，包括转义序列。可以用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊意义。</td></tr><tr><td><code>[^xyz]</code></td><td>一个反向字符集。匹配任何没有包含在方括号中的字符。同样可以使用破折号来指定一个字符范围。</td></tr><tr><td><code>[\b]</code></td><td>匹配一个退格(U+0008)</td></tr><tr><td><code>\b</code></td><td>匹配一个词的边界。一个词的边界就是一个词不被另外一个字字符跟随的位置或者没有其他“字”字符在其前面的位置。</td></tr><tr><td><code>\B</code></td><td>匹配一个非单词边界。匹配一个前后字符都是相同类型的位置。都是’字‘字符或者都不是’字‘字符。一个字符串的开始和结尾都被认为不是‘字’字符，或者是字符串。</td></tr><tr><td><code>\cX</code></td><td>当 X 是处于A 到 Z 之间的字符的时候，匹配字符串中的一个控制符</td></tr><tr><td><code>\d</code></td><td>匹配一个数字</td></tr><tr><td><code>\D</code></td><td>匹配一个非数字字符</td></tr><tr><td><code>\f</code></td><td>匹配一个换页符（U+000C）</td></tr><tr><td><code>\n</code></td><td>匹配一个换行符（U+000A）</td></tr><tr><td><code>\r</code></td><td>匹配一个回车符（U+000D）</td></tr><tr><td><code>\s</code></td><td>匹配一个空白符号，包括空格、制表符、换页符和换行符。<br>等价于<code>[\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]</code></td></tr><tr><td><code>\S</code></td><td>匹配一个非空白字符。<br>等价于<code>[^</code>\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff<code>]</code>。</td></tr><tr><td><code>\t</code></td><td>匹配一个水平制表符（U+0009）</td></tr><tr><td><code>\v</code></td><td>匹配一个垂直制表符（U+000B）</td></tr><tr><td><code>\w</code></td><td>匹配一个单字字符（字母、数字或者下划线）<br>等价于  <code>[A-Za-z0-9_]</code></td></tr><tr><td><code>\W</code></td><td>匹配一个单字字符<br>等价于 <code>[^A-Za-z0-9_]</code></td></tr><tr><td><code>\n</code></td><td>在正则表达式中，它返回最后的第 n 个子捕获匹配的子字符串（捕获的数目以左括号计数）</td></tr><tr><td><code>\0</code></td><td>匹配 NULL(U+0000)字符，不要在这后面跟着其他小数，因为 <code>\0&lt;digits&gt;</code>是一个八进制转义序列</td></tr><tr><td><code>\xhh</code></td><td>与代码 hh 匹配字符（两个十六进制数字）</td></tr><tr><td><code>\uhhhh</code></td><td>与代码 <code>hhhh</code>匹配字符（四个十六进制数字）</td></tr></tbody></table><h3 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h3><p>正则表达式被用于 RegExp 的 exec 和 test 方法，还有 String  的 match、replace、search和 split 方法。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>exec</code></td><td>一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组(未匹配返回 null)</td></tr><tr><td><code>test</code></td><td>一个在字符串中测试是否匹配的 RegExp 方法，它返回 true 或者 false</td></tr><tr><td><code>match</code></td><td>一个在字符串中执行查找匹配的 String 方法，它返回一个数组或者在未匹配时返回 null</td></tr><tr><td><code>search</code></td><td>一个在字符串中测试匹配的 String  方法，它返回匹配到的位置索引，或者在失败时返回 -1</td></tr><tr><td><code>replace</code></td><td>一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉后面的子字符串</td></tr><tr><td><code>split</code></td><td>一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的字符串存储到数组中的 String 方法</td></tr></tbody></table><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 脚本使用 exec 方法在一个字符串中查找一个匹配</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/d(b+)d/g</span>;</span><br><span class="line"><span class="comment">/**reg参数</span></span><br><span class="line"><span class="comment">* 5 lastIndex 下一个匹配的索引值</span></span><br><span class="line"><span class="comment">* "d(b+)d" source 模式文本。在正则表达式创建时更新，不执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> myArray = reg.exec(<span class="string">"cdbbdbsbz"</span>)</span><br><span class="line">myArray; <span class="comment">// ["dbbd", "bb", index: 1, input: "cdbbdbsbz", groups: undefined]</span></span><br><span class="line"><span class="comment">/** myArray参数</span></span><br><span class="line"><span class="comment">* ["dbbd,bb"] 匹配到的字符和所有被记住的子字符串</span></span><br><span class="line"><span class="comment">* 1 1input 初始字符串</span></span><br><span class="line"><span class="comment">* input:cdbbdbsbz  初始字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 不需要访问正则表达式的属性，通过另一个方法来创建</span></span><br><span class="line">myArray = <span class="regexp">/d(b+)d/g</span>.exec(<span class="string">"cdbbdbsbz"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过一个字符串构建正则表达式，还有另一种方式</span></span><br><span class="line">reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"d(b+)d"</span>,<span class="string">"g"</span>);</span><br><span class="line">myArray = reg.exec(<span class="string">"cdbbdbsbz"</span>)</span><br></pre></td></tr></table></figure><h4 id="使用括号的子字符串匹配"><a href="#使用括号的子字符串匹配" class="headerlink" title="使用括号的子字符串匹配"></a>使用括号的子字符串匹配</h4><p>一个正则表达式模式使用括号，将导致相应的子匹配被记住。使用括号匹配的子字符串的数量是无限的。返回的数组中保存所有被发现的子匹配。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(\w+)\s(\w+)/</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'John Smith'</span>;</span><br><span class="line"><span class="keyword">let</span> newStr = str.replace(reg,<span class="string">"$2,$1"</span>)</span><br><span class="line">newStr; <span class="comment">// "Smith,John"</span></span><br></pre></td></tr></table></figure><h4 id="通过标志进行高级搜索"><a href="#通过标志进行高级搜索" class="headerlink" title="通过标志进行高级搜索"></a>通过标志进行高级搜索</h4><p>正则表达式有四个可选参数进行全局和不区分大小写搜索，这些参数可以单独使用也可以一起使用在任何顺序和包含正则表达式的部分中。</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td><code>g</code></td><td>全局搜索</td></tr><tr><td><code>i</code></td><td>不区分大小写搜索</td></tr><tr><td><code>m</code></td><td>多行搜索(使用该标志，<code>^</code>和 <code>$</code>匹配的开始或者结束输入字符串的)</td></tr><tr><td><code>y</code></td><td>执行“粘性”搜索，匹配从目标字符串的当前位置开始，可以使用 <code>y</code>标志</td></tr></tbody></table><p>格式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/pattern/</span>flags;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\w+\s/g</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"pattern"</span>,<span class="string">"flags"</span>)</span><br><span class="line">reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\w+\\s"</span>,<span class="string">"g"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近这段时间因为赶项目，一直没有更新博客。精通正则这本书一年前翻阅过过一些。用到的地方不多，便很快就忘记了。今忙里抽空复习一下正则，在项目中也会有所用到。主要是跟随&lt;a href=&quot;http://deerchao.net/tutorials/regex/regex-1.ht
      
    
    </summary>
    
      <category term="正则表达式" scheme="http://laibh.top/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
      <category term="正则表达式" scheme="http://laibh.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面试官问我HTML5是什么（下）</title>
    <link href="http://laibh.top/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91HTML5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%8B%EF%BC%89.html"/>
    <id>http://laibh.top/面试官问我HTML5是什么（下）.html</id>
    <published>2019-05-30T01:30:54.000Z</published>
    <updated>2020-07-11T03:24:57.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><p>发展历史</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSS1 -&gt; CSS2 -&gt; CSS2.1 -&gt;CSS3</span><br></pre></td></tr></table></figure><p><strong>模块与模块化结构</strong></p><p>CSS3采用了分工协作的模块化结构</p><p>其中最重要的 CSS3 模块包括：</p><ul><li>选择器</li><li>框模型</li><li>背景和边框</li><li>文本效果</li><li>2D/3D 转换</li><li>动画</li><li>多列布局</li><li>用户界面</li></ul><h3 id="CSS3-新增的选择器"><a href="#CSS3-新增的选择器" class="headerlink" title="CSS3 新增的选择器"></a>CSS3 新增的选择器</h3><p><strong>属性选择器</strong></p><table><thead><tr><th>选择器</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td><em>E[att^=”val”]</em></td><td>属性 <code>att</code>的值以 <code>val</code>开头的元素</td><td><code>div[id^=&#39;haha&#39;]</code></td></tr><tr><td><em>E[att$=”val”]</em></td><td>属性 <code>att</code>的值以 <code>val</code>结尾的元素</td><td><code>div[id^=&#39;haha&#39;]</code></td></tr><tr><td><em>E[att</em>=”val”]</td><td>属性 <code>att</code>的值包含 <code>val</code>字符串的元素</td><td><code>div[id^=&#39;haha&#39;]</code></td></tr></tbody></table><p><strong>结构性伪类选择器</strong></p><table><thead><tr><th>选择器</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td><em>E:root</em></td><td>匹配文档的根元素，对于 HTML 文档就是 HTML元素</td><td></td></tr><tr><td><em>E:not(s)</em></td><td>匹配不符合当前选择器的任何元素</td><td><code>div:not([class=&quot;demo&quot;])</code>:除了<code>class</code>为<code>demo</code>的div以外</td></tr><tr><td><em>E:empty</em></td><td>匹配一个不包含任何子元素的元素（文本节点也被看成子元素，空格也是一个元素）</td><td></td></tr><tr><td><em>E:target</em></td><td>匹配被 <code>location.hash</code>选中的元素（即锚点元素），选择器可以用来选取当前活动的目标元素</td><td></td></tr><tr><td><em>E:first-child</em></td><td>匹配<code>E</code>父元素的第一个子元素,如果当前位置元素不是前面所修饰的元素，那么无效</td><td><code>li:first-child</code>:匹配页面中所有第一个<code>li</code></td></tr><tr><td><em>E:last-child</em></td><td>匹配<code>E</code>父元素的最后一个子元素，等同于 <code>E:nth-last-child(1)</code>,如果当前位置元素不是前面所修饰的元素，那么无效</td><td></td></tr><tr><td><em>E:nth-child(n)</em></td><td>匹配<code>E</code>父元素的第<code>n</code>个元素，第一个编号为1,如果当前位置元素不是前面所修饰的元素，那么无效</td><td></td></tr><tr><td><em>E:nth–last-child(n)</em></td><td>匹配<code>E</code>父元素的倒数第n个子元素，第一个编号为1,如果当前位置元素不是前面所修饰的元素，那么无效</td><td></td></tr><tr><td><em>E:nth-of-type(n)</em></td><td>与<code>E:nth-child()</code>类似，但是仅匹配使用同种标签的元素</td><td><code>p:nth-of-type(2)</code>:匹配父元素的第2个子元素p</td></tr><tr><td><em>E:first-of-type(n)</em></td><td>匹配父元素使用同种标签的第一个子元素，等同于 <code>E:nth-of-type(1)</code></td><td></td></tr><tr><td><em>E:last-of-type(n)</em></td><td>匹配父元素使用同种标签的最后一个子元素，等同于 <code>E:nth-last-of-type(1)</code></td><td></td></tr><tr><td><em>E:nth-last-of-type(n)</em></td><td>与 <code>E:nth-last-child(n)</code>类似，但是仅匹配使用相同标签的元素</td><td></td></tr><tr><td><em>E:only-child</em></td><td>匹配父元素下仅有的一个子元素，等同于 <code>E:first-child:last-child</code>或者 <code>E:nth-child(1):nth-last-child(1)</code></td><td></td></tr><tr><td><em>E：only-of-type</em></td><td>匹配父元素下使用同种标签的唯一一个子元素，等同于 <code>E:first-of-type:last-of-type</code>或者 <code>E:nth-of-type(1):nth-last-of-type(1)</code></td><td></td></tr><tr><td>备注：</td><td><code>n</code>里面可以是 odd(奇数)、even(偶数)</td><td>循环使用样式：<code>li:nth-child(2n+1)</code></td></tr></tbody></table><p><strong>UI状态伪类选择器</strong></p><table><thead><tr><th>选择器</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td><em>E:enabled</em></td><td>匹配表单中激活的元素</td><td></td></tr><tr><td><em>E:disabled</em></td><td>匹配表单中禁用的元素</td><td></td></tr><tr><td><em>E:checked</em></td><td>匹配表单中被选中的单选框或者复选框</td><td></td></tr><tr><td><em>E::selection</em></td><td>匹配用户用鼠标当前选中的元素</td><td><code>user-select: none;</code>取消鼠标选中的默认样式</td></tr><tr><td><em>E:read-only</em></td><td>匹配选中只读的元素</td><td><code>&lt;input type=&quot;text&quot; readonly=&quot;readonly&quot; value=&quot;hahha&quot;/&gt;</code></td></tr><tr><td><em>E:read-write</em></td><td>匹配选中非只读的元素</td><td><code>&lt;input type=&quot;text&quot; value=&quot;hahha&quot;/&gt;</code></td></tr></tbody></table><p><strong>级元素通用选择器</strong></p><table><thead><tr><th>选择器</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td><code>E~F</code></td><td>匹配任何在 <code>E</code>元素之后的同级元素 <code>F</code></td><td>p~ul{background:#ff9;}</td></tr></tbody></table><ol><li>E：hover</li><li>E：active</li><li>E：focus</li><li>E：enabled</li><li>E：disabled</li><li>E：read-only</li><li>E：read-write</li><li>E：checked</li><li>E：default</li><li>E：indeterminate</li><li>E：selection</li></ol><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><ol><li>简单属性选择</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*把包含某个attribute的所有边元素变成红色*/</span></span><br><span class="line">*<span class="selector-attr">[attribute]</span>&#123;<span class="attribute">color</span>:red&#125;</span><br><span class="line"><span class="comment">/*只对有attribute属性的div元素应用样式*/</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[attribute]</span>&#123;<span class="attribute">color</span>:red&#125;</span><br><span class="line"><span class="comment">/*根据多个属性，同时拥有attribute1和attribute2的元div应用样式*/</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[attribute1]</span><span class="selector-attr">[attribute2]</span>&#123;<span class="attribute">color</span>:red&#125;</span><br><span class="line"><span class="comment">/*对有alt属性的图像*/</span></span><br><span class="line"><span class="selector-tag">img</span><span class="selector-attr">[alt]</span>&#123;<span class="attribute">border</span>:<span class="number">5px</span> solid red&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>根据具体属性选择</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*某个具体的a标签*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href="http://laibh.top"]</span>&#123;<span class="attribute">color</span>:red&#125;;</span><br><span class="line"><span class="comment">/*加多一个限制*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href="http://laibh.top"]</span><span class="selector-attr">[title="赖同学"]</span>&#123;<span class="attribute">color</span>:red&#125;;</span><br><span class="line"><span class="comment">/*不要忽略空格*/</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[class="red small"]</span>&#123;<span class="attribute">color</span>:red&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>根据部分属性值选择</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*选择 class属性中包含 important元素的 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[class~="important"]</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">[abc^=”def”]</td><td style="text-align:left">选择 abc 属性值以 “def” 开头的所有元素</td></tr><tr><td style="text-align:left">[abc$=”def”]</td><td style="text-align:left">选择 abc 属性值以 “def” 结尾的所有元素</td></tr><tr><td style="text-align:left">[abc*=”def”]</td><td style="text-align:left">选择 abc 属性值中包含子串 “def” 的所有元素</td></tr></tbody></table><ol start="4"><li>特定属性选择类型</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这个规则会选择 lang 属性等于 en 或以 en- 开头的所有元素*/</span></span><br><span class="line">*<span class="selector-attr">[lang|="en"]</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure><p><strong>css属性选择器表</strong></p><table><thead><tr><th style="text-align:left">选择器</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">[<em>attribute</em>]</td><td style="text-align:left">用于选取带有指定属性的元素。</td></tr><tr><td style="text-align:left">[<em>attribute</em>=<em>value</em>]</td><td style="text-align:left">用于选取带有指定属性和值的元素。</td></tr><tr><td style="text-align:left">[<em>attribute</em>~=<em>value</em>]</td><td style="text-align:left">用于选取属性值中包含指定词汇的元素。</td></tr><tr><td style="text-align:left">[<em>attribute</em>\</td><td style="text-align:left">=<em>value</em>]</td><td>用于选取带有以指定值开头的属性值的元素，该值必须是<strong>整个单词</strong>。</td></tr><tr><td style="text-align:left">[<em>attribute</em>^=<em>value</em>]</td><td style="text-align:left">匹配属性值以指定值开头的每个元素。（CSS3新增）</td></tr><tr><td style="text-align:left">[<em>attribute</em>$=<em>value</em>]</td><td style="text-align:left">匹配属性值以指定值结尾的每个元素。（CSS3新增）</td></tr><tr><td style="text-align:left">[<em>attribute**=</em>value*]</td><td style="text-align:left">匹配属性值中包含指定值的每个元素。（CSS3新增）</td></tr></tbody></table><h3 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a>伪类与伪元素</h3><h4 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h4><p>CSS2定义：用于向某些选择器添加特殊的效果。</p><p>CSS3定义：</p><ol><li>伪类的存在是为了通过选择器找到那些不存于DOM树中的信息以及不能被常规 CSS选择器获取到的信息（:target）</li><li>伪类由<strong>一个</strong>冒号<code>:</code>开头，冒号后面是伪类的名称和包含在圆括号中的可选参数</li><li>任何常规选择器都可以在任何位置使用伪类。伪类语法不区分大小写。一些伪类的作用会互斥，另外一些伪类可以同时被同一个元素使用。并且，为了满足用户在操作  DOM时产生的 DOM 结构变化，伪类也可以是动态的</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">selector</span> : <span class="selector-tag">pseudo-class</span>&#123; <span class="attribute">property</span>:value &#125;</span><br><span class="line"><span class="selector-tag">selector</span><span class="selector-class">.class</span> : <span class="selector-tag">pseudo-class</span>&#123; <span class="attribute">property</span>:value &#125;</span><br></pre></td></tr></table></figure><p><strong>锚伪类</strong>（不存在于 DOM树的信息）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>&#123;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>&#123;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;&#125;</span><br><span class="line"><span class="selector-tag">a</span>;<span class="selector-tag">active</span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.tab_content</span> &#123;</span></span><br><span class="line"><span class="undefined">  height: 800px;</span></span><br><span class="line"><span class="undefined">  background: red;</span></span><br><span class="line"><span class="undefined">  margin-bottom: 100px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#tab1</span><span class="selector-pseudo">:target</span>, <span class="selector-id">#tab2</span><span class="selector-pseudo">:target</span>, <span class="selector-id">#tab3</span><span class="selector-pseudo">:target</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line"><span class="undefined">&#125;    </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tab1"</span> <span class="attr">class</span>=<span class="string">"tab_content"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--tabed content--&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tab2"</span> <span class="attr">class</span>=<span class="string">"tab_content"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--tabed content--&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tab3"</span> <span class="attr">class</span>=<span class="string">"tab_content"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--tabed content--&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--:target通过CSS实现了常规CSS无法实现的逻辑--&gt;</span></span><br></pre></td></tr></table></figure><p><strong>伪类表</strong></p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th><th style="text-align:left">CSS</th></tr></thead><tbody><tr><td style="text-align:left">:active</td><td style="text-align:left">向被激活的元素添加样式。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:focus</td><td style="text-align:left">向拥有键盘输入焦点的元素添加样式。</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:hover</td><td style="text-align:left">当鼠标悬浮在元素上方时，向元素添加样式。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:link</td><td style="text-align:left">向未被访问的链接添加样式。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:visited</td><td style="text-align:left">向已被访问的链接添加样式。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:first-child</td><td style="text-align:left">向元素的第一个子元素添加样式。</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:lang</td><td style="text-align:left">向带有指定 lang 属性的元素添加样式。</td><td style="text-align:left">2</td></tr></tbody></table><h4 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h4><p>CSS2定义：用于向某些选择器设置特殊效果</p><p>CSS3定义：</p><ol><li>伪元素在DOM树中创建了一些抽象元素，这些抽象元素是不存在文档语言里面的（html源码）。如：document接口不提供访问元素内容的第一个字或者第一行的机制，而伪元素可以使得开发者提取到这些信息。并且，一些伪元素可以使开发者获取到不存在与源文档中的内容（<code>:before</code>/<code>:after</code>）</li><li>伪元素由<strong>两个</strong>冒号<code>:：</code>开头，然后是伪元素的名称</li><li>使用<code>::</code>是为了区分伪类和伪元素（CSS2中没有区别）。考虑兼容性的话，CSS2中的已存伪元素可以使用 <code>:</code>，但是 CSS3的就要使用 <code>::</code></li><li>一个选择器只能使用一个伪元素，并且伪元素必须处于选择器语句的最后</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">selector</span><span class="selector-pseudo">:pseudo-element</span>&#123;<span class="attribute">property</span>:value&#125;</span><br><span class="line"><span class="selector-tag">selector</span><span class="selector-class">.class</span><span class="selector-pseudo">:pseudo-element</span>&#123;<span class="attribute">property</span>:value&#125;</span><br></pre></td></tr></table></figure><p><code>:first-line</code></p><p>用于向文本的首行设置特殊样式(只能用于块级元素)</p><p>下面属性可以应用这个伪元素</p><ul><li>font</li><li>color</li><li>background</li><li>word-spacing</li><li>letter-spacing</li><li>text-decoration</li><li>vertical-align</li><li>text-transform</li><li>line-height</li><li>clear</li></ul><p><code>:first-letter</code></p><p>用于向文本的首字母设置特殊样式</p><p>下面的属性可以应用这个伪元素</p><ul><li>font</li><li>color</li><li>background</li><li>margin</li><li>padding</li><li>border</li><li>text-decoration</li><li>vertical-align(当 float为none)</li><li>text-transform</li><li>line-height</li><li>float</li><li>clear</li></ul><p><code>:before</code></p><p>在元素内容前面插入新内容</p><p><code>:after</code></p><p>在元素内容之后插入新内容</p><p><strong>伪元素表</strong></p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th><th style="text-align:left">CSS</th></tr></thead><tbody><tr><td style="text-align:left">:first-letter</td><td style="text-align:left">向文本的第一个字母添加特殊样式。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:first-line</td><td style="text-align:left">向文本的首行添加特殊样式。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:before</td><td style="text-align:left">在元素之前添加内容。</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:after</td><td style="text-align:left">在元素之后添加内容。</td><td style="text-align:left">2</td></tr></tbody></table><h4 id="伪类与伪元素特性与区别"><a href="#伪类与伪元素特性与区别" class="headerlink" title="伪类与伪元素特性与区别"></a>伪类与伪元素特性与区别</h4><ol><li>伪类本质上是为了弥补常规 CSS 选择器的不足，以便获取更多的信息（不存在 DOM树的信息，不能被常规CSS选择器获取的信息）</li><li>伪元素本质上是创建了一个有内容的虚拟容器,这个容器不包含任何DOM元素，但是可以包含内容</li><li>CSS3 中的伪类和伪元素的语法不同（<code>:</code>与<code>::</code>）</li><li>可以同时使用多个伪类，而只能同时使用一个伪元素</li></ol><h3 id="完整表格"><a href="#完整表格" class="headerlink" title="完整表格"></a>完整表格</h3><table><thead><tr><th style="text-align:left">选择器</th><th style="text-align:left">示例</th><th style="text-align:left">示例说明</th><th style="text-align:left">CSS</th></tr></thead><tbody><tr><td style="text-align:left">.<em>class</em></td><td style="text-align:left">.intro</td><td style="text-align:left">选择所有class=”intro”的元素</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">#<em>id</em></td><td style="text-align:left">#firstname</td><td style="text-align:left">选择所有id=”firstname”的元素</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">*</td><td style="text-align:left">选择所有元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>element</em></td><td style="text-align:left">p</td><td style="text-align:left">选择所有<p>元素</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"><em>element,element</em></td><td style="text-align:left">div,p</td><td style="text-align:left">选择所有<div>元素和<p>元素</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"><em>element</em> <em>element</em></td><td style="text-align:left">div p</td><td style="text-align:left">选择<div>元素内的所有<p>元素</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"><em>element</em>&gt;<em>element</em></td><td style="text-align:left">div&gt;p</td><td style="text-align:left">选择所有父级是 <div> 元素的 <p> 元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>element</em>+<em>element</em></td><td style="text-align:left">div+p</td><td style="text-align:left">选择所有紧接着<div>元素之后的<p>元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>attribute</em></td><td style="text-align:left">[target]</td><td style="text-align:left">选择所有带有target属性元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>attribute</em>=<em>value</em></td><td style="text-align:left">[target=-blank]</td><td style="text-align:left">选择所有使用target=”-blank”的元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>attribute</em>~=<em>value</em></td><td style="text-align:left">[title~=flower]</td><td style="text-align:left">选择标题属性包含单词”flower”的所有元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>attribute</em></td><td style="text-align:left">=<em>language</em>[lang\</td><td style="text-align:left">=en]</td><td style="text-align:left">选择 lang 属性以 en 为开头的所有元素</td><td>2</td></tr><tr><td style="text-align:left">:link</td><td style="text-align:left">a:link</td><td style="text-align:left">选择所有未访问链接</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:visited</td><td style="text-align:left">a:visited</td><td style="text-align:left">选择所有访问过的链接</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:active</td><td style="text-align:left">a:active</td><td style="text-align:left">选择活动链接</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:hover</td><td style="text-align:left">a:hover</td><td style="text-align:left">选择鼠标在链接上面时</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:focus</td><td style="text-align:left">input:focus</td><td style="text-align:left">选择具有焦点的输入元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:first-letter</td><td style="text-align:left">p:first-letter</td><td style="text-align:left">选择每一个<P>元素的第一个字母</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:first-line</td><td style="text-align:left">p:first-line</td><td style="text-align:left">选择每一个<P>元素的第一行</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:first-child</td><td style="text-align:left">p:first-child</td><td style="text-align:left">指定只有当<p>元素是其父级的第一个子级的样式。</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:before</td><td style="text-align:left">p:before</td><td style="text-align:left">在每个<p>元素之前插入内容</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:after</td><td style="text-align:left">p:after</td><td style="text-align:left">在每个<p>元素之后插入内容</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:lang(<em>language</em>)</td><td style="text-align:left">p:lang(it)</td><td style="text-align:left">选择一个lang属性的起始值=”it”的所有<p>元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>element1</em>~<em>element2</em></td><td style="text-align:left">p~ul</td><td style="text-align:left">选择p元素之后的每一个ul元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left"><em>attribute</em>^=<em>value</em></td><td style="text-align:left">a[src^=”https”]</td><td style="text-align:left">选择每一个src属性的值以”https”开头的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left"><em>attribute</em>$=<em>value</em></td><td style="text-align:left">a[src$=”.pdf”]</td><td style="text-align:left">选择每一个src属性的值以”.pdf”结尾的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left"><em>attribute</em>=<em>value</em></td><td style="text-align:left">a[src*=”runoob”]</td><td style="text-align:left">选择每一个src属性的值包含子字符串”runoob”的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:first-of-type</td><td style="text-align:left">p:first-of-type</td><td style="text-align:left">选择每个p元素是其父级的第一个p元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:last-of-type</td><td style="text-align:left">p:last-of-type</td><td style="text-align:left">选择每个p元素是其父级的最后一个p元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:only-of-type</td><td style="text-align:left">p:only-of-type</td><td style="text-align:left">选择每个p元素是其父级的唯一p元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:only-child</td><td style="text-align:left">p:only-child</td><td style="text-align:left">选择每个p元素是其父级的唯一子元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:nth-child(<em>n</em>)</td><td style="text-align:left">p:nth-child(2)</td><td style="text-align:left">选择每个p元素是其父级的第二个子元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:nth-last-child(<em>n</em>)</td><td style="text-align:left">p:nth-last-child(2)</td><td style="text-align:left">选择每个p元素的是其父级的第二个子元素，从最后一个子项计数</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:nth-of-type(<em>n</em>)</td><td style="text-align:left">p:nth-of-type(2)</td><td style="text-align:left">选择每个p元素是其父级的第二个p元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:nth-last-of-type(<em>n</em>)</td><td style="text-align:left">p:nth-last-of-type(2)</td><td style="text-align:left">选择每个p元素的是其父级的第二个p元素，从最后一个子项计数</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:last-child</td><td style="text-align:left">p:last-child</td><td style="text-align:left">选择每个p元素是其父级的最后一个子级。</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:root</td><td style="text-align:left">:root</td><td style="text-align:left">选择文档的根元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:empty</td><td style="text-align:left">p:empty</td><td style="text-align:left">选择每个没有任何子级的p元素（包括文本节点）</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:target</td><td style="text-align:left">#news:target</td><td style="text-align:left">选择当前活动的#news元素（包含该锚名称的点击的URL）</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:enabled</td><td style="text-align:left">input:enabled</td><td style="text-align:left">选择每一个已启用的输入元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:disabled</td><td style="text-align:left">input:disabled</td><td style="text-align:left">选择每一个禁用的输入元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:checked</td><td style="text-align:left">input:checked</td><td style="text-align:left">选择每个选中的输入元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:not(<em>selector</em>)</td><td style="text-align:left">:not(p)</td><td style="text-align:left">选择每个并非p元素的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">::selection</td><td style="text-align:left">::selection</td><td style="text-align:left">匹配元素中被用户选中或处于高亮状态的部分</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:out-of-range</td><td style="text-align:left">:out-of-range</td><td style="text-align:left">匹配值在指定区间之外的input元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:in-range</td><td style="text-align:left">:in-range</td><td style="text-align:left">匹配值在指定区间之内的input元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:read-write</td><td style="text-align:left">:read-write</td><td style="text-align:left">用于匹配可读及可写的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:read-only</td><td style="text-align:left">:read-only</td><td style="text-align:left">用于匹配设置 “readonly”（只读） 属性的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:optional</td><td style="text-align:left">:optional</td><td style="text-align:left">用于匹配可选的输入元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:required</td><td style="text-align:left">:required</td><td style="text-align:left">用于匹配设置了 “required” 属性的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:valid</td><td style="text-align:left">:valid</td><td style="text-align:left">用于匹配输入值为合法的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:invalid</td><td style="text-align:left">:invalid</td><td style="text-align:left">用于匹配输入值为非法的元素</td><td style="text-align:left">3</td></tr></tbody></table><h3 id="在页面插入内容"><a href="#在页面插入内容" class="headerlink" title="在页面插入内容"></a>在页面插入内容</h3><p><code>:before</code>或者 <code>:after</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入文字 */</span></span><br><span class="line"><span class="comment">/* 在h2前 */</span></span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">'哈哈哈'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在h2后 */</span></span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">'内容'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 指定个别元素不进行插入 */</span></span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-class">.sample</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入图像 */</span></span><br><span class="line"><span class="comment">/* 在h2前 */</span></span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:bofore</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="built_in">url</span>(mark.png);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在h2后 */</span></span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="built_in">url</span>(mark.png);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将元素属性作为content的值来显示 */</span></span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">context</span>:<span class="built_in">attr</span>(alt);</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">    <span class="attribute">margin-top</span>:<span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>content</code>插入项目编号</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>大标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>实例文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>大标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>实例文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*多个标题加上连续编号*/</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="built_in">counter</span>(mycounter)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line"><span class="attribute">counter-increment</span>:mycounter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*追加文字*/</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">'第'</span><span class="built_in">counter</span>(mycounter)<span class="string">'章'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line"><span class="attribute">counter-increment</span>:mycounter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 指定样式 */</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">'第'</span><span class="built_in">counter</span>(mycounter)<span class="string">'章'</span>;</span><br><span class="line"><span class="attribute">color</span>:blue;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">42px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line"><span class="attribute">counter-increment</span>:mycounter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 指定编号种类 list-style-type的值*/</span></span><br><span class="line"><span class="comment">/* content(计数器名，编号种类)*/</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">'第'</span><span class="built_in">counter</span>(mycounter,lower-roman)<span class="string">'章'</span>;</span><br><span class="line"><span class="attribute">color</span>:blue;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">42px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 编号嵌套 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:bofore</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="built_in">counter</span>(mycounter2,lower-roman);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>:mycounter2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list-style-type 的值</p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">none</td><td style="text-align:left">无标记。</td></tr><tr><td style="text-align:left">disc</td><td style="text-align:left">默认。标记是实心圆。</td></tr><tr><td style="text-align:left">circle</td><td style="text-align:left">标记是空心圆。</td></tr><tr><td style="text-align:left">square</td><td style="text-align:left">标记是实心方块。</td></tr><tr><td style="text-align:left">decimal</td><td style="text-align:left">标记是数字。</td></tr><tr><td style="text-align:left">decimal-leading-zero</td><td style="text-align:left">0开头的数字标记。(01, 02, 03, 等。)</td></tr><tr><td style="text-align:left">lower-roman</td><td style="text-align:left">小写罗马数字(i, ii, iii, iv, v, 等。)</td></tr><tr><td style="text-align:left">upper-roman</td><td style="text-align:left">大写罗马数字(I, II, III, IV, V, 等。)</td></tr><tr><td style="text-align:left">lower-alpha</td><td style="text-align:left">小写英文字母The marker is lower-alpha (a, b, c, d, e, 等。)</td></tr><tr><td style="text-align:left">upper-alpha</td><td style="text-align:left">大写英文字母The marker is upper-alpha (A, B, C, D, E, 等。)</td></tr><tr><td style="text-align:left">lower-greek</td><td style="text-align:left">小写希腊字母(alpha, beta, gamma, 等。)</td></tr><tr><td style="text-align:left">lower-latin</td><td style="text-align:left">小写拉丁字母(a, b, c, d, e, 等。)</td></tr><tr><td style="text-align:left">upper-latin</td><td style="text-align:left">大写拉丁字母(A, B, C, D, E, 等。)</td></tr><tr><td style="text-align:left">hebrew</td><td style="text-align:left">传统的希伯来编号方式</td></tr><tr><td style="text-align:left">armenian</td><td style="text-align:left">传统的亚美尼亚编号方式</td></tr><tr><td style="text-align:left">georgian</td><td style="text-align:left">传统的乔治亚编号方式(an, ban, gan, 等。)</td></tr><tr><td style="text-align:left">cjk-ideographic</td><td style="text-align:left">简单的表意数字</td></tr><tr><td style="text-align:left">hiragana</td><td style="text-align:left">标记是：a, i, u, e, o, ka, ki, 等。（日文片假名）</td></tr><tr><td style="text-align:left">katakana</td><td style="text-align:left">标记是：A, I, U, E, O, KA, KI, 等。（日文片假名）</td></tr><tr><td style="text-align:left">hiragana-iroha</td><td style="text-align:left">标记是：i, ro, ha, ni, ho, he, to, 等。（日文片假名）</td></tr><tr><td style="text-align:left">katakana-iroha</td><td style="text-align:left">标记是：I, RO, HA, NI, HO, HE, TO, 等。（日文片假名）</td></tr></tbody></table><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.cnblogs.com/ihardcoder/p/5294927.html">CSS3伪类和伪元素的特性和区别</a></li><li><a href="https://read.douban.com/ebook/15160963/">HTML 5与CSS 3权威指南</a></li><li><a href="https://www.w3cschool.cn/html/">W3cScholl</a></li><li><a href="https://www.cnblogs.com/dreamingbaobei/p/5062998.html">CSS3新增的选择器和属性</a></li><li><a href="https://www.cnblogs.com/wangzhenling/p/8824093.html">神奇的css3（1）新增属性、选择器</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS3&quot;&gt;&lt;a href=&quot;#CSS3&quot; class=&quot;headerlink&quot; title=&quot;CSS3&quot;&gt;&lt;/a&gt;CSS3&lt;/h2&gt;&lt;p&gt;发展历史&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="前端面试" scheme="http://laibh.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="HTML5" scheme="http://laibh.top/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>面试官问我HTML5是什么（中）</title>
    <link href="http://laibh.top/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91HTML5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%AD%EF%BC%89.html"/>
    <id>http://laibh.top/面试官问我HTML5是什么（中）.html</id>
    <published>2019-05-25T01:30:54.000Z</published>
    <updated>2020-07-11T03:24:57.647Z</updated>
    
    <content type="html"><![CDATA[<p>学习链接：<br><a href="https://read.douban.com/ebook/15160963/">HTML 5与CSS 3权威指南</a></p><p><a href="https://www.w3cschool.cn/html/">W3cScholl</a></p><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p>HTML5 中的一个新增元素，可以在页面绘制出各种漂亮的图形与图像。</p><h3 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h3><p>canvas 元素就是 HTML5 中新增的一个用来绘制图形。在页面上放置一个 <code>canvas</code>元素，相当于在页面上放置一块画布，可以在其中进行图形绘制。</p><h3 id="在页面中放置-canvas元素"><a href="#在页面中放置-canvas元素" class="headerlink" title="在页面中放置 canvas元素"></a>在页面中放置 canvas元素</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Canvas<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"draw('canvas')"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"300"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"canvas.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--script--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">id</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span></span><br><span class="line"><span class="javascript">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span></span><br><span class="line"><span class="undefined">  context.fillRect(0, 0, 400, 300);</span></span><br><span class="line"><span class="javascript">  context.fillStyle = <span class="string">'red'</span>;</span></span><br><span class="line"><span class="javascript">  context.strokeStyle = <span class="string">'blue'</span>;</span></span><br><span class="line"><span class="undefined">  context.lineWidth = 1;</span></span><br><span class="line"><span class="undefined">  context.fillRect(50,50,100,100);</span></span><br><span class="line"><span class="undefined">  context.strokeRect(50,50,100,100);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先，要指定 ID,width,height 这三个属性。</p><h4 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h4><ol><li>取得 canvas 元素，用 DOM 方法取得要绘制的目标元素</li><li>取得上下文（context）。进行绘制的时候需要用到图形上下文（graphics context），图形上下文是一个封装了很多绘图功能的对象。使用 canvas 对象的 <code>getContext</code>方法来获得图形上下文。</li><li>填充与绘制边框。绘制图形的时候有两种方式：填充（fill）与绘制边框（stroke）。填充是指填充图形内部，绘制边框是指不填充图形内部，值绘制图形的外框。</li><li>设定绘图样式（style）。在进行图形绘制的时候，要设定好绘图的样式，然后调用相关的方法进行图形绘制。相关的属性有 fillStyle(填充图形的样式)，strokeStyle(图形边框的样式)</li><li>指定线宽。使用图形上下文对象的 lineWidth 属性设置图形边框的宽度。</li><li>指定颜色值。颜色名，或者十六进制的颜色值</li><li>分别使用 fillRect 与 strokeRect 方法来填充矩形和绘制矩形边框。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.fillRect(x,y,width,height);</span><br><span class="line">context.strokeRect(x,y,width,height);</span><br></pre></td></tr></table></figure><p>还有一个 clearRect 方法，擦除指定矩形区域中的图形，使得矩形中的颜色全部变成透明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.clearRect(x,y,width,height);</span><br></pre></td></tr></table></figure><h3 id="使用路径"><a href="#使用路径" class="headerlink" title="使用路径"></a>使用路径</h3><h4 id="绘制圆形"><a href="#绘制圆形" class="headerlink" title="绘制圆形"></a>绘制圆形</h4><p>使用路径绘制图形的过程：</p><ol><li>开始创建路径</li><li>创建图形的路径</li><li>路径创建完成后，关闭路径</li><li>设定绘制样式，调用绘制方法，绘制路径</li></ol><p>大概的意思就是，先用路径勾勒图形轮廓，然后设置颜色，进行绘制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawCircle</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.arc(i * <span class="number">25</span>, i * <span class="number">25</span>, i * <span class="number">10</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>)</span><br><span class="line">    context.closePath();</span><br><span class="line">    context.fillStyle = <span class="string">'rgba(255,0,0,0.25)'</span>;</span><br><span class="line">    context.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>context.arc(x,y,radius,startAngle,endAngle,anticlockwise)</code></p><p>这个方法使用了六个参数，<code>x</code>为绘制圆形的横坐标，<code>y</code>为纵坐标，<code>radius</code>为圆形半径，<code>startAngle</code>为开始的角度，<code>endAngle</code>为结束角度，<code>anticlockwise</code>为是否按顺时针方向进行绘制。</p><p>关于角度与弧度的计算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> radius = degress * <span class="built_in">Math</span>.PI / <span class="number">180</span>;</span><br></pre></td></tr></table></figure><p><code>arc</code>方法不仅可以用阿里绘制圆形，也可以用来绘制圆弧。因此，使用时必须要指定开始角度与结束角度。因为这两个角度决定了弧度。<code>anticlockwise</code>为一个布尔值的参数，参数为 true 时，按顺时针绘制，参数为 false时，按逆时针绘制。</p><p>绘制完图形后，使用 <code>context.closePath()</code>将路径关闭，接着就可以使用 <code>fill</code>方法（<code>stroke</code>）填充图形与绘制图形边框了。</p><h4 id="不关闭路径"><a href="#不关闭路径" class="headerlink" title="不关闭路径"></a>不关闭路径</h4><p>如果不关闭路径，已经创建的路径会被永远保留，使用 fill 或者 stroke 绘制的时候会重复绘制已存在的路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawCircle</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    context.arc(i * <span class="number">25</span>, i * <span class="number">25</span>, i * <span class="number">10</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>)</span><br><span class="line">    context.fillStyle = <span class="string">'rgba(255,0,0,0.25)'</span>;</span><br><span class="line">    context.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="绘制线"><a href="#绘制线" class="headerlink" title="绘制线"></a>绘制线</h4><p><strong>moveTo 与 lineTo</strong></p><p>moveTo 方法的作用是将光标移动到指定坐标，绘制直线的时候以这个坐标点为起点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moveTo(x,y)</span><br></pre></td></tr></table></figure><p>lineTo方法，也是用两个参数，x ，y表示直线终点的横纵坐标。使用该方法绘制直线后，光标会自动移动到 lineTo 方法参数所指定的直线终点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawLine</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">let</span> dx = <span class="number">150</span>;</span><br><span class="line">  <span class="keyword">let</span> dy = <span class="number">150</span>;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="number">100</span>;</span><br><span class="line">  context.beginPath();</span><br><span class="line">  context.fillStyle = <span class="string">'rgb(100,255,100)'</span>;</span><br><span class="line">  context.strokeStyle = <span class="string">'rgb(0,0,100)'</span>;</span><br><span class="line">  <span class="keyword">let</span> dig = <span class="built_in">Math</span>.PI / <span class="number">15</span> * <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">Math</span>.sin(i * dig);</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Math</span>.cos(i * dig);</span><br><span class="line">    context.lineTo(dx + x * s, dy + y * s);</span><br><span class="line">  &#125;</span><br><span class="line">  context.closePath()</span><br><span class="line">  context.fill();</span><br><span class="line">  context.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-bezierCurveTo-绘制贝塞尔曲线"><a href="#使用-bezierCurveTo-绘制贝塞尔曲线" class="headerlink" title="使用 bezierCurveTo 绘制贝塞尔曲线"></a>使用 bezierCurveTo 绘制贝塞尔曲线</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.bezierCurveTo(cp1x,cp1y,cp2x,cpy2y,x,y);</span><br></pre></td></tr></table></figure><p>绘制曲线，需要两个控制点以及一点终点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawBezierLine</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">let</span> dx = <span class="number">150</span>;</span><br><span class="line">  <span class="keyword">let</span> dy = <span class="number">150</span>;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="number">100</span>;</span><br><span class="line">  context.beginPath();</span><br><span class="line">  context.fillStyle = <span class="string">'rgb(100,255,100)'</span>;</span><br><span class="line">  context.strokeStyle = <span class="string">'rgb(0,0,100)'</span>;</span><br><span class="line">  <span class="keyword">let</span> dig = <span class="built_in">Math</span>.PI / <span class="number">15</span> * <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">Math</span>.sin(i * dig);</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Math</span>.cos(i * dig);</span><br><span class="line">    context.bezierCurveTo(dx + x * s, dy + y * s - <span class="number">100</span>, dx + x * s + <span class="number">100</span>, dy + y * s, dx + x * s, dy + y * s);</span><br><span class="line">  &#125;</span><br><span class="line">  context.closePath()</span><br><span class="line">  context.fill();</span><br><span class="line">  context.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>quadraticCurveTo</code>方法绘制二次贝塞尔曲线</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.quadraticCurveTo(cpx,cpy,x,y)</span><br></pre></td></tr></table></figure><h3 id="绘制渐变图形"><a href="#绘制渐变图形" class="headerlink" title="绘制渐变图形"></a>绘制渐变图形</h3><h4 id="绘制线性渐变"><a href="#绘制线性渐变" class="headerlink" title="绘制线性渐变"></a>绘制线性渐变</h4><p>绘制线性渐变需要用到 <code>lineargradient</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.createLinearGradient(xStart,yStart,xEnd,yEnd);</span><br></pre></td></tr></table></figure><p>接着使用 addColorStop 方法设定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.addColorStop(offset,color);</span><br></pre></td></tr></table></figure><p>offset 为所设定的颜色离开渐变起始点的偏移量。参数的值是0到1之间的浮点值，渐变起始点的偏移量是0，渐变结束点的偏移量是1.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawLineGradient</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  <span class="keyword">const</span> gl = context.createLinearGradient(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>);</span><br><span class="line">  gl.addColorStop(<span class="number">0</span>, <span class="string">'rgb(255,255,0)'</span>);</span><br><span class="line">  gl.addColorStop(<span class="number">1</span>, <span class="string">'rgb(0,255,255)'</span>);</span><br><span class="line">  context.fillStyle = gl;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">const</span> g2 = context.createLinearGradient(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">0</span>);</span><br><span class="line">  g2.addColorStop(<span class="number">0</span>, <span class="string">'rgba(0,0,255,0.5)'</span>);</span><br><span class="line">  g2.addColorStop(<span class="number">0</span>, <span class="string">'rgba(255,0,0,0.5)'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.fillStyle = g2;</span><br><span class="line">    context.arc(i * <span class="number">25</span>, i * <span class="number">25</span>, i * <span class="number">10</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">    context.closePath();</span><br><span class="line">    context.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="绘制径向渐变"><a href="#绘制径向渐变" class="headerlink" title="绘制径向渐变"></a>绘制径向渐变</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.createRadialGradient(xStart,yStart,radiusStart,xEnd,yEnd,radiusEnd);</span><br></pre></td></tr></table></figure><p>分别指定两个圆的大小和位置。从第一个圆的圆心处向外进行扩散渐变，一直扩散到第二个圆的外轮廓处。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawRadialGradient</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  <span class="keyword">const</span> g1 = context.createRadialGradient(<span class="number">400</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">0</span>, <span class="number">400</span>);</span><br><span class="line">  g1.addColorStop(<span class="number">0.1</span>, <span class="string">'rgb(255,255,0)'</span>);</span><br><span class="line">  g1.addColorStop(<span class="number">0.3</span>, <span class="string">'rgb(255,0,255)'</span>);</span><br><span class="line">  g1.addColorStop(<span class="number">1</span>, <span class="string">'rgb(0,255,255)'</span>);</span><br><span class="line">  context.fillStyle = g1;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">const</span> g2 = context.createRadialGradient(<span class="number">250</span>, <span class="number">250</span>, <span class="number">0</span>, <span class="number">250</span>, <span class="number">250</span>, <span class="number">300</span>);</span><br><span class="line">  g2.addColorStop(<span class="number">0.1</span>, <span class="string">'rgb(255,0,0,0.5)'</span>);</span><br><span class="line">  g2.addColorStop(<span class="number">0.7</span>, <span class="string">'rgb(255,255,0,0.5)'</span>);</span><br><span class="line">  g2.addColorStop(<span class="number">1</span>, <span class="string">'rgb(0,0,255,0.5)'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.fillStyle = g2;</span><br><span class="line">    context.arc(i * <span class="number">25</span>, i * <span class="number">25</span>, i * <span class="number">10</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">    context.closePath();</span><br><span class="line">    context.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制变形图形"><a href="#绘制变形图形" class="headerlink" title="绘制变形图形"></a>绘制变形图形</h3><h4 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h4><p>主要有三种形式：</p><ul><li>平移，使用图形上下文的 <code>translate</code>方法来移动图形坐标轴原点。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.translate(x,y);</span><br></pre></td></tr></table></figure><ul><li>扩大，使用对象的 <code>scale</code>方法将图形放大</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.scale(x,y)</span><br></pre></td></tr></table></figure><ul><li>旋转，使用 <code>rotate</code>方法将图形进行旋转</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.rotate(angle);</span><br></pre></td></tr></table></figure><p>旋转中西是坐标轴的原点，顺时针方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawDeformationGraphics</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">   <span class="comment">// 改变圆心位置</span></span><br><span class="line">  context.translate(<span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'rgba(255,0,0,0.25)'</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    context.translate(<span class="number">25</span>, <span class="number">25</span>);</span><br><span class="line">    context.scale(<span class="number">0.95</span>, <span class="number">0.95</span>);</span><br><span class="line">    context.rotate(<span class="built_in">Math</span>.PI / <span class="number">10</span>);</span><br><span class="line">    context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码使用坐标变换的方法。首先绘制了一个长方形，然后在一个循环中反复使用平移坐标轴，图形缩小，图形旋转三种技巧绘制出来变形图形。</p><h4 id="与路径结合使用"><a href="#与路径结合使用" class="headerlink" title="与路径结合使用"></a>与路径结合使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawDeformationGraphicsWithFivePointedStar</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  context.translate(<span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'rgba(255,0,0,0.25)'</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    context.translate(<span class="number">25</span>, <span class="number">25</span>);</span><br><span class="line">    context.scale(<span class="number">0.95</span>, <span class="number">0.95</span>);</span><br><span class="line">    context.rotate(<span class="built_in">Math</span>.PI / <span class="number">10</span>);</span><br><span class="line">    createFivePointedStar(context);</span><br><span class="line">    context.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFivePointedStar</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.beginPath();</span><br><span class="line">  context.fillStyle = <span class="string">'rgba(255,0,0,0.5)'</span>;</span><br><span class="line">  <span class="keyword">const</span> dx = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">const</span> dy = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> s = <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">let</span> dig = <span class="built_in">Math</span>.PI / <span class="number">5</span> * <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">Math</span>.sin(i * dig);</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Math</span>.cos(i * dig);</span><br><span class="line">    context.lineTo(dx + x * s, dy + y * s);</span><br><span class="line">  &#125;</span><br><span class="line">  context.closePath();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h4><p>当图形上下文被创建完毕时，事实上也创建了一个默认的变换矩阵，如果不对这个变换矩阵进行修改，绘制的图形将以画布的最左上角为坐标原点绘制图形，绘制出来的图形也不经过缩放、变形的处理。我们可以对这个变换矩形进行修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.transform(a , b , c , d , e , f )</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><em>a</em></td><td style="text-align:left">水平缩放绘图</td></tr><tr><td style="text-align:left"><em>b</em></td><td style="text-align:left">水平倾斜绘图</td></tr><tr><td style="text-align:left"><em>c</em></td><td style="text-align:left">垂直倾斜绘图</td></tr><tr><td style="text-align:left"><em>d</em></td><td style="text-align:left">垂直缩放绘图</td></tr><tr><td style="text-align:left"><em>e</em></td><td style="text-align:left">水平移动绘图</td></tr><tr><td style="text-align:left"><em>f</em></td><td style="text-align:left">垂直移动绘图</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawTransform</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  <span class="keyword">const</span> colors = [<span class="string">'red'</span>, <span class="string">'orange'</span>, <span class="string">'yellow'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'navy'</span>, <span class="string">'purple'</span>];</span><br><span class="line">  context.lineWidth = <span class="number">10</span>;</span><br><span class="line">  context.transform(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; colors.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 定义每次向下移动 10个像素的变换矩阵</span></span><br><span class="line">    context.transform(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    context.strokeStyle = colors[i];</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.arc(<span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI, <span class="literal">true</span>);</span><br><span class="line">    context.stroke();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setTransform 会将变换矩阵重置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTransform(m11,m12,m21,m22,dx,dy)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawSetTransform</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.strokeStyle = <span class="string">'red'</span>;</span><br><span class="line">  context.strokeRect(<span class="number">30</span>, <span class="number">10</span>, <span class="number">60</span>, <span class="number">20</span>);</span><br><span class="line">  <span class="keyword">let</span> rad = <span class="number">45</span> * <span class="built_in">Math</span>.PI / <span class="number">180</span>;</span><br><span class="line"></span><br><span class="line">  context.setTransform(<span class="built_in">Math</span>.cos(rad), <span class="built_in">Math</span>.sin(rad), -<span class="built_in">Math</span>.sin(rad), <span class="built_in">Math</span>.cos(rad), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  context.strokeStyle = <span class="string">'blue'</span>;</span><br><span class="line">  context.strokeRect(<span class="number">30</span>, <span class="number">10</span>, <span class="number">60</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  context.setTransform(<span class="number">2.5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2.5</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  context.strokeStyle = <span class="string">'green'</span>;</span><br><span class="line">  context.strokeRect(<span class="number">30</span>, <span class="number">10</span>, <span class="number">60</span>, <span class="number">20</span>);</span><br><span class="line">  </span><br><span class="line">  context.setTransform(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">40</span>, <span class="number">80</span>);</span><br><span class="line">  context.strokeStyle = <span class="string">'gray'</span>;</span><br><span class="line">  context.strokeRect(<span class="number">30</span>, <span class="number">10</span>, <span class="number">60</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图形组合"><a href="#图形组合" class="headerlink" title="图形组合"></a>图形组合</h3><p>设定图形上下文对象的 <code>globalCompositeOperation</code>属性能自己决定图形的组合方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.globalCompositeOperation = type</span><br></pre></td></tr></table></figure><p>type 的值必须是下面几种字符串之一：</p><ul><li><p>source-over(默认值)</p><p>表示新图形覆盖杂原有图形上</p></li><li><p>destination-over</p><p>表示在原有图形之下绘制新图形</p></li><li><p>source-in</p><p>新图形与原有图形作 in 运算，只显示新图形中与原有图像相互重叠的部分，新图形与原有图形的其他部分均变成透明</p></li><li><p>destination-in</p><p>原有图形与新图形作 in 运算，只显示原有图形中与新图形相重叠的部分，新图形与原有图形的其他部分均变成透明</p></li><li><p>source-out</p><p>新图形与原有图形 out 运算。只显示新图形中与原有图形不重叠的部分，新图形与原有图形的其他部分变成透明</p></li><li><p>destination-out</p><p>新图形与原有图形 out 运算。只显示原有图形中与新图形不重叠的部分，原有图形与新图形的其他部分变成透明</p></li><li><p>source-atop</p><p>只绘制新图形中与原有图形重叠的部分与未被重叠覆盖的原有图形，新图形的其他部分变成透明</p></li><li><p>destination-atop</p><p>只绘制原有图形中被新图形重叠覆盖的部分与新图形的其他部分，原有图形中的其他部分变成透明，不绘制新图形中与原有图形相重叠的部分</p></li><li><p>lighter</p><p>原有图形与新图形均绘制，重叠部分做加色处理</p></li><li><p>xor</p><p>只绘制新图形中与原有图形不重叠的部分，重叠部分变成透明</p></li><li><p>copy</p><p>只绘制新图形，原有图形中未与新图形重叠的部分变成透明</p></li></ul><h3 id="给图形绘制阴影"><a href="#给图形绘制阴影" class="headerlink" title="给图形绘制阴影"></a>给图形绘制阴影</h3><ul><li>shadowOffsetX——阴影的横线位移量</li><li>shadowOffsetY——阴影的纵向位移量</li><li>shadowColor——阴影的颜色</li><li>shadowBlur——阴影的模糊范围</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawShadowFifthStar</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  context.shadowOffsetX = <span class="number">10</span>;</span><br><span class="line">  context.shadowOffsetY = <span class="number">10</span>;</span><br><span class="line">  context.shadowColor = <span class="string">'rgba(100,100,100,0.5)'</span>;</span><br><span class="line">  context.shadowBlur = <span class="number">7.5</span>;</span><br><span class="line">  context.translate(<span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    context.translate(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    createFivePointedStar(context);</span><br><span class="line">    context.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用图像"><a href="#使用图像" class="headerlink" title="使用图像"></a>使用图像</h3><h4 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宽高 为原图像宽高</span></span><br><span class="line">context.drawImage(image,x,y);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加宽高的自定义</span></span><br><span class="line">context.drawImage(image,x,y,w,h)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将画布中绘制好的图像的全部或者部分复制到画布的另一个位置上</span></span><br><span class="line">context.drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawCanvasImage</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>)</span><br><span class="line">  image = <span class="keyword">new</span> Image();</span><br><span class="line">  image.src = <span class="string">'../Desktop/微信图片_20190311090059.jpg'</span></span><br><span class="line">  image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    drawBigImage(context, image)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawImage</span>(<span class="params">context, image</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    context.drawImage(image, <span class="number">0</span> + i * <span class="number">50</span>, <span class="number">0</span> + i * <span class="number">25</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawBigImage</span>(<span class="params">context, image</span>) </span>&#123;</span><br><span class="line">  context.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">  context.drawImage(image, <span class="number">23</span>, <span class="number">5</span>, <span class="number">57</span>, <span class="number">80</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图像平铺"><a href="#图像平铺" class="headerlink" title="图像平铺"></a>图像平铺</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawTileImage</span>(<span class="params">canvas, context, image</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(canvas);</span><br><span class="line">  <span class="keyword">const</span> scale = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">let</span> n1 = image.width / scale;</span><br><span class="line">  <span class="keyword">let</span> n2 = image.height / scale;</span><br><span class="line">  <span class="keyword">let</span> n3 = canvas.width / n1;</span><br><span class="line">  <span class="keyword">let</span> n4 = canvas.height / n2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n3; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n4; j++) &#123;</span><br><span class="line">      context.drawImage(image, i * n1, j * n2, n1, n2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面使用变量和循环来实现图像平铺。还可以用更简便的图形上下文的 <code>createPattern</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.createPattern(image,type)</span><br></pre></td></tr></table></figure><p>image 参数为要平铺的图像，type 参数：</p><ul><li>no-repeat：不平铺</li><li>repeat-x：横方向平铺</li><li>repeat-y：纵方向平铺</li><li>repeat：全方向平铺</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawCanvasImage</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>)</span><br><span class="line">  image = <span class="keyword">new</span> Image();</span><br><span class="line">  image.src = <span class="string">'../Desktop/微信图片_20190311090059.jpg'</span>;</span><br><span class="line">  image.width = <span class="number">10</span>;</span><br><span class="line">  image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> canvasTemp = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">    <span class="keyword">const</span> contextTemp = canvasTemp.getContext(<span class="string">'2d'</span>);</span><br><span class="line">    canvasTemp.width = <span class="number">100</span>;</span><br><span class="line">    canvasTemp.height = <span class="number">100</span>;</span><br><span class="line">    contextTemp.drawImage(<span class="keyword">this</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">let</span> ptrn = context.createPattern(canvasTemp,<span class="string">'repeat'</span>);</span><br><span class="line">    <span class="comment">// context.drawImage(image, 23, 5, 57, 80);</span></span><br><span class="line">    context.fillStyle = ptrn;</span><br><span class="line">    context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当图像太大的时候，可以通过把图像绘制在一个临时的 canvas 里面，然后再用主canvas 重复这个临时 canvas </p><h4 id="图像裁剪"><a href="#图像裁剪" class="headerlink" title="图像裁剪"></a>图像裁剪</h4><p>使用 clip 方法设置裁剪区域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cutImage</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  <span class="keyword">const</span> gr = context.createLinearGradient(<span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>, <span class="number">0</span>);</span><br><span class="line">  gr.addColorStop(<span class="number">0</span>, <span class="string">'rgb(255,255,0)'</span>);</span><br><span class="line">  gr.addColorStop(<span class="number">1</span>, <span class="string">'rgb(0,255,255)'</span>);</span><br><span class="line">  context.fillStyle = gr;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  image = <span class="keyword">new</span> Image();</span><br><span class="line">  image.src = <span class="string">'../Desktop/微信图片_20190311090059.jpg'</span>;</span><br><span class="line">  image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    createFivePointedStar(context);</span><br><span class="line">    context.drawImage(image, <span class="number">-50</span>, <span class="number">-150</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFivePointedStar</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.beginPath();</span><br><span class="line">  context.translate(<span class="number">100</span>,<span class="number">150</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'rgba(255,0,0,0.5)'</span>;  </span><br><span class="line">  <span class="keyword">const</span> dx = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">const</span> dy = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> s = <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">let</span> dig = <span class="built_in">Math</span>.PI / <span class="number">5</span> * <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">Math</span>.sin(i * dig);</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Math</span>.cos(i * dig);</span><br><span class="line">    context.lineTo(dx + x * s, dy + y * s);</span><br><span class="line">  &#125;</span><br><span class="line">  context.closePath();</span><br><span class="line">  context.clip();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="像素处理"><a href="#像素处理" class="headerlink" title="像素处理"></a>像素处理</h4><p>使用 getImageData 方法可以获取图像中的像素,获得像素组依次 rgba 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageData = context.getImageData(x,y,width,height);</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><em>x</em></td><td style="text-align:left">开始复制的左上角位置的 x 坐标。</td></tr><tr><td style="text-align:left"><em>y</em></td><td style="text-align:left">开始复制的左上角位置的 y 坐标。</td></tr><tr><td style="text-align:left"><em>width</em></td><td style="text-align:left">将要复制的矩形区域的宽度。</td></tr><tr><td style="text-align:left"><em>height</em></td><td style="text-align:left">将要复制的矩形区域的高度。</td></tr></tbody></table><p>对于 ImageData 对象中的每个像素，都存在着四方面的信息，即 RGBA 值：</p><ul><li>R - 红色 (0-255)</li><li>G - 绿色 (0-255)</li><li>B - 蓝色 (0-255)</li><li>A - alpha 通道 (0-255; 0 是透明的，255 是完全可见的)</li></ul><p>利用 putImageData 将图像数据放回画布,期间做一些颜色处理，可以模拟滤镜。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// createFivePointedStar(context);</span></span><br><span class="line">  context.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">let</span> imagedata = context.getImageData(<span class="number">0</span>, <span class="number">0</span>, image.width, image.height)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = imagedata.data.length; i &lt; n; i += <span class="number">4</span>) &#123;</span><br><span class="line">    imagedata.data[i + <span class="number">0</span>] = <span class="number">255</span> - imagedata.data[i + <span class="number">0</span>];</span><br><span class="line">    imagedata.data[i + <span class="number">1</span>] = <span class="number">255</span> - imagedata.data[i + <span class="number">2</span>];</span><br><span class="line">    imagedata.data[i + <span class="number">2</span>] = <span class="number">255</span> - imagedata.data[i + <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  context.putImageData(imagedata, <span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.putImageData(imgData,x,y,dirtyX,dirtyY,dirtyWidth,dirtyHeight);</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><em>imgData</em></td><td style="text-align:left">规定要放回画布的 ImageData 对象。</td></tr><tr><td style="text-align:left"><em>x</em></td><td style="text-align:left">ImageData 对象左上角的 x 坐标，以像素计。</td></tr><tr><td style="text-align:left"><em>y</em></td><td style="text-align:left">ImageData 对象左上角的 y 坐标，以像素计。</td></tr><tr><td style="text-align:left"><em>dirtyX</em></td><td style="text-align:left">可选。水平值（x），以像素计，在画布上放置图像的位置。</td></tr><tr><td style="text-align:left"><em>dirtyY</em></td><td style="text-align:left">可选。水平值（y），以像素计，在画布上放置图像的位置。</td></tr><tr><td style="text-align:left"><em>dirtyWidth</em></td><td style="text-align:left">可选。在画布上绘制图像所使用的宽度。</td></tr><tr><td style="text-align:left"><em>dirtyHeight</em></td><td style="text-align:left">可选。在画布上绘制图像所使用的高度。</td></tr></tbody></table><h3 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h3><p>fillText 填充方式绘制字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.fillText(text,x,y,maxWidth);</span><br></pre></td></tr></table></figure><p>maxWidth，允许最大的宽度，像素单位</p><p>strokeText 用轮廓方式绘制字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.strokeText(text,x,y,maxWidth);</span><br></pre></td></tr></table></figure><p>一些关于文字绘制的属性：</p><ul><li>font：字体</li><li>textAlign：水平对齐方式，start(默认)、end、left、right、center</li><li>textBaseline：垂直对齐方式，top、hanging、middle、alphabetic(默认)、ideographic、bottom</li></ul><p>获得文字的宽度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.measureText(text)</span><br></pre></td></tr></table></figure><p>接受一个参数 text，该参数为需要绘制的文字，返回一个 TextMetrics 对象，TextMetrics对象的 width 属性表示使用当前指定的文字后  text 参数中指定的文字的总文字宽度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawText</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.font = <span class="string">'italic 20px sans-serif'</span>;</span><br><span class="line">  <span class="keyword">let</span> txt = <span class="string">'字符串的宽度为：'</span>;</span><br><span class="line">  <span class="keyword">let</span> tml = context.measureText(txt);</span><br><span class="line">  context.fillText(txt, <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">  context.fillText(tml.width, tml.width + <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">  context.font = <span class="string">'bold 30px sans-serif'</span>;</span><br><span class="line">  <span class="keyword">let</span> tm2 = context.measureText(txt);</span><br><span class="line">  context.fillText(txt, <span class="number">10</span>, <span class="number">70</span>);</span><br><span class="line">  context.fillText(tm2.width, tm2.width + <span class="number">10</span>, <span class="number">70</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="保存与恢复状态"><a href="#保存与恢复状态" class="headerlink" title="保存与恢复状态"></a>保存与恢复状态</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将当前状态保存到 栈中</span></span><br><span class="line">context.save();</span><br><span class="line"><span class="comment">// 从栈中取出之前保存的图形上下文的状态进行恢复 </span></span><br><span class="line">context.restore();</span><br></pre></td></tr></table></figure><p>绘画状态包括坐标的原点、变形时的变换矩阵，图形上下文对象的当前属性值。</p><p>可以应用在下面但不仅仅下面的场景：</p><ul><li>图像或图形变形</li><li>图像裁剪</li><li>改变图形上下文的以下属性的时候：fillStyle、font、globalAlpha、globalComposite、Operation、lineCap、lineJoin、lineWidth、miterLimit、shadowBlur、shadowColor、shadowOffsetX、shadowOffsetY、strokeStyle、textAlign、textBaseline</li></ul><h4 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h4><p> 原理实际上是把当前的绘画状态输出到一个 data URL 地址所指向的数据中的过程。data URL指的是目前大部分浏览器能够识别的一种 base64编码的 URL，主要用于小型的、可以在网页中直接嵌入的，而不需要从外部文件嵌入的数据，例如 img 元素中的图像文件等。</p><p>toDataURL 方法把绘画状态输出到一个 data URL中，然后重新装载，客户可以直接把装载后的文件进行保存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">canvas.toDataURL(type);</span><br><span class="line"><span class="comment">// type 表示输出输出类型的 MIME 类型</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawDataURL</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'rgb(0,0,255)'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">  context.fillStyle = <span class="string">'rgb(255,255,0)'</span>;</span><br><span class="line">  context.fillRect(<span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(canvas.toDataURL(<span class="string">"image/jepg"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单动画的制作"><a href="#简单动画的制作" class="headerlink" title="简单动画的制作"></a>简单动画的制作</h4><p>canvas 画布中制作的动画实际上就是一个不断擦除（clearRect）、重绘的过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animationOnCanvas</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  width = canvas.width;</span><br><span class="line">  height = canvas.height;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  setInterval(rotate, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rotate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  context.clearRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">  context.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">  context.fillRect(i, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">  i += <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多媒体播放"><a href="#多媒体播放" class="headerlink" title="多媒体播放"></a>多媒体播放</h2><h3 id="关于-video-与-audio元素"><a href="#关于-video-与-audio元素" class="headerlink" title="关于 video 与 audio元素"></a>关于 video 与 audio元素</h3><p>HTML4页面中播放视频或者音频数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">classid</span>=<span class="string">"clsid:F08DF954-8592-11D1-B16A-00C0F0283628"</span> <span class="attr">id</span>=<span class="string">"Slider1"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"50"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"BorderStyle"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"MousePointer"</span> <span class="attr">value</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Enabled"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Min"</span> <span class="attr">value</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Max"</span> <span class="attr">value</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"allowFullScreen"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"allowscriptaccess"</span> <span class="attr">value</span>=<span class="string">"always"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">embed</span> <span class="attr">type</span>=<span class="string">"application/x-shockwave-flash"</span> <span class="attr">width</span>=<span class="string">"425"</span> <span class="attr">height</span>=<span class="string">"344"</span> <span class="attr">src</span>=<span class="string">"p.swf"</span> <span class="attr">allowscriptaccess</span>=<span class="string">"always"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">allowfullscreen</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出上面代码的一些缺点：冗长，需要使用 Flash 插件，用户没有安装的话，则视频看不了。需要结合多个元素，并且需要添加很多属性。</p><p>HTML5 中的则是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">'xxx.mp3'</span>&gt;</span></span><br><span class="line">    您的浏览器器不支持 audio 元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">"640"</span> <span class="attr">height</span>=<span class="string">"360"</span> <span class="attr">src</span>=<span class="string">'xxx.mp4'</span>&gt;</span></span><br><span class="line">    您的浏览器器不支持 video 元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--结合 source元素为同一个媒体数据指定多个播放格式与编码方式，浏览器会从中找到一种自己支持的播放格式来播放 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"sample.ogv"</span> <span class="attr">type</span>=<span class="string">"video/ogg"</span>;<span class="attr">codecs</span>=<span class="string">"theora,vorbis"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"sample.mov"</span> <span class="attr">type</span>=<span class="string">"video/quicktime"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--type指播放媒体的MIME类型，codes表示媒体的编码格式--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p>src</p><p>指定媒体数据的 URL 地址</p></li><li><p>autoplay</p><p>指定媒体是否在页面加载后自动播放</p></li><li><p>preload</p><p>指定数据是否预加载。预加载浏览器会预先将视频或者音频数据缓冲，加快播放速度，因为播放时数据已经缓冲完毕。该属性有 none（不进行预加载）、metadata（只预加载媒体的元数据：媒体字节数、第一帧、播放列表、持续时间等）、auto(默认，表示预加载全部视频或者音频)。</p></li><li><p>poster(video独有)</p><p>当视频不可用的时候，可以使用该元素向用户展示一副替代用的图片。用户体验良好</p></li><li><p>loop</p><p>循环播放</p></li><li><p>controls</p><p>添加浏览器自带的播放用的控制条，具有播放、暂停等按钮。</p></li><li><p>width 与 height（video独有）</p><p>该属性中指定视频的宽度和高度（像素）</p></li><li><p>error</p><p>读取使用媒体数据的过程中出错的话，返回一个 MediaError对象，该对象的code返回对应的错误状态，有4个值</p><p>MEDIA_ERR_ABORTED(数字值为1)：媒体数据的下载过程由于用户操作的原因而被中止</p><p>MEDIA_ERR_NETWORK(数字值为2)：确认媒体资源可用，但是在下载时出现网络错误，媒体数据的下载过程被中止</p><p>MEDIA_ERR_DECODE(数字值为3)：确认媒体资源可用，但是解码时发生错误。</p><p>MEDIA_ERR_SRC_NOT_SUPPORTED(数字值为4)：媒体资源不可用媒体格式不被支持，error属性为只读属性</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.getElementById(<span class="string">'video element'</span>);</span><br><span class="line">video.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; error &#125; = video;</span><br><span class="line">  <span class="keyword">switch</span> (error.code) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'视频的下载过程被中止'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'网络发生故障，视频的下载过程被中止'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'解码失败'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'不支持的播放格式'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'无'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><ul><li>networkState,4个可能值<ul><li>NETWORK_EMPTY(数字值为0)：音频/视频尚未初始化</li><li>NETWORK_IDLE(1)：音频/视频是活动的且已选取资源，但并未使用网络</li><li>NETWORK_LOADING(2)：浏览器正在下载数据</li><li>NETWORK_NO_SOURCE(3)：未找到音频/视频来源</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">video.addEventListener(<span class="string">'progress'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; networkState &#125; = video;</span><br><span class="line">  <span class="keyword">if</span> (networkState === <span class="number">2</span>) &#123;</span><br><span class="line">    x.innerHTML = <span class="string">`加载中...[<span class="subst">$&#123;e.loaded&#125;</span>/<span class="subst">$&#123;e.total&#125;</span> byte]`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (networkState === <span class="number">3</span>) &#123;</span><br><span class="line">    x.innerHTML = <span class="string">'记载失败'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><ul><li><p>currentSrc</p><p>读取播放中的媒体数据的 URL地址，为只读属性</p></li><li><p>buffered（只读）</p><p>buffered 属性返回 TimeRanges 对象。该对象表示用户的音视频缓冲范围，缓冲范围指的是已缓冲音视频的时间范围。如果用户在音频中跳跃播放，会得到多个缓冲范围。</p></li></ul><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">audio|video.buffered</span><br></pre></td></tr></table></figure><p>返回值</p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">TimeRanges 对象</td><td style="text-align:left">表示音视频的已缓冲部分。TimeRanges 对象属性：length - 获得音视频中已缓冲范围的数量<br>start(index) - 获得某个已缓冲范围的开始位置<br/>end(index) - 获得某个已缓冲范围的结束位置<br/><strong>注释：</strong>首个缓冲范围的下表是 0。</td></tr></tbody></table><ul><li><p>readyState（只读）</p><p>返回媒体当前的播放位置的就绪状态值：</p><p>HAVE_NOTHING(0)：没有获取到媒体的任何信息，当前的播放位置没有可播放数据</p><p>HAVE_METADATA(1)：已经获取到足够的媒体数据，但是当前播放位置没有有效的媒体数据（获取到的媒体数据无效）</p><p>HAVE_CURRENT_DATA(2)：当前播放位置已经有数据可以播放，但没有获取到可以让播放器前进的数据。当媒体为视频，即当前帧的数据已经获得，也获得了下一帧大数据，或者当前帧已经是最后一帧</p><p>HAVE_FUTURE_DATA(3)：当前播放位置已经有数据可以播放，而且也获得到了可以让播放器前进的数据。当媒体为视频时，即当前帧的数据已经获得，而且也获得了下一帧的数据，当前帧是播放的最后一帧时，readyState 属性不可能为 HAVE_FUTURE_DATA</p><p>HAVE_ENOUGH_DATA(4)：当前播放位置已经有数据可以播放，同时也获得了可以让播放器前进的数据，而且浏览器确认媒体数据以某一种速度可以加载，可以保证有足够的后续数据进行播放。</p></li><li><p>seeking属性与seekable（只读）</p><p>seeking属性返回一个布尔值，表示浏览器是否正在请求某一特定播放为孩子的数据，true表示浏览器正在请求数据，false表示浏览器正在停止请求。</p><p>seekable返回一个 TimeRanges对象，该对象表示请求到的数据的时间范围。当媒体为视频时，开始时间为请求到视频数据第一帧的时间结束为请求到视频数据最后一帧的时间。</p></li><li><p>currentTime（可读写）/startTime（只读）/duration（只读）</p><p>currentTime获取当前播放位置，也可以通过修改currentTime来修改当前播放位置。如果修改的位置上没有可用的媒体数据时，将抛出 INVALID_STATE_ERR 异常。如果修改的位置超出了浏览器在一次请求中可以请求的数据范围，将抛出 INDEX_SIZE_ERR  异常。</p><p>startTime 来读取媒体播放的开始时间，通常为0</p><p>duration 读取媒体文件总的播放时间</p><p>三者单位均为秒</p></li><li><p>played/paused/ended（均为只读）</p><p>played 返回一个 TimeRanges 对象，从该对象中可以去读媒体文件的以播放部分的时间段。开始时间为已播放部分的开始时间，结束时间为已播放部分的结束时间。</p><p>paused 返回一个布尔值，表示是否处于暂停播放中，true 表示媒体暂停播放，false 表示媒体正在播放</p><p>end 返回一个布尔值，表示是否播放完毕，true表示播放完毕，false表示还没有播放完毕</p></li><li><p>defaultPlaybackRate/playbackRate</p><p>前者读取或者修改默认的播放速率，后者可以读取修改当前的播放速率</p></li><li><p>volume与 muted</p><p>Volume 读取或者修改媒体的播放音量，范围为0到1。0为静音，1为最大音量</p><p>muted读取或者修改媒体的静音状态，布尔值。true表示静音状态，false表示非静音状态</p></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>video与 audio都有以下四种方法：</p><ul><li>play。播放媒体，将 paused变为 false</li><li>pause。暂停媒体，将 paused 变为 true</li><li>load。重新载入媒体进行播放，将 playbackRate变为 defaultPlaybackRate，error变为 null</li><li>canPlayType。来测试浏览器是否支持指定的媒体类型。<code>support = videoElement.canPlayType(type)</code>。该方法使用一个参数type，该参数的指定方法与 source元素的type参数的指定方法相同，都用播放文件的 MIME 类型来指定，可以在指定的字符串中加上表示媒体编码格式的 codes参数。该方法返回3个可能值：<ul><li>空字符串：表示浏览器不支持此种媒体类型</li><li>maybe：表示浏览器可能支持此种媒体类型</li><li>probably：表示浏览器确定支持此种媒体类型</li></ul></li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件处理方式分为两种：</p><ul><li>addEventListener</li><li>获取事件句柄的方式</li></ul><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>loadstart</td><td>浏览器开始在网上寻找媒体数据</td></tr><tr><td>progress</td><td>浏览器正在获取媒体数据</td></tr><tr><td>suspend</td><td>浏览器暂停获取媒体数据，但是下载过程并没有正常结束</td></tr><tr><td>abort</td><td>浏览器在下载完全部媒体数据之前中止获取媒体数据，但是并不是由错误引起的</td></tr><tr><td>error</td><td>获取媒体数据过程中出错</td></tr><tr><td>emptied</td><td>video元素或者 audio元素所在网络突然变为未初始状态。可能引起的原因有两个：载入媒体过程中突然发生一个致命错误和在浏览器正在选择支持的播放格式时，又调用了 load 方法重新载入媒体</td></tr><tr><td>stalled</td><td>浏览器尝试获取媒体数据失败</td></tr><tr><td>play</td><td>即使开始播放，当执行了 play 方法时触发，或者数据下载完之后元素被谁 autoplay</td></tr><tr><td>pause</td><td>播放暂停，当执行了 pause 方法时触发</td></tr><tr><td>loadedmetadata</td><td>浏览器获取完毕媒体的时长好字节数</td></tr><tr><td>loadeddata</td><td>浏览器已经加载完毕当前播放位置的媒体数据，准备播放</td></tr><tr><td>waiting</td><td>播放过程由于得不到下一帧而暂停播放（例如下一帧尚未加载完毕），但很快就能够播放下一帧</td></tr><tr><td>playing</td><td>正在播放</td></tr><tr><td>canplay</td><td>浏览器能够播放媒体，但估计以前播放速率不能直接将媒体播放完毕，播放需要缓冲</td></tr><tr><td>canplaythrough</td><td>浏览器能够播放媒体，而且以当前播放速率能够将媒体播放完毕，不再需要进行缓冲</td></tr><tr><td>seeking</td><td>seeking属性变为 true，浏览器正在请求数据</td></tr><tr><td>seeked</td><td>seeking属性变成false，浏览器停止请求数据</td></tr><tr><td>timeupdate</td><td>当前播放位置被改变，可能是播放过程中的自然改变，也可能是人为地改变，或由于播放不能连续而发生的跳变</td></tr><tr><td>ended</td><td>播放结束后停止播放</td></tr><tr><td>ratechange</td><td>defaultplaybackRate属性（默认播放速率）或 playbackRate属性（当前播放速率）被改变</td></tr><tr><td>durationchange</td><td>播放时长被改变</td></tr><tr><td>volumechange</td><td>volume（音量）被改变或者 muted（静音状态） 被改变</td></tr></tbody></table><h3 id="事件捕捉示例"><a href="#事件捕捉示例" class="headerlink" title="事件捕捉示例"></a>事件捕捉示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">video.addEventListener(<span class="string">'timeupdate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> timer = <span class="built_in">document</span>.getElementById(<span class="string">'time'</span>);</span><br><span class="line">  timer.innerHTML = <span class="built_in">Math</span>.floor(video.currentTime) + <span class="string">'/'</span> + <span class="built_in">Math</span>.floor(video.duration) + <span class="string">'(秒)'</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><h3 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h3><p>我们可以使用 cookies 在客户端保存注入用户等简单的用户信息，但它有一些限制：</p><ul><li>大小：cookies大小被限制在 4KB</li><li>带宽：cookies 随 HTTP 事务一起被发送，会浪费一部分发送 cookies使用的带宽</li><li>复杂度</li></ul><p>在 HTML5中重新提供了一种在客户端本地保存数据的功能，就是 Web Storage 功能。它分为两种</p><ul><li><p>sessionStorage</p><p>将数据保存在 seesion对象中。所谓的 session，是指用户在浏览某个网站的时候，从进入网站到浏览器关闭所经过这段时间，也就是用户浏览器这个网站所花费的时间，session 对象可以用来保存这时间所要求保存的任何数据、</p></li><li><p>localStorage</p><p>将数据保存在客户端本地的硬件设备（通常值硬盘，但也可以是其他硬件设备）中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站仍然可以使用。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sessionStorage</span></span><br><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">sessionStorage.setItem(key,value);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line">变量 = seesionStorage.getItem(key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// localStorage</span></span><br><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">localStorage.setItem(key,value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">变量 = localStorage.getItem(key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存时不允许重复键名。保存后可以修改键值，但是不允许修改键名（只能重新取键名，然后保存键值）</span></span><br></pre></td></tr></table></figure><h3 id="示例：简单-web-留言本"><a href="#示例：简单-web-留言本" class="headerlink" title="示例：简单 web 留言本"></a>示例：简单 web 留言本</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>简单 Web 留言本<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"memo"</span> <span class="attr">id</span>=<span class="string">"memo"</span> <span class="attr">cols</span>=<span class="string">"60"</span> <span class="attr">rows</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"追加"</span> <span class="attr">onclick</span>=<span class="string">"saveStorage('memo')"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"初始化"</span> <span class="attr">onclick</span>=<span class="string">"clearStorage('msg')"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">saveStorage</span>(<span class="params">id</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> data = <span class="built_in">document</span>.getElementById(id).value;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span></span><br><span class="line"><span class="undefined">    localStorage.setItem(time, data);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'数据已经保存了'</span>);</span></span><br><span class="line"><span class="javascript">    loadStorage(<span class="string">'msg'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">loadStorage</span>(<span class="params">id</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> result = <span class="string">`&lt;table border="1"&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; localStorage.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> key = localStorage.key(i);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> value = localStorage.getItem(key);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="undefined">      date.setTime(key);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> datestr = date.toGMTString();</span></span><br><span class="line"><span class="xml">      result += `<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;value&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;datestr&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span>`</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    result += <span class="string">`&lt;/table&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> target = <span class="built_in">document</span>.getElementById(id);</span></span><br><span class="line"><span class="undefined">    target.innerHTML = result;</span></span><br><span class="line"><span class="undefined">  &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">clearStorage</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    localStorage.clear();</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'全部数据被清除'</span>);</span></span><br><span class="line"><span class="javascript">    loadStorage(<span class="string">'msg'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="示例：简易数据库"><a href="#示例：简易数据库" class="headerlink" title="示例：简易数据库"></a>示例：简易数据库</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>简易数据库<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>EMAIL:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"email"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>电话号码:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"tel"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>备注:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"memo"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"saveStorage()"</span> <span class="attr">value</span>=<span class="string">"保存"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>检索：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"find"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"检索"</span> <span class="attr">onclick</span>=<span class="string">"findStorage('msg')"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">saveStorage</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Object</span>;</span></span><br><span class="line"><span class="javascript">    data.name = <span class="built_in">document</span>.getElementById(<span class="string">'name'</span>).value;</span></span><br><span class="line"><span class="javascript">    data.email = <span class="built_in">document</span>.getElementById(<span class="string">'email'</span>).value;</span></span><br><span class="line"><span class="javascript">    data.tel = <span class="built_in">document</span>.getElementById(<span class="string">'name'</span>).value;</span></span><br><span class="line"><span class="javascript">    data.memo = <span class="built_in">document</span>.getElementById(<span class="string">'memo'</span>).value;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(data);</span></span><br><span class="line"><span class="undefined">    localStorage.setItem(data.name, str);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'数据已经保存了'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">findStorage</span>(<span class="params">id</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> find = <span class="built_in">document</span>.getElementById(<span class="string">'find'</span>).value;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> str = localStorage.getItem(find);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(str);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> result = <span class="string">`姓名： <span class="subst">$&#123;data.name&#125;</span>&lt;br&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    result += <span class="string">`EMAIL： <span class="subst">$&#123;data.email&#125;</span>&lt;br&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    result += <span class="string">`电话号码： <span class="subst">$&#123;data.tel&#125;</span>&lt;br&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    result += <span class="string">`备注： <span class="subst">$&#123;data.memo&#125;</span>&lt;br&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> target = <span class="built_in">document</span>.getElementById(id);</span></span><br><span class="line"><span class="undefined">    target.innerHTML = result;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="本地数据库-新的推荐IndexedDB实现"><a href="#本地数据库-新的推荐IndexedDB实现" class="headerlink" title="本地数据库(新的推荐IndexedDB实现)"></a>本地数据库(新的推荐IndexedDB实现)</h2><p>HTML5中内置了一个可以通过 SQL 语言来访问的数据库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> db = openDatabase(<span class="string">'mydb'</span>,<span class="string">'1.0'</span>,<span class="string">'Test DB'</span>,<span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br></pre></td></tr></table></figure><p>openDatabase接收五个参数：</p><ol><li>数据库名字</li><li>数据库版本号</li><li>显示名字</li><li>数据库保存数据的大小（以字节为单位 )</li><li>回调函数（非必须)</li></ol><p>transaction 方法来执行事务处理，防止在对数据库进行访问以及有关操作的时候收到外界的干扰。当一条语法执行失败的时候，整个事务会回滚</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.transaction(<span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    context.executeSql(<span class="string">'CREATE TABLE IF NOT EXISTS tesTable (id unique,name)'</span>);</span><br><span class="line">    context.executeSql(<span class="string">'INSERT INTO testTable(id,name) VALUES (0,"haha")'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>executeSql 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transaction.executeSql(sqlquery,[],dataHandler,errorHandler);</span><br></pre></td></tr></table></figure><p>executeSql 接收四个参数：</p><ol><li>查询字符串</li><li>用以替换查询字符串中问号的参数</li><li>执行成功回调函数（可选）</li><li>执行失败回调函数（可选）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transaction.executeSql(<span class="string">"UPDATE people set age=?where name=?;"</span>,[age,name],(transaction,result)=&gt;&#123;&#125;,(transaction,errmsg)=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure><h3 id="实例：留言本"><a href="#实例：留言本" class="headerlink" title="实例：留言本"></a>实例：留言本</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"init()"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>使用数据库实现的 Web 留言本<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>留言：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"memo"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"保存"</span> <span class="attr">onclick</span>=<span class="string">"saveData()"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">"datatable"</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> datatable = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> db = openDatabase(<span class="string">'MyData'</span>, <span class="string">''</span>, <span class="string">'My Database'</span>, <span class="number">102400</span>);</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(datatable.childNodes);</span></span><br><span class="line"><span class="javascript">    datatable = <span class="built_in">document</span>.getElementById(<span class="string">'datatable'</span>);</span></span><br><span class="line"><span class="undefined">    showAllData();</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">removeAllData</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = datatable.childNodes.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span></span><br><span class="line"><span class="undefined">      datatable.removeChild(datatable.childNodes[i]);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> tr = <span class="built_in">document</span>.createElement(<span class="string">'tr'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> th1 = <span class="built_in">document</span>.createElement(<span class="string">'th'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> th2 = <span class="built_in">document</span>.createElement(<span class="string">'th'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> th3 = <span class="built_in">document</span>.createElement(<span class="string">'th'</span>);</span></span><br><span class="line"><span class="javascript">    th1.innerHTML = <span class="string">'姓名'</span>;</span></span><br><span class="line"><span class="javascript">    th2.innerHTML = <span class="string">'留言'</span>;</span></span><br><span class="line"><span class="javascript">    th3.innerHTML = <span class="string">'时间'</span>;</span></span><br><span class="line"><span class="undefined">    tr.appendChild(th1);</span></span><br><span class="line"><span class="undefined">    tr.appendChild(th2);</span></span><br><span class="line"><span class="undefined">    tr.appendChild(th3);</span></span><br><span class="line"><span class="undefined">    datatable.appendChild(tr);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">showData</span>(<span class="params">row</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> tr = <span class="built_in">document</span>.createElement(<span class="string">'tr'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> td1 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span></span><br><span class="line"><span class="undefined">    td1.innerHTML = row.name;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> td2 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span></span><br><span class="line"><span class="undefined">    td2.innerHTML = row.message;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> td3 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> t = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="undefined">    t.setTime(row.time);</span></span><br><span class="line"><span class="javascript">    td3.innerHTML = t.toLocaleDateString() + <span class="string">" "</span> + t.toLocaleTimeString();</span></span><br><span class="line"><span class="undefined">    tr.appendChild(td1);</span></span><br><span class="line"><span class="undefined">    tr.appendChild(td2);</span></span><br><span class="line"><span class="undefined">    tr.appendChild(td3);</span></span><br><span class="line"><span class="undefined">    datatable.appendChild(tr);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">showAllData</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    db.transaction(<span class="function"><span class="keyword">function</span> (<span class="params">tx</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      tx.executeSql(<span class="string">'CREATE TABLE IF NOT EXISTS MsgData(name TEXT,message TEXT,time INTEGER)'</span>, []);</span></span><br><span class="line"><span class="javascript">      tx.executeSql(<span class="string">'SELECT * FROM MsgData'</span>, [], <span class="function"><span class="keyword">function</span> (<span class="params">tx, rs</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">        removeAllData();</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rs.rows.length; i++) &#123;</span></span><br><span class="line"><span class="undefined">          showData(rs.rows.item(i));</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">addData</span>(<span class="params">name, message, time</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    db.transaction(<span class="function"><span class="keyword">function</span> (<span class="params">tx</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      tx.executeSql(<span class="string">'INSERT INTO MsgData VALUES(?,?,?)'</span>, [name, message, time], <span class="function"><span class="keyword">function</span> (<span class="params">tx, rs</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'成功保存数据'</span>);</span></span><br><span class="line"><span class="javascript">      &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">tx, error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;error.source&#125;</span>:<span class="subst">$&#123;error.message&#125;</span>`</span>);</span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">saveData</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> name = <span class="built_in">document</span>.getElementById(<span class="string">'name'</span>).value;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> memo = <span class="built_in">document</span>.getElementById(<span class="string">'memo'</span>).value;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span></span><br><span class="line"><span class="undefined">    addData(name, memo, time);</span></span><br><span class="line"><span class="undefined">    showAllData();</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不过，Web SQL Database规范已经被废弃。因为每个浏览器都有自己的实现，浏览器的兼容性就不重要了。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">关于 IndexedDB</a></p><h2 id="离线应用程序（已废弃）"><a href="#离线应用程序（已废弃）" class="headerlink" title="离线应用程序（已废弃）"></a>离线应用程序（<strong>已废弃</strong>）</h2><p>HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。</p><p>应用程序缓存为应用带来三个优势：</p><ul><li>离线浏览 - 用户可在应用离线时使用它们</li><li>速度 - 已缓存资源加载得更快</li><li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</li></ul><p><strong>本地缓存与浏览器网页缓存的区别</strong></p><p>本地缓存为整个 Web 程序服务的，浏览器的网页缓存只服务于单个网页。任何网页都有网页缓存，而本地缓存值缓存指定的网页。本地缓存可以控制缓存更新，利用缓存对象的各种属性、状态和事件来开发出离线应用程序</p><h3 id="manifest文件"><a href="#manifest文件" class="headerlink" title="manifest文件"></a>manifest文件</h3><p>首先在 index.html 中引入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">！DOCTYPE</span> <span class="attr">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">mainfest</span> =<span class="string">'index.appcache'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。</p><p>manifest 文件的建议的文件扩展名是：”.appcache”。</p><p>请注意，manifest 文件需要配置<em>正确的 MIME-type</em>，即 “text/cache-manifest”。必须在 web 服务器上进行配置。</p><p>Web 应用程序的本地缓存是通过每个页面的 <code>manifest</code>文件来管理的。是一个简单的文件文本，清单列举了需要被缓存或者不需要被缓存的资源文件的文件名以及访问路径。</p><p>manifest 文件可分为三个部分：</p><ul><li><em>CACHE MANIFEST</em> - 在此标题下列出的文件将在首次下载后进行缓存</li><li><em>NETWORK</em> - 在此标题下列出的文件需要与服务器的连接，且不会被缓存</li><li><em>FALLBACK</em> - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"># 文件开头必须要书写 CACHE MANIFEST</span><br><span class="line"># 以下是需要缓存的文件</span><br><span class="line"></span><br><span class="line">other.html</span><br><span class="line">images/1.jpg</span><br><span class="line">js/jquery.js</span><br><span class="line">css/bootstrap.css</span><br><span class="line"></span><br><span class="line">NETWORK：</span><br><span class="line">login.asp</span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line">online.js locale.js</span><br><span class="line"># 如果无法建立因特网连接，用 404页面替换/html/目录所有的文件，第一个是 URI资源，第二个是替补</span><br><span class="line">/html5/ /404.html</span><br></pre></td></tr></table></figure><p><strong>更新缓存</strong></p><p>一旦应用被缓存，它就会保持缓存知道下列的情况发生：</p><ul><li>用户清空浏览器缓存</li><li>manifest 文件被修改</li><li>由程序来更新应用缓存</li></ul><h3 id="浏览器与服务器的交互过程"><a href="#浏览器与服务器的交互过程" class="headerlink" title="浏览器与服务器的交互过程"></a>浏览器与服务器的交互过程</h3><p>场景：访问 网站A,以 index.html 为主页，使用 manifest 缓存了 index.html、1.js、1.css、1.jpg几个资源文件。</p><p>第一次访问：</p><ol><li>浏览器请求访问网站 A</li><li>服务器访问 index.html</li><li>浏览器解析 index.html，请求页面上的所有资源，包括 HTML/图像文件/CSS/JS/manifest文件等</li><li>服务器返回所有资源</li><li>浏览器处理 manifest文件，请求 manifest指定的本地缓存的文件，即使3中已经请求过了。如果要求缓存所有文件也是一个比较大的重复过程。</li><li>服务器返回所有要求缓存的文件</li><li>浏览器对本地缓存文件进行缓存，触发一个事件，通知本地缓存被更新</li></ol><p>manifest文件没有被修改，第二次访问：</p><ol><li>浏览器再次请求网站A</li><li>浏览器发现这个页面被本地缓存，于是使用本地缓存中的 index.html页面</li><li>浏览器解析 index.html，使用所有本地缓存中的资源文件</li><li>浏览器向服务器请求 manifest 文件</li><li>服务器返回一个 304，通知浏览器 manifest没有发生变化</li></ol><p>manifest文件被修改了，第三次访问：</p><ol><li>浏览器再次请求网站A</li><li>浏览器发送这个页面被本地缓存了，于是使用本地缓存中的 index.html页面</li><li>浏览器解析 index.html 文件，使用所有本地缓存中的资源文件</li><li>浏览器向服务器请求 manifest文件</li><li>服务器返回更新过的 manifest文件</li><li>浏览器处理 manifest文件，发送文件已经更新了，于是请求所有要求进行本地缓存的资源文件，包括 index.html 本身</li><li>浏览器返回要求进行本地缓存的资源文件</li><li>浏览器对本地缓存进行更新，存入所有新的资源文件，并且触发一个事件，通知本地缓存被更新了</li></ol><p>浏览器缓存过程中会触发一系列事件，该事件处理程序注册在ApplicationCache对象上，此对象是window的applicationCache属性的值。</p><p>下面详细描述了加载文档与更新应用缓存的流程：</p><ol><li>当浏览器访问一个包含 <code>manifest</code> 特性的文档时，如果应用缓存不存在，浏览器会加载文档，然后获取所有在清单文件中列出的文件，生成应用缓存的第一个版本。</li><li>对该文档的后续访问会使浏览器直接从应用缓存(而不是服务器)中加载文档与其他在清单文件中列出的资源。此外，浏览器还会向 <code>window.applicationCache 对象发送一个</code> <code>checking</code> 事件，在遵循合适的 HTTP 缓存规则前提下，获取清单文件。</li><li>如果当前缓存的清单副本是最新的，浏览器将向 <code>applicationCache 对象发送一个</code> <code>noupdate</code> 事件，到此，更新过程结束。注意，如果你在服务器修改了任何缓存资源，同时也应该修改清单文件，这样浏览器才能知道它需要重新获取资源。</li><li>如果清单文件<em>已经</em>改变，文件中列出的所有文件—也包括通过调用 <code>applicationCache.add() 方法添加到缓存中的那些文件</code>—会被获取并放到一个临时缓存中，遵循适当的 HTTP 缓存规则。对于每个加入到临时缓存中的文件，浏览器会向 <code>applicationCache 对象发送一个</code> <code>progress</code> 事件。如果出现任何错误，浏览器会发送一个 <code>error</code> 事件，并暂停更新。</li><li>一旦所有文件都获取成功，它们会自动移送到真正的离线缓存中，并向  <code>applicationCache</code>对象发送一个 <code>cached</code> 事件。鉴于文档早已经被从缓存加载到浏览器中，所以更新后的文档不会重新渲染，直到页面重新加载(可以手动或通过程序).</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//载入的时候，检查该清单文件。</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onchecking = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"san"</span>).innerHTML = <span class="string">"checking for a new version"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果清单文件没有动，同时应用程序也已经缓存了，该事件执行。</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onnoupdate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"san"</span>).innerHTML = <span class="string">"This version is up-to-date"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果还未缓存应用程序，或者清单有改动</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.ondownloading = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"san"</span>).innerHTML = <span class="string">"Downloading new version"</span>;</span><br><span class="line">    <span class="built_in">window</span>.progresscount = <span class="number">0</span>; <span class="comment">//在下面的事件中用到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下载过程不断调用progress事件，通常在每个文件下载完的时候。</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> progress = <span class="string">""</span>; </span><br><span class="line">    <span class="keyword">if</span>(e &amp;&amp; e.lengthComputable)&#123;</span><br><span class="line">        progress = <span class="string">""</span> + <span class="built_in">Math</span>.round(<span class="number">100</span>*e.loaded / e.total) + <span class="string">"%"</span>; <span class="comment">//计算下载完成比例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        progress = <span class="string">"("</span> + ++progresscount + <span class="string">")"</span>;  <span class="comment">//输出调用次数。</span></span><br><span class="line">    &#125;</span><br><span class="line">    $(<span class="string">"san"</span>).innerHTML = <span class="string">"Downloading new version"</span> + progress;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当下载完成并且首次将应用程序下载到缓存中时</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.oncached = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"san"</span>).innerHTML = <span class="string">"This application is now cached locally"</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下载完成并且首次将应用程序下载到缓存中。</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.oncached = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">"This application is now cached locally"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//下载完成并缓存的程序更新后触发，注意触发此事件时，用户任然看到老版本，只有当用户再次载入时才会访问最新版。</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onupdateready = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">"A new version has been downloaded.  Reload to run it"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//处于离线时，检查清单失败触发。</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">window</span>.applicationCache.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">"Couldn't load manifest or cache application"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//程序引用一个不存在的清单文件触发，同时将应用从缓存中删除。</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onobsolete = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">"This application is no longer cached. "</span> + </span><br><span class="line">           <span class="string">"Reload to get the latest version from the network."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="通信-API"><a href="#通信-API" class="headerlink" title="通信 API"></a>通信 API</h2><h3 id="跨文档消息传输"><a href="#跨文档消息传输" class="headerlink" title="跨文档消息传输"></a>跨文档消息传输</h3><p>可以在不同网页文档、不同端口、不同域之间进行消息传递。</p><p>HTML5 提供了在网页文档之间互相接受与发送消息的功能，只要获取到网页所在窗口对象的实例，不仅同源（域+端口号）的 Web 之间可以互相通信，甚至可以实现跨域通信。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.postMessage();</span><br><span class="line"><span class="comment">// 这个方法可以安全实现跨域通信。提供了一个受控禁止来规避同源策略的限制。这个方法被调用时，会在所有页面脚本执行完毕之后向目标窗口派发一个 MessageEvent 消息。这个消息有四个属性：message属性表示 message类型，data属性为 window.postMessage的第一个参数；origin属性表示调用 window.postMessage方法调用页面的当前状态；source属性记录调用 window.postMessage方法的窗口消息</span></span><br><span class="line"></span><br><span class="line">otherWindow.postMessage(message,targetOrigin,[transfer]);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* otherWindow 其他窗口的一个引用，比如 iframe的contentWindow属性，执行 window.open返回的窗口对象，或者是命名过或数值索引的 window.frames</span></span><br><span class="line"><span class="comment">* message 将要发送到其他 window的数据，会被结构化克隆算法序列化。意味着不受什么限制将数据对象安全传送给目标窗口不用自己序列化</span></span><br><span class="line"><span class="comment">* targetOrigin 通过窗口的 origin 属性来指定哪些窗口能接受到消息时间。可以是“*”或者一个URI.如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；</span></span><br><span class="line"><span class="comment">* transfer 可选 是一串和 message同时传递的 Transferable 对象，这些对象的所有权将被转移给消息的接收方，而发送一方不再保有所有权。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>派发事件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,receiveMessage,<span class="literal">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; origin,data,source&#125; = event;</span><br><span class="line">    <span class="keyword">if</span>(origin !== <span class="string">'http://example.com:8080'</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(source+<span class="string">':'</span>+data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* message的属性;</span></span><br><span class="line"><span class="comment">* data 从其他 window 传递来的对象</span></span><br><span class="line"><span class="comment">* origin 调用 postMessage 时消息发送方窗口的 origin，不能保证是该窗口当前的 或者 未来的origin，因为 postMessage被调用后可能被导航到不同的位置</span></span><br><span class="line"><span class="comment">* source 对发送消息窗口的引用，可以使用这个在具有不同 origin 的两个窗口建立双向通信</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A窗口域名是 http://example.com:8080 下面是 A 窗口 script 里面代码</span></span><br><span class="line"><span class="keyword">let</span> popup = <span class="built_in">window</span>.open(...popup details...);</span><br><span class="line"><span class="comment">// 如果弹出框没有被阻止且加载完成</span></span><br><span class="line"><span class="comment">// 这行语句没有发送信息出去，即使假设当前页面没有改变location（因为targetOrigin设置不对）</span></span><br><span class="line">popup.postMessage(<span class="string">"The user is 'bob' and the password is 'secret'"</span>,<span class="string">"https://secure.example.net"</span>);</span><br><span class="line"><span class="comment">// 假设当前页面没有改变location，这条语句会成功添加message到发送队列中去（targetOrigin设置对了）</span></span><br><span class="line">popup.postMessage(<span class="string">"hello there!"</span>,<span class="string">"http://example.com"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event.origin !== <span class="string">'http://example.org'</span>) <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,receiveMessage,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弹出页 popup域名是 http://example.org 下面是 script 里面代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当A页面postMessage被调用后，这个function被addEventListenner调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event.origin !== <span class="string">'http://example.com:8080'</span>) <span class="keyword">return</span></span><br><span class="line">     <span class="comment">// event.data 是 "hello there!"</span></span><br><span class="line">    <span class="comment">// event.source 就当前弹出页的来源页面</span></span><br><span class="line">    event.source.postMessage(<span class="string">"hi there yourself!  the secret response "</span> +<span class="string">"is: rheeeeet!"</span>,event.origin);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, receiveMessage, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="Web-Sockets-通信"><a href="#Web-Sockets-通信" class="headerlink" title="Web Sockets 通信"></a>Web Sockets 通信</h3><p>使用 Web Sockets API 可以在服务器与客户端之间建立一个非 HTTP 的双向连接。这个连接是实时的，也是要永久的，除非某一方显示关闭。</p><p><strong>常量</strong></p><table><thead><tr><th><strong>Constant</strong></th><th><strong>Value</strong></th></tr></thead><tbody><tr><td><code>WebSocket.CONNECTING</code></td><td><code>0</code></td></tr><tr><td><code>WebSocket.OPEN</code></td><td><code>1</code></td></tr><tr><td><code>WebSocket.CLOSING</code></td><td><code>2</code></td></tr><tr><td><code>WebSocket.CLOSED</code></td><td><code>3</code></td></tr></tbody></table><p>以上是WebSocket 构造函数的原型中存在的一些常量，可通过 <code>WebSocket.readyState</code> 对照上述常量判断 WebSocket 连接 当前所处的状态</p><p><strong>用法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL字符串以 ws 或者 wss（加密通信时）文字开头</span></span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br><span class="line"></span><br><span class="line">socket.addEventListener(<span class="string">'open'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// send方法对服务器发送数据，只能发送文本数据，可以使用 JSON对象把任何 js对象转换为文本数据后发送</span></span><br><span class="line">    socket.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.addEventListerner(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Message from server'</span>,event.data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件句柄</span></span><br><span class="line"><span class="comment">// 接受服务器传过来的数据</span></span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; data &#125; = event</span><br><span class="line">&#125;</span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 开始通信</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听 socket 关闭事件</span></span><br><span class="line">socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 通信结束时的处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭 socket，切断通信连接0000</span></span><br><span class="line">socket.close()</span><br></pre></td></tr></table></figure><h2 id="使用-Web-Workers-处理线程"><a href="#使用-Web-Workers-处理线程" class="headerlink" title="使用 Web Workers 处理线程"></a>使用 Web Workers 处理线程</h2><p>web worker 是运行在后台的 javaScript，不会影响页面的性能。</p><p>创建后台线程的步骤很简单。将需要在后台线程中指定的脚本文件的 URL 地址作为参数，然后创建 Worker对象就可以了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">'worker.js'</span>);</span><br><span class="line"><span class="comment">// 后台线程是不能访问到页面或者窗口对象的，所以如果使用到 window对象或者 document对象会以前你错误的发生</span></span><br></pre></td></tr></table></figure><p>可以通过发送和接收消息来与后台线程互相传递数据。通过 Worker 对象的 onmessage 事件句柄活期户后台线程之间的消息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 处理收到的消息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// message 文本数据</span></span><br><span class="line">worker.postMessage(message);</span><br></pre></td></tr></table></figure><h3 id="示例：求和计算"><a href="#示例：求和计算" class="headerlink" title="示例：求和计算"></a>示例：求和计算</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>从1到给定数值求和<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  输入数值：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"num"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"calculate()"</span>&gt;</span>计算<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">'SumCalculate.js'</span>);</span></span><br><span class="line"><span class="javascript">    worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(event.data);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">calculate</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> num = <span class="built_in">parseInt</span>(<span class="built_in">document</span>.getElementById(<span class="string">'num'</span>).value,<span class="number">10</span>);</span></span><br><span class="line"><span class="undefined">      worker.postMessage(num);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SumCalculate.js</span></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num = event.data;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= num; i++) &#123;</span><br><span class="line">    result += i;</span><br><span class="line">  &#125;</span><br><span class="line">  postMessage(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例：与线程进行数据的交互"><a href="#示例：与线程进行数据的交互" class="headerlink" title="示例：与线程进行数据的交互"></a>示例：与线程进行数据的交互</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>从随机生成的数字中抽取3的倍数并显示<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">"table"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 随机数组</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> intArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> intStr = <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 生成100个随机数</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">      intArray[i] = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">100</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">        intStr += <span class="string">';'</span>;       </span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">      intStr += intArray[i]</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">'script.js'</span>);</span></span><br><span class="line"><span class="undefined">    worker.postMessage(intStr);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (event.data != <span class="string">''</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> j;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> k;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> tr;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> td;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> intArray = event.data.split(<span class="string">';'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> table = <span class="built_in">document</span>.getElementById(<span class="string">'table'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; intArray.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">          j = <span class="built_in">parseInt</span>(i / <span class="number">10</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="undefined">          k = i % 10;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 该行不存在</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 添加行</span></span></span><br><span class="line"><span class="javascript">            tr = <span class="built_in">document</span>.createElement(<span class="string">'tr'</span>);</span></span><br><span class="line"><span class="javascript">            tr.id = <span class="string">'tr'</span> + j;</span></span><br><span class="line"><span class="undefined">            table.appendChild(tr);</span></span><br><span class="line"><span class="javascript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            tr = <span class="built_in">document</span>.getElementById(<span class="string">'tr'</span> + j);</span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="javascript">          td = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span></span><br><span class="line"><span class="undefined">          tr.appendChild(td);</span></span><br><span class="line"><span class="undefined">          td.innerHTML = intArray[j * 10 + k];</span></span><br><span class="line"><span class="javascript">          td.style.backgroundColor = <span class="string">'blue'</span>;</span></span><br><span class="line"><span class="javascript">          td.style.color = <span class="string">'white'</span>;</span></span><br><span class="line"><span class="undefined">          td.width = 30;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script.js</span></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; data &#125; = event;</span><br><span class="line">  <span class="keyword">let</span> returnStr=<span class="string">""</span>;</span><br><span class="line">  <span class="keyword">let</span> intArray = data.split(<span class="string">';'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; intArray.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">parseInt</span>(intArray[i]) % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (returnStr != <span class="string">''</span>) &#123;</span><br><span class="line">        returnStr += <span class="string">';'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      returnStr += intArray[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  postMessage(returnStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程嵌套"><a href="#线程嵌套" class="headerlink" title="线程嵌套"></a>线程嵌套</h3><p><strong>单层嵌套</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html script</span></span><br><span class="line"><span class="keyword">let</span> worket = <span class="keyword">new</span> Worker(<span class="string">'script.js'</span>)</span><br><span class="line">worket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// script.js</span></span><br><span class="line"></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; data &#125; = event;</span><br><span class="line">    <span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">'script2.js'</span>)</span><br><span class="line">    <span class="comment">// 把数据提交给子线程处理</span></span><br><span class="line">    worker.postMessage(<span class="built_in">JSON</span>.stringfy(data))</span><br><span class="line">    worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 把结果返回主页面</span></span><br><span class="line">        postMessage(event.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// script2.js</span></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; data &#125; = event;</span><br><span class="line">    result = someMethod(data);</span><br><span class="line">    <span class="comment">// 将处理好的处理返回</span></span><br><span class="line">    postMessage(result)</span><br><span class="line">    <span class="comment">// 如果不再使用则关闭子线程</span></span><br><span class="line">    close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多个线程中进行数据的交互</strong></p><p>实现子线程与子线程之间数据交互的，大致需要下面步骤：</p><ol><li>先创建发送数据的子线程</li><li>执行子线程中的任务，然后把要传递的数据发送给主线程</li><li>在主线程接受到子线程传回来的消息时，创建接受数据的子线程，然后把发送数据的子线程中返回的消息传递给接受数据的子线程</li><li>执行接受数据子线程中的代码</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> worker;</span><br><span class="line">    worker = <span class="keyword">new</span> Worker(<span class="string">'worker1.js'</span>);</span><br><span class="line">    worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 接受子线程中的数据</span></span><br><span class="line">        <span class="keyword">let</span> &#123; data &#125; = event;</span><br><span class="line">        worker = <span class="keyword">new</span> Worker(<span class="string">'worker2.js'</span>);</span><br><span class="line">        <span class="comment">// 把从发送数据的子线程中发回的消息传递给接受数据的子线程</span></span><br><span class="line">        worker.postMessage(data);</span><br><span class="line">        worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 获取接受数据的子线程中传回的数据</span></span><br><span class="line">            <span class="keyword">let</span> &#123;data&#125; = event;</span><br><span class="line">            <span class="comment">// 把结果发送到主页面</span></span><br><span class="line">            postMessage(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker1.js 发送数据的子线程</span></span><br><span class="line">onmessga = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;someData&#125; = event;</span><br><span class="line">    result = someMethod(someData);</span><br><span class="line">    postMassage(result);</span><br><span class="line">    <span class="comment">// 关闭子线程</span></span><br><span class="line">    close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程中可用的变量、函数与类"><a href="#线程中可用的变量、函数与类" class="headerlink" title="线程中可用的变量、函数与类"></a>线程中可用的变量、函数与类</h3><ul><li><p>self</p><p>表示本线程范围内的作用域</p></li><li><p>postMessage(message)</p><p>向创建线程的源窗口发送信息</p></li><li><p>onmessage</p><p>获取接受消息的事件句柄</p></li><li><p>importScripts(urls)</p><p>导入其他脚本文件，参数为文件的 URL地址，可以导入多个</p></li><li><p>navigator</p><p>与 window.navigator对象类似，具有 appName、platform、userAgent、appVersion这些属性</p></li><li><p>sessionStorage/localStorage</p><p>可以在线程中使用 Web Storage</p></li><li><p>XMLHttpRequest</p><p>在线程中处理 Ajax请求</p></li><li><p>setTimeout/setInterval</p><p>在线程中实现定时处理</p></li><li><p>close</p><p>结束本线程</p></li><li><p>eval/isNaN/escape</p><p>使用 javascipt 的核心函数</p></li><li><p>object</p><p>可以创建对象</p></li><li><p>WebSockets</p><p>使用 WebSockets API 来想服务器发送和接收信息</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习链接：&lt;br&gt;&lt;a href=&quot;https://read.douban.com/ebook/15160963/&quot;&gt;HTML 5与CSS 3权威指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.w3cschool.cn/html/&quot;&gt;W3cScholl
      
    
    </summary>
    
      <category term="前端面试" scheme="http://laibh.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="HTML5" scheme="http://laibh.top/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>面试官问我HTML5是什么（上）</title>
    <link href="http://laibh.top/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91HTML5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%8A%EF%BC%89.html"/>
    <id>http://laibh.top/面试官问我HTML5是什么（上）.html</id>
    <published>2019-05-23T01:30:54.000Z</published>
    <updated>2020-07-11T03:24:57.647Z</updated>
    
    <content type="html"><![CDATA[<p>学习链接：<br><a href="https://read.douban.com/ebook/15160963/">HTML 5与CSS 3权威指南</a></p><p><a href="https://www.w3cschool.cn/html/">W3cScholl</a></p><h2 id="HTML5-与-HTML4-的区别"><a href="#HTML5-与-HTML4-的区别" class="headerlink" title="HTML5 与 HTML4 的区别"></a>HTML5 与 HTML4 的区别</h2><p>常见代码区别：</p><p>新增的一些属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"search"</span> <span class="attr">id</span>=<span class="string">"search"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'search'</span>).focus();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"search"</span> <span class="attr">autofocus</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结构上：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"nav"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"section"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"side-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HTML-5-要解决的三个问题"><a href="#HTML-5-要解决的三个问题" class="headerlink" title="HTML 5 要解决的三个问题"></a>HTML 5 要解决的三个问题</h3><ul><li>Web 浏览器之间的兼容性很低</li><li>文档结构不明确</li><li>Web应用程序的功能受到了限制</li></ul><h3 id="语法的改变"><a href="#语法的改变" class="headerlink" title="语法的改变"></a>语法的改变</h3><p>HTML 语法是在 SGML(Standard Generalized Markup Language)语言的基础上建立起来的。对于 HTML 的执行在各个浏览器之间没有统一的一个标准。</p><p>HTML5 就是围绕这个Web标准，重新定义了一套在现有的 HTML 的基础上修改而来的语法，使它运行在各浏览器时它们都能符合这个通用标准。</p><h4 id="HTML5-的标记方法"><a href="#HTML5-的标记方法" class="headerlink" title="HTML5 的标记方法"></a>HTML5 的标记方法</h4><p>1.内容类型（ContentType）</p><p>扩展符仍为 ‘.html’或者 ‘.htm’。内容类型仍然为 ‘text/html’</p><p>2.DOCTYPE 声明</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C/DTD 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/Xhtml1-transitional.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure><p>3.指定字符编码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equive</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="确保与之前的HTML-版本兼容"><a href="#确保与之前的HTML-版本兼容" class="headerlink" title="确保与之前的HTML 版本兼容"></a>确保与之前的HTML 版本兼容</h4><p>1.可以省略标记的元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不允许写结束标记的元素有：area/base/br/col/command/embed/hr/img/input/keygen/link/meta/param/source/track/wbr</span><br><span class="line">可以省略结束标记的元素：</span><br><span class="line">li/dt/dd/p/rt/rp/optgroup/option/colgroup/thead/tbody/tfoot/tr/td/th</span><br><span class="line">可以省略全部标记的元素(隐式存在，在文档结构仍然存在)：</span><br><span class="line">html/head/body/colgroup/tbody</span><br></pre></td></tr></table></figure><p>2.具有 boolean 值的属性</p><p>例如 disable/readonly/checked 等，只写属性不写属性值或者属性值为空字符表示属性值为 true。</p><p>3.省略引号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="新增的元素和废除的元素"><a href="#新增的元素和废除的元素" class="headerlink" title="新增的元素和废除的元素"></a>新增的元素和废除的元素</h3><h3 id="新增-html5-html4"><a href="#新增-html5-html4" class="headerlink" title="新增-html5(html4)"></a>新增-<code>html5(html4)</code></h3><h4 id="结构元素"><a href="#结构元素" class="headerlink" title="结构元素"></a>结构元素</h4><p><code>section(div)</code></p><p>表示页面中的一个内容区块，用于章节、页眉、页脚或者页面中的其他部分。与 h1-h6元素结合使用，表示文档结构</p><p><code>article(div)</code></p><p>表示页面中的一块与上下文不相关的独立内容，例如博客中的一篇文章或者报纸中的一篇文章</p><p><code>aside(div)</code></p><p>aside 元素表示 article 元素的内容之外的，与 article 元素内容相关的辅助信息</p><p><code>header(div)</code></p><p>表示页面一个内容区块或者整个页面的标题</p><p><code>hgroup(div)</code></p><p>用于整个页面或者页面中的一个内容块的标题进行组合</p><p><code>footer(div)</code></p><p>整个页面或者页面中的一个内容区块的脚注。一般来说，会包括作者的姓名、创作日期以及作者的联系信息。</p><p><code>nav(ul)</code></p><p>页面中导航链接部分</p><p><code>figure(dl)</code></p><p>一段独立的流内容，一般表示文档主体流内容中的一个独立单元，使用 <code>figcaption</code> 元素 为 <code>figure</code> 元素组添标题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hahahahaha<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hahahahaha<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="多媒体元素"><a href="#多媒体元素" class="headerlink" title="多媒体元素"></a>多媒体元素</h4><p><code>video(object)</code></p><p>定义视频，比如电影片段或者其他视频流</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">'movie.ogg'</span> <span class="attr">controls</span>=<span class="string">'controls'</span>&gt;</span>video元素<span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">type</span>=<span class="string">'video/ogg'</span> <span class="attr">data</span>=<span class="string">'movie.ogv'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parma</span> <span class="attr">name</span>=<span class="string">'src'</span> <span class="attr">value</span>=<span class="string">"movie.ogv"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>audio(object)</code></p><p>定义音频，比如音乐或者其他音频流</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">'music.wav'</span>&gt;</span>audio元素<span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">type</span>=<span class="string">'application/ogg'</span> <span class="attr">data</span>=<span class="string">'someaudio.wav'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parma</span> <span class="attr">name</span>=<span class="string">'src'</span> <span class="attr">value</span>=<span class="string">"someaudio.wav"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>embed(object)</code></p><p>用来插入各种多媒体，格式可以是 Midi/Wav/AIFF/AU/MP3</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">'music.swf'</span>&gt;</span>embed元素<span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">type</span>=<span class="string">'application/x-shockwave-flash'</span> <span class="attr">data</span>=<span class="string">'music.swf'</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>source</code></p><p>为媒介元素定义媒介资源</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"horse.ogg"</span> <span class="attr">type</span>=<span class="string">"audio/ogg"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"horse.mp3"</span> <span class="attr">type</span>=<span class="string">"audio/mpeg"</span>&gt;</span></span><br><span class="line"> Your browser does not support the audio element.</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">type</span>=<span class="string">'application/ogg'</span> <span class="attr">data</span>=<span class="string">'someaudio.wav'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parma</span> <span class="attr">name</span>=<span class="string">'src'</span> <span class="attr">value</span>=<span class="string">"someaudio.wav"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="语义元素"><a href="#语义元素" class="headerlink" title="语义元素"></a>语义元素</h4><p><code>mark(span)</code>元素</p><p>用来在视觉上向用户呈现那些需要突出显示或者高亮显示的文字。mark 元素的一个比较经典的应用就是在搜索结果中向用户高亮显示搜索关键词</p><p><code>progress(无)</code></p><p>表示进程运行中的进程，可以用 progress 来显示 javascript 中耗费时间的函数的进程</p><p><code>meter(无)</code></p><p>表示度量衡。仅用于已知最大值和最小值的度量。必须定义度量的范围，既可以在元素的文本中，也可以在 min/max 属性中定义。</p><p><code>time(span)</code></p><p>表示日期或者时间，也可以同时表示两者</p><p><code>ruby(无)</code></p><p>表示 ruby 注释（中文注音或者字符）</p><p>在东亚使用，显示的是东亚字符的发音。</p><p>与 <code>&lt;ruby&gt;</code> 以及 <code>&lt;rt&gt;</code> 标签一同使用：</p><p>ruby 元素由一个或多个字符（需要一个解释/发音）和一个提供该信息的 rt 元素组成，还包括可选的 rp 元素，定义当浏览器不支持 “ruby” 元素时显示的内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;ruby&gt;</span><br><span class="line"> 漢 <span class="tag">&lt;<span class="name">rt</span>&gt;</span> ㄏㄢˋ <span class="tag">&lt;/<span class="name">rt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>rt(无)</code></p><p>表示元素字符的解释或者发音</p><p><code>rp（无）</code></p><p>在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容</p><p><code>wbr</code></p><p>表示软换行，wbr 与 br 区别在于后者表示此处必须换行，前者是浏览器窗口或者父级元素的宽度足够宽的时候不进行换行，而当宽度不够时，主动在此处进行换行。wbr 元素好像对字符型的语言作用挺大，但是对中文没有多大用处。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>学习 AJAX ,您必须熟悉 <span class="tag">&lt;<span class="name">wbr</span>&gt;</span>Http<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>Request 对象。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>canvas</code></p><p>canvas 表示图形，比如图表和其他图像。元素本身没有行为，仅提供一块画布，但它把一个绘图 API 展示给 客户端的 javascript 以使得脚本能够把想绘制的东西绘制到这块画布上面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">'myCanvas'</span> <span class="attr">width</span>=<span class="string">'200'</span> <span class="attr">height</span>=<span class="string">'200'</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">type</span>=<span class="string">'image/svg+xml'</span> <span class="attr">data</span>=<span class="string">'inc/hdr.svg'</span> <span class="attr">width</span>=<span class="string">'200'</span> <span class="attr">height</span>=<span class="string">'200'</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>details</code></p><p>details 元素表示用户要求得到并且可以得到的细节信息，可以与 <code>summary</code>元素配合使用。<code>summary</code>提供标题或者图例。标题是可见的，用户点击标题时，会显示出细节信息。<code>summary</code>元素应该是 <code>details</code>元素的第一个子元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">summary</span>&gt;</span>H5<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">    hahahahha</span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>datalist</code></p><p>表示可选数据的列表，与 input 元素配合使用，可以制作出 输入值的下拉列表。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">list</span>=<span class="string">"cars"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"cars"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"BMW"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Ford"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Volvo"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>datagrid</code></p><p>表示可选数据的列表，以树形列表的形式来显示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">datagrid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span> (datagrid row 0) <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span> (datagrid row 1)</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">style</span>=<span class="string">"list-style-type:lower-alpha;"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span> (datagrid row 1,0) <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span> (datagrid row 1,1) <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span> (datagrid row 2) <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">datagrid</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>output(span)</code></p><p>表示不同类型的输出，比如脚本输出</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">form</span> <span class="attr">oninput</span>=<span class="string">"x.value=parseInt(a.value)+parseInt(b.value)"</span>&gt;</span></span><br><span class="line">0</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">id</span>=<span class="string">'a'</span> <span class="attr">value</span>=<span class="string">"50"</span>&gt;</span>100+</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">value</span>=<span class="string">"50"</span>&gt;</span>=</span><br><span class="line"><span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">"x"</span> <span class="attr">for</span>=<span class="string">"a b"</span>&gt;</span><span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>menu</code></p><p>表示菜单列表，当希望列出表单控件的时候使用该标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">type</span>=<span class="string">"toolbar"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">menu</span> <span class="attr">label</span>=<span class="string">"File"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"file_new()"</span>&gt;</span>新建<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"file_open()"</span>&gt;</span>打开<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"file_save()"</span>&gt;</span>保存<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">menu</span> <span class="attr">label</span>=<span class="string">"Edit"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"edit_cut()"</span>&gt;</span>剪切<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"edit_copy()"</span>&gt;</span>复制<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"edit_paste()"</span>&gt;</span>粘贴<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是目前主流所有浏览器都不支持这个标签</p><h4 id="input元素类型"><a href="#input元素类型" class="headerlink" title="input元素类型"></a>input元素类型</h4><p><code>email</code></p><p>表示必须输入 E-mail </p><p><code>url</code></p><p>输入 URL 地址</p><p><code>number</code></p><p>输入数值</p><p><code>range</code></p><p>输入一定范围内数字值</p><p><code>Date Pickers</code></p><p>拥有多个选择日期和时间的新型输入文本框</p><p>data-日、月、年</p><p>month-月、年</p><p>week-周、年</p><p>time-小时、分钟</p><p>datetime-日、月、年（UTC）</p><p>datetime-local-日、月、年（本地时间）</p><h3 id="废除（替代元素）"><a href="#废除（替代元素）" class="headerlink" title="废除（替代元素）"></a>废除（替代元素）</h3><p>1.能用css替代的元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">basefont/big/center/font/s/strike(del)/tt/u</span><br></pre></td></tr></table></figure><p>2.不再使用 frame 框架</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frameset/frame/noframes，现只支持 iframe框架。</span><br></pre></td></tr></table></figure><p>3.只有部分浏览器支持的元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applet(embed/obejct)/bgsound(audio)/blink/marquee</span><br></pre></td></tr></table></figure><p>4.其他被废除的元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rb(ruby)/acronym(abbr)/dir(ul)/isindex(form+input)/listing(pre)/xmp(code)/nextid(GUIDS)/plaintext('text/plain' MIME 类型)</span><br></pre></td></tr></table></figure><h3 id="新增的属性和废除的属性"><a href="#新增的属性和废除的属性" class="headerlink" title="新增的属性和废除的属性"></a>新增的属性和废除的属性</h3><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><h4 id="表单相关的属性"><a href="#表单相关的属性" class="headerlink" title="表单相关的属性"></a>表单相关的属性</h4><ul><li><code>input[type=text]</code>、<code>select</code>与 <code>button</code> 指定 <code>autofucus</code>属性，以指定的方式让元素在画面打开的时候自动获得焦点</li><li><code>input[type=text]</code>与 <code>textarea</code>指定 <code>placeholder</code>属性，会对用户的输入进行提示，提示用户输入的内容</li><li><code>input</code>、<code>output</code>、<code>select</code>、<code>textarea</code>、<code>button</code>与 <code>fieldset</code>指定 <code>form</code>属性，声明它们属性哪个表单，然后将其放置任何位置，而不是在表单之内</li><li><code>input[type=text]</code>与 <code>textarea</code>指定 <code>required</code>。表示用户提交的时候进行检查，检查该元素内一定要有输入内容</li><li><code>input</code>其他新增的属性：<code>autocomplete</code>、<code>min</code>、<code>max</code>、<code>multiple</code>、<code>pattern</code>、<code>step</code>。同时还有一个 新的 <code>list</code>元素可以与 <code>datalist</code>配合使用。<code>datalist</code>与 <code>autocomplete</code>属性配合使用。<code>multiple</code>属性允许在上传文件的时候一次上传多个文件。</li><li><code>input</code>、<code>button</code>增加了新的属性 <code>formaction</code>、<code>formenctype</code>、<code>formmethod</code>、<code>formnovalidate</code>与 <code>formtarget</code>，它们可以重载 <code>form</code>元素的 <code>action</code>、<code>enctype</code>、<code>method</code>、<code>novalidate</code>与 <code>target</code>属性。为  <code>fileset</code>增加了 <code>disabled</code>，可以把它的子元素设为 <code>disabled(无效)</code>状态</li><li><code>input</code>、<code>button</code>、<code>form</code>增加了 <code>novalidate</code>属性，该属性可以取消提交时进行的有关检查，表单可以被无条件提交。</li></ul><h4 id="链接相关属性"><a href="#链接相关属性" class="headerlink" title="链接相关属性"></a>链接相关属性</h4><ul><li><code>a</code>与 <code>area</code>增加 <code>media</code>属性，该属性规定目标 URL是什么类型的媒介/设备进行优化，只能在 <code>href</code>属性存在时使用</li><li>为 <code>area</code>元素增加了 <code>hreflang</code>属性与 <code>rel</code>属性，以保持与 <code>a</code>元素、<code>link</code>元素的一致。</li><li><code>link</code>元素增加了新的属性 <code>sizes</code>。该属性可以与 <code>icon</code>属性元素结合使用(通过 <code>rel</code>属性)，该属性指定关联图标（<code>icon</code>元素）的大小。</li><li>为 <code>base</code>元素增加了<code>target</code>属性，主要目的是保持与 <code>a</code>元素的一致性。</li></ul><h4 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h4><p>除了上面介绍的与表单和链接相关的属性外，HTML5 还增加了下面的属性：</p><ul><li><code>ol</code>元素增加 <code>reversed</code>,它指定了列表倒序显示</li><li><code>meta</code>增加 <code>charset</code>属性。因为这个属性被广泛支持了，而且为文档的字符编码的执行提供了一种良好的方式</li><li>为 <code>style</code>属性增加<code>scoped</code>属性，用来规定样式的作用范围，例如只对页面某个树起作用。</li><li><code>script</code>增加 <code>async</code>属性，定义脚本是否异步执行</li><li><code>html</code>增加 <code>mainfest</code>，开发离线Web 应用程序时它与 API 结合使用，定义一个 URL,在这个 URL 上描述文档的缓存信息。</li><li><code>iframe</code>元素增加了三个属性 <code>sandbox</code>、<code>seamless</code>与 <code>srcdoc</code>，用来提高页面安全性，防止不信任的 Web 页面执行某些操作。</li></ul><h3 id="废除"><a href="#废除" class="headerlink" title="废除"></a>废除</h3><table><thead><tr><th><strong>在HTML 4中使用的属性</strong></th><th><strong>使用该属性的元素</strong></th><th><strong>在HTML 5中的替代方案</strong></th></tr></thead><tbody><tr><td><strong>rev</strong></td><td>link、a</td><td>rel</td></tr><tr><td><strong>charset</strong></td><td>link、a</td><td>在被链接的资源的中使用HTTP Content-type头元素</td></tr><tr><td><strong>shape</strong>、coords</td><td>a</td><td>使用area元素代替a元素</td></tr><tr><td><strong>longdesc</strong></td><td>img、iframe</td><td>使用a元素链接到校长描述</td></tr><tr><td><strong>target</strong></td><td>link</td><td>多余属性，被省略</td></tr><tr><td><strong>nohref</strong></td><td>area</td><td>多余属性，被省略</td></tr><tr><td><strong>profile</strong></td><td>head</td><td>多余属性，被省略</td></tr><tr><td><strong>version</strong></td><td>html</td><td>多余属性，被省略</td></tr><tr><td><strong>name</strong></td><td>img</td><td>id</td></tr><tr><td><strong>scheme</strong></td><td>meta</td><td>只为某个表单域使用scheme</td></tr><tr><td><strong>archive**</strong>、chlassid、codebose、codetype、declare、standby**</td><td>object</td><td>使用data与typc属性类调用插件。需要使用这些属性来设置参数时，使用param属性</td></tr><tr><td><strong>valuetype</strong>、type</td><td>param</td><td>使用name与value属性，不声明之的MIME类型</td></tr><tr><td><strong>axis</strong>、abbr</td><td>td、th</td><td>使用以明确简洁的文字开头、后跟详述文字的形式。可以对更详细内容使用title属性，来使单元格的内容变得简短</td></tr><tr><td><strong>scope</strong></td><td>td</td><td>在被链接的资源的中使用HTTP Content-type头元素</td></tr><tr><td><strong>align</strong></td><td>caption、input、legend、div、h1、h2、h3、h4、h5、h6、p</td><td>使用CSS样式表替代</td></tr><tr><td><strong>alink</strong>、link、text、vlink、background、bgcolor</td><td>body</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、bgcolor、border、cellpadding、cellspacing、frame、rules、width</td><td>table</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、char、charoff、height、nowrap、valign</td><td>tbody、thead、tfoot</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、bgcolor、char、charoff、height、nowrap、valign、width</td><td>td、th</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、bgcolor、char、charoff、valign</td><td>tr</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、char、charoff、valign、width</td><td>col、colgroup</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、border、hspace、vspace</td><td>object</td><td>使用CSS样式表替代</td></tr><tr><td><strong>clear</strong></td><td>br</td><td>使用CSS样式表替代</td></tr><tr><td><strong>compace</strong>、type</td><td>ol、ul、li</td><td>使用CSS样式表替代</td></tr><tr><td><strong>compace</strong></td><td>dl</td><td>使用CSS样式表替代</td></tr><tr><td><strong>compace</strong></td><td>menu</td><td>使用CSS样式表替代</td></tr><tr><td><strong>width</strong></td><td>pre</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、hspace、vspace</td><td>img</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、noshade、size、width</td><td>hr</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、frameborder、scrolling、marginheight、marginwidth</td><td>iframe</td><td>使用CSS样式表替代</td></tr><tr><td><strong>autosubmit</strong></td><td>menu</td></tr></tbody></table><h3 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h3><h4 id="contentEditable"><a href="#contentEditable" class="headerlink" title="contentEditable"></a>contentEditable</h4><p>允许用户编辑元素中的内容，该元素必须是可以获得用户鼠标焦点的元素，在点击鼠标后要向用户提供一个插入符号，提示用户该元素中的内容允许被编辑。<code>contentEditable</code>属性是一个布尔值属性，可以被指定 <code>true</code>或者 <code>false</code></p><p>除此之外，还有一个隐藏的 <code>inherit</code>状态，属性为  <code>true</code>，元素被指定为允许编辑，属性为 <code>false</code>时，元素被指定为不允许编辑。未指定 <code>true</code>或者 <code>false</code>时，则由 <code>inherit</code>状态来决定，如果元素的父元素是可以编辑的，则该元素就是可编辑的。</p><p>元素还具有一个叫做 <code>isContentEditable</code>属性，当元素可编辑时，该属性为 true，当元素不可编辑时，该属性 为 false。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">contentEditable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>元素列表1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>元素列表2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>元素列表3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="designMode"><a href="#designMode" class="headerlink" title="designMode"></a>designMode</h4><p><code>designMode</code> 属性用来指定整个页面是否可编辑，当页面可编辑时，页面中任何支持上文所述的 <code>contentEditable</code> 属性的元素都变成了可编辑状态。<code>designMode</code>只能在 javascript 脚本里被编辑修改。该属性有两个值——“on” 和 “off”。属性被指定为 <code>on</code>时，页面可编辑，被指定为 <code>off</code>时，页面不可编辑。使用 javascript 来指定 designMode 属性的方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.designMode = <span class="string">'on'</span></span><br></pre></td></tr></table></figure><p>针对 <code>designMode</code> 属性，各个浏览器的支持情况也不一样：</p><ul><li>IE8：安全考虑，不允许使用 <code>designMode</code>属性让页面进行编辑状态</li><li>IE9：允许使用 <code>designMode</code>属性让页面进入编辑状态</li><li>Chrome3 和 Safari：使用内嵌 <code>frame</code>方式，该内嵌 <code>frame</code>是可编辑的</li><li>Firefox 和 Opera：允许使用 <code>designMode</code>属性让页面进入编辑状态</li></ul><h4 id="hidden"><a href="#hidden" class="headerlink" title="hidden"></a>hidden</h4><p>在 HTML5 中，所有的元素都允许有一个 <code>hidden</code>属性，该属性类似于 <code>input</code> 中的 <code>hidden</code>元素，功能是通知浏览器不渲染该元素，使该元素处于不可见状态。但是元素中的内容还是浏览器创建的，也就是说页面装载后允许使用 javascript 脚本将该属性取消，取消后该元素变为可见状态，同时元素中的内容页即时显示出来。<code>hidden</code>属性是一个布尔值的属性，为设为 <code>true</code>后，元素处于不可见状态，当设为 <code>false</code>后，元素属于可见状态。</p><h4 id="spellcheck"><a href="#spellcheck" class="headerlink" title="spellcheck"></a>spellcheck</h4><p><code>spellcheck</code> 是针对 <code>input</code>与 <code>textarea</code>这两个文本输入框提供的一个新属性，它的功能为对用户输入的文本内容进行拼写和语法检查。是一个布尔值属性，具有 true 和 false 两种值。必须明确书写属性值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">contentEditable</span> <span class="attr">spellcheck</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">spellcheck</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span> <span class="attr">spellcheck</span>=<span class="string">"true"</span>&gt;</span>这是可编辑的段落。请试着编辑文本。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是如果元素的 <code>readonly</code>或者  <code>disabled</code>设为 <code>true</code>，则不执行拼写检查。</p><h4 id="tabindex"><a href="#tabindex" class="headerlink" title="tabindex"></a>tabindex</h4><p>当不断敲击 Tab 键让窗口或者页面中的控件获得焦点，对窗口或者页面的所有控件进行遍历的时候，每一个控件的 <code>tabindex</code>表示该控件是第几个页面访问到的。</p><p>过去的这个属性在编辑网页的时候非常有用，但如今控件的遍历顺序是由元素在页面上所处的位置决定的，所以不再需要了。</p><p>但是 <code>tabindex</code>还有另外一个作用，在默认属性下，只有链接元素与表单可以通过按键获得焦点。如果对其他元素使用 <code>tabindex</code>属性后，也能让该元素获得焦点，那么当脚本中执行 <code>focus()</code>语句的时候，就可以让该元素获得焦点了。但这样做会有一个副作用：钙元素也可以通过按 Tab 键获得焦点，而这时有可能也不是开发者想要的结果。</p><p>把元素的 <code>tabindex</code>设为为负数（通常为-1）后就可以解决这个问题。<code>tabindex</code>的值为负数后，仍然可以通过编程的方式让元素获得焦点，但按下 Tab 键时该元素就不能获得焦点了。这在复杂的页面中或复杂的 Web 应用程序中是非常有用的。在 HTML4 中，-1 是一个无用的属性值，但到了 HTML5 中，通过巧妙运用让该属性得到了极大的应用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://laibh.top"</span> <span class="attr">tabindex</span>=<span class="string">"2"</span>&gt;</span>赖同学<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.com/"</span> <span class="attr">tabindex</span>=<span class="string">"1"</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.microsoft.com/"</span> <span class="attr">tabindex</span>=<span class="string">"3"</span>&gt;</span>Microsoft<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="data"><a href="#data" class="headerlink" title="data-*"></a>data-*</h4><p>使用 data-* 属性来嵌入自定义数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"e1"</span> <span class="attr">data-animal-type</span>=<span class="string">"鸟类"</span>&gt;</span>喜鹊<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"e2"</span> <span class="attr">data-animal-type</span>=<span class="string">"鱼类"</span>&gt;</span>金枪鱼<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"e3"</span> <span class="attr">data-animal-type</span>=<span class="string">"蜘蛛"</span>&gt;</span>蝇虎<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">showDetails</span>(<span class="params">animal</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> animalType = animal.getAttribute(<span class="string">"data-animal-type"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(animal.innerHTML + <span class="string">'是一种'</span> + animalType);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'target'</span>);</span></span><br><span class="line"><span class="javascript">    ul.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> ev = e || <span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> target = ev.target || ev.srcElement;</span></span><br><span class="line"><span class="undefined">        showDetails(target);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="draggable"><a href="#draggable" class="headerlink" title="draggable"></a>draggable</h4><p>规定元素是否可以拖动，链接和图像默认是可以拖动的。</p><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element</span> <span class="attr">draggable</span>=<span class="string">"true|false|auto"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-id">#dropbox</span>&#123;</span></span><br><span class="line"><span class="undefined">width: 400px;</span></span><br><span class="line"><span class="undefined">height: 400px;</span></span><br><span class="line"><span class="css"><span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-id">#aaaaaa</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"dropbox"</span> <span class="attr">ondrop</span>=<span class="string">"drop(event)"</span> <span class="attr">ondragover</span>=<span class="string">"allowDrop(event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"drag"</span> <span class="attr">draggable</span>=<span class="string">"true"</span> <span class="attr">ondragstart</span>=<span class="string">"drag(event)"</span>&gt;</span>这是一段可移动的段落，请把该段落拖入上面的矩形<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">allowDrop</span>(<span class="params">ev</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">        ev.preventDefault();</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">ev</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        ev.dataTransfer.setData(<span class="string">'Text'</span>,ev.target.id)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">drop</span>(<span class="params">ev</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> data = ev.dataTransfer.getData(<span class="string">'Text'</span>);</span></span><br><span class="line"><span class="javascript">        ev.target.appendChild(<span class="built_in">document</span>.getElementById(data));</span></span><br><span class="line"><span class="undefined">        ev.preventDefault()</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="新结构元素使用样式"><a href="#新结构元素使用样式" class="headerlink" title="新结构元素使用样式"></a>新结构元素使用样式</h3><p>兼容旧版本浏览器的 hack</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    article,aside,dialog,figure,footer,header,legend,nav,section&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">display</span><span class="selector-pseudo">:block</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    nav&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:20</span>%;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    article&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">float</span><span class="selector-pseudo">:right</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:79</span>%;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--IE8之前的浏览器不支持使用 CSS方法来使用这些尚未支持的结构元素，需要使用脚本定义--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.createElement(<span class="string">'header'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.createElement(<span class="string">'nav'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.createElement(<span class="string">'article'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.createElement(<span class="string">'footer'</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--或者引入一个 js来hack--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML5 HACK<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[if lt IE9]&gt;</span></span><br><span class="line"><span class="comment">&lt;script src="http://apps.bdimg.com/libs/html5shiv/3.7/html5shiv.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">    &lt;![end if]--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="表单与文件"><a href="#表单与文件" class="headerlink" title="表单与文件"></a>表单与文件</h2><p><strong>新的 form 属性</strong>：</p><ul><li>autocomplete</li><li>novalidate</li></ul><p><strong>新的 input 属性</strong>：</p><ul><li>autocomplete</li><li>autofocus</li><li>form</li><li>form overrides (formaction, formenctype, formmethod, formnovalidate, formtarget)</li><li>height 和 width</li><li>list</li><li>min, max 和 step</li><li>multiple</li><li>pattern (regexp)</li><li>placeholder</li><li>required</li></ul><p><strong>浏览器支持</strong></p><table><thead><tr><th style="text-align:left">Input type</th><th style="text-align:left">IE</th><th style="text-align:left">Firefox</th><th style="text-align:left">Opera</th><th style="text-align:left">Chrome</th><th style="text-align:left">Safari</th></tr></thead><tbody><tr><td style="text-align:left">autocomplete</td><td style="text-align:left">8.0</td><td style="text-align:left">3.5</td><td style="text-align:left">9.5</td><td style="text-align:left">3.0</td><td style="text-align:left">4.0</td></tr><tr><td style="text-align:left">autofocus</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">10.0</td><td style="text-align:left">3.0</td><td style="text-align:left">4.0</td></tr><tr><td style="text-align:left">form</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">9.5</td><td style="text-align:left">No</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">form overrides</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">10.5</td><td style="text-align:left">No</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">height and width</td><td style="text-align:left">8.0</td><td style="text-align:left">3.5</td><td style="text-align:left">9.5</td><td style="text-align:left">3.0</td><td style="text-align:left">4.0</td></tr><tr><td style="text-align:left">list</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">9.5</td><td style="text-align:left">No</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">min, max and step</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">9.5</td><td style="text-align:left">3.0</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">multiple</td><td style="text-align:left">No</td><td style="text-align:left">3.5</td><td style="text-align:left">No</td><td style="text-align:left">3.0</td><td style="text-align:left">4.0</td></tr><tr><td style="text-align:left">novalidate</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">pattern</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">9.5</td><td style="text-align:left">3.0</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">placeholder</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">3.0</td><td style="text-align:left">3.0</td></tr><tr><td style="text-align:left">required</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">9.5</td><td style="text-align:left">3.0</td><td style="text-align:left">No</td></tr></tbody></table><h3 id="新增属性"><a href="#新增属性" class="headerlink" title="新增属性"></a>新增属性</h3><p><code>form</code></p><p>在 HTML4 中表单内的从属元素必须写在表单内容，但是 HTML5 中，可以把它书写在页面的任何地方，然后给该元素指定一个 <code>form</code>属性。属性值为该表单的 id，这样就可以声明该元素从属于指定表单了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"testform"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">form</span>=<span class="string">"testform"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目前只有 Opera 支持这个属性</p><p><code>formaction</code></p><p>HTML4中，一个表单内的所有元素都只能通过表单的 <code>action</code>属性统一提交到另一个页面，而在 HTML5 可以给所有的提交按钮，<code>&lt;input type=&quot;submit&quot;&gt;</code>、<code>&lt;input type=&quot;image&quot;&gt;</code>、<code>&lt;button type=&quot;submit&quot;&gt;</code>都增加 <code>formaction</code>属性，使得点击不同的按钮，可以将表单提交到不同的页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"testform"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s1"</span> <span class="attr">value</span>=<span class="string">"v1"</span> <span class="attr">formaction</span>=<span class="string">"s1.jsp"</span>&gt;</span>提交到 s1</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s2"</span> <span class="attr">value</span>=<span class="string">"v2"</span> <span class="attr">formaction</span>=<span class="string">"s2.jsp"</span>&gt;</span>提交到 s2</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s3"</span> <span class="attr">value</span>=<span class="string">"v3"</span> <span class="attr">formaction</span>=<span class="string">"s3.jsp"</span>&gt;</span>提交到 s3</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目前没有浏览器支持这一属性</p><p><code>formmethod</code></p><p>在 HTML4 中只有一个表单内有 <code>action</code>属性来对表单内所有元素统一指定提交页面，所以每个表单内只有一个 <code>method</code>属性来指统一指定提交方法。在 HTML5 中，可以使用 <code>formaction</code>属性来对每个表单元素分别指定不同的提交页面，也可以用 <code>formmethod</code>对每个表单元素分别指定不同的提交方式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"testform"</span> <span class="attr">action</span>=<span class="string">"serve.jsp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s1"</span> <span class="attr">value</span>=<span class="string">"v1"</span> <span class="attr">formaction</span>=<span class="string">"s1.jsp"</span> <span class="attr">formmethod</span>=<span class="string">"get"</span>&gt;</span>提交到 s1</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s2"</span> <span class="attr">value</span>=<span class="string">"v2"</span> <span class="attr">formaction</span>=<span class="string">"s2.jsp"</span> <span class="attr">formmethod</span>=<span class="string">"post"</span>&gt;</span>提交到 s2</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目前没有浏览器支持这一属性</p><p><code>placeholder</code></p><p>是指文本框为输入状态时，文本框里面显示的输入提示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"input me"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>autofocus</code></p><p>给文本框、选择框或者按钮控件加上该属性，当画面打开的时候，该控件自动获得光标焦点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">autofocus</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个页面只能有一个控件具有该属性。不要滥用，建议只有当一个页面是以使用某个控件为主要目的的时候才使用。例如搜索页面中的搜索文本框。</p><p><code>list</code></p><p>为单行文本框添加一个 <code>list</code>属性，它的值为某个 <code>datalist</code>元素的 id。类似于 <code>select</code>，不同的是它除了可以选择之外，还可以自己输入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">list</span>=<span class="string">"cars"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"cars"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"BMW"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Ford"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Volvo"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>autocomplete</code></p><p>辅助输入所用的自动完成功能，是一个节省输入时间，同时也非常方便的功能。可以指定 <code>on</code>、<code>off</code>、<code>&quot;&quot;</code>三个值。不指定时用浏览器的默认值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"greeting"</span> <span class="attr">autocomplete</span>=<span class="string">"on"</span> <span class="attr">list</span>=<span class="string">"greetings"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="表单元素种类"><a href="#表单元素种类" class="headerlink" title="表单元素种类"></a>表单元素种类</h3><p><code>url</code>、<code>email</code>、<code>date</code>、<code>time</code>、<code>datetime</code>、<code>datetime-local</code>、<code>month</code>、<code>week</code>、<code>number</code>、<code>range</code>、<code>search</code>、<code>tel</code>、<code>color</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"http://laibh.top"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">value</span>=<span class="string">"544289495@qq.com"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">value</span>=<span class="string">"2019-05-22"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"time"</span> <span class="attr">value</span>=<span class="string">"11:27"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"datetime"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"datetime-local"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"month"</span> <span class="attr">value</span>=<span class="string">"2019-05"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"week"</span> <span class="attr">value</span>=<span class="string">"2019-W21"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">value</span>=<span class="string">"25"</span> <span class="attr">min</span>=<span class="string">"10"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">step</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">value</span>=<span class="string">"25"</span> <span class="attr">min</span>=<span class="string">"10"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">step</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"tel"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"color"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>output</code></p><p>定义了不同类型的输出，比如计算结果或者脚本的输出。output 元素必须从属某个表单，必须将它书写在表单内部，或者对它添加 form 属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"testform1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">name</span>=<span class="string">"range1"</span> <span class="attr">step</span>=<span class="string">"5"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">output</span> <span class="attr">onforminput</span>=<span class="string">"value=range1.value"</span>&gt;</span>50<span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--或者浏览器兼容更好的下面这种方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"testform1"</span> <span class="attr">oninput</span>=<span class="string">"x.value=range1.value"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">name</span>=<span class="string">"range1"</span> <span class="attr">step</span>=<span class="string">"5"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">"x"</span> <span class="attr">for</span>=<span class="string">"range1"</span>&gt;</span>50<span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="http://www.w3school.com.cn/tags/att_output_for.asp">for</a></td><td style="text-align:left"><em>element_id</em></td><td style="text-align:left">定义输出域相关的一个或多个元素。</td></tr><tr><td style="text-align:left"><a href="http://www.w3school.com.cn/tags/att_output_form.asp">form</a></td><td style="text-align:left"><em>form_id</em></td><td style="text-align:left">定义输入字段所属的一个或多个表单。</td></tr><tr><td style="text-align:left"><a href="http://www.w3school.com.cn/tags/att_output_name.asp">name</a></td><td style="text-align:left"><em>name</em></td><td style="text-align:left">定义对象的唯一名称。（表单提交时使用）</td></tr></tbody></table><h3 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h3><p><strong>自动验证</strong></p><p><code>require</code></p><p>可以应用在大部分输入元素（除了隐藏元素，图片按钮上）。在提交时，如果元素中内容为空白，则不允许提交，同时在浏览器中显示信息提示文字。</p><p><code>pattern</code></p><p>要求输入内容格式的，对 <code>input</code>使用 <code>pattern</code>属性，设为某个正则表达式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">pattern</span>=<span class="string">"[0-9][A-Z]&#123;3&#125;"</span> <span class="attr">name</span>=<span class="string">"part"</span> <span class="attr">placeholder</span>=<span class="string">"输入内容；一个数字与三个大写字母"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>min</code> 与 <code>max</code></p><p>数值类型与日期类型元素专用属性。限制了 <code>input</code>元素输入的数值与日期范围。</p><p><code>step</code></p><p>控制 <code>input</code>元素中的值增加或者减少的步幅。</p><p><strong>显式验证</strong></p><p>HTML5 中，<code>form</code> 与 <code>input</code>(除了 <code>select</code> 与 <code>textarea</code>)都具有一个 <code>checkValidity</code>。使用这个方法，可以显示对表单内所有元素内容或者单个元素内容进行有效性验证。返回 boolen值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"textform4"</span> <span class="attr">onsubmit</span>=<span class="string">"return check()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"http://laibh.top"</span> <span class="attr">id</span>=<span class="string">"url"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> url = <span class="built_in">document</span>.getElementById(<span class="string">'url'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (!url.value) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'地址不能为空'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (!url.checkValidity()) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'请输入正确的url地址'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(url.value)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但其实一般提交按钮的时候，会自动检验格式</p><h3 id="取消校验"><a href="#取消校验" class="headerlink" title="取消校验"></a>取消校验</h3><p>有两种方法取消校验，第一种用 <code>form</code>的 <code>novalidate</code>属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"textform4"</span> <span class="attr">onsubmit</span>=<span class="string">"return check()"</span> <span class="attr">novalidate</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"http://laibh.top"</span> <span class="attr">id</span>=<span class="string">"url"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是上述的方法里面的 <code>checkValidity()</code>仍会生效</p><p>第二种是利用 <code>input</code>  或者 <code>submit</code>元素的 <code>formnovalidate</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"textform4"</span> <span class="attr">onsubmit</span>=<span class="string">"return check()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"http://laibh.top"</span> <span class="attr">id</span>=<span class="string">"url"</span> <span class="attr">formnovalidate</span>=<span class="string">"formnovalidate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--或者--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"textform4"</span> <span class="attr">onsubmit</span>=<span class="string">"return check()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"http://laibh.top"</span> <span class="attr">id</span>=<span class="string">"url"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">formnovalidate</span>=<span class="string">"formnovalidate"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前者是单单让一个 <code>input</code>取消验证，后者是取消验证整个 <code>form</code>表单</p><h3 id="自定义错误信息"><a href="#自定义错误信息" class="headerlink" title="自定义错误信息"></a>自定义错误信息</h3><p>HTML5 中可以利用 javascript 调用各个 input 元素的 <code>setCustomValidity</code>方法来自定义错误信息。需要注意的是一旦设置了 <code>setCustomValidity</code>，检验通过的条件变成了 <code>setCustomValidity(&#39;&#39;) &amp;&amp; !valueMissing &amp;&amp; !patternMismatch</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"code"</span> <span class="attr">required</span> <span class="attr">pattern</span>=<span class="string">"^\d&#123;4&#125;$"</span> <span class="attr">placeholder</span>=<span class="string">"请输入代码"</span> <span class="attr">oninput</span>=<span class="string">"check(this)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">i</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> &#123; valueMissing,patternMismatch &#125; = i.validity;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(valueMissing,patternMismatch)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(valueMissing)&#123;</span></span><br><span class="line"><span class="javascript">            i.setCustomValidity(<span class="string">'该字段不能为空，请按要求填入代码'</span>)</span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(patternMismatch)&#123;</span></span><br><span class="line"><span class="javascript">                i.setCustomValidity(<span class="string">'请输入4位数字的代码'</span>)</span></span><br><span class="line"><span class="javascript">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                i.setCustomValidity(<span class="string">''</span>)</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;    </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="增强的页面元素"><a href="#增强的页面元素" class="headerlink" title="增强的页面元素"></a>增强的页面元素</h3><p><code>figure</code>和 <code>figcaption</code></p><p><code>figure</code>是一种元素的组合，带有可选标题。figure 元素用来表示网页上一块独立内容，将其从网页上移除后不会对网页上的其他内容产生任何影响。<code>figure</code>元素所表示的内容可以是图片、统计图或者代码示例。</p><p><code>figcaption</code>表示 <code>figure</code>元素的标题，从属于 <code>figure</code>。一个 <code>figure</code>最多只允许防止一个 <code>figcaption</code>元素，但是运行放置多个其他元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>黄浦江上的的卢浦大桥<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>拍摄者：W3School 项目组，拍摄时间：2010 年 10 月<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.w3school.com.cn/i/shanghai_lupu_bridge.jpg"</span> <span class="attr">width</span>=<span class="string">"350"</span> <span class="attr">height</span>=<span class="string">"234"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>figure</code>所表示的内容通常是图片、统计图或者代码示例，也可以是音频插件、视频插件或者统计表格。</p><p><code>details</code></p><p>提供了一种替代 javascript 的将画面上的局部区域进行展开或者收缩的方法，目前只有 Chrome 和 Safari 6 支持 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">summary</span>&gt;</span>Copyright 2011.<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>All pages and graphics on this web site are the property of W3School.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>mark</code></p><p>表示页面需要高亮或者突出显示的。只好是对网页全文检索某个关键词时显示的检索结果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Do not forget to buy <span class="tag">&lt;<span class="name">mark</span>&gt;</span>milk<span class="tag">&lt;/<span class="name">mark</span>&gt;</span> today.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了某种特殊目的把原文作者没有特别重点标示的内容给标示出来。</p><p>与 <code>em</code> 、<code>strong</code>元素的区别在于前者是作者自己标出来的重点要注意的，而<code>mark</code>跟作者本身没有太多关系，是在后来引用的时候添加上去的。</p><p><code>progress</code></p><p>表示一个任务的完成进度。</p><p>该元素有两个参数来表示当前任务完成情况。<code>value</code>表示完成了多少工作量，<code>max</code>表示总共多少工作量。</p><p>在属性设定的时候，这两个属性只能设定为有效的浮点数，<code>value</code>的值必须大于0，小于等于 <code>max</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>progress 使用示例<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>完成百分比：<span class="tag">&lt;<span class="name">progress</span> <span class="attr">id</span>=<span class="string">"progress"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">value</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span>%<span class="tag">&lt;/<span class="name">progress</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">'add()'</span> <span class="attr">value</span>=<span class="string">"请点击"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> progressBar = <span class="built_in">document</span>.getElementById(<span class="string">'progress'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        progressBar.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>].textContent = <span class="string">'0'</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">            setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">                progressBar.value = i;</span></span><br><span class="line"><span class="javascript">                progressBar.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>].textContent = i</span></span><br><span class="line"><span class="undefined">            &#125;, 1000 * i)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>meter</code></p><p>表示规定范围内的数量值。例如磁盘使用量，对于某个候选者的投票人数占总投票人数的比例等。</p><p>meter 元素有六个属性：</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">high</td><td style="text-align:left"><em>number</em></td><td style="text-align:left">定义度量的值位于哪个点，被界定为高的值。</td></tr><tr><td style="text-align:left">low</td><td style="text-align:left"><em>number</em></td><td style="text-align:left">定义度量的值位于哪个点，被界定为低的值。</td></tr><tr><td style="text-align:left">max</td><td style="text-align:left"><em>number</em></td><td style="text-align:left">定义最大值。默认值是 1。</td></tr><tr><td style="text-align:left">min</td><td style="text-align:left"><em>number</em></td><td style="text-align:left">定义最小值。默认值是 0。</td></tr><tr><td style="text-align:left">optimum</td><td style="text-align:left"><em>number</em></td><td style="text-align:left">定义什么样的度量值是最佳的值。如果该值高于 “high” 属性，则意味着值越高越好。如果该值低于 “low” 属性的值，则意味着值越低越好。</td></tr><tr><td style="text-align:left">value</td><td style="text-align:left"><em>number</em></td><td style="text-align:left">定义度量的值。</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">value</span>=<span class="string">"5"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"10"</span> <span class="attr">high</span>=<span class="string">"8"</span> <span class="attr">low</span>=<span class="string">"2"</span> <span class="attr">optimum</span>=<span class="string">"5"</span>&gt;</span>3/10<span class="tag">&lt;/<span class="name">meter</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">value</span>=<span class="string">"0.6"</span>&gt;</span>60%<span class="tag">&lt;/<span class="name">meter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>注释：<span class="tag">&lt;/<span class="name">b</span>&gt;</span>Internet Explorer 不支持 meter 标签。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>menu</code>与 <code>command</code></p><p>用于菜单工具条与弹出菜单。两个元素的浏览器支持不是很好，不做介绍。</p><p><code>ol</code></p><p>增加了 <code>start</code>与 <code>reversed</code>属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">reversed</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>咖啡<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>牛奶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>茶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">start</span>=<span class="string">"50"</span> <span class="attr">reversed</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>咖啡<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>牛奶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>茶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>dl</code></p><p>重新定义后的 <code>dl</code>列表包含多个带名字的列表项。每一项包含一条或者多条带名字的 <code>dt</code>元素，用来表示术语，<code>dt</code>元素后面紧跟一个或者多个 <code>dd</code>元素，用来表示定义。在一个元素内，不允许带有相同的 <code>dt</code>元素，不允许有重复的术语。<code>dl</code>可以用来定义文章或者网页上的术语解释</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>Black hot drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>White cold drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>cite</code></p><p>标签定义作品（比如书籍、歌曲、电影、电视节目、绘画、雕塑等等）的标题。不能是人名</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/i/ct_fcsz.jpg"</span> <span class="attr">alt</span>=<span class="string">"富春山居图"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cite</span>&gt;</span>《富春山居图》<span class="tag">&lt;/<span class="name">cite</span>&gt;</span>由黄公望始画于至正七年(1347)，于至正十年完成。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>small</code></p><p>由原来的通用展示性元素变成更具体的、专门用来标识所谓的”小字印刷体”的元素。通常用于免责声明、注意事项、法律法规、与版权相关等的法律性声明文字中，同时不允许被应用在页面主内容中，只允许被当做辅助信息用 <code>inline</code>方式内嵌在页面上使用。同时 <code>small</code>元素也不意味着元素中内容字体会变小，如果需要将字体变小，需要配合  CSS 样式来用。</p><h3 id="文件-API"><a href="#文件-API" class="headerlink" title="文件 API"></a>文件 API</h3><p>HTML5 中提供了一个关于文件操作的文件 API.</p><h4 id="FileList-对象与-file-对象"><a href="#FileList-对象与-file-对象" class="headerlink" title="FileList 对象与 file 对象"></a>FileList 对象与 file 对象</h4><p><code>FileList</code> 对象表示用户选择的文件列表。在 HTML4 中，<code>file</code> 控件只允许放置一个文件，到了 HTML5 中。通过添加 <code>multiple</code>属性，<code>file</code>控件允许一次放置多个文件。控件内的每一个用户选择的文件都是一个 <code>file</code>对象，而 <code>FileList</code>对象则为这些 <code>file</code>对象的列表，代表用户选择的所有文件。 <code>file</code>对象有两个属性，<code>name</code>属性表示文件名，不包括路径，<code>lastModifiedDate</code>属性表示文件的最后修改日期。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span> <span class="attr">multiple</span> <span class="attr">size</span>=<span class="string">"80"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"showFileName()"</span> <span class="attr">value</span>=<span class="string">"文件上传"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">showFileName</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> file;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> files = <span class="built_in">document</span>.getElementById(<span class="string">'file'</span>).files;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> len = files.length;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="undefined">            file = files[i]</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(file.name);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Blob对象"><a href="#Blob对象" class="headerlink" title="Blob对象"></a>Blob对象</h4><p>Blob 表示二进制原始数据，它提供一个 <code>slice</code>方法，可以通过该方法访问到字节内部数据块。事实上，上面的 <code>file</code>对象也继承了这个 Blob 对象。</p><p>Blob 对象有两个属性，<code>size</code>属性表示一个 Blob 对象的字节长度，<code>type</code> 属性表示 Blob 的 MIME 类型，如果是未知类型的话，返回一个空字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showFileName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> file;</span><br><span class="line">    <span class="keyword">const</span> files = <span class="built_in">document</span>.getElementById(<span class="string">'file'</span>).files;</span><br><span class="line">    <span class="keyword">const</span> len = files.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        file = files[i]</span><br><span class="line">       <span class="built_in">console</span>.log(file.name + <span class="string">'==='</span> + file.size + <span class="string">'==='</span> + file.type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对 <code>file.size</code>或者 <code>file.type</code>判断可以进行文件大小与文件类型的限制。另外 HTML5 已经对 <code>file</code>控件添加了 <code>accept</code>属性，企图让 <code>file</code>控件只能接受某种类型的文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span> <span class="attr">multiple</span> <span class="attr">size</span>=<span class="string">"80"</span> <span class="attr">accept</span>=<span class="string">"image/gif"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样打开文件的时候就会显示 gif结尾的文件，当然如果你强行传其他类型的也是没有报错的。所以如果要做限制上传文件类型的话要结合 <code>file.type</code>来实现。</p><h4 id="FileReader接口"><a href="#FileReader接口" class="headerlink" title="FileReader接口"></a>FileReader接口</h4><p>主要用来把文件读入内存，并且读取文件中的数据。FileReader 接口有了一个异步 API,使用该 API可以在浏览器主线程中异步访问文件系统，读取文件中的数据。</p><p>检查是否可以使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="keyword">typeof</span> FileReader)&#123;</span><br><span class="line">    <span class="comment">// 浏览器为实现 FileReader 接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口方法</strong></p><p>这个接口拥有4个方法，其中三个用来读取文件，另一个用来读取过程中断</p><table><thead><tr><th>方法名</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>readAsBinaryString</td><td>file</td><td>将文件读取为二进制码</td></tr><tr><td>readAsText</td><td>file,[encoding]</td><td>将文件读取为文本</td></tr><tr><td>readAsDataURL</td><td>file</td><td>将文件读取为 DataURL</td></tr><tr><td>abort</td><td>（none）</td><td>中断读取操作</td></tr></tbody></table><ul><li>readAsBinaryString,这个方法将文件读取为二进制字符串，通常我们把它传送到后端，后端可以通过这段字符串存储文件。</li><li>readAsText,有两个参数，第二个参数是文本的编码方式，默认值为 <code>UTF-8</code>。将文件以文本方式读取，读取的结果是这个文本文件中的内容。</li><li>readAsDateURL,该方法将文件读取为一串 Data URL字符串，该方法事实上是将小文件以一种特殊格式的URL 地址形式直接读入页面。这里的小文件通常是图像与 html 格式的文件。</li></ul><p><strong>接口的事件</strong></p><p>除了上面打方法，FileReader 接口还包含了一套完整的事件模型，用于捕获读取文件时的状态。</p><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>onabort</td><td>数据读取中断时触发</td></tr><tr><td>onerror</td><td>数据读取出错时触发</td></tr><tr><td>onloadstart</td><td>数据取数开始时触发</td></tr><tr><td>onprogress</td><td>数据读取中</td></tr><tr><td>onload</td><td>数据读取成功完成时触发</td></tr><tr><td>onloadend</td><td>数据读取完成时触发，无论成功或者失败</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"file"</span>&gt;</span>请选择一个文件<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"readAsDataURL()"</span> <span class="attr">value</span>=<span class="string">"读取图像"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"readAsBinaryString()"</span> <span class="attr">value</span>=<span class="string">"读取二进制数据"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"readAsText()"</span> <span class="attr">value</span>=<span class="string">"读取文本数据"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">name</span>=<span class="string">"result"</span> <span class="attr">id</span>=<span class="string">"result"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> result = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> file = <span class="built_in">document</span>.getElementById(<span class="string">'file'</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (!<span class="keyword">typeof</span> FileReader) &#123;</span></span><br><span class="line"><span class="javascript">  alert(<span class="string">'浏览器不支持 FileReader 接口'</span>)</span></span><br><span class="line"><span class="javascript">  file.setAttribute(<span class="string">'disabled'</span>, <span class="string">'disabled'</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">readAsDataURL</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 检查文件是否为图像</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> &#123; files &#125; = file;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> len = files.length;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!<span class="regexp">/image\/\w+/</span>.test(files[i].type)) &#123;</span></span><br><span class="line"><span class="javascript">      alert(<span class="string">'请确保文件都为图像类型'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将文件以 Data URL 形式读入页面</span></span></span><br><span class="line"><span class="undefined">    reader.readAsDataURL(files[i])</span></span><br><span class="line"><span class="javascript">    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span></span><br><span class="line"><span class="javascript">      img.src = <span class="keyword">this</span>.result</span></span><br><span class="line"><span class="undefined">      result.appendChild(img)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 将文件以二进制的形式读入页面</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">readAsBinaryString</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 检查文件是否为图像</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> &#123; files &#125; = file;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> len = files.length;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!<span class="regexp">/image\/\w+/</span>.test(files[i].type)) &#123;</span></span><br><span class="line"><span class="javascript">      alert(<span class="string">'请确保文件都为图像类型'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将文件以 二进制形式读入页面</span></span></span><br><span class="line"><span class="undefined">    reader.readAsBinaryString(files[i])</span></span><br><span class="line"><span class="javascript">    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>)</span></span><br><span class="line"><span class="javascript">      p.innerHTML += <span class="keyword">this</span>.result</span></span><br><span class="line"><span class="undefined">      result.appendChild(p)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 将文件以文本形式读入页面</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">readAsText</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 检查文件是否为图像</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> &#123; files &#125; = file;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> len = files.length;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!<span class="regexp">/image\/\w+/</span>.test(files[i].type)) &#123;</span></span><br><span class="line"><span class="javascript">      alert(<span class="string">'请确保文件都为图像类型'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将文件以 二进制形式读入页面</span></span></span><br><span class="line"><span class="undefined">    reader.readAsText(files[i])</span></span><br><span class="line"><span class="javascript">    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>)</span></span><br><span class="line"><span class="javascript">      p.innerHTML += <span class="keyword">this</span>.result</span></span><br><span class="line"><span class="undefined">      result.appendChild(p)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于读取状态的先后顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readAsDataURL</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检查文件是否为图像</span></span><br><span class="line">  <span class="keyword">const</span> &#123; files &#125; = file;</span><br><span class="line">  <span class="keyword">const</span> len = files.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/image\/\w+/</span>.test(files[i].type)) &#123;</span><br><span class="line">      alert(<span class="string">'请确保文件都为图像类型'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    <span class="comment">// 将文件以 Data URL 形式读入页面</span></span><br><span class="line">    reader.readAsDataURL(files[i])</span><br><span class="line">    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">      img.src = <span class="keyword">this</span>.result</span><br><span class="line">      result.appendChild(img)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'load'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    reader.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'progress'</span>);&#125;</span><br><span class="line">    reader.onabort = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'abort'</span>);&#125;</span><br><span class="line">    reader.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'error'</span>);&#125;</span><br><span class="line">    reader.onloadstart = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'loadstart'</span>);&#125;</span><br><span class="line">    reader.onloadend = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'loadend'</span>);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// loadstart</span></span><br><span class="line"><span class="comment">// progress</span></span><br><span class="line"><span class="comment">// load</span></span><br><span class="line"><span class="comment">// loadend</span></span><br></pre></td></tr></table></figure><p>在 <code>onprogress</code>里面可以用 <code>progress</code>来显示文件读取的百分比。</p><h4 id="拖放-API"><a href="#拖放-API" class="headerlink" title="拖放 API"></a>拖放 API</h4><p>虽然在 HTML5 之前已经可以使用 <code>mousedown</code>、<code>mousemove</code>、<code>mouseup</code>来实现拖放操作，但是这只是在浏览器内容的拖放。在 HTML5 中，支持在浏览器与其他应用程序之间的数据互相拖动，同时也大大简化了拖放方面的代码。</p><h5 id="实现拖放的步骤"><a href="#实现拖放的步骤" class="headerlink" title="实现拖放的步骤"></a>实现拖放的步骤</h5><ol><li>将想要拖放的对象元素的 <code>draggable</code>属性设为 <code>true</code>，这样才能将该元素进行拖放。另外，img元素与 a 元素默认运行拖放。</li><li>编写与拖放有关的代码。</li></ol><h5 id="拖放的相关事件"><a href="#拖放的相关事件" class="headerlink" title="拖放的相关事件"></a>拖放的相关事件</h5><table><thead><tr><th>事件</th><th>产生事件的元素</th><th>描述</th></tr></thead><tbody><tr><td>drastart</td><td>被拖放的元素</td><td>开始施放操作</td></tr><tr><td>drag</td><td>被拖放的元素</td><td>拖放过程中</td></tr><tr><td>dragenter</td><td>拖放过程中鼠标经过的元素</td><td>被拖放的元素开始进入本元素的范围</td></tr><tr><td>dragover</td><td>拖放过程中鼠标经过的元素</td><td>被拖放的元素正在本元素范围内移动</td></tr><tr><td>dragleave</td><td>拖放过程中鼠标经过的元素</td><td>被拖放的元素离开本元素的范围</td></tr><tr><td>drop</td><td>拖放的目标元素</td><td>有其他元素被拖放到了本元素中</td></tr><tr><td>dragend</td><td>拖放的对象元素</td><td>拖放操作结束</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"init()"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>简单拖放示例<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"dragme"</span> <span class="attr">draggable</span>=<span class="string">"true"</span> <span class="attr">style</span>=<span class="string">"width:200px;border:1px solid gray"</span>&gt;</span></span><br><span class="line">    请拖放</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"text"</span> <span class="attr">style</span>=<span class="string">"width:200px;height:200px;border:1px solid gray"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> source = <span class="built_in">document</span>.getElementById(<span class="string">'dragme'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> dest = <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>);</span></span><br><span class="line"><span class="javascript">      source.addEventListener(<span class="string">'dragstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> dt = ev.dataTransfer;</span></span><br><span class="line"><span class="javascript">        dt.effectAllowed = <span class="string">'all'</span>;</span></span><br><span class="line"><span class="javascript">        dt.setData(<span class="string">'text/plain'</span>, <span class="string">'你好'</span>)</span></span><br><span class="line"><span class="javascript">      &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      dest.addEventListener(<span class="string">'dragend'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 不执行默认处理（拒绝被拖放）</span></span></span><br><span class="line"><span class="undefined">        ev.preventDefault();</span></span><br><span class="line"><span class="undefined">      &#125;);</span></span><br><span class="line"><span class="javascript">      dest.addEventListener(<span class="string">'drop'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> dt = ev.dataTransfer;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> text = dt.getData(<span class="string">'text/plain'</span>);</span></span><br><span class="line"><span class="undefined">        dest.textContent += text;</span></span><br><span class="line"><span class="undefined">        ev.preventDefault();</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 禁止事件传播</span></span></span><br><span class="line"><span class="undefined">        ev.stopPropagation();</span></span><br><span class="line"><span class="javascript">      &#125;, <span class="literal">false</span>)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 页面设置属性，不执行默认处理(拒绝被拖放)</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.ondragover = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; e.preventDefault() &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.ondrop = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; e.preventDefault() &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>开始拖动（<code>dragstart</code>事件发生）时，将要拖动的数据存入 <code>DataTransfer</code>对象（<code>setData()方法</code>）。<code>DataTransfer</code>对象专门用来存放拖放时要携带的数据，它可以被设置为拖动事件对象的 <code>dataTransfer</code>属性。<code>setData</code>方法中的第一个参数为携带数据的数据种类的字符串，第二个参数为要修改的数据。第一个参数中表示数据种类的字符串里只能填入类似 <code>text/plain</code>或者<code>text/html</code>的表示 MIME 类型的文字，不能填入其他文字。</li><li>如果把<code>dt.setData(&quot;text/plain&quot;,&quot;你好&quot;)</code>改成 <code>dt.setData(&quot;text/plain&quot;,this.id)</code>。因为把被拖动元素的 id 当成了参数，所以携带的数据就是被拖动元素中的数据了，因为浏览器在使用 <code>getData()</code>方法读取数据时会自动读取该元素中的数据。</li><li>针对拖放的目标元素，必须在 <code>dragend</code>或者 <code>dragover</code>事件内调用事件对象的 <code>preventDefault()</code>方法。因为默认情况下，被拖放的目标元素不允许接受元素的，为了把元素拖放到其中，必须把默认处理给关闭掉。</li><li>目标元素接受到被拖放的元素后，执行 <code>getData</code>方法从 <code>DataTransfer</code>获得数据。<code>getData</code>方法的参数为 <code>setData</code>方法中指定的数据种类</li><li>要实现拖放过程，还必须在目标元素的 <code>drop</code>事件中关闭默认处理（拒绝被拖放），否则目标元素不能接受被拖放的元素</li><li>实现拖放过程，还必须设定整个页面为不执行默认处理（拒绝被拖放），否则拖放处理也不能被实现。因为页面是先于其他元素接受拖放的，如果页面上拒绝拖放，那么页面上其他元素就都不能接受拖放</li><li>要使元素可以被拖放，首先必须把该元素的 <code>draggable</code>属性设为 <code>true</code>，另外，为了让这个示例在所有支持拖放 API 的浏览器中都能正常运行，需要指定 <code>-webkit-user-drag:element</code>这种 Webkit 特有的 CSS 属性</li></ul><p>现在支持拖放处理的 MIME 类型主要有一下几种：</p><ul><li>text/plain:文本文字</li><li>text/html：HTML文字</li><li>text/xml：xml 文字</li><li>text/uri-list：URL 列表，每个 URL 为一行</li></ul><h5 id="DataTransfer-对象的属性与方法"><a href="#DataTransfer-对象的属性与方法" class="headerlink" title="DataTransfer 对象的属性与方法"></a>DataTransfer 对象的属性与方法</h5><table><thead><tr><th>属性/方法</th><th>描述</th></tr></thead><tbody><tr><td>dropEffect属性</td><td>表示拖放操作的视觉效果，运行对其进行值的设定。该效果必须用 <code>effectAllowed</code>属性置顶的允许的效果范围内。允许指定的值为 none、copy、move、link</td></tr><tr><td>effectAllowed属性</td><td>用来指定当元素被拖放时所运行的视觉效果，可以指定的值为none、copy、copyLink、copyMove、link、linkMove、move、all、unintialize</td></tr><tr><td>types属性</td><td>存入数据的种类，字符串的伪数组</td></tr><tr><td>void clearData(DOMString format)方法</td><td>清除 DataTransfer 对象中存放的数据，如果省略参数 format,则清除全部数据</td></tr><tr><td>void setData(DOMString format、DOMString data)</td><td>向 DataTransfer 对象内存入数据</td></tr><tr><td>DOMString getData(DOMString format)</td><td>从 DataTransfer 对象中读数据</td></tr><tr><td>void setDragImage(Element image,long x,long y)</td><td>用 img 元素来设置拖放图标（部分浏览器可以用 canvas 等其他元素来设置）</td></tr></tbody></table><h5 id="设定拖放时的视觉效果"><a href="#设定拖放时的视觉效果" class="headerlink" title="设定拖放时的视觉效果"></a>设定拖放时的视觉效果</h5><p><code>dropEffect</code>与 <code>effectAllowed</code>属性结合起来可以设定拖放时的视觉效果。<code>effectAllowed</code>属性表示当一个元素被拖动时所运行的视觉效果，一般在 <code>ondragstart</code>事件中设定，运行使用的值为 none、copy、copyLink、copyMove、link、move、all、unintialize。</p><p><code>dropEffect</code>属性表示实际拖放时的视觉效果，一般在 <code>ondragover</code>事件中指定，运行设定的值为 none、copy、link、move。<code>dropEffect</code>属性所表示的实际视觉效果必须在 <code>effectAllowed</code>属性所表示的允许的视觉效果范围内。规则如下：</p><ol><li>如果 <code>effectAllowed</code>属性被设为 <code>none</code>，则不允许拖放元素。</li><li>如果 <code>dropEffect</code>属性设定为 <code>none</code>，则不允许被拖放到目标元素中</li><li><code>effectAllowed</code>属性设定为 <code>all</code>或者不设定，则 <code>dropEffect</code>属性允许被设定为任何值，并按照指定的视觉效果进行显示</li><li>如果 <code>effectAllowed</code>属性设定为具体效果（不为 none或者 all），<code>dropEffect</code>属性也设定了具体视觉效果，则两个具体效果值必须完全相等，否则不允许被拖放元素拖放到目标元素中。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">source.addEventListener(<span class="string">'dragstart'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dt = ev.dataTransfer;</span><br><span class="line">    dt.effectAllowed = <span class="string">'copy'</span>;</span><br><span class="line">    dt.setData(<span class="string">"text/plain"</span>,<span class="string">"你好"</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">dest.addEventListener(<span class="string">'dragover'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dt = ev.dataTransfer;</span><br><span class="line">    dt.dropEffect = <span class="string">'copy'</span>;</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h5 id="自定义拖放图标"><a href="#自定义拖放图标" class="headerlink" title="自定义拖放图标"></a>自定义拖放图标</h5><p>除了上面所说的使用 <code>effectAllowed</code>属性与<code>dropEffect</code>属性外，HTML5 还允许自定义拖放图标——指的是在用鼠标拖动元素的过程中，位于鼠标指针下部的小图标。</p><p><code>setDragImage</code>方法有三个惨呼，第一个参数 image 设定为拖放图标的图标元素，第二个参数 x 为拖放图标离鼠标指针x轴方向的位移量，第三个参数 y 为拖放图标距离鼠标指针的 y 轴方向的位移量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dragIcon.src = <span class="string">'http://laibh.top/images/favicon-32x32-next.png?v=5.1.4'</span>;</span><br><span class="line">source.addEventListener(<span class="string">'dragstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> dt = ev.dataTransfer;</span><br><span class="line"><span class="built_in">console</span>.log(ev)</span><br><span class="line"><span class="built_in">console</span>.log(dt)</span><br><span class="line">dt.effectAllowed = <span class="string">'all'</span>;</span><br><span class="line">dt.setDragImage(dragIcon, <span class="number">-10</span>, <span class="number">-10</span>)</span><br><span class="line">dt.setData(<span class="string">'text/plain'</span>, <span class="string">'你好'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习链接：&lt;br&gt;&lt;a href=&quot;https://read.douban.com/ebook/15160963/&quot;&gt;HTML 5与CSS 3权威指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.w3cschool.cn/html/&quot;&gt;W3cScholl
      
    
    </summary>
    
      <category term="前端面试" scheme="http://laibh.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="HTML5" scheme="http://laibh.top/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题目汇总摘录（React 基础篇）</title>
    <link href="http://laibh.top/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E6%91%98%E5%BD%95-React%20%E5%9F%BA%E7%A1%80%E7%AF%87.html"/>
    <id>http://laibh.top/前端面试题目汇总摘录-React 基础篇.html</id>
    <published>2019-05-13T02:30:54.000Z</published>
    <updated>2020-07-11T03:24:57.643Z</updated>
    
    <content type="html"><![CDATA[<p>温故而知新，保持空杯心态</p><h2 id="React-基础"><a href="#React-基础" class="headerlink" title="React  基础"></a>React  基础</h2><h3 id="什么是-React"><a href="#什么是-React" class="headerlink" title="什么是 React?"></a>什么是 React?</h3><p>是一个用于构建用户界面的 javaScript 库，主要用于构建 UI,很多人认为是 MVC 中的 View 层</p><p>特点：</p><ul><li>声明式设计 – 采用声明范式，可以轻松描述应用</li><li>高效 – 通过对 DOM 的模拟，最大限度地减少与 DOM 的交互</li><li>灵活 –  React 可以与很多库或者框架很好地配合</li><li>JSX – JSX 是 javascript 语法的扩展</li><li>组件 – 通过 React 构建的组件，使得代码更加容易得到，很好的应用在大项目的开发中</li><li>单向响应的数据流 – 减少了重复代码</li></ul><h3 id="React的渲染机制"><a href="#React的渲染机制" class="headerlink" title="React的渲染机制"></a>React的渲染机制</h3><h4 id="React-渲染过程"><a href="#React-渲染过程" class="headerlink" title="React 渲染过程"></a>React 渲染过程</h4><p>页面打开的时候，React 会调用 render 函数来构建一颗 DOM 树，在 <code>state/props</code>改变的时候， render 函数会再次调用渲染出来另外一颗树，接着， React 会对两棵树进行对比，找出需要更新的地方进行批量改动</p><h4 id="Diff-算法"><a href="#Diff-算法" class="headerlink" title="Diff 算法"></a>Diff 算法</h4><p><strong>作用</strong></p><p>计算出 Virtual DOM 中真正变化的部分，并只针对该部分进行原生 DOM 操作，而非重新渲染整个页面。</p><p><strong>传统 diff 算法的劣处</strong></p><p>通过循环递归节点进行依次对比，算法复杂度达到 <code>O(n^3)</code>，n 是树的节点数。假设展示1000个节点，得执行上亿次比较。CPU 无法进行在很短的时间内计算出差异</p><p><strong>React 的 diff 算法</strong></p><p>将 Virtual DOM 树转换成为 Actual DOM 树的最少操作过程被称为调和。React  的 diff 算法就是调和的具体实现。</p><p><strong>React 的diff 策略</strong></p><p>React 用三大策略将 <code>O(n^3)</code>复杂都转换为 <code>O(n)</code>复杂度</p><p>策略1（tree diff）:</p><p>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计</p><p>策略2（component diff）:</p><p>拥有相同类的两个组件生成相似的树形结构</p><p>拥有不同类的两个组件生成不同的树形结构</p><p>策略三（element diff）:</p><p>对于同一层级的一组子节点，通过唯一的 id 区分</p><p><strong>diff 策略详解</strong></p><p><em>Tree diff</em></p><ol><li>React 通过 updateDepth 对 Virtual DOM 树进行层级控制</li><li>对树分层比较，两棵树只对同一层次节点进行比较，如果该节点不存在时，则该节点以及其节点会被完全删除，不会再进行进一步比较</li><li>只要遍历一次，就能完成整颗 DOM 的比较</li><li>如果 DOM 出现了跨层操作，diff 只会简单考虑同层级的节点位置变化，如果是跨层的话，只有创建和删除节点的操作。因此也不建议进行跨 DOM 操作，可以通过 CSS 隐藏、显示节点，而不是真正地移除，添加 DOM 节点</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">updateChildren:<span class="function"><span class="keyword">function</span>(<span class="params">nextNestedChildrenElements,transaction,context</span>)</span>&#123;</span><br><span class="line">    updateDepth++;</span><br><span class="line">    <span class="keyword">var</span> errorThrow = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._updateChildren(nextNestedChildrenElements,transaction,context)</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        updateDepth--;</span><br><span class="line">        <span class="keyword">if</span>(updateDepth)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errorThrow)&#123;</span><br><span class="line">            clearQueue();   </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                processQueue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Component diff</em></p><ol><li>同一类型的两个组件，按原策略（层级比较）继续比较 Virtual DOM 树即可</li><li>同一类型的两个组件，组件 A 变化为 组件 B时，可能 Virtual DOM 没有任何改变，如果知道这一点，可节省大量计算时间。用户可以通过 <code>shouldComponentUpdate()</code> 来判断是否需要判断计算</li><li>不同类型的组件，将一个（将被改变的）组件判断为 <code>dirty component(脏组件)</code>，从而替换整个组件的所有节点。</li></ol><p>注意：如果组件 A 和 组件 B 的结构相似，但是 React 判断是不同类型的组件，则不会比较其结构，而是删除 组件 A 以及其子节点，创建组件 B 以其子节点。</p><p><em>Element diff</em></p><p>当节点处于同一层级时，diff 提供三个节点操作：删除、插入、移动</p><p>插入：组件 C 不在集合 （AB）中,需要插入</p><p>删除：组件 D 在集合 （ABD）中，但是集合变成（AB）,D就需要被删除</p><p>移动：组件 D 已经在集合（ABCD）中，且集合更新时，D 没有发生更新，只是位置的改变，如新的集合（ADBC）。D 在第二个，无须像传统的 diff,让旧集合的第二个 B 和新集合的比较，并且删除第二个位置的 B，再在第二个位置插入 D 。需要做的是（对同一层级的同组子节点）添加唯一的 key 进行区分，移动即可。</p><p><strong>移动逻辑详解</strong></p><p>情形一：新旧集合中存在相同节点但是位置不同时，如何移动节点</p><p><img src="/images/前端面试题目汇总摘录-React 基础篇-react-diff移动1.png" alt="react-diff移动1"></p><p><code>lastIndex</code>有点像浮标，或者一个 map 的索引，默认值是 0，会与 map 中的元素进行比较后改变自己的值（取 <code>index</code>和 <code>lastIndex</code>中的较大值）</p><ol><li>B，React 在新中取得 ,判断旧中是否存在相同的节点B,发现节点B后判断是否需要移动B。<ol><li>B 在旧中 <code>index = 1</code>,它 的 <code>lastIndex = 0</code></li><li>不满足 <code>lastIndex &gt; index</code>，无需移动操作。</li><li><code>lastindex = Math.max(lastindex,index) = 1</code> </li></ol></li><li>A，A在旧的 <code>index=0</code>,此时 <code>lastIndex=1</code>。满足 <code>lastIndex &gt; index</code>，对 A 进行移动到 <code>lastIndex=1</code>。接着操作 <code>lastIndex=Math.max(lastIndex,index)</code>还是等于1</li><li>D，同 1，不移动，由于旧的D <code>index=3</code>,<code>lastIndex=1</code>，改 <code>lastIndex=Math.max(lastIndex,index)=3</code></li><li>C,同 2，移动。C在旧的 <code>index=2</code>,满足<code>lastIndex(3)&gt;index</code>，移动</li><li>由于 C 已经是最后一个节点了，所以 diff 操作结束</li></ol><p>情形二：新集合中有新加入的节点，旧集合中有删除的节点</p><p><img src="/images/前端面试题目汇总摘录-React 基础篇-react-diff移动2.png" alt="react-diff移动2"></p><ol><li>B,同上理，不移动，更新 <code>lastIndex=1</code></li><li>E,旧集合中没有，在 <code>lastIndex=1</code>上创建E，更新 <code>lastIndex=1</code></li><li>C，C在旧集合中 <code>index=2</code>,不满足<code>lastIndex&gt;index</code>，不移动，更新 <code>lastIndex=Math.max(lastIndex,index)=2</code></li><li>A，旧集合中 <code>index=0</code>，符合 <code>lastIndex&gt;index</code>，移动，<code>lastIndex还是等于 2</code></li><li>新旧集合对比后，再对旧集合遍历。判断新集合中没有，但是旧集合有的元素D，删除 D，diff 操作结束</li></ol><p><strong>diff 的不足之处与待优化的地方</strong></p><p>情形三：将最后一个元素移动到最前面</p><p><img src="/images/前端面试题目汇总摘录-React 基础篇-react-diff移动3.png" alt="react-diff移动3"></p><p>D,此时D 不移动，但是因为它的 index 最大的，导致 <code>lastIndex=3</code>，从而使得其他元素的 <code>index &lt; lastIndex</code>，导致都要去移动。</p><p>理想的情况是值移动D,不移动 ABC.因此在开发中，应该尽量减少将最后一个节点移动到列表的首部，当节点数量过大或者操作更新过于频繁的时候，会影响到 React 的渲染性能。</p><h3 id="React-JSX"><a href="#React-JSX" class="headerlink" title="React JSX"></a>React JSX</h3><p>React 使用 JSX 来替代常规的 javascript,有几个优点：</p><ul><li>执行更快，在编译为 javascript 代码后进行了优化</li><li>类型安全，在编译过程中就能发现错误</li><li>使用 JSX 编写模板简单快速</li></ul><p>在 React 应用中，元素是构成 React 的最小单位，JSX 就是用来声明 React 当中的元素。</p><p>与浏览器的 DOM 元素不同，React 当中的元素是普通的对象，ReactDOM 可以确保浏览器的数据内容与 React 元素一致。通过 <code>ReactDOM.render</code>将元素渲染到 DOM 节点上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"foo "</span> /&gt;</span></span></span><br><span class="line">ReactDOM.render(&lt;App&gt;,document.getElementById('root'))</span><br></pre></td></tr></table></figure><p><strong>原理</strong></p><p>如何用 JavaScript 元素来表示一个 DOM 元素的结构:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">        Hello</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个 DOM 元素包含的信息其实只有三个：标签、属性，子元素，所以上面的内容可以表示为</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tag:'div',</span><br><span class="line">    attrs:&#123;className:'box',id:'content'&#125;,</span><br><span class="line">    children:[&#123;</span><br><span class="line">        tag:'div',</span><br><span class="line">        attrs&#123;className:'title'&#125;,</span><br><span class="line">        children:['Hello']</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        tag:'button',</span><br><span class="line">        attrs:null,</span><br><span class="line">        children:['Click']</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 javaScript 有个缺点就是内容太长，结构不够清晰，用 HTML 的方式会方便很多。而 React 把 javascript 扩展了一下，让 javascript 能够支持直接在 javascript 代码中编写类似 HTML 标签结构的语法。编译的过程中会把类似 HTML 的 JSX 结构转换成为 javascript 的对象结构。例如下面的代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'/index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1 className=<span class="string">'title'</span>&gt;React JSX&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;MyComponent /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElememtById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>经过编译后：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'/index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            React.createElement(</span><br><span class="line">                <span class="string">'div'</span>,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                React.createElement(</span><br><span class="line">                <span class="string">'h1'</span>,</span><br><span class="line">                &#123;<span class="attr">className</span>:<span class="string">'title'</span>&#125;,</span><br><span class="line">                <span class="string">"React JSX"</span></span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    React.createElement(MyComponent,<span class="literal">null</span>)</span><br><span class="line">    <span class="built_in">document</span>.getElememtById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>React.createElement</code> 会构建一个 JavaScript 对象来描述 HTML 结构的信息，包括标签名，属性，还有子元素等等。</p><p><strong>所谓的JSX 其实就是 JavaScript 对象</strong></p><p><code>React.render</code>功能就是把组件渲染并且构造 DOM 树，然后插入到页面上特定的元素上。</p><p>总结过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Babel 编译 +   </span><br><span class="line">React.js 构造           ReactDOM.render</span><br><span class="line">JSX -----&gt; JavaScript 对象结构 -----&gt; DOM 元素 -----&gt; 插入页面</span><br></pre></td></tr></table></figure><h3 id="React-生命周期函数"><a href="#React-生命周期函数" class="headerlink" title="React 生命周期函数"></a>React 生命周期函数</h3><h4 id="React-v16-0-前的生命周期"><a href="#React-v16-0-前的生命周期" class="headerlink" title="React v16.0 前的生命周期"></a>React v16.0 前的生命周期</h4><p>分成四个阶段 Initialization、Mounting、Updation、Unmounting</p><h4 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a><strong>Initialization</strong></h4><p>setup props and states</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test 类继承 react 的基本类，拥有了 render ，生命周期等等方法可以使用。</p><p><code>super(props)</code>，用来调用基类的构造方法（constructor()），将父组件中的props 注入给子组件，供其读取。</p><p>使用ES6 classes构建组件的时候<strong>static defaultProps={}</strong>其实就是调用内部的<strong>getDefaultProps</strong>方法。</p><p><code>constructor</code>可以做一些组件初始化的功能，例如初始化 <code>state</code>,就是调用内部的 <code>getIntialState</code>方法</p><h4 id="Mounting"><a href="#Mounting" class="headerlink" title="Mounting"></a><strong>Mounting</strong></h4><p>getDefaultProps =&gt; getInitialState =&gt; componentWillMount =&gt; render =&gt; componentDidMount</p><ul><li>componentWillMount</li></ul><p>在组件挂载到 DOM 之前调用且只会被调用一次，这里调用 <code>setState</code>不会引起组件重新渲染，也可以把这边的内容写在 <code>constructor</code>中。另外 在 React SSR 中，这个生命周期函数很重要。React-Helmet等等插件都是根据这个函数来实现在 Server 插入内容</p><ul><li>render</li></ul><p>根据组件的 <code>props</code>和 <code>state</code>，返回一个 React 元素，不负责组件的实际渲染工作，之后 React 根据元素去渲染 页面的 DOM 工作。render 是纯函数，不能在里面执行 <code>this.setState</code>，会有改变组件状态的副作用</p><ul><li>componentDidMount</li></ul><p>组件挂载到 DOM 后调用，且只会被调用一次</p><h4 id="Updation"><a href="#Updation" class="headerlink" title="Updation"></a><strong>Updation</strong></h4><p>props:</p><p>componentWillReciveProps =&gt; shouldComponentUpdate =&gt; ComponentWillUpdate =&gt; render =&gt; componentDidUpdate</p><p>states:</p><p>shouldComponentUpdate =&gt; componentWillUpdate =&gt; render =&gt; componentDidUpdate</p><p><strong>造成组件更新的情况有两类（三种）情况</strong></p><p>1.父组件重新 render</p><p>父组件重新 render 引起子组件重新 render 的情况有两种</p><p>a) 直接使用，每当父组件重新 render 导致 重传 <code>props</code>,子组件将跟着重新渲染，无论 <code>props</code> 知否有变化，可通过 <code>shouldComponentUpdate</code>方法优化</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    shouldComponentUpdate(nextProps)&#123; <span class="comment">// 使用这个方法，可以避免无论 props 是否有更新都会导致组件跟着渲染</span></span><br><span class="line">        <span class="keyword">if</span>(nextProps.somethings === <span class="keyword">this</span>.props.somethings)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        render()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.sometings&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b) 在 <code>componentWillReceiveProps</code>方法中，将 <code>props</code> 换成自己的 <code>state</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            sometings:props.somethings</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillReceiveProps(nextProps)&#123;</span><br><span class="line">        <span class="comment">// 父组件重传 props 时会调用这个方法</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">something</span>:nextProps.somethings&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.sometings&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官网的描述，在 <code>componentWillReceiveProps</code>中调用 <code>this.setState()</code>不会引起第二次渲染</p><p>是因为 <code>componentWillReceiveProps</code>中判断 <code>props</code>是否变化了，如果变化了， <code>this.setState</code>将引起 <code>state</code>的变化，从而引起 <code>render</code>，此时就没有必要再做第二次重传 <code>props</code>引起的 <code>render</code>,避免重复做一样的渲染。</p><p>2.组件本身调用 <code>setState</code>，无论 <code>state</code> 是否有变化，可通过 <code>shouldComponentUpdate</code>方法优化</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            something:<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    shouldComponentUpdate(nextState)&#123;</span><br><span class="line">        <span class="comment">// 使用这个方法，可以避免相同 state引起 render</span></span><br><span class="line">        <span class="keyword">if</span>(nextState.something === <span class="keyword">this</span>.state.something)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> preSomething = <span class="keyword">this</span>.state.something</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">something</span>:preSomething&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleChild&#125;</span>&gt;</span>&#123;this.state.something&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>componentWillReceviceProps(nextProps)</li></ul><p>这个方法只会调用于<code>props</code> 引起的组件更新过程中，参数 <code>nextProps</code>是父组件传给当前组件的新 <code>props</code>。但是父组件 <code>render</code>方法的调用不能保证重传给当前组件的 <code>props</code> 是否有变化，所以在此方法根据 <code>nextProps</code>和 <code>this.props</code>来查明重传的 <code>props</code>是否有变化，以及如果改变了要执行什么，例如根据新的 <code>props</code>调用 <code>this.setState()</code>触发当前组件重新 <code>render</code></p><ul><li>shouldComponentUpdate(nextProps,nextState)</li></ul><p>通过比较 <code>nextProps</code>，<code>nextState</code>以及 <code>this.state</code>,<code>this.props</code>返回 true 时当前组件将继续执行更新过程，返回 false 当前组件停止更新，从而来减少组件的不必要的渲染，优化组件性能。</p><ul><li>componentWillUpdate(nextProps,nextState)</li></ul><p>在 调用 render 之前调用，在这里可以执行一些组件更新前的工作，一般比较少用</p><ul><li>componentDidUpdate(prevProps,prevState)</li></ul><p>这个方法组件更新后调用，可以操作组件更新的 DOM,<code>prevProps</code>，<code>prevState</code>这两个参数是指组件更新前的 <code>props</code> 和 <code>state</code></p><h4 id="Unmounting"><a href="#Unmounting" class="headerlink" title="Unmounting"></a><strong>Unmounting</strong></h4><p>componentWillUnMount</p><ul><li>componentWillUnMount</li></ul><p>这个方法在组件被卸载前调用，可以在这里执行一些清理工作。例如组件中使用的定时器，componentDidMount 中手动创建的 DOM 元素等等，可以避免内存泄露</p><p>具体实现可以看看这篇文章，<a href="https://segmentfault.com/a/1190000018499749">一次性搞懂 React 生命周期</a></p><h4 id="React-v-16-4-的生命周期"><a href="#React-v-16-4-的生命周期" class="headerlink" title="React v.16.4 的生命周期"></a>React v.16.4 的生命周期</h4><p><a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">图</a></p><p><img src="/images/前端面试题目汇总摘录-React 基础篇-react-v16.4-生命周期函数图.png" alt="v.16.4"></p><h4 id="变更缘故"><a href="#变更缘故" class="headerlink" title="变更缘故"></a>变更缘故</h4><p>生命周期在React v16 推出 Fiber 后就不合适了，如果开启 <code>async rendering</code>，在 <code>render</code>函数之前的所有函数，都有可能被执行多次。</p><p>v.16 前的生命周期中,<code>componentWillMount</code>,<code>componentReceiveProps</code>,  <code>shouldComponentUpdate</code>,<code>componentWillUpdate</code>是在 <code>render</code>之前执行的。</p><p>开发者如果开启了 <code>async rendering</code>，而且在上述的生命周期方法做 ajax 请求的话，那就将会被无谓多次调用。明显不是我们期望的结果。在 <code>componentWillMount</code>请求 ajax ,不管多快的结果都跟不上首次 <code>render</code>，而且 <code>componentWillMount</code>在服务器渲染也会被调用到，这样的 IO 操作放在 <code>componentDidMount</code>里面更加适合。</p><p>禁止不能用比劝导开发者不要这样用更好，所以除了 <code>shouldComponentUpdate</code>，其他在 <code>render</code>函数之前的所有函数 <code>componentWillMount</code>、<code>componentWillReceiveProps</code>，<code>componentWillUpdate</code>都被 <code>getDerivedStateFromProps</code>替代。</p><p>就是用一个静态函数 <code>getDerivedStateFromProps</code>来取代被 <code>deprecate</code>的几个生命周期函数，强制开发者在 <code>render</code>之前只做无副作用的操作，而且能做的操作局限在根据 <code>props</code>和 <code>state</code>决定新的 <code>state</code></p><p><a href="https://react.docschina.org/docs/react-component.html?no-cache=1#static-getderivedstatefromprops">官网API-getDerivedStateFromProps()</a></p><p><a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html">关于更多</a></p><p>v16.0 刚推出的时候，增加了一个 <code>componentDidCatch</code> 生命周期函数，新引入的两个生命周期函数:<code>getDerivedStateFromProps</code>和 <code>getSnapshotBeforeUpdate</code></p><ul><li>getDerivedStateFromProps</li></ul><p><code>getDerivedStateFromProps</code>在v.16.3 中只是创建和更新（由父组件引发的）。如果不由父组件引发，这个方法是不会调用的，如自身的 <code>setState</code> 和 <code>forceUpate</code>引发的。</p><p>在 v.16.4  中改正了这一点，让 <code>getDerivedStateFromProps</code> 无论是 <code>Mounting</code> 还是 <code>Updating</code>,也无论是因为什么引起的 <code>Updating</code>全部都会被调用。</p><p><em>static getDerivedStateFromProps(props,state)</em>在组件创建时和更新时的 <code>render</code>方法之前调用，它应该返回一个对象来更新状态，或者返回 null 来不更新任何内容</p><ul><li>getSnapshotBeforeUpadate</li></ul><p><code>getSnapshotBeforeUpdate</code>被调用于 <code>render</code> 之后，可以读取但是无法使用 DOM 的时候。它使得组件可以在可能更改之前从 DOM 中捕获一些信息（例如滚动位置）。这个生命周期返回的任何值都将作为参数传递给 <code>componentDidUpdate</code></p><p>官网的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.listRef = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line">    getSnapshotBeforeUpdate(nextProps,prevState)&#123;</span><br><span class="line">        <span class="comment">// 我们是否要添加新的 items 到列表中，捕获滚动位置以便我们可以稍后整理滚动</span></span><br><span class="line">        <span class="keyword">if</span>(prevProps.list.length &lt; <span class="keyword">this</span>.props.list.length)&#123;</span><br><span class="line">            <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">            <span class="keyword">return</span> list.scrollHeight - list.scrollTop</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidUpdate(prevProps,prevState,snapshot)&#123;</span><br><span class="line">        <span class="comment">// 如果我们有 snapshot 值，我们已经添加新的 items，调整滚动以至于这些新的 items，不会将就的 items 推出视图。</span></span><br><span class="line">        <span class="keyword">if</span>(snapshot)&#123;</span><br><span class="line">            <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">            list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div ref=&#123;<span class="keyword">this</span>.listRef&#125;&gt;&#123;<span class="comment">/* ...contents */</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>另外可以看看这篇文章，<a href="https://www.imooc.com/article/39395">你可能不需要派生状态</a></p><h3 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h3><p>官方的解释:</p><p><strong>React Fiber 是对核心算法的一次重新实现</strong></p><h4 id="同步更新过程的局限"><a href="#同步更新过程的局限" class="headerlink" title="同步更新过程的局限"></a><strong>同步更新过程的局限</strong></h4><p>v16 之前，更新过程是同步的，这可能会导致性能问题。</p><p>React 决定要加载或者更新组件树的时候，会做很多事情，比如调用各个组件的生命周期函数，计算和对比 Virtual DOM ,最后更新 DOM 树，这整个过程是同步进行的，也就是说只要一个加载或者更新过程开始，那么 React 就会一直更新下去，中途不会停歇。</p><p>表面看，这样的设计也是合理的，更新过程中不会有 I/O 操作，完全是 CPU 计算，所以不需异步操作。但是当组件书比较庞大的时候，问题就来了。</p><p>例如更新一个组件需要1毫秒，如果有200个组件需要更新，那就有200毫秒。用户在 input 按钮输入一个子，要等待200毫秒才会有反应，造成界面卡顿，带来不好的用户体验。</p><p>另外一个生动的比较就是潜水员的比喻，潜水员进行潜水任务，在潜到底的过程中，如果岸上有更加优先的任务他是不知道的，只有当他重新浮出水面才能去执行优先级更高的任务。</p><p>因为 javascript 单线程的特点，每个同步任务的耗时不能太长，不然就会让程序不会对其他输入做出反应，React 的更新就是犯了这个禁止，而 React Fiber 是要改变现状。</p><h4 id="React-Fiber-1"><a href="#React-Fiber-1" class="headerlink" title="React Fiber"></a>React Fiber</h4><p>分片是破解 Javascript 同步操作时间过长的方法。</p><p>把一个耗时长的任务分成很多小片，每一个小片的运行时间都很短，虽然总时间依然很长，但是在每个小片执行之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的时间。</p><p>React Fiber 把更新过程碎片化，每执行一段更新过程，就把控制权交还给 React 负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。</p><p>维护每一个分片的数据结构，就是 Fiber</p><h4 id="为什么叫-Fiber"><a href="#为什么叫-Fiber" class="headerlink" title="为什么叫 Fiber"></a>为什么叫 Fiber</h4><p>在计算机科学中，Fiber 的含义是 “纤维”，意指比 Thread(线程) 更细的线，也就是比线程控制更精密的并发处理机制。</p><h4 id="React-Fiber-对现有代码的影响"><a href="#React-Fiber-对现有代码的影响" class="headerlink" title="React Fiber 对现有代码的影响"></a>React Fiber 对现有代码的影响</h4><p>在 React Fiber 中，一次更新过程会分成多个分片完成，所以完全可能一个更新任务还没有完成，会被另一个更高优先级的更新过程打断，这时候，<strong>优先级的更新任务会优先处理完，而低优先级更新任务所做的工作则会完全作废，然后等待机会重头再来。</strong></p><p>因为一个更新过程可能会被打断，所以 React Fiber 更新过程会被分成两个阶段（Phase）：第一个阶段 Reconciliation 和 第二个阶段 Commit Phase.</p><p>在第一个阶段中，React Fiber 会找出需要更新哪些 DOM,这个阶段可以被打断，但是到了第二个阶段，那就是一鼓作气把 DOM 更新完成，不会被打断。</p><p>这两个阶段大部分工作是结合 React Fiber 和 生命周期函数。</p><p>以 <code>render</code> 为界，第一个阶段可能会调用下面这些生命周期函数：</p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li></ul><p>下面这些生命周期函数则会在第二个阶段调用</p><ul><li>componentDidMount</li><li>componentDidUpdate</li><li>componentWillUnmount</li></ul><p>因为第一个阶段会被打断，重新再来，会造成意想不到的情况。</p><p>比如说，一个低优先级的任务 A 正在执行，已经调用了某个组件的 <code>componentWillUpdate</code>函数，接下来发现自己的时间分片已经用完了，于是冒出水面，看看有没有紧急任务，发现有个紧急任务B，接下来 React Fiber 就去执行这个紧急任务B。任务A 虽然执行了一半，但是没有办法，只能完全放弃，等到任务B 完成后，任务 A 重头来一遍，也就是说 <code>componentWillUpdate</code>函数会被再重新调用一次。</p><p>在现有的 React 中，每个生命周期函数在一个加载或者更新过程中决定只会被调用一次，在 React Fiber 中，不再是这样了，第一阶段的声生命周期函数在一次加载和更新过程中可能会被多次调用。</p><p>使用 React Fiber 之后，一定要检查一下第一阶段相关的这些生命周期函数，看看有没有逻辑是假设在一个更新过程中只调用一次的，有的话就要改了。</p><p>看看可能会重复调用的函数</p><p><code>componentWillReceiveProps</code>即使当前组件不更新，只要父组件更新也会引起和这个函数被调用多次，调用多次无妨</p><p><code>shouldComponentUpdate</code>这个函数的作用是返回一个 true 或者 false，不应该有任何副作用，调用多次无妨</p><p><code>render</code> 是纯函数，调用多次无妨</p><p>剩下 <code>componentWillMount</code> 和 <code>componentWillUpdate</code>这两个函数往往包含副作用，所以当使用 React Fiber 的时候一定要重点看这两个函数的实现。</p><h3 id="this-setState-异步原因以及更新机制"><a href="#this-setState-异步原因以及更新机制" class="headerlink" title="this.setState 异步原因以及更新机制"></a>this.setState 异步原因以及更新机制</h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a><strong>现象</strong></h4><p>在 React 中，如果是由 React 引发的事件处理（比如通过 onClick 引发的合成事件处理）和组件生命周期函数内（比如 <code>componentDidMount</code>），调用 <code>this.setState</code> 不会同步更新 <code>this.state</code>，除此之外的 <code>setState</code> 调用会同步执行 <code>this.state</code>。除此之外指的是绕过 React 通过 <code>addEventListener</code> 直接添加的事件处理函数，还有通过 <code>setTimeout</code>/<code>setInterval</code> 产生的异步调用。另外在合成事件和生命周期函数中的异步调用 <code>setState</code>（比如 <code>ajax</code> 和 <code>setTimeout</code>） 也是会同步更新 <code>this.setState</code></p><h4 id="保证内部（数据）的统一"><a href="#保证内部（数据）的统一" class="headerlink" title="保证内部（数据）的统一"></a>保证内部（数据）的统一</h4><p>假设 setState 是同步的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value); <span class="comment">//0</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>:<span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value); <span class="comment">//1</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>:<span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value); <span class="comment">//2</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>:<span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>这种只用到了 state 的情况下，同步 setState 是可以的。</p><p>然而这时需要将状态提升到父组件，以供多个兄弟组件共享：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.props.value) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">this</span>.props.onIncrement();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.props.value) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">this</span>.props.onIncrement();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.props.value) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">this</span>.props.onIncrement();</span><br></pre></td></tr></table></figure><p>在同步模型中，虽然 this.state 会立即更新，但是 this.props 并不会。而且在没有重渲染父组件的情况下，我们不能立即更新 this.props。如果要立即更新 this.props(立即重新渲染父组件)，必须放弃批处理（根据不同的情况，性能可能有显著下降）</p><p>所以为了解决这样的问题，在 React 中，this.state 和 this.props 都是异步更新的，在上面的例子中重构前后都会打印出0，这让状态提升更加安全。</p><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>我们通常认为状态更新会按照既定顺序被应用，无论 state 是同步更新还是异步更新，然而事实并不一定如此。</p><p>React 会依据不同的调用源，给不同的 setState 调用分配不同的优先级。调用源包括事件处理、网络请求、动画等。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用法1</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;&#125;,()=&gt;&#123;&#125;)</span><br><span class="line"><span class="comment">// 用法2</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">()</span>=(<span class="params">&#123;&#125;</span>),<span class="params">()</span>=&gt;</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1：对象，key是 this.state 中key值，val 是修改后的值</span></span><br><span class="line"><span class="comment">// 参数2：函数，可查看数据是否更新完成，获取到数据更新后的最新 dom 结构</span></span><br></pre></td></tr></table></figure><p><strong>不要直接修改 state</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state.comment = <span class="string">'Hello'</span> (X)</span><br></pre></td></tr></table></figure><p><strong>state  更新可能会异步</strong></p><p>从上面也知道了，React 为了性能优化，有可能会将多个 setState 调用合并为一次更新，因为 this.props 与 this.state  可能是异步更新的，你不可能依赖他们的值进行下一个 state 的计算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">counter</span>:<span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment&#125;) (X)</span><br></pre></td></tr></table></figure><p>为了弥补这个问题，使用了另一种 setState 形式，接受一个函数。这个函数接收前一个状态作为第一个参数，应用更新时的 props 作为第二个参数，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState,props</span>)=&gt;</span>&#123;</span><br><span class="line">    counter:prevState.counter + props.increment</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>多次setState函数调用产生的效果会合并</strong></p><p>当调用 setState ,React 会合并你提供的对象到当前的状态。所以当 state 是一个多键值的结构，可以单独更新其中一个，此时会 差分 更新，不会影响到其他的属性值</p><p>总结起来就是：</p><ol><li>setState 不会立刻改变 React 组件中的 state</li><li>setState 通过触发一次组件的更新来引发重绘</li><li>多次 setState 函数嗲用产生的效果会合并</li></ol><p>重绘指的更新的生命周期函数：</p><ul><li><code>shouldComponentUpdate</code>:被调用时 this.state 没有更新，如果返回 false，生命周期被中断，虽然不调用之后的函数，但是 state 仍然会被更新</li><li><code>componentWillUpdate</code>：被调用时 this.state 没有更新</li><li><code>render</code>：被调用时 this.state 得到更新</li><li><code>componentDidUpdate</code></li></ul><p>React会将setState的效果放在队列中，积攒着一次引发更新过程。为的就是把Virtual DOM和DOM树操作降到最小，用于提高性能。</p><p><strong>执行setState 后拿到最新的 state</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">updateData = <span class="function">(<span class="params">newData</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(</span><br><span class="line">        &#123;<span class="attr">data</span>:newData&#125;,</span><br><span class="line">        () =&gt;&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.data)</span><br><span class="line">        &#125; </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="setState-更新机制"><a href="#setState-更新机制" class="headerlink" title="setState 更新机制"></a>setState 更新机制</h4><p><strong>循环调用风险</strong></p><p>不要在 <code>shouldComponentUpdate</code>和 <code>componentWillUpdate</code>中调用 <code>setState</code>，不然会出现死循环</p><p>在调用 <code>setState</code>时候实际上会执行 <code>enqueueSetState</code>方法，并对 <code>partialState</code>、<code>pendingStateQueue</code>更新队列进行合并操作，最终通过 <code>enqueueUpdate</code>执行 state 更新。</p><p>而 <code>performUpdateIfNecessary</code>方法会获取 <code>pendingElement</code>、<code>pendingStateQueue</code>、<code>pendingForceUpdate</code>并调用 <code>receiveComponent</code>和 <code>updateComponent</code>方法进行组件更新</p><p>如果在 <code>componentWillUpdate</code> 和 <code>shouldComponentUpdate</code> 中调用 <code>setState</code>，此时 <code>pendingStateQueue !== null</code>则 <code>performUpdateIfNessary</code> 会调用 <code>updateComponent</code> 进行组件更新，而 <code>updateComponent</code>又会调用 <code>shouldComponentUpdate</code> 和 <code>componentWillUpdate</code>这样就导致了循环调用</p><p>setState 源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React 组件继承自 React.Component，而 SetState 是 React.Component 的方法，对于组件来说，setState 属于其原型方法</span></span><br><span class="line"><span class="comment">// 在 React 中每个组件都拥有一个 this.updater，是用来驱动 state 更新的工具对象。当我们在构造函数中调用 super 的时实质调用的就是函数 ReactComponent</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactComponent</span>(<span class="params">props,context,updater</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">    <span class="keyword">this</span>.context = context;</span><br><span class="line">    <span class="keyword">this</span>.refs = emptyObject;</span><br><span class="line">    <span class="comment">// ReactNoopUpdateQueue 实际是没有什么意义的，只相当于是一个初始化的过程。而 ReactNoopUpdateQueue.enqueueSetState 主要起到一个在非生产版本中警告的作用。真正的 updater 是在 renderer 中注入（inject）。因此如果在 constructor 尝试调用 this.helper.isMount会返回 false，表示并没有安装（mount），如果你调用 setState，也会给出响应的警告</span></span><br><span class="line">    <span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line">ReactComponent.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">partialState,callback</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 调用 enqueueSetState 将 setState 事务放进队列中</span></span><br><span class="line">    <span class="comment">// partialState 可以传 Object,也可以传 function,会产生新的 state 以一种 Object.assign() 的方式跟旧的 state 进行合并</span></span><br><span class="line">    <span class="comment">// 参数 this 是组件的实例</span></span><br><span class="line">    <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>,partialState);</span><br><span class="line">    <span class="keyword">if</span>(callback)&#123;</span><br><span class="line">        <span class="keyword">this</span>.updater.enqueueCallback(<span class="keyword">this</span>,callback,<span class="string">'setState'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ReactUpdateQueue = &#123;</span><br><span class="line">    <span class="comment">// 实际通过 enqueueSetState 执行</span></span><br><span class="line">    <span class="comment">// 1.将新的 state 放进数组</span></span><br><span class="line">    <span class="comment">// 2.用 enqueueUpdate 来处理将要更新的实例对象</span></span><br><span class="line">    enqueueSetState：<span class="function"><span class="keyword">function</span>(<span class="params">publicInstance,partialState</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前组件的 instance，里面有很多属性，主要关注 pendingState(待更新队列)，pendingCallbacks(更新回调队列)</span></span><br><span class="line">        <span class="keyword">const</span> internalInstance = getInernalInstanceReadyForUpdate(</span><br><span class="line">            publickInstance,</span><br><span class="line">            <span class="string">'setState'</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span>(!inernalInstance) <span class="keyword">return</span></span><br><span class="line">        <span class="comment">// 更新队列合并操作</span></span><br><span class="line">        <span class="keyword">const</span> queue = internalInstance._pendingStateQueue || （internalInstance._pendingStateQueue = []）</span><br><span class="line">        <span class="comment">// partialState 可以理解为之前的 state</span></span><br><span class="line">        queue.push(partialState)</span><br><span class="line">        <span class="comment">// 最终通过 enqueueUpdate 更新，将新的 component instance 放入一个队列</span></span><br><span class="line">        enqueueUpdate(internalInstance)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在 _pendingElement、_pendingStateQueue 和 _pendingForceUpdate 则更新组件</span></span><br><span class="line">    performUpdateIfNessary:<span class="function"><span class="keyword">function</span>(<span class="params">transaction</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>._pendingElement != <span class="literal">null</span>)&#123;        ReactReconciler.receiveComponent(<span class="keyword">this</span>,<span class="keyword">this</span>._pendingElement,transaction,<span class="keyword">this</span>._context)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>._pendingStateQueue !== <span class="literal">null</span> || <span class="keyword">this</span>._pendingForceUpdate)&#123;        <span class="keyword">this</span>.updateComponent(transaction,<span class="keyword">this</span>._currentElement,<span class="keyword">this</span>._currentElement,<span class="keyword">this</span>._context)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>setState 调用栈</strong></p><pre class="mermaid">graph TDA[this.setState]B[newState存入pending队列]C{是否处于 batch update}D(保存组件在 dirtyComponent中)E(遍历所有的dirtyComponents 调用updateComponent 更新 pending state or props)F[调用enqueueUpdate]A --> BB --> FF --> CC == Y ==> DC == N ==> E</pre><p>React的setState函数实现中，会根据一个变量 <code>isBatchingUpdates</code> 判断是 直接更新 this.state还是 放到队列 中。</p><p><code>isBatchingUpdates</code>默认<code>false</code>，表示setState会同步更新this.state，但是函数<code>batchedUpdates</code>函数会把<code>isBatchingUpdates</code>修改为<code>true</code>。当React在调用事件处理函数之前就会调用<code>batchedUpdates</code>，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">internalInstance</span>)</span>&#123;</span><br><span class="line">    ReactUpdates.enqueueUpdate(internalInstance)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ReactUpdates = &#123;</span><br><span class="line">    enqueueUpdate:<span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">component</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 保证 ReactUpdates.ReactReconcileTransaction 与 batchingStrategy 是存在的，否则给出对应的警告</span></span><br><span class="line">        ensureInjected();</span><br><span class="line">        <span class="comment">// 如果不处于批量更新模式</span></span><br><span class="line">        <span class="keyword">if</span>(!batchingStrategy.isBatchingUpdates)&#123;</span><br><span class="line">            <span class="comment">// 调用事务</span></span><br><span class="line">            batchingStrategy.batchedUpdates(enqueueUpdate,component)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果处于批量更新模式,将组件放入脏组件队列，也就是待更新组件队列</span></span><br><span class="line">        dirtyComponents.psuh(component);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// batchingStrategy。实质上是一种批量更新策略</span></span><br><span class="line"><span class="keyword">const</span> ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">    isBatchingupdates:<span class="literal">false</span>,</span><br><span class="line">    batchedUpdates:<span class="function"><span class="keyword">function</span>(<span class="params">callback,a,b,c,d,e</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates</span><br><span class="line">        ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span>(callback)&#123;</span><br><span class="line">            callback(a,b,c,d,e)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            transaction.perform(callback,<span class="literal">null</span>,a,b,c,d,e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Transaction</strong></p><p>关于 React 中的事务 Transaction,源码中有这样的 ASCII图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *                       wrappers (injected at creation time)</span><br><span class="line"> *                                      +        +</span><br><span class="line"> *                                      |        |</span><br><span class="line"> *                    +-----------------|--------|--------------+</span><br><span class="line"> *                    |                 v        |              |</span><br><span class="line"> *                    |      +---------------+   |              |</span><br><span class="line"> *                    |   +--|    wrapper1   |---|----+         |</span><br><span class="line"> *                    |   |  +---------------+   v    |         |</span><br><span class="line"> *                    |   |          +-------------+  |         |</span><br><span class="line"> *                    |   |     +----|   wrapper2  |--------+   |</span><br><span class="line"> *                    |   |     |    +-------------+  |     |   |</span><br><span class="line"> *                    |   |     |                     |     |   |</span><br><span class="line"> *                    |   v     v                     v     v   | wrapper</span><br><span class="line"> *                    | +---+ +---+   +---------+   +---+ +---+ | invariants</span><br><span class="line"> * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained</span><br><span class="line"> * +-----------------&gt;|-|---|-|---|--&gt;|anyMethod|---|---|-|---|-|--------&gt;</span><br><span class="line"> *                    | |   | |   |   |         |   |   | |   | |</span><br><span class="line"> *                    | |   | |   |   |         |   |   | |   | |</span><br><span class="line"> *                    | |   | |   |   |         |   |   | |   | |</span><br><span class="line"> *                    | +---+ +---+   +---------+   +---+ +---+ |</span><br><span class="line"> *                    |  initialize                    close    |</span><br><span class="line"> *                    +-----------------------------------------+</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>React 中的事务 Transaction，会给方法包装一个个 wrapper，其中每个 wrapper 都有两个方法：initialize 与 close。当执行方法时，需要执行事务的 perform 方法。这个方法会首先一次执行 wrapper 的 initialize,然后执行函数本身，最后执行 wrapper 的 close 方法</p><p>定义 Transaction 需要给构造函数混入 Transaction.Mixin，并需要提供一个原型方法 getTransactionWrappers 用于返回 wrapper 数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> RESET_BATCHED_UPDATES = &#123;</span><br><span class="line">    initialize:emptyFuntion,</span><br><span class="line">    colse:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 重置为 false</span></span><br><span class="line">        ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> FLUSH_BATCHED_UPPDATES = &#123;</span><br><span class="line">    initialize:emptyFunction,</span><br><span class="line">    close:ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES,RESET_BATCHED_UPDATES]；</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactDefaultBatchingStrategyTransaction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reinitializeTransaction();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(</span><br><span class="line">    ReactDefaultBatchingStrategyTransaction.prototype,</span><br><span class="line">    Transaction.Mixin,&#123;</span><br><span class="line">        getTransactionWrappers:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> TRANSACTION_WRAPPERS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> transaction = <span class="keyword">new</span> ReactDefaultBatchingStrategyTransaction();</span><br></pre></td></tr></table></figure><p>重新回顾一下更新的过程，如果处于批量更新的过程中（<code>isBatchingUpdates</code>为 true）的时候，则直接将组件传入 <code>dirtyComponents</code>。如果不是的话，就开启批量更新，用事务 <code>transaction.perform</code>执行 <code>enqueueUpdate</code>，这时候 <code>isBatchingUpdates</code>经过上次执行已经是 true，将直接传入 <code>dirtyComponents</code>。那么更新的组件传入 <code>dirtyComponent</code>会发生什么？</p><p><code>batchUpdates</code>是处于一个事务中的，该事务在 close 阶段做了两件事，首先是将 <code>ReactDefaultBatchingStrategy.isBatchingUpdates</code>设置为 false，即关闭批量更新的标志位，第二个就是调用方法 <code>ReactUpdates.flushBatchedUpdates</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码有省略</span></span><br><span class="line"><span class="keyword">var</span> flushBatchedUpdates = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(dirtyComponents.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dirtyComponents.length)&#123;</span><br><span class="line">            <span class="keyword">var</span> transaction = ReactUpdatesFlushTransaction.getPooled();</span><br><span class="line">            <span class="comment">// 以事务的方式执行了 runBatchedUpdates             </span></span><br><span class="line">            transaction.perform(runBatchedUpdates,<span class="literal">null</span>,transaction);</span><br><span class="line">            ReactUpdatesFlushTransaction.release(transaction)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runBatchedUpdates</span>(<span class="params">transaction</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = transactiono.dirtyComponentsLength;</span><br><span class="line">    <span class="comment">// 将组件中的 mountOrder 进行了递增排序，目的就是保证更新顺序，父组件保证其子组件之前更新。</span></span><br><span class="line">    dirtyComponents.sort(mountOrderComparator);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="comment">// 在组件中获得 setState 完成之后的回调函数</span></span><br><span class="line">        <span class="keyword">var</span> component = dirtyComponents[i];</span><br><span class="line">        <span class="keyword">var</span> callbacks = component._pendingCallbacks;</span><br><span class="line">        component._pendingCallbacks = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        ReactReconciler.performUpdateIfNessary(component,transaction.reconcileTransaction)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span>(callbacks)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;callbacks.length;j++)&#123;</span><br><span class="line">                transaction.callbackQueue.enqueue(</span><br><span class="line">                callbacks[j],</span><br><span class="line">                component.getPublickInstance()</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// performUpdateIfNessary 执行组件实例的原型方法performUpdateIfNecessary</span></span><br><span class="line">performUpdateIfNessary:<span class="function"><span class="keyword">function</span>(<span class="params">internalInstance,transaction</span>)</span>&#123;</span><br><span class="line">    interbalInstance.performUpdateIfNecessary(transaction)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略版本</span></span><br><span class="line"><span class="keyword">var</span> ReactCompositeComponentMixin = &#123;</span><br><span class="line">    performUpdateIfNecessary:<span class="function"><span class="keyword">function</span>(<span class="params">transaction</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>._pendingStateQueue !==<span class="literal">null</span> || <span class="keyword">this</span>._pendingForceUpdate)&#123;</span><br><span class="line">            <span class="keyword">this</span>.updateComponent(</span><br><span class="line">                transaction,</span><br><span class="line">                <span class="keyword">this</span>._currentElement,</span><br><span class="line">                <span class="keyword">this</span>._currentElement,</span><br><span class="line">                <span class="keyword">this</span>._context,</span><br><span class="line">                <span class="keyword">this</span>._context</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updateComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">    prevParentElement,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextParentElement,</span></span></span><br><span class="line"><span class="function"><span class="params">    prevUnmaskedContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextUnmaskedContext</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance;</span><br><span class="line">    <span class="keyword">var</span> willReceive = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> nextContext;</span><br><span class="line">    <span class="keyword">var</span> nextProps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证组件context是否改变</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证是否是props更新还是组件state更新</span></span><br><span class="line">    <span class="keyword">if</span> (prevParentElement === nextParentElement) &#123;</span><br><span class="line">      nextProps = nextParentElement.props;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//存在props的更新  </span></span><br><span class="line">      nextProps = <span class="keyword">this</span>._processProps(nextParentElement.props);</span><br><span class="line">      willReceive = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据条件判断是否调用钩子函数componentWillReceiveProps</span></span><br><span class="line">    <span class="keyword">if</span> (willReceive &amp;&amp; inst.componentWillReceiveProps) &#123;</span><br><span class="line">      inst.componentWillReceiveProps(nextProps, nextContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算新的state</span></span><br><span class="line">    <span class="keyword">var</span> nextState = <span class="keyword">this</span>._processPendingState(nextProps, nextContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shouldUpdate =</span><br><span class="line">      <span class="keyword">this</span>._pendingForceUpdate ||</span><br><span class="line">      !inst.shouldComponentUpdate ||</span><br><span class="line">      inst.shouldComponentUpdate(nextProps, nextState, nextContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldUpdate) &#123;</span><br><span class="line">      <span class="keyword">this</span>._pendingForceUpdate = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">this</span>._performComponentUpdate(</span><br><span class="line">        nextParentElement,</span><br><span class="line">        nextProps,</span><br><span class="line">        nextState,</span><br><span class="line">        nextContext,</span><br><span class="line">        transaction,</span><br><span class="line">        nextUnmaskedContext</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._currentElement = nextParentElement;</span><br><span class="line">      <span class="keyword">this</span>._context = nextUnmaskedContext;</span><br><span class="line">      inst.props = nextProps;</span><br><span class="line">      inst.state = nextState;</span><br><span class="line">      inst.context = nextContext;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 计算新的 state 里面调用了 _processPending</span></span><br><span class="line">&#123;</span><br><span class="line">  _processPendingState: <span class="function"><span class="keyword">function</span>(<span class="params">props, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance;</span><br><span class="line">    <span class="keyword">var</span> queue = <span class="keyword">this</span>._pendingStateQueue;</span><br><span class="line">    <span class="keyword">var</span> replace = <span class="keyword">this</span>._pendingReplaceState;</span><br><span class="line">    <span class="keyword">this</span>._pendingReplaceState = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>._pendingStateQueue = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!queue) &#123;</span><br><span class="line">      <span class="keyword">return</span> inst.state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replace &amp;&amp; queue.length === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> queue[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> nextState = <span class="built_in">Object</span>.assign(&#123;&#125;, replace ? queue[<span class="number">0</span>] : inst.state);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = replace ? <span class="number">1</span> : <span class="number">0</span>; i &lt; queue.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> partial = queue[i];</span><br><span class="line">      <span class="built_in">Object</span>.assign(</span><br><span class="line">        nextState,</span><br><span class="line">        <span class="keyword">typeof</span> partial === <span class="string">'function'</span> ?</span><br><span class="line">          partial.call(inst, nextState, props, context) :</span><br><span class="line">          partial</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nextState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一部分代码相对来说不算是很难，<code>replace</code>是存在是由于之前被废弃的API<code>this.replaceState</code>，我们现在不需要关心这一部分，现在我们可以知道为什么给 <code>setState</code> 传入的参数是函数时，就可以解决 <code>setState</code> 的潜在问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>:<span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>:<span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>调用 <code>setState</code>是批量更新，那么在第一次调用之后，this.state.value的值并没有发生拜年话。两次更新的指都是一样的。如果传递的是会调用函数形式，那么 <code>partial.call(inst,nextState,props,context)</code>接受的 state 都是上一轮更新之后的新值，因此可以达到我们想要的结果。</p><p><code>_processPendingState</code> 在计算完新的 state 之后会执行 <code>_performComponentUpdate</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_performComponentUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    nextElement,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextProps,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextState,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">    unmaskedContext</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hasComponentDidUpdate = <span class="built_in">Boolean</span>(inst.componentDidUpdate);</span><br><span class="line">    <span class="keyword">var</span> prevProps;</span><br><span class="line">    <span class="keyword">var</span> prevState;</span><br><span class="line">    <span class="keyword">var</span> prevContext;</span><br><span class="line">    <span class="keyword">if</span> (hasComponentDidUpdate) &#123;</span><br><span class="line">      prevProps = inst.props;</span><br><span class="line">      prevState = inst.state;</span><br><span class="line">      prevContext = inst.context;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  在更新之前，调用钩子函数 componentWillUpdate，然后更新了属性（props,state,context）</span></span><br><span class="line">    <span class="keyword">if</span> (inst.componentWillUpdate) &#123;</span><br><span class="line">      inst.componentWillUpdate(nextProps, nextState, nextContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._currentElement = nextElement;</span><br><span class="line">    <span class="keyword">this</span>._context = unmaskedContext;</span><br><span class="line">    inst.props = nextProps;</span><br><span class="line">    inst.state = nextState;</span><br><span class="line">    inst.context = nextContext;</span><br><span class="line"><span class="comment">// 执行函数_updateRenderedComponent，涉及到 render 调用和相应的 DOM 更新</span></span><br><span class="line">    <span class="keyword">this</span>._updateRenderedComponent(transaction, unmaskedContext);</span><br><span class="line"><span class="comment">// 最后执行 componentDidUpdate</span></span><br><span class="line">    <span class="keyword">if</span> (hasComponentDidUpdate) &#123;</span><br><span class="line">      transaction.getReactMountReady().enqueue(</span><br><span class="line">        inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext),</span><br><span class="line">        inst</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止，我们已经基本介绍完了setState的更新过程，只剩一个部分没有介绍，那就是setState执行结束之后的回调函数。我们知道，setState函数中如果存在callback，则会有:　　</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (callback) &#123;</span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueCallback(<span class="keyword">this</span>, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　call函数会被传递给<code>this.updater</code>的函数<code>enqueueCallback</code>，然后非常类似于setState，<code>callback</code>会存储在组件内部实例中的<code>_pendingCallbacks</code>属性之中。我们知道，回调函数必须要setState真正完成之后才会调用，那么在代码中是怎么实现的。大家还记得在函数<code>flushBatchedUpdates</code>中有一个事务<code>ReactUpdatesFlushTransaction</code>:　　</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码有省略</span></span><br><span class="line"><span class="keyword">var</span> flushBatchedUpdates = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (dirtyComponents.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dirtyComponents.length) &#123;</span><br><span class="line">      <span class="comment">//从事务pool中获得事务实例</span></span><br><span class="line">      <span class="keyword">var</span> transaction = ReactUpdatesFlushTransaction.getPooled();</span><br><span class="line">      transaction.perform(runBatchedUpdates, <span class="literal">null</span>, transaction);</span><br><span class="line">      <span class="comment">//释放实例</span></span><br><span class="line">      ReactUpdatesFlushTransaction.release(transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　我们现在看看<code>ReactUpdatesFlushTransaction</code>的wrapper是怎么定义的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> UPDATE_QUEUEING = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackQueue.reset();</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackQueue.notifyAll();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　我们看到在事务的<code>close</code>阶段定义了<code>this.callbackQueue.notifyAll()</code>,即执行了回调函数，通过这种方法就能保证回调函数一定是在setState真正完成之后才执行的。</p><p>现在可以回答，为什么下面这两种改代码会产生不同的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未按预期执行</span></span><br><span class="line">_addValue() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        value: <span class="keyword">this</span>.state.value + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        value: <span class="keyword">this</span>.state.value + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按预期执行</span></span><br><span class="line">_addValue() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            value: <span class="keyword">this</span>.state.value + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            value: <span class="keyword">this</span>.state.value + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一种情况下，如果打断点追踪你会发现，在第一次执行<code>setState</code>前，已经触发了一个 <code>batchedUpdates</code>，等到执行setState时已经处于一个较大的事务，因此两个setState都是会被批量更新的(相当于异步更新的过程，this.state.value值并没有立即改变)，执行setState只不过是将两者的<code>partialState</code>传入<code>dirtyComponents</code>，最后再通过事务的<code>close</code>阶段的<code>flushBatchedUpdates</code>方法去执行重新渲染。但是通过<code>setTimeout</code>函数的包装，两次setState都会在click触发的批量更新<code>batchedUpdates</code>结束之后执行，这两次setState会触发<strong>两次</strong>批量更新batchedUpdates，当然也会执行两个事务以及函数<code>flushBatchedUpdates</code>,这就相当于一个同步更新的过程，自然可以达到我们的目的，这也就解释了为什么React文档中既没有说setState是同步更新或者是异步更新，只是模糊地说到，setState并不保证同步更新。</p><h4 id="DOM事件和生命周期"><a href="#DOM事件和生命周期" class="headerlink" title="DOM事件和生命周期"></a>DOM事件和生命周期</h4><pre class="mermaid">graph TDA(DOM)B(生命周期)C[dispatchEvent-ReactEventListener.js]D[_renderNewRootComponent-ReactMount.js]E[ReactUpdates.batchedUpdates-ReactUpdates.js]F[isBatchingUpdates=true]G[transaction.perform 执行事件回调和生命周期进入事务]H[close isBatchingUpdates=false ReactUpdates.flushBatchedUpdates]I[检查 dirtyComponents 完成更新]A == type:'click' ==> CB == componentDidMount ==> DC --> ED --> EE --> FF --> GG --> HH --> I</pre><h3 id="React合成事件"><a href="#React合成事件" class="headerlink" title="React合成事件"></a>React合成事件</h3><h3 id="HOC-的应用"><a href="#HOC-的应用" class="headerlink" title="HOC 的应用"></a>HOC 的应用</h3><p>### </p><h3 id="中间件应用"><a href="#中间件应用" class="headerlink" title="中间件应用"></a>中间件应用</h3><h3 id="Redux-的应用和原理"><a href="#Redux-的应用和原理" class="headerlink" title="Redux 的应用和原理"></a>Redux 的应用和原理</h3><h3 id="Mobx-的应用和原理"><a href="#Mobx-的应用和原理" class="headerlink" title="Mobx 的应用和原理"></a>Mobx 的应用和原理</h3><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ol><li><a href="https://segmentfault.com/a/1190000010522782">React 渲染机制解析</a></li><li><a href="https://www.jianshu.com/p/3ba0822018cf">React之diff算法</a></li><li><a href="https://www.runoob.com/react/react-jsx.html">React JSX</a></li><li><a href="http://huziketang.mangojuice.top/books/react/lesson6">使用 JSX 描述 UI 信息</a></li><li><a href="https://zhuanlan.zhihu.com/p/26027085">React Fiber 是什么？</a></li><li><a href="https://www.jianshu.com/p/cc12e9a8052c">为什么setState是异步的</a></li><li><a href="https://www.imooc.com/article/23912?block_id=tuijian_wz">React 中 setState() 为什么是异步的？</a></li><li><a href="https://www.cnblogs.com/t-sun-j/p/10300825.html">this.setState使用时的一些坑</a></li><li><a href="https://segmentfault.com/a/1190000015463599">React setState 简单整理总结</a></li><li><a href="https://segmentfault.com/a/1190000018615027">日常抄书之一次性弄懂setState</a></li><li><a href="https://segmentfault.com/a/1190000018499749">一次性搞懂解React生命周期</a></li><li><a href="https://segmentfault.com/a/1190000010785692">React技术内幕:setState的秘密</a></li><li><a href="https://segmentfault.com/a/1190000015821018">浅入深出setState（下篇）</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;温故而知新，保持空杯心态&lt;/p&gt;
&lt;h2 id=&quot;React-基础&quot;&gt;&lt;a href=&quot;#React-基础&quot; class=&quot;headerlink&quot; title=&quot;React  基础&quot;&gt;&lt;/a&gt;React  基础&lt;/h2&gt;&lt;h3 id=&quot;什么是-React&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="前端面试" scheme="http://laibh.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端面试题" scheme="http://laibh.top/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>React-SSR浅析</title>
    <link href="http://laibh.top/2019-05-11-React-SSR%E6%B5%85%E6%9E%90.html"/>
    <id>http://laibh.top/2019-05-11-React-SSR浅析.html</id>
    <published>2019-05-11T08:30:00.000Z</published>
    <updated>2020-07-11T03:24:57.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-SSR-同构浅析"><a href="#React-SSR-同构浅析" class="headerlink" title="React SSR 同构浅析"></a>React SSR 同构浅析</h2><h2 id="客户端渲染（CSR）"><a href="#客户端渲染（CSR）" class="headerlink" title="客户端渲染（CSR）"></a>客户端渲染（CSR）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>传统 react项目,在浏览器打开项目，查看源代码，可以看到 index.js 页面里面只有一个基本的 DOM 节点，下面引入了一个 js 文件。而项目的所有内容就是通过这个 js 来渲染，通过禁止浏览器的 javascript 功能可以看到浏览器提示要 开启 javascript 功能的提示，没有项目的内容生成。</p><p>CSR 过程:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览器发送请求 =&gt; 服务器返回HTML =&gt; 浏览器发送 bundle.js 请求 =&gt; 服务器返回 bundle.js =&gt; 浏览器运行 React 代码 =&gt; 页面准备就绪</span><br></pre></td></tr></table></figure><h3 id="优势与劣势"><a href="#优势与劣势" class="headerlink" title="优势与劣势"></a>优势与劣势</h3><p>优势：前后端分离，前端 ajax 请求数据，后端内部处理好逻辑返回 JSON 给前端处理。代码在客户端运行，性能良好</p><p>劣势：首屏加载速度慢。SEO 差（百度爬虫不能识别 js 文件）</p><h2 id="服务器渲染（SSR）"><a href="#服务器渲染（SSR）" class="headerlink" title="服务器渲染（SSR）"></a>服务器渲染（SSR）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>SSR 过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览器发送请求 =&gt; 服务器运行 React 代码生成页面 =&gt; 服务器返回页面</span><br></pre></td></tr></table></figure><h3 id="优势与劣势-1"><a href="#优势与劣势-1" class="headerlink" title="优势与劣势"></a>优势与劣势</h3><p>优势：首屏速度快</p><p>劣势：服务器性能需求大</p><h3 id="renderToString"><a href="#renderToString" class="headerlink" title="renderToString"></a>renderToString</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;renderToString&#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</span><br><span class="line"><span class="keyword">const</span> content = renderToString((</span><br><span class="line">    <span class="comment">// 组件</span></span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    res.send(</span><br><span class="line">        <span class="string">`&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;div&gt;<span class="subst">$&#123;content&#125;</span>&lt;/div&gt;</span></span><br><span class="line"><span class="string"> &lt;/html&gt;`</span></span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="路由-React-router-config"><a href="#路由-React-router-config" class="headerlink" title="路由 React-router-config"></a>路由 React-router-config</h2><p>可识别嵌套路由，内置 ssr 方案</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>服务器上呈现的路由都是无状态的，所以我们将应用程序包装在无状态的 <code>&lt;StaticRouter&gt;</code> e而不是<code>&lt;BrowserRouter&gt;</code>。从服务器传入请求的路由，以便路由可以匹配。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line">&lt;BroswerRouter&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">&lt;<span class="regexp">/BroswerRouter&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ server </span></span><br><span class="line"><span class="regexp">&lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt;</span></span><br><span class="line"><span class="regexp">    &lt;App /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/StaticRouter&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>&lt;Redirect&gt;</code>客户端呈现 a 标签的时候，浏览器历史记录会更改状态，我们获得新的屏幕。在静态服务器 换机中，我们无法更改应用程序的状态。我们可以使用 context 来找出需要渲染的结果。我们找到了 context.url 就知道应用是否被重定向了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> context = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> markup = ReactDOMServer.renderToString(</span><br><span class="line">    &lt;StaticRouter location=&#123;req.path&#125; context=&#123;context&#125;&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">if(context.url)&#123;</span></span><br><span class="line"><span class="regexp">    redirect(301,context.url)</span></span><br><span class="line"><span class="regexp">&#125;else&#123;</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="添加应用特定上下文信息"><a href="#添加应用特定上下文信息" class="headerlink" title="添加应用特定上下文信息"></a>添加应用特定上下文信息</h3><p>路由器只会添加 context.url,如果希望重定向 301或者 302 可以在希望呈现的 UI 的某个特定分支发送 404 响应，或者如果未授权则发送 401。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RedirectWithStats</span>(<span class="params">&#123;from,to,status&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;Route render=&#123;(&#123;staticContext&#125;)=&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(staticContext) staticContext.status = status;</span><br><span class="line">                <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">from</span>=<span class="string">&#123;from&#125;</span> <span class="attr">to</span>=<span class="string">&#123;to&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            &#125;&#125; </span></span><br><span class="line"><span class="xml">            /&gt;</span></span><br><span class="line"><span class="xml">    )</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// somewhere in app</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function App()&#123;</span></span><br><span class="line"><span class="xml">return(</span></span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;RedirectWithStatus status=&#123;301&#125; from='/users' to='/profiles' /&gt;</span><br><span class="line">            &lt;RedirectWithStatus status=&#123;302&#125; from='/courses' to='/dashboard' /&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// server</span><br><span class="line">const context = &#123;&#125;;</span><br><span class="line">const markup = ReactDOMServer.renderToString(</span><br><span class="line">    &lt;StaticRouter context=&#123;context&#125;&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;/StaticRouter&gt;</span><br><span class="line">)</span><br><span class="line">if(context.url)&#123;</span><br><span class="line">    redirect(context.status,context.url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="404-401-或者任何其他状态"><a href="#404-401-或者任何其他状态" class="headerlink" title="404,401 或者任何其他状态"></a>404,401 或者任何其他状态</h3><p>跟上面的操作差不多，可以创建一个组件，添加一些上下文并在应用程序中的任何位置呈现它以获取不同的状态码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Status</span>(<span class="params">&#123;code,children&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;Route </span><br><span class="line">            render=&#123;(&#123;staticContext&#125;)=&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(staticContext) staticContext.status = code</span><br><span class="line">                <span class="keyword">return</span> children;</span><br><span class="line">            &#125;&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NotFound</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;Status code=&#123;<span class="number">404</span>&#125;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;Sorry,can<span class="string">'t find that.&lt;/h1&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/Status&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// somewhere else</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;Switch&gt;</span></span><br><span class="line"><span class="string">    &lt;Route path='</span>/about<span class="string">' component=&#123;About&#125; /&gt;</span></span><br><span class="line"><span class="string">    &lt;Route path='</span>/dashboard<span class="string">' component=&#123;Dashboard&#125; /&gt;</span></span><br><span class="line"><span class="string">    &lt;Route component=&#123;NotFound&#125;&gt;</span></span><br><span class="line"><span class="string">&lt;/Switch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>这不是一个真正的应用程序，但是它显示了将所有这些组合在一起所需要的所有常规部分</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="keyword">import</span> &#123;createServer&#125; <span class="keyword">from</span> <span class="string">'http'</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOMServer <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;StaticRouter&#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"></span><br><span class="line">createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> html = ReactDOMServer.renderToString(</span><br><span class="line">        &lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt;</span><br><span class="line">            &lt;App /&gt;</span><br><span class="line">        &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">    if(context.url)&#123;</span></span><br><span class="line"><span class="regexp">        res.writeHead(301,&#123;</span></span><br><span class="line"><span class="regexp">            Location:context.url</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">        res.send()</span></span><br><span class="line"><span class="regexp">    &#125;else&#123;</span></span><br><span class="line"><span class="regexp">        res.write(`&lt;!doctype html&gt;&lt;div id="app"&gt;$&#123;html&#125;&lt;/</span>div&gt;<span class="string">`)</span></span><br><span class="line"><span class="string">        res.send();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;).listen(3000)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// client</span></span><br><span class="line"><span class="string">import ReactDOM from 'react-dom';</span></span><br><span class="line"><span class="string">import &#123;BrowserRouter&#125; from 'react-router-dom';</span></span><br><span class="line"><span class="string">import App from './App';</span></span><br><span class="line"><span class="string">ReactDOM.render(</span></span><br><span class="line"><span class="string">    &lt;BrowserRouter&gt;</span></span><br><span class="line"><span class="string">        &lt;App /&gt;</span></span><br><span class="line"><span class="string">    &lt;/BrowserRouter&gt;</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure><h3 id="★数据的加载"><a href="#★数据的加载" class="headerlink" title="★数据的加载"></a>★数据的加载</h3><p>在页面呈现之前加载数据，React Router 导出 matchPath 它在内部使用的静态函数，以匹配路由的位置。可以在服务器上使用此功能来帮助确定在呈现之前数据的依赖项。</p><p>这种方法的要求是依赖于静态路由的配置，用于在呈现之前根据路由匹配来加载对应的数据</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// routes.js</span></span><br><span class="line"><span class="keyword">const</span> routes = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">    path:<span class="string">'/'</span>,</span><br><span class="line">    component:Root,</span><br><span class="line">    loadData:<span class="function"><span class="params">()</span>=&gt;</span> getSomeData()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;router&#125; <span class="keyword">from</span> <span class="string">'./routes'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &#123;routes.map(<span class="function"><span class="params">route</span>=&gt;</span>(</span><br><span class="line">                &lt;Route &#123;...route&#125;/&gt;</span><br><span class="line">            ))&#125;</span><br><span class="line">        &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ server </span></span><br><span class="line"><span class="regexp">import &#123;matchPath&#125; from 'react-router-dom';</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const promises = [];</span></span><br><span class="line"><span class="regexp">routers.some(route=&gt;&#123;</span></span><br><span class="line"><span class="regexp">    const match = matchPath(req.path,route);</span></span><br><span class="line"><span class="regexp">    if(match) promises.push(route.loadData(match))</span></span><br><span class="line"><span class="regexp">    return match</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Promise.all(promises).then(data=&gt;&#123;</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><h2 id="Webpack-配置"><a href="#Webpack-配置" class="headerlink" title="Webpack 配置"></a>Webpack 配置</h2><h3 id="公共部分"><a href="#公共部分" class="headerlink" title="公共部分"></a>公共部分</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.js?$/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        presets: [<span class="string">'react'</span>, <span class="string">'stage-0'</span>, [<span class="string">'env'</span>, &#123;</span><br><span class="line">          <span class="comment">// 版本兼容大部分浏览器最后2个</span></span><br><span class="line">          targets: &#123;</span><br><span class="line">            browsers: [<span class="string">'last 2 versions'</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 不打包 node modules</span></span><br><span class="line"><span class="keyword">const</span> nodeExternals = <span class="built_in">require</span>(<span class="string">'webpack-node-externals'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.base.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> serverConfig = &#123;</span><br><span class="line">  <span class="comment">// 指明服务器</span></span><br><span class="line">  target: <span class="string">'node'</span>,</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/server/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'build'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  externals: [nodeExternals()],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.css?$/</span>,</span><br><span class="line">      <span class="comment">// 在高阶组件中通过注水跟脱水 css 来获取 css 代码，这个loader 提供了 ._getCss() 函数</span></span><br><span class="line">      use: [<span class="string">'isomorphic-style-loader'</span>, &#123;</span><br><span class="line">        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          importLoaders: <span class="number">1</span>,</span><br><span class="line">          modules: <span class="literal">true</span>,</span><br><span class="line">          localIdentName: <span class="string">'[name]_[local]_[hash:base64:5]'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(config, serverConfig);</span><br></pre></td></tr></table></figure><h4 id="webpack-node-externals"><a href="#webpack-node-externals" class="headerlink" title="webpack-node-externals"></a>webpack-node-externals</h4><p>不打包引入 的 node modules</p><h4 id="isomorphic-style-loader"><a href="#isomorphic-style-loader" class="headerlink" title="isomorphic-style-loader"></a>isomorphic-style-loader</h4><p>服务端打包 CSS 可以通过这个插件在对应的 DOM 元素上生成 class 类名，然后返回 CSS 样式代码。在高阶组件中，利用插件内置 API <code>._getCss()</code>将CSS 数据通过注水与脱水的方式在服务端获取，将这些字符串格式的 css 添加到服务器渲染的 HTML 就可以完成 CSS 服务器渲染</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.base.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clientConfig = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/client/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'index.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'public'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.css?$/</span>,</span><br><span class="line">      use: [<span class="string">'style-loader'</span>, &#123;</span><br><span class="line">        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          importLoaders: <span class="number">1</span>,</span><br><span class="line">          modules: <span class="literal">true</span>,</span><br><span class="line">          localIdentName: <span class="string">'[name]_[local]_[hash:base64:5]'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(config, clientConfig);</span><br></pre></td></tr></table></figure><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"server"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"react-ssr"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"npm-run-all --parallel dev:**"</span>,</span><br><span class="line">    <span class="attr">"dev:start"</span>: <span class="string">"nodemon --watch build --exec node \"./build/bundle.js\""</span>,</span><br><span class="line">    <span class="attr">"dev:build:server"</span>: <span class="string">"webpack --config webpack.server.js --watch"</span>,</span><br><span class="line">    <span class="attr">"dev:build:client"</span>: <span class="string">"webpack --config webpack.client.js --watch"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [</span><br><span class="line">    <span class="string">"react"</span>,</span><br><span class="line">    <span class="string">"ssr"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"lbh"</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"axios"</span>: <span class="string">"^0.18.0"</span>,</span><br><span class="line">    <span class="attr">"babel-core"</span>: <span class="string">"^6.26.3"</span>,</span><br><span class="line">    <span class="attr">"babel-loader"</span>: <span class="string">"^7.1.5"</span>,</span><br><span class="line">    <span class="attr">"babel-preset-env"</span>: <span class="string">"^1.7.0"</span>,</span><br><span class="line">    <span class="attr">"babel-preset-react"</span>: <span class="string">"^6.24.1"</span>,</span><br><span class="line">    <span class="attr">"babel-preset-stage-0"</span>: <span class="string">"^6.24.1"</span>,</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^2.1.1"</span>,</span><br><span class="line">    <span class="attr">"express"</span>: <span class="string">"^4.16.4"</span>,</span><br><span class="line">    <span class="attr">"express-http-proxy"</span>: <span class="string">"^1.5.1"</span>,</span><br><span class="line">    <span class="attr">"isomorphic-style-loader"</span>: <span class="string">"^5.0.1"</span>,</span><br><span class="line">    <span class="attr">"react"</span>: <span class="string">"^16.8.6"</span>,</span><br><span class="line">    <span class="attr">"react-dom"</span>: <span class="string">"^16.8.6"</span>,</span><br><span class="line">    <span class="attr">"react-helmet"</span>: <span class="string">"^5.2.0"</span>,</span><br><span class="line">    <span class="attr">"react-redux"</span>: <span class="string">"^7.0.1"</span>,</span><br><span class="line">    <span class="attr">"react-router-config"</span>: <span class="string">"^5.0.0"</span>,</span><br><span class="line">    <span class="attr">"react-router-dom"</span>: <span class="string">"^5.0.0"</span>,</span><br><span class="line">    <span class="attr">"redux"</span>: <span class="string">"^4.0.1"</span>,</span><br><span class="line">    <span class="attr">"redux-thunk"</span>: <span class="string">"^2.3.0"</span>,</span><br><span class="line">    <span class="attr">"style-loader"</span>: <span class="string">"^0.23.1"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.29.6"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.0"</span>,</span><br><span class="line">    <span class="attr">"webpack-merge"</span>: <span class="string">"^4.2.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-node-externals"</span>: <span class="string">"^1.7.2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h4><p>一个本地服务器，可以监控文件的变化来重启服务器，全局安装</p><h4 id="npm-run-all"><a href="#npm-run-all" class="headerlink" title="npm-run-all"></a>npm-run-all</h4><p>并行运行同名前缀的所有 <code>script</code> 语句，全局安装</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-SSR-同构浅析&quot;&gt;&lt;a href=&quot;#React-SSR-同构浅析&quot; class=&quot;headerlink&quot; title=&quot;React SSR 同构浅析&quot;&gt;&lt;/a&gt;React SSR 同构浅析&lt;/h2&gt;&lt;h2 id=&quot;客户端渲染（CSR）&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="react" scheme="http://laibh.top/categories/react/"/>
    
    
      <category term="react" scheme="http://laibh.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题目汇总摘录（JS 基础篇3）</title>
    <link href="http://laibh.top/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E6%91%98%E5%BD%95-JS%20%E5%9F%BA%E7%A1%80%E7%AF%873.html"/>
    <id>http://laibh.top/前端面试题目汇总摘录-JS 基础篇3.html</id>
    <published>2019-04-23T01:30:54.000Z</published>
    <updated>2020-07-11T03:24:57.643Z</updated>
    
    <content type="html"><![CDATA[<p>温故而知新，保持空杯心态,复习到一半的时间，突然发现了 <a href="https://yuchengkai.cn/docs/frontend">前端面试之道</a>，按学习这本书的路径来</p><h2 id="JS-基础3"><a href="#JS-基础3" class="headerlink" title="JS 基础3"></a>JS 基础3</h2><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>前端监控一般分为三种，页面埋点、性能监控以及异常监控</p><h3 id="页面埋点"><a href="#页面埋点" class="headerlink" title="页面埋点"></a>页面埋点</h3><p>页面埋点一般会监控下面几个数据：</p><ul><li>PV/UV</li><li>停留时长</li><li>流量来源</li><li>用户交互</li></ul><p>实现的思路分成两种，手写埋点和无埋点的方式</p><p>第一种自主选择需要监控的数据然后在相应的地方写入代码，这种方式灵活性很大，唯一的缺点就是工作量大，每个需要监控的地方都要插入代码</p><p>另一种的无埋点的方式基本不需要开发者手写埋点，而是统计所有的事件并且定时上报，这种方式虽然没有前一种繁琐，但是因为统计的是所有事件，所以还需要后期过滤出需要的数据</p><h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><p>可以使用浏览器期自带的  <a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FPerformance">Performance API</a> 来实现功能。一行代码就可以获得页面中各种详细的性能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">performance.getEntriesByType(<span class="string">'navigation'</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">    PerformanceNavigationTiming:&#123;</span></span><br><span class="line"><span class="comment">        connectEnd: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        connectStart: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        decodedBodySize: 0</span></span><br><span class="line"><span class="comment">        domComplete: 22873.60000000001</span></span><br><span class="line"><span class="comment">        domContentLoadedEventEnd: 22690.200000000004</span></span><br><span class="line"><span class="comment">        domContentLoadedEventStart: 22689.999999999996</span></span><br><span class="line"><span class="comment">        domInteractive: 22689.999999999996</span></span><br><span class="line"><span class="comment">        domainLookupEnd: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        domainLookupStart: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        duration: 22873.700000000015</span></span><br><span class="line"><span class="comment">        encodedBodySize: 0</span></span><br><span class="line"><span class="comment">        entryType: "navigation"</span></span><br><span class="line"><span class="comment">        fetchStart: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        initiatorType: "navigation"</span></span><br><span class="line"><span class="comment">        loadEventEnd: 22873.700000000015</span></span><br><span class="line"><span class="comment">        loadEventStart: 22873.60000000001</span></span><br><span class="line"><span class="comment">        name: ""</span></span><br><span class="line"><span class="comment">        nextHopProtocol: ""</span></span><br><span class="line"><span class="comment">        redirectCount: 0</span></span><br><span class="line"><span class="comment">        redirectEnd: 0</span></span><br><span class="line"><span class="comment">        redirectStart: 0</span></span><br><span class="line"><span class="comment">        requestStart: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        responseEnd: 726.4000000000124</span></span><br><span class="line"><span class="comment">        responseStart: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        secureConnectionStart: 0</span></span><br><span class="line"><span class="comment">        serverTiming: []</span></span><br><span class="line"><span class="comment">        startTime: 0</span></span><br><span class="line"><span class="comment">        transferSize: 0</span></span><br><span class="line"><span class="comment">        type: "back_forward"</span></span><br><span class="line"><span class="comment">        unloadEventEnd: 0</span></span><br><span class="line"><span class="comment">        unloadEventStart: 0</span></span><br><span class="line"><span class="comment">        workerStart: 0</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-性能监控.png" alt="性能监控"></p><h3 id="异常监控"><a href="#异常监控" class="headerlink" title="异常监控"></a>异常监控</h3><p>对于代码运行错误，通常的办法是使用 window.onerror 拦截报错，该方法能拦截到大部分的详细报错信息，但是也有例外的</p><ul><li>对于跨域的代码运行错误会显示 script error 对于这种情况需要给 script 标签添加 crossorigin 属性</li><li>对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 arguments.callee.caller 来做栈递归</li></ul><p>对于异步代码来说，可以使用 catch 的方式捕获错误。比如 Promise 可以直接使用 catch 函数，async await 可以使用 try catch</p><p>线上的代码是经过压缩的，打包的时候要设置 sourceMap</p><h2 id="常考的面试题目：UDP-与-TCP-的区别是什么？"><a href="#常考的面试题目：UDP-与-TCP-的区别是什么？" class="headerlink" title="常考的面试题目：UDP 与 TCP 的区别是什么？"></a>常考的面试题目：UDP 与 TCP 的区别是什么？</h2><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP 协议是面向无连接，不需要在正式传递数据之前先连接双方，然后 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且 UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便</p><h3 id="面向无连接"><a href="#面向无连接" class="headerlink" title="面向无连接"></a>面向无连接</h3><p>UDP 不要跟 TCP 一样在发送数据前进行三次握手建立连接，想发数据就可以发送了。</p><p>并且也只是数据的搬运工，不会对数据进行拆分和拼接操作。</p><p>具体来说：</p><ul><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给应用层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作。</li></ul><h3 id="不可靠性"><a href="#不可靠性" class="headerlink" title="不可靠性"></a>不可靠性</h3><p>不可靠性体现在无连接上，通信都不需要建立连接，想发就发。不用备份，也不用关心对方是否已经正确接收到数据。UDP 没有拥塞控制，一直会以恒定的速度发送数据，即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端是在网络条件不好的情况下可能会导致丢包，但是优点很明显是在某些实时性要求很高的场景（如电话会议）就需要使用 UDP 而不是 TCP</p><h3 id="高效"><a href="#高效" class="headerlink" title="高效"></a>高效</h3><p>UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要小得多，在传输数据报文时是很高效的。</p><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-UDP.png" alt="UDP"></p><p>UDP 头部包含了以下几个数据：</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误</li></ul><h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对一的方式，也就说说 UDP 提供了单播，多播，广播的功能。</p><h3 id="适用的场景"><a href="#适用的场景" class="headerlink" title="适用的场景"></a>适用的场景</h3><p>在很多实时性要求很高的地方都可以看到 UDP 的身影</p><h4 id="直播"><a href="#直播" class="headerlink" title="直播"></a>直播</h4><p>如果使用基于 TCP 的协议，TCP 会严格控制传输的正确性，一旦有某个数据对端没有收到，就会停下来直到对端收到这个数据。这种问题在网络条件不错的情况下不会有问题，但是如果网络差就会变成画面卡着，然后在继续播放下一帧的情况。</p><p>TCP 这种情况下会降低用户体验，不适合</p><h4 id="王者荣耀"><a href="#王者荣耀" class="headerlink" title="王者荣耀"></a>王者荣耀</h4><p>作者说不知道王者荣耀底层是使用了什么协议，但是对于这种实时性很高的游戏来说，UDP 是跑不了的。用户体量相当大的情况下，如果使用 TCP 连接可能会出现服务器不够用情况，因为每台服务器可供支撑的 TCP 连接数据是有限制的。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-TCP.png" alt="TCP"></p><p>对于TCP 头部来说，以下几个字段是很重要的</p><ul><li>Sequence number，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文</li><li>Acknowledgement Number，这个序号表示数据接收端期望接受的下一个字节编号是多少，同时也表示上一序号的数据已经收到</li><li>Window Size,窗口大小，表示还能接受多少字节的数据，用于流量控制</li><li>标识符<ul><li>UGR=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指标标明了紧急数据的尾部。</li><li>ACK=1：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须要把 ACK 置为一</li><li>PSH=1：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交</li><li>RST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立连接，也可以用于拒绝非法的报文段和拒绝连接请求</li><li>SYN=1：当 SYN = 1,ACK=0时，表示当前报文段是一个连接请求报文。当 SYN=1,ACK=1时，表示当前报文daunt是一个同意连接的应答报文</li><li>FIN=1：该字段为一表示此报文是一个释放连接的请求报文</li></ul></li></ul><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>TCP 的状态机是很复杂的，并且与建立连接时的握手息息相关</p><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-状态机.png" alt="状态机"></p><p>一个重要的性能指标 RTT.该指标表示发送端发送数据到接收到对端所需的往返时间</p><h3 id="建立连接三次握手"><a href="#建立连接三次握手" class="headerlink" title="建立连接三次握手"></a>建立连接三次握手</h3><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-三次握手.png" alt="三次握手"></p><p>首先假设主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP 连接建立完后都可以发送和接收数据，所以 TCP 是一个全双工的协议。</p><p>起初，两端都是 CLOSED 状态，在通信开始前，双方都会建立 TCB,服务端创建完TCB 后便进入 LISTEN 状态，此时开始等待客户端发送数据</p><h4 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h4><p>客户端向服务端发送连接请求报文段，该报文段中包含自身数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态</p><h4 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h4><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</p><h4 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h4><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端接收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功</p><p>第三次握手中可以包含数据，通过快速打开（TFO）技术就可以实现这一功能。其中只要涉及到握手的协议，都可以使用类似 TFO 方式，客户端和服务端存储相同的 cookie ，下次握手发出 cookie 达到减少 RTT 的目的。</p><p><strong>为什么TCP 建立连接需要三次握手，明明两次就可以建立起连接？</strong></p><p>因为这是为了防止出现失效的连接请求报文段被服务端接收后，从而产生错误。</p><p>如果客户端发送了一个连接报文请求A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求报文B。此时请求顺利达到服务器，服务端应答完就建立了请求，然后接受数据后释放了连接。</p><p>假设这时候请求 A 在两端关闭后终于达到了服务端，那么此时服务端会认为客户端有需要建立 TCP 连接，从而应答了该请求并进入了 ESTABLISHED 状态，但是实际上客户端是 CLOSED 状态，那么就会导致服务端一直等待，造成资源的浪费。</p><p>在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试5次，在建立连接可能遇到 SYN Flood 攻击。遇到这种情况可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。</p><h3 id="断开连接四次握手"><a href="#断开连接四次握手" class="headerlink" title="断开连接四次握手"></a>断开连接四次握手</h3><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-断开连接四次握手.png" alt="四次握手"></p><p>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK</p><h4 id="第一次握手-1"><a href="#第一次握手-1" class="headerlink" title="第一次握手"></a>第一次握手</h4><p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。</p><h4 id="第二次握手-1"><a href="#第二次握手-1" class="headerlink" title="第二次握手"></a>第二次握手</h4><p>B 收到连接释放请求后，会告诉应用层就要释放 TCP 连接，然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双工的，所以 B 依旧可以发送数据给 A</p><h4 id="第三次握手-1"><a href="#第三次握手-1" class="headerlink" title="第三次握手"></a>第三次握手</h4><p>B 如果此时还有没有发完的数据会继续发送，完毕后向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送</p><h4 id="第四次握手"><a href="#第四次握手" class="headerlink" title="第四次握手"></a>第四次握手</h4><p>A 收到释放请求后，向 B 发送确认应答，A 进入 TIME-WAIT 状态。该状态会持续 2MSL(最大生存期，指报文段在网络中生存的时间，超时会被抛弃)时间，若该时间段内没有 B 的重发请求的话，就会进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态</p><p><strong>为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后再进入CLOSED 状态？</strong></p><p>为了保证 B 能接受到 A 的确认应答，若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭</p><h2 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h2><p>ARQ 协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，ARQ 协议包含停止等待 ARQ 和连续 ARQ 两种协议</p><h3 id="停止等待-ARQ"><a href="#停止等待-ARQ" class="headerlink" title="停止等待 ARQ"></a>停止等待 ARQ</h3><h4 id="正常传输协议"><a href="#正常传输协议" class="headerlink" title="正常传输协议"></a>正常传输协议</h4><p>只要 A 向 B 发送一段报文，都要停止发送并且启动一个定时器，等待对端应答，在定时器内接收到对端应答就取消定时器并发送下一段报文</p><h4 id="报文丢失或者出错"><a href="#报文丢失或者出错" class="headerlink" title="报文丢失或者出错"></a>报文丢失或者出错</h4><p>在报文传输过程中可能会出现丢包，这时候超过定时器设定的时间就会再次发送丢失的数据直到对端响应，所以需要每次都备份发送的数据</p><p>即使报文正常传输到对端，有可能出现在传输过程中的报文出错的问题。这时候对端会抛弃该报文并等待 A 端重传</p><p>一般定时器设定的时间会大于一个 RTT 的平均时间</p><h4 id="ACK-超时或者丢失"><a href="#ACK-超时或者丢失" class="headerlink" title="ACK 超时或者丢失"></a>ACK 超时或者丢失</h4><p>对端传输的应答也可能出现丢失或者超时的情况，那么超过定时器时间 A 端照样会重报文，这时候 B 端会接收到相同序号的报文之后丢弃该报文并重传应答，直到 A 端发送下一个序号的报文。</p><p>在超时的情况下也可能会出现应答很迟到达，这时候 A 端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。</p><p>假设在良好的网络环境中，每次发送数据都需要等待片刻肯定是不能接受的，这个协议看起来不是很高效。</p><h3 id="连续ARQ"><a href="#连续ARQ" class="headerlink" title="连续ARQ"></a>连续ARQ</h3><p>在连续 ARQ 中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率</p><h4 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h4><p>连续 ARQ 中，接收端会持续不断收到报文，如果和停止等待 ARQ 中接收一个报文就发送一个应答一样，就太浪费资源了。通过累计确认，可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 标示位可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号后的数据。</p><p>但是累计确认也有一个弊端，在连续接收报文时，可能会遇到接收到序号5 的报文后，并未接收到序号6 的报文，然而序号7 的报文已经接收。遇到这种情况，ACK 只能回复 6，这样就会造成发送端重复发送数据的情况。</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>TCP 中，两端其实都维护者窗口，分别为发送端窗口和接收端窗口</p><p>发送端窗口包含已经发送但未收到应答的数据和可以发送但是未发送的数据</p><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-滑动窗口1.png" alt="滑动窗口1"></p><p>发送端窗口是由接收端窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。</p><p>当发送端接收到应答报文后，会随着窗口进入滑动。</p><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-滑动窗口2.png" alt="滑动窗口2"></p><p>滑动窗口是一个很重要概念，它帮助了 TCP 实现了流量控制的功能。接收方通过报文告知发送方还可以发送多少数据，从而保证了接收方能够来得及接收数据，防止出现接收方带宽已满，但是发送方还是一直发送数据的情况。</p><h4 id="zero-窗口"><a href="#zero-窗口" class="headerlink" title="zero 窗口"></a>zero 窗口</h4><p>在发送报文的过程中，可能会遇到对端出现零窗口的情况，在该情况下，发送端会停止发送数据，并启动 persistent timer.该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 TCP 链接。</p><h3 id="拥塞处理"><a href="#拥塞处理" class="headerlink" title="拥塞处理"></a>拥塞处理</h3><p>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接收数据，而后者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</p><p>拥塞处理包括了四个算法，分别是：慢开始，拥塞避免，快速重传，快递恢复</p><h4 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h4><p>慢开始算法，就是在传输开始时将发送窗口慢慢指数等级扩大，从而避免一开始就传输最大量数据导致网络阻塞。</p><p>慢开始算法步骤具体如下：</p><ol><li>连接初始设置拥塞窗口（Congestion Window）为 1 MSS(一个分段的最大数据量)</li><li>每过一个 RTT 将窗口大小乘二</li><li>指数级增加肯定不能没有限制的，所以有一个阈值限制，当窗口大于阈值就会启动拥塞避免算法</li></ol><h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4><p>拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样就能避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值</p><p>在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞，会马上进行一下步骤：</p><ol><li>将阈值设定为当前拥塞窗口的一半</li><li>将拥塞窗口设定为 1MSS</li><li>启动拥塞避免算法</li></ol><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号。如果发送端收到三个重复的 ACK ,无需等待定时器超时而是启动快速重传算法。具体是：<br>TCP Taho 的实现：</p><ul><li>将阈值设为当前阈值的一般</li><li>将拥塞窗口设为 1MSS</li><li>重新开始慢开始算法</li></ul><p>TCP Reno 实现：</p><ul><li>拥塞窗口减半</li><li>将阈值设定为当前拥塞窗口</li><li>进入块恢复阶段（重发对端需要的包，一旦接收到一个新的 ACK 答复就退出该阶段），这种方在丢失多个包的情况下就不那么友好了</li><li>使用拥塞避免算法</li></ul><h4 id="TCP-New-Ren-改进后的快恢复"><a href="#TCP-New-Ren-改进后的快恢复" class="headerlink" title="TCP New Ren 改进后的快恢复"></a>TCP New Ren 改进后的快恢复</h4><p><strong>TCP New Reno</strong> 算法改进了之前 <strong>TCP Reno</strong> 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。</p><p>在 <strong>TCP New Reno</strong> 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。</p><p>假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收的话就会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>TCP建立连接需要三次握手，断开连接需要四次握手</li><li>滑动窗口解决了数据的丢包、顺序不对和流量控制的问题</li><li>拥塞窗口实现了对流量的控制，保证全天候环境下最优的传递数据</li></ul><h2 id="HTTP-以及-TLS"><a href="#HTTP-以及-TLS" class="headerlink" title="HTTP 以及 TLS"></a>HTTP 以及 TLS</h2><h3 id="HTTP-请求的内容"><a href="#HTTP-请求的内容" class="headerlink" title="HTTP 请求的内容"></a>HTTP 请求的内容</h3><p>HTTP 请求由三部分组成，分别是：</p><ul><li>请求行</li><li>首部</li><li>实体</li></ul><p>请求行基本由请求方法、URL、版本协议组成。</p><p>请求方法分很多种，POST,GET,HEAD,OPTION,等等，更多具体的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">点击这里</a></p><h3 id="副作用和幂等"><a href="#副作用和幂等" class="headerlink" title="副作用和幂等"></a>副作用和幂等</h3><p>副作用是指对服务器上的资源做改变，搜素是无副作用的，注册是副作用的。</p><p>幂等指发送 M 和 N 次请求（两者不同且大于1），服务器上资源的状态一致，比如注册10个和11个账号是不幂等的，对文章进行更改10次和11次是幂等的。因为前者多了一个账号（资源），后者只是更新同一个资源</p><p>在规范的应用场景来说，Get 多用于无副作用的，幂等的场景，例如搜索关键字。Post 多用于副作用的，不幂等的场景，例如注册</p><p>技术上来说：</p><ul><li>Get 请求能缓存，Post 不能</li><li>Post 相对 Get 安全一点，因为GET 请求都包含在 URL 里面，且会被浏览器保存历史记录。而 Post 不会，但是在抓包的情况下是一样的。</li><li>URL 有长度限制，会影响 GET 请求，但是这个长度限制是浏览器限制的，不是 RFC 规定的</li><li>Post 支持更多的编码并且不对数据类型限制</li></ul><h3 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h3><p>首部分成请求首部和响应首部，并且部分首部两种通用。下面是常见的首部</p><h4 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h4><table><thead><tr><th>通用字段</th><th>作用</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存的行为</td></tr><tr><td>Connection</td><td>浏览器想要优先使用的连接类型，比如 keep-alive</td></tr><tr><td>Date</td><td>创建报文的时间</td></tr><tr><td>Pragma</td><td>报文指令</td></tr><tr><td>Via</td><td>代理服务器相关信息</td></tr><tr><td>Transfer-Encoding</td><td>制定报文主体的传输编码方式</td></tr><tr><td>Upgrade</td><td>要求客户端升级协议</td></tr><tr><td>Warning</td><td>在内容中可能存在错误</td></tr></tbody></table><p>具体解释的可以<a href="http://laibh.top/2018-08-16-read-%E5%9B%BE%E8%A7%A3HTTP-Part6%E4%B8%8A.html">点击这里</a></p><h4 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h4><table><thead><tr><th>请求首部</th><th>作用</th></tr></thead><tbody><tr><td>Accept</td><td>能正确接收的媒体类型</td></tr><tr><td>Accept-Charset</td><td>能正确接收的字符集</td></tr><tr><td>Accept-Encoding</td><td>能正确接收的编码格式列表</td></tr><tr><td>Accept-Language</td><td>能正确接收的语言列表</td></tr><tr><td>Expect</td><td>期待服务端的指定行为</td></tr><tr><td>From</td><td>请求方邮箱地址</td></tr><tr><td>Host</td><td>服务器的域名</td></tr><tr><td>If-Match</td><td>两端资源标记比较</td></tr><tr><td>If-Modified-Since</td><td>本地资源未修改返回 304（比较时间）</td></tr><tr><td>If-None-Match</td><td>本地资源未修改返回 304（比较标记）</td></tr><tr><td>User-Agent</td><td>客户端信息</td></tr><tr><td>Max-Forwards</td><td>限制可被代理以及网关转发的次数</td></tr><tr><td>Proxy-Authorization</td><td>向代理服务器发送验证信息</td></tr><tr><td>Range</td><td>请求某个内容的一部分</td></tr><tr><td>Referer</td><td>表示浏览器所访问的前一个页面</td></tr><tr><td>TE</td><td>传输编码方式</td></tr></tbody></table><h4 id="响应首部"><a href="#响应首部" class="headerlink" title="响应首部"></a>响应首部</h4><table><thead><tr><th>响应头部</th><th>作用</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>是否支持某些种类的范围</td></tr><tr><td>Age</td><td>资源在代理缓存中存在的时间</td></tr><tr><td>ETag</td><td>资源标识</td></tr><tr><td>Location</td><td>客户端重定向到某个 URL</td></tr><tr><td>Proxy-Authenticate</td><td>想代理服务器发送验证信息</td></tr><tr><td>Server</td><td>服务器名字</td></tr><tr><td>WWW-Authenticate</td><td>获取资源需要的验证信息</td></tr></tbody></table><h4 id="实体首部"><a href="#实体首部" class="headerlink" title="实体首部"></a>实体首部</h4><table><thead><tr><th>实体首部</th><th>作用</th></tr></thead><tbody><tr><td>Allow</td><td>资源的正确请求方式</td></tr><tr><td>Content-Encoding</td><td>内容编码的格式</td></tr><tr><td>Content-Language</td><td>内容使用的语言</td></tr><tr><td>Content-Length</td><td>request body 长度</td></tr><tr><td>Content-Location</td><td>返回数据的备用地址</td></tr><tr><td>Content-MD5</td><td>Base64 加密格式的内容 MD5 校验值</td></tr><tr><td>Content-Range</td><td>内容的位置范围</td></tr><tr><td>Content-Type</td><td>内容的媒体类型</td></tr><tr><td>Expires</td><td>内容的过期时间</td></tr><tr><td>Last_modified</td><td>内容的最后修改时间</td></tr></tbody></table><h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><p>状态码的责任是当客户端向服务端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务单是正常处理了请求，还是出现了错误。</p><h4 id="状态码的类别"><a href="#状态码的类别" class="headerlink" title="状态码的类别"></a>状态码的类别</h4><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">类别</th><th style="text-align:left">原因短语</th></tr></thead><tbody><tr><td style="text-align:left">1XX</td><td style="text-align:left">Information（信息性状态码）</td><td style="text-align:left">接受的请求正在处理</td></tr><tr><td style="text-align:left">2XX</td><td style="text-align:left">Success（成功状态码）</td><td style="text-align:left">请求正常处理完毕</td></tr><tr><td style="text-align:left">3XX</td><td style="text-align:left">Redirection（重定向状态码）</td><td style="text-align:left">需要进行附加操作以完成请求</td></tr><tr><td style="text-align:left">4XX</td><td style="text-align:left">Client Error（客户端错误状态码）</td><td style="text-align:left">服务器无法处理请求</td></tr><tr><td style="text-align:left">5XX</td><td style="text-align:left">Server Error（服务器错误状态码）</td><td style="text-align:left">服务器处理请求出错</td></tr></tbody></table><h4 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h4><ul><li>200 OK,表示从客户端发来的请求在服务端被正确处理</li><li>204，No content，表示请求成功，但响应报文不含实体的主体部分</li><li>205，Reset Content，表示请求成功，但响应报文不含实体的主体部分，与204响应不同的是要求请求方重置内容</li><li>206 Partial Content，表示对客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求，响应报文中由 Content-Range 指定范围的实体内容</li></ul><h4 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h4><ul><li>301 moved permanently,永久性重定向，表示资源已被分配到了新的 URL</li><li>302 found,临时重定向，表示资源临时被分配了新的 URL</li><li>303 see other，表示资源存在着另一个 URL应使用 GET 方法获取资源</li><li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li><li>307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求。</li></ul><h4 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h4><ul><li>400 bad request，请求报文存在语法错误</li><li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证消息</li><li>403 fobidden，表示对请求资源的访问被服务器拒绝</li><li>404 no found,表示在服务器上没有找到请求的资源</li></ul><h4 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h4><ul><li>500 internal server error,表示服务器端在执行请求时发生了错误</li><li>501 Not Implemented,表示服务器不支持当期请求所需要的某个功能</li><li>503 service unavaliable,表示服务器暂时处于超负载或者停机服务，无法处理请求</li></ul><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><p>HTTPS 通过 HTTP 来传输信息，但是信息通过 TLS 协议进行了 加密</p><p>TLS 协议位于传输层之上，应用层之下。首先进行 TLS 协议传输需要两个 RTT,可以通过 Session Resumption 减少到一个 RTT</p><p>在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。</p><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>对称加密就是两边都拥有相同的密钥，两边都知道药怎么将密文加密解密</p><p>这种加密方式缺点在于因为传输数据走的都是网络，如果密钥被截获那就没有加密的意义了</p><h4 id="非对称机密"><a href="#非对称机密" class="headerlink" title="非对称机密"></a>非对称机密</h4><p>有公钥私钥之分，公钥所有人都可以知道，如果将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</p><p>这种加密方式就可以完美解决对称加密存在的问题，假设两端都需要使用对称加密，那么在这之前，可以先使用非对称加密交换密钥。</p><p>简单流程化如下：服务端将公钥发布出去，那么客户端也知道公钥，就下来客户端创建了一个密钥，然后通过公钥加密后发送给服务端，服务端接收到私钥解密出正确的密钥，这时候两端就都知道密钥是什么了。</p><p>TLS 握手过程如下图：</p><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-TLS握手协议.png" alt="TLS 握手协议"></p><ol><li>客户端发送一个随机值以及需要的协议和加密方式</li><li>服务端收到客户端的随机值，自己也产生了一个随机值，并根据客户端的需求的协议和加密方式来使用对应的方式，并且发送自己的证书（如果需要验证客户端证书需要说明）</li><li>客户端收到服务端的证书验证是否有效，验证通过会生成一个随机值，通过服务端证书的公钥加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书</li><li>服务端收到加密过的随机值并使用私钥解密获得三个随机值，这时候两端都有三个随机值，可以通过这三个随机值按照之前的约定的加密方式生成密钥，接下来的通信既可以使用该密钥加密解密了。</li></ol><p>通过上面步骤，可以知道 TLS 握手阶段，两端使用非对称加密的方式进行通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据的时候，两端使用对称加密的方式进行通信。</p><p>关于 http 安全的具体可以<a href="http://laibh.top/2018-08-29-read-%E5%9B%BE%E8%A7%A3HTTP-Part7.html">点击这里</a></p><h3 id="HTTP-2-以及-HTTP-3"><a href="#HTTP-2-以及-HTTP-3" class="headerlink" title="HTTP/2 以及 HTTP/3"></a>HTTP/2 以及 HTTP/3</h3><p>HTTP/2 很好的解决了当下最常用的 HTTP/1 所存在的一些性能问题，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，当然兼容问题以及如何优雅降级应该是国内还不普遍使用的原因之一。</p><p>虽然 HTTP/2 已经解决了很多问题，但是并不代表它已经是完美的了，HTTP/3 就是为了解决 HTTP/2 所存在的一些问题而被推出来的。</p><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><p>HTTP/2 相比对 HTTP/1 可以说是大幅度提高了网页的性能。</p><p>在 HTTP/1 为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量（Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</p><p>在 HTTP/2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。</p><p>大家可以通过 <a href="https://link.juejin.im/?target=https%3A%2F%2Fhttp2.akamai.com%2Fdemo">该链接</a> 感受下 HTTP/2 比 HTTP/1 到底快了多少。</p><h3 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h3><p>HTTP/2 中所有加强性能的核心在于此，在之前的 HTTP 版本，我们是通过文本的方式传输数据，在 HTTP/2 中引入了新的编码机制，所有的传输数据都会被分割，并采用二进制格式编码。</p><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-二进制传输.png" alt="二进制传输"></p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>在 HTTP/2 中有两个非常重要的概念，分别是 帧（frame）和 流 （stream）</p><p>帧代表着最小的数据单位，每个帧都会标识出该帧属于哪个流，流也就是多个帧组成的数据流</p><p>多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的对头阻塞的问题，极大提高了传输的性能。</p><h3 id="Header-压缩"><a href="#Header-压缩" class="headerlink" title="Header 压缩"></a>Header 压缩</h3><p>在 HTTP/1 中使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千字节。</p><p>在 HTTP/2 中使用 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header。后面在传输过程中可以传输以及记录过的 header 的键名，对端收到的数据后就可以通过键名找到对应的值</p><h3 id="服务端-Push"><a href="#服务端-Push" class="headerlink" title="服务端 Push"></a>服务端 Push</h3><p>在 HTTP/2 中，服务端可以在客户端某个请求后，主动推送其他资源</p><p>某些资源客户端是一定会请求的，这时候可以采用服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下也可以使用 prefetch</p><h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3><p>底层的 TCP 协议导致 HTTP/2 版本存在一个问题，因为使用了多路复用，一般来说同一个域名下面只需要一个 TCP 连接。当这个连接中出现了丢包的情况，就会导致 HTTP/2 的表现不如 HTTP/1</p><p>在丢包的情况下，整个 TCP 都要开始等待重传，就导致了后面的所有的数据都会被阻塞。但是对于 HTTP/1 来说可以开启多个 TCP 连接，出现这种情况只会影响一个连接，剩余的 TCP 连接可以正常传输数据</p><p>这个协议是由操作系统实现的，如果要去修改 TCP 协议看起来不怎么现实。</p><p>基于这个原因，Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上，</p><p>HTTP/3 之前名为 HTTP-over-QUIC</p><h4 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h4><p>UDP 协议虽然效率很高，但是并不是那么的可靠.QUIC 是基于 UDP ,在原生的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等功能。</p><h4 id="多路复用-1"><a href="#多路复用-1" class="headerlink" title="多路复用"></a>多路复用</h4><p>虽然 HTTP/2 支持多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 就原生实现了这个功能，并且传输的单个数据流可以保证有序交付但不会影响其他的数据流，这样的技术就解决了之前的 TCP 存在的问题。</p><p>并且 QUIC 在移动端会比 TCP 好，因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是因为 QUIC 是通过 ID 的方式去识别一个连接的，不会随着网络的变化而变化，可以迅速重连上。</p><h4 id="0-RRT"><a href="#0-RRT" class="headerlink" title="0-RRT"></a>0-RRT</h4><p>通过使用类似 TCP 的快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。</p><h4 id="纠错机制"><a href="#纠错机制" class="headerlink" title="纠错机制"></a>纠错机制</h4><p>假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。当出现其中的非校验丢包的 情况的时候，可以通过另外三个包计算出丢失的数据包的内容。</p><p>当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li>HTTP/2 通过多路复用、二进制流、header 压缩等技术，极大提高了性能，但是还是存在着问题</li><li>QUIC 基于 UDP 实现，是 HTTP/3 中底层支撑协议，该协议基于 UDP，而且拿了 TCP 中的精华，实现了又快有可靠的协议</li></ul><p>关于 HTTP/3 更多<a href="http://www.sohu.com/a/299243519_115128">点击这里</a></p><h2 id="输入-URL-到页面渲染的整个过程"><a href="#输入-URL-到页面渲染的整个过程" class="headerlink" title="输入 URL 到页面渲染的整个过程"></a>输入 URL 到页面渲染的整个过程</h2><p>首先是 DNS 查询，如果这一步做到了智能 DNS 解析的话，会提供速度最快的 IP 地址回来</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS 的作用就是通过域名查询到具体的 IP 地址</p><p>因为 IP 存在数据和英文的组合（IPv6），不利于记忆，所以就出现了域名，可以把它看成某个 IP 地址的别名，DNS 就是通过这个别名去查询真正的名字是什么</p><p>在 TCP 握手之前以及先进行了 DNS 查询，这个查询是操作系统自己做的，在浏览器中访问 <a href="http://www.googel.com">www.googel.com</a> 的时候，会进行以下的操作：</p><ol><li>操作系统会首先在本地缓存中查询 IP</li><li>没有的话就会去系统配置的 DNS 服务器中查询</li><li>如果这时候还没有找到，就会直接去 DNS 根服务器查询，这一步查询会找出负责 <code>com</code>这个域名的服务器</li><li>然后去该服务器查询  <code>google</code>这个二级域名</li><li>接下来是三级域名的查询，这个是我们自己配置的，可以给 <code>www</code> 这个域名配置一个IP,然后还可以给别的三级域名配置一个 IP</li></ol><p>上面是DNS 迭代查询，还有一种格式递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果将数据返回给客户端。</p><p>DNS 是基于 UDP 做的查询</p><p>接下来是 TCP 握手协议，应用层会下发数据给传输层，这里的 TCP 协议会指明两端的端口号，然后下发给网络层。网络层的 IP 协议会确定 IP 地址，并制定了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了。</p><p>在这一部分中，TCP 握手结束后，会进行 TLS 握手，然后开始正式的传输数据了。</p><p>数据在进入服务端之前，可能还会警告负责负载均衡的服务器，它的作用是将请求合理的分发到多态服务器上面，这时假设服务端会响应一个 HTML 文件</p><p>首先浏览器会判断状态码是什么，如果是200 就继续解析，如果是 400 或者 500 的话就会报错，如果是 300 就会重定向，这里会有一个 重定向计数器，避免多次的重定向，超过次数也会报错。</p><p>浏览器开始解析文件，如果是 gzip 格式的会先解压一下，然后通过文件的编码格式知道该如何取解码文件。</p><p>文件解码后就会正式开始渲染流程，先根据 HTML 创建 DOM 树，有 CSS 的话就是 CSSOM 树，如果遇到 script 标签的话，会判断是否存在 async 或者 defer,前者会并行进行下载并执行 JS,后者会先下载文件，然后等待 HTML 解析完成后顺序执行。</p><p>如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到下载文件就会去下载文件，如果使用 HTTP/2 协议的话就会极大提高多图的下载效率</p><p>CSSOM 树 和 DOM 树构建完成之后会生成 render 树，这一步就是确定页面布局、样式等诸多方面的东西。</p><p>在生成 Render 树的过程中，浏览器就会开始调用 GPU 绘制，合成图层，将内容显示在 屏幕上了。</p><p>关于这个流程，更多的可以<a href="https://github.com/skyline75489/what-happens-when-zh_CN">点击这里</a></p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>关于具体的设计模式我有过一些<a href="http://laibh.top/tags/javaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">笔记</a></p><p>下面还是根据作者的脚步来回顾这一点知识点</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>有一份很复杂的代码需要用户去调用，但是用户并不关心这些代码是怎么实现的，只需要提供一个接口去调用，用户只负责传递需要的参数。参数的使用都在内部逻辑去完成，不暴露出来给用户。只要给用户返回一个实例，这种构造过程就是工厂。</p><p>简而言之就是隐藏了创建实例的复杂度，只需要提供一个接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    alertName()&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> create(name)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Man(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Factory.create(<span class="string">'haha'</span>).alertName()</span><br></pre></td></tr></table></figure><p>Vue 源码中，也可以看到工厂模式的使用，比如创建异步组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export function createComponent(</span><br><span class="line">  Ctor: Class&lt;Component&gt; | Function | Object | void,</span><br><span class="line">  data: ?VNodeData,</span><br><span class="line">  context: Component,</span><br><span class="line">  children: ?Array&lt;VNode&gt;,</span><br><span class="line">  tag?: string</span><br><span class="line">): VNode | Array&lt;VNode&gt; | void &#123;</span><br><span class="line"></span><br><span class="line">  // 逻辑处理...</span><br><span class="line"></span><br><span class="line">  const vnode = new VNode(</span><br><span class="line">    `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : &apos;&apos;&#125;`,</span><br><span class="line">    data, undefined, undefined, undefined, context,</span><br><span class="line">    &#123; Ctor, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  return vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们可以看到我们只需要调用 <code>createComponent</code> 传入参数就能创建一个组件实例，但是创建这个实例是很复杂的一个过程，工厂帮助我们隐藏了这个复杂的过程，只需要一句代码调用就能实现功能。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式很常用，比如全局缓存、全局状态管理等等只需要一个对象，就可以使用单例模式</p><p>单例模式的核心就是保证全局只有一个对象可以访问。因为 JS 是门无类的语言，所以别的语言实现单例的方式不能套入 JS 中，我们需要用一个变量确保值创建一次就可以了，下面是如何实现单例模式的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Singleton.getInstance = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> Singleton.getInstance();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> Singleton.getInstance();</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在 Vuex 源码中也可以看到单例模式的运用，虽然实现的方式不大一样，通过一个外部变量来控制只安装一次 Vuex</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue <span class="comment">// bind on install</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span> (<span class="params">_Vue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Vue &amp;&amp; Vue === Vue)&#123;</span><br><span class="line">       <span class="comment">// 如果发现 Vue 有值，就不重新创建实例了</span></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Vue = _Vue;</span><br><span class="line">    applyMixin(Vue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作</p><p>简单实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plug</span></span>&#123;</span><br><span class="line">    getName()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'港版插头'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.plug = <span class="keyword">new</span> Plug()</span><br><span class="line">    &#125;</span><br><span class="line">    getName()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.plug.getName() + <span class="string">' 适配转二脚插头'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> target = <span class="keyword">new</span> Target();</span><br><span class="line">target.getName(); <span class="comment">// 港版插头 适配转二脚插头</span></span><br></pre></td></tr></table></figure><p>在 Vue 中经常使用到适配器模式，比如父组件传递给子组件一个时间戳属性，组件内部需要将时间戳转为正常的日期显示，一般会使用 computed 来做转换这件事情，这个过程就是用到了适配器模式</p><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>装饰模式不需要改变已有的接口，作用是给对象添加功能，就像我们经常需要给手机戴个保护套防摔一样，不改变手机自身，给手机添加了保护套提供防摔的功能。</p><p>以下是如何实现装饰模式的例子，使用了 ES7 中的装饰器语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target,key,descriptor</span>)</span>&#123;</span><br><span class="line">    descriptor.writable = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> descriptor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    @readonly</span><br><span class="line">    name = <span class="string">'haha'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> Test();</span><br><span class="line">t.haha = <span class="string">'11'</span>; <span class="comment">// 不可修改</span></span><br></pre></td></tr></table></figure><p>在 React 中，装饰模式是随处可见的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(MyComponent)</span><br></pre></td></tr></table></figure><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理是为了控制对对象的访问，不让外部直接访问到对象，事件代理也是用到了代理模式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#ul'</span>);</span></span><br><span class="line"><span class="javascript">    ul.addEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.target);</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为存在太多 li，不可能每个都去绑定事件，这时候可以通过给父节点绑定一个事件，让父节点作为代理去拿到真实点击的节点。</p><h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h3><p>发布-订阅模式也叫做观察者模式，通过一对一或者一对多的依赖关系，当对象发生改变的时候，订阅方都会收到通知。现实生活中的例子是当我需要在购物网站购买一个产品的时候，但是发现该产品目前处于缺货状态，这时候我们可以点击有货通知的按钮，让网站在产品有货的时候通过短信通知我。</p><p>在实际代码中，其实发布-定于模式也很常见，比如我们点击一个按钮触发了点击事件其实就是使用了该模式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#ul'</span>);</span></span><br><span class="line"><span class="javascript">    ul.addEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.target);</span></span><br><span class="line"><span class="undefined">    &#125;)    </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Vue 中，如何实现响应式也是使用了该模式，对于需要实现想爱你过隐式的对象来说，在 get 的时候会进行依赖手机，当改变了对象的属性的时候，就会触发派发更新</p><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>外观模式提供了一个接口，隐藏了内部的逻辑，更加方便外部的调用</p><p>我们需要实现一个兼容多种浏览器的添加事件方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">elm, evType, fn, useCapture</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (elm.addEventListener) &#123;</span><br><span class="line">    elm.addEventListener(evType, fn, useCapture);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (elm.attachEvent) &#123;</span><br><span class="line">    <span class="keyword">return</span> elm.attachEvent(<span class="string">'on'</span> + evType, fn)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    elm[<span class="string">"on"</span> + evType] = fn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不同的浏览器，添加事件的方式可能会存在兼容问题，如果每次都要这样写一遍是不可能，我们将逻辑判断统一在一个接口里面，外部需要添加事件只需要调用 addEvent 就可以了</p><h2 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h2><p>关于数据结构我之前的笔记也有过记录，具体的可以<a href="http://laibh.top/tags/javaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">点击这里</a></p><p>下面还是跟着作者来重温一遍常见的数据结构</p><h3 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h3><p>如何衡量算法的效率？通常是用资源，例如CPU（时间）占用、内存占用、硬盘占用和网络占用。当讨论大O表示法时，一般考虑的是CPU（时间）占用。</p><p>分析算法时，时常遇到以下几类函数</p><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">名称</th></tr></thead><tbody><tr><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left">常数的</td></tr><tr><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left">对数的</td></tr><tr><td style="text-align:left"><em>O((log(n)c))</em></td><td style="text-align:left">对数多项式的</td></tr><tr><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left">线性的</td></tr><tr><td style="text-align:left"><em>O(n2)</em></td><td style="text-align:left">二次的</td></tr><tr><td style="text-align:left"><em>O(nc)</em></td><td style="text-align:left">多项式的</td></tr><tr><td style="text-align:left"><em>O(cn)</em></td><td style="text-align:left">指数的</td></tr></tbody></table><h3 id="常用数据结构的时间复杂度"><a href="#常用数据结构的时间复杂度" class="headerlink" title="常用数据结构的时间复杂度"></a>常用数据结构的时间复杂度</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><table><thead><tr><th style="text-align:left">数据结构</th><th style="text-align:left">一般情况</th><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left">最差情况</th><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left"></td><td style="text-align:left">插入</td><td style="text-align:left">删除</td><td style="text-align:left">搜索</td><td style="text-align:left">插入</td><td style="text-align:left">删除</td><td style="text-align:left">搜索</td></tr><tr><td style="text-align:left">数组-栈-队列</td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td></tr><tr><td style="text-align:left">链表</td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td></tr><tr><td style="text-align:left">双向链表</td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td></tr><tr><td style="text-align:left">散列表</td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(n)</em></td></tr><tr><td style="text-align:left">二分搜索树</td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(n)</em></td></tr><tr><td style="text-align:left">AVL树</td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td></tr></tbody></table><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><table><thead><tr><th style="text-align:left">算法（用于数组）</th><th style="text-align:left">最好情况</th><th style="text-align:left">一般情况</th><th style="text-align:left">最差情况</th></tr></thead><tbody><tr><td style="text-align:left">冒泡排序</td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(n2)</em></td><td style="text-align:left"><em>O(n2)</em></td></tr><tr><td style="text-align:left">选择排序</td><td style="text-align:left"><em>O(n2)</em></td><td style="text-align:left"><em>O(n2)</em></td><td style="text-align:left"><em>O(n2)</em></td></tr><tr><td style="text-align:left">插入排序</td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(n2)</em></td><td style="text-align:left"><em>O(n2)</em></td></tr><tr><td style="text-align:left">归并排序</td><td style="text-align:left"><em>O(nlog(n))</em></td><td style="text-align:left"><em>O(nlog(n))</em></td><td style="text-align:left"><em>O(nlog(n))</em></td></tr><tr><td style="text-align:left">快速排序</td><td style="text-align:left"><em>O(nlog(n))</em></td><td style="text-align:left"><em>O(nlog(n))</em></td><td style="text-align:left"><em>O(n2)</em></td></tr><tr><td style="text-align:left">堆排序</td><td style="text-align:left"><em>O(nlog(n))</em></td><td style="text-align:left"><em>O(nlog(n))</em></td><td style="text-align:left"><em>O(nlog(n))</em></td></tr><tr><td style="text-align:left">桶排序</td><td style="text-align:left"><em>O(n+k)</em></td><td style="text-align:left"><em>O(n+k)</em></td><td style="text-align:left"><em>O(n2)</em></td></tr><tr><td style="text-align:left">基数排序</td><td style="text-align:left"><em>O(nk)</em></td><td style="text-align:left"><em>O(nk)</em></td><td style="text-align:left"><em>O(nk)</em></td></tr></tbody></table><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一个线性结构，在计算机中是一个相当常见的数据结构，栈的特点是只能在某一端添加或者删除数据，遵循先进后出的规则（FILO）的原则</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加一个或者结构新元素到栈顶</span></span><br><span class="line">  push(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除栈顶的元素</span></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回栈顶的元素</span></span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack[<span class="keyword">this</span>.size() - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack.length</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size() === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = [];</span><br><span class="line">  &#125;</span><br><span class="line">  getStack() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>题意是匹配括号，可以通过栈的特性来完成这道题目</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isVaild = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;</span><br><span class="line">    <span class="string">"("</span>: <span class="number">-1</span>,</span><br><span class="line">    <span class="string">")"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"["</span>: <span class="number">-2</span>,</span><br><span class="line">    <span class="string">"]"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">"&#123;"</span>: <span class="number">-3</span>,</span><br><span class="line">    <span class="string">"&#125;"</span>: <span class="number">3</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map[s[i]] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      stack.push(s[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> last = stack.pop()</span><br><span class="line">      <span class="keyword">if</span> (map[last] + map[s[i]] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stack.size() === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Vue  中关于模板解析的代码，就有应用到匹配尖括号的内容</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一个线性结构，特点是在某一段添加数据，在另一端删除数据，遵循先进先出的原则（FIFO）</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>分成单链队列和循环队列</p><h5 id="单链队列"><a href="#单链队列" class="headerlink" title="单链队列"></a>单链队列</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = []</span><br><span class="line">  &#125;</span><br><span class="line">  enQueue(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  deQueue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.shift();</span><br><span class="line">  &#125;</span><br><span class="line">  front() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.length</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size() === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为单链队列在出队操作的时候㤇 O(n)的时间复杂度，所以引入了循环队列，循环队列的出队操作平均是 O(1)的时间复杂度</p><h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sqQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> <span class="built_in">Array</span>(length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 队头</span></span><br><span class="line">    <span class="keyword">this</span>.first = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 队尾</span></span><br><span class="line">    <span class="keyword">this</span>.last = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前队列的大小</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  enQueue(item) &#123;</span><br><span class="line">    <span class="comment">// 如果队尾 +1 是否为队头，如果是就代表需要扩容数组，%this.queue.length 是为了防止数组越界</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.first === (<span class="keyword">this</span>.last + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length) &#123;</span><br><span class="line">      <span class="keyword">this</span>.resize(<span class="keyword">this</span>.size() * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.queue[<span class="keyword">this</span>.last] = item;</span><br><span class="line">    <span class="keyword">this</span>.size++;</span><br><span class="line">    <span class="keyword">this</span>.last = (<span class="keyword">this</span>.last + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length</span><br><span class="line">  &#125;</span><br><span class="line">  deQueue() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Queue is empty'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first];</span><br><span class="line">    <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.first = (<span class="keyword">this</span>.first + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length;</span><br><span class="line">    <span class="keyword">this</span>.size--;</span><br><span class="line">    <span class="comment">// 判断当前队列是否过小，为了保证不浪费空间，在队列空间等于总长度四分之一的时候且不为2时缩小总长度为当前的一半</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size === <span class="keyword">this</span>.size() / <span class="number">4</span> &amp;&amp; <span class="keyword">this</span>.size() / <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.resize(<span class="keyword">this</span>.size() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  front() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Queue is empty'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first]</span><br><span class="line">  &#125;</span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.length - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.first === <span class="keyword">this</span>.last;</span><br><span class="line">  &#125;</span><br><span class="line">  resize(length) &#123;</span><br><span class="line">    <span class="keyword">let</span> q = <span class="keyword">new</span> <span class="built_in">Array</span>(length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      q[i] = <span class="keyword">this</span>.queue[(i + <span class="keyword">this</span>.first) % <span class="keyword">this</span>.queue.length]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.queue = q;</span><br><span class="line">    <span class="keyword">this</span>.first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.last = <span class="keyword">this</span>.size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存活动管理。但是链表失去了数组随机读取的优点，同时链表也增加了结点的指针域，空间开销比较大。</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>单向链表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 链表长度</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 虚拟头部</span></span><br><span class="line">    <span class="keyword">this</span>.dummyNode = <span class="keyword">new</span> Node(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  find(header, index, currentIndex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === currentIndex) <span class="keyword">return</span> header</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.find(header.next, index, currentIndex + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  addNode(v, index) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkIndex(index);</span><br><span class="line">    <span class="comment">// 当往链表末尾插入时，prev.next 为空，其他情况时，因为要插入节点，所以插入的节点的next 应该是 prev.next 然后设置 prev.next 为插入的节点</span></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="keyword">this</span>.find(<span class="keyword">this</span>.dummyNode, index, <span class="number">0</span>);</span><br><span class="line">    prev.next = <span class="keyword">new</span> Node(v, prev.next);</span><br><span class="line">    <span class="keyword">this</span>.size++;</span><br><span class="line">    <span class="keyword">return</span> prev.next;</span><br><span class="line">  &#125;</span><br><span class="line">  insertNode(v, index) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.addNode(v, index);</span><br><span class="line">  &#125;</span><br><span class="line">  addToFirst(v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.addNode(v, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  addToLast(v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.addNode(v, <span class="keyword">this</span>.size);</span><br><span class="line">  &#125;</span><br><span class="line">  removeNode(index, isLast) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkIndex(index);</span><br><span class="line">    index = isLast ? index - <span class="number">1</span> : index;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="keyword">this</span>.find(<span class="keyword">this</span>.dummyNode, index, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> node = prev.next;</span><br><span class="line">    prev.next = node.next;</span><br><span class="line">    node.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.size--;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  removeFirstNode() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.removeNode(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  removeLastNode() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.removeNode(<span class="keyword">this</span>.size, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  checkIndex(index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="keyword">this</span>.size) <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Index error'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  getNode(index) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkIndex(index);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.find(<span class="keyword">this</span>.dummyNode, index, <span class="number">0</span>).next;</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>树拥有很多种结构，二叉树是树中最常见的结构，同时也是一个天然的递归结构</p><p>二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一棵树的数量为满，该树就可以称之为二叉树</p><pre class="mermaid">graph TDA[2] --> B[7]A[2] --> C[5]C[5] --> F[9]F[9] --> J[4]B[7] --> D[2]B[7] --> E[6]E[6] --> G[5]E[6] --> H[11]</pre><h4 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h4><p>二分搜索树也是二叉树，拥有二叉树的特性。但是区别于在二分搜索树每个节点的值都比它的左子树的值大，比右子树的值小。</p><p>这种存储方式很适合数据搜索。如下图显示，当需要查找6的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率</p><pre class="mermaid">graph TDA[5] --> B[2]B[2] --> C[1]B[2] --> D[4]D[4] --> E[3]A[5] --> F[6]F[6] --> G[7]</pre><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>具体可以<a href="http://laibh.top/2018-11-05-JavaScipt%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Part8.html">点击这里</a></p><h2 id="CSS-常考面试题目资料"><a href="#CSS-常考面试题目资料" class="headerlink" title="CSS 常考面试题目资料"></a>CSS 常考面试题目资料</h2><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000013325778">50道CSS基础面试题（附答案）</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000013860482">《50道CSS基础面试题（附答案）》中的答案真的就只是答案吗？</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Ffunteas.com%2Ftopic%2F5ada8eac230d1e5e25e45b89">CSS 面试题总结</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fyangshun%2Ffront-end-interview-handbook%2Fblob%2Fmaster%2FTranslations%2FChinese%2Fquestions%2Fcss-questions.md">front-end-interview-handbook</a></li></ul><h2 id="推荐的资料"><a href="#推荐的资料" class="headerlink" title="推荐的资料"></a>推荐的资料</h2><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fgetify%2FYou-Dont-Know-JS">You-Dont-Know-JS</a>，这套书深入的讲解很多 JS 的内容，英文版是开源免费阅读的，如果你英文不好的话，国内这套书已经有出版了，可以选择购买。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fgetify%2FFunctional-Light-JS">Functional-Light-JS</a>，这本书是讲解函数式编程的，函数式编程也是一种编程范式，轻量级的函数式可以很方便的解决很多问题，有兴趣的可以一读。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fleonardomso%2F33-js-concepts">33-js-concepts</a>，这份资料讲解了 33 个前端开发必须知道的 JS 概念，内容是英文的，如果你英文不好的话，可以寻找这份资料的中文版。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fdt-fe%2Fweekly">前端精读周刊</a>，这是一份前端好文集合，每周都会更新，目前已经更新了 84 篇文章。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FJohnsenZhou%2FFront-End-Performance-Checklist">前端性能清单</a>，这是一份前端性能清单，如果你需要优化一个项目的话，可以根据这份清单一个个来检查优化项。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2F30-seconds%2F30-seconds-of-code">30-seconds-of-code</a>，30 秒系列，很短的代码片段让你了解一个知识点。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FAllThingsSmitty%2Fmust-watch-javascript">must-watch-javascript</a>，这份资料包含了很多高质量的前端相关视频，值得一看。</li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FAllThingsSmitty%2Fcss-protips">css-protips</a>，通过这份资料你可以学习到很多 tips 来提高你的 CSS 技能。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2F30-seconds%2F30-seconds-of-css">30-seconds-of-css</a>，30 秒系列，很短的代码片段让你了解一个知识点</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fitem.jd.com%2F12262251.html">CSS 世界</a>，张鑫旭出版的书籍，没什么好说的了，看就是了。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fchokcoco%2FiCSS">一些有趣的 CSS 话题</a>，CSS 奇技淫巧，在这里，都有。</li></ul><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>React 核心团队成员 Dan Abramov 的 <a href="https://link.juejin.im/?target=https%3A%2F%2Foverreacted.io%2F">blog</a>。</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fnswbmw%2Fnode-in-debugging">Node.js 调试指南</a>，这是一本专注于讲解 Node 调试的书籍，已经出版了，但是可以开源免费阅读。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fitem.jd.com%2F12380404.html">Node.js：来一打 C++ 扩展</a>，死月出版的书籍，没什么好说的，看就是了。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fi0natan%2Fnodebestpractices%2Fblob%2Fmaster%2FREADME.chinese.md">Node.js 最佳实践</a>，这是对 Node.js 最佳实践中排名最高的内容的总结和分享</li></ul><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Ftrimstray%2Fthe-book-of-secret-knowledge">the-book-of-secret-knowledge</a>，这是一份安全领域的资料，如果你对安全感兴趣的话，可以阅读一下内容。</li></ul><h3 id="周报"><a href="#周报" class="headerlink" title="周报"></a>周报</h3><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fweekly.75team.com%2F">奇舞周刊</a>，每周都会整理一份不错的中文文章合集。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fweekly.techbridge.cc%2F">TechBridge Weekly</a>，这是一份台湾地区整理的一份多个技术领域的周报。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fjavascriptweekly.com%2F">JavaScript Weekly</a>，这是一份相当有名气的英文周报，整理的文章质量都很高，如果你只想订阅一份周报，那就是它了。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fponyfoo.com%2Fweekly">Pony Foo Weekly</a>，这也是一份不错的英文周报，文章质量也很高，并且和上一份周报重叠的内容不多。</li></ul><h3 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h3><p>Medium 上我并没有怎么固定阅读，更多的是订阅它的日报或者从别的周报上看到的 Medium 的文章，但是如果一定要推荐两个组织的话，我只推荐这两个，毕竟他们的文章质量都很高。</p><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fmedium.freecodecamp.org%2F">freecodecamp</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fhackernoon.com%2F">hackernoon</a></li></ul><h3 id="Youtube"><a href="#Youtube" class="headerlink" title="Youtube"></a>Youtube</h3><p>Youtube 有很多高质量的视频，但是门槛大家都知道，这里我推荐一些值得订阅的频道。</p><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fchannel%2FUCzoVCacndDCfGDf41P-z0iA">JSConf</a>，很多会议的视频你都可以在这里找到。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fchannel%2FUCnUYZLuoy1rq1aVMwx4aTzw">Google Chrome Developers</a>，Google 金字招牌，没啥好说的。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fchannel%2FUC9-y-6csu5WGm29I7JiwpnA">Computerphile</a>，内容偏向于计算机领域。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fchannel%2FUCtxCXg-UvSnTKPOzLH4wJaQ%2Fvideos">Coding Tech</a>，内容偏向于入门。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fchannel%2FUCO1cgjhGzsSYb1rsB4bFe4Q">Fun Fun Function</a>，如果你想学习函数式编程的一些内容，这是一个值得订阅的频道。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fuser%2FDevTipsForDesigners%2Fvideos">DevTips</a>，每周更新一个视频，能够学习到不少开发中的 Tips。</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fdavideuler%2Farchitecture.of.internet-product">互联网公司技术架构</a>，这份资料介绍了当下互联网公司的一个技术架构。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Ftrekhleb%2Fjavascript-algorithms">javascript-algorithms</a>，这份资料作者使用了 JS 来实现了大部分的数据结构和算法。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fjamiebuilds%2Fthe-super-tiny-compiler">小型编译器</a>，这份资料告诉了我们该如何去实现一个小型的编译器，很适合前端开发者阅读。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fmtdvio%2Fevery-programmer-should-know">every-programmer-should-know</a>，这份资料列举了很多每个开发者都应该知道的知识点。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;温故而知新，保持空杯心态,复习到一半的时间，突然发现了 &lt;a href=&quot;https://yuchengkai.cn/docs/frontend&quot;&gt;前端面试之道&lt;/a&gt;，按学习这本书的路径来&lt;/p&gt;
&lt;h2 id=&quot;JS-基础3&quot;&gt;&lt;a href=&quot;#JS-基础3&quot; cla
      
    
    </summary>
    
      <category term="前端面试" scheme="http://laibh.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端面试题" scheme="http://laibh.top/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>webpack4.x从基础到实战</title>
    <link href="http://laibh.top/2019-04-13-webpack4x%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98.html"/>
    <id>http://laibh.top/2019-04-13-webpack4x从基础到实战.html</id>
    <published>2019-04-13T08:30:00.000Z</published>
    <updated>2020-07-11T03:24:57.639Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://coding.imooc.com/learn/list/316.html">DellLee 老师的 webpack 学习与记录</a></p><p>知识点：</p><blockquote><p><code>Loader</code> <code>HMR</code> <code>Create React App</code> <code>Caching</code> <code>Plugin</code> <code>SourceMap</code> <code>Vue Cli 3.0</code> <code>Shimming</code> <code>WebpackDevServer</code> <code>TreeShaking</code>  <code>CodeSplitting</code> <code>Babel</code> <code>React</code> <code>Library</code> <code>Eslint</code> <code>PWA</code> <code>Vue</code> <code>Mode</code> <code>性能优化</code> <code>多页应用</code> <code>原理</code> <code>PreLoading</code> <code>PreFetching</code> <code>环境变量</code>  <code>TypeScript</code></p></blockquote><h2 id="Webpack-是什么"><a href="#Webpack-是什么" class="headerlink" title="Webpack 是什么"></a>Webpack 是什么</h2><p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)</em>。当 webpack 处理应用程序时，它会递归地构建一个<em>依赖关系图(dependency graph)</em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em>。</p><p><a href="https://webpack.js.org/concepts/modules/">扩展阅读-Modules</a></p><h2 id="webapack-打包浅析"><a href="#webapack-打包浅析" class="headerlink" title="webapack 打包浅析"></a>webapack 打包浅析</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// production 模式下代码压缩，development 代码不压缩</span></span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>module 处理方案，loader 有先后顺序，从下到上，从右到左</p><h3 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a><strong>file-loader</strong></h3><p>处理图片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 开发还是生产环境</span></span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  <span class="comment">// 进口</span></span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  <span class="comment">// 模块处理</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 规则</span></span><br><span class="line">    rules: [&#123;</span><br><span class="line">      <span class="comment">// 匹配</span></span><br><span class="line">      test: <span class="regexp">/\.jpg$/</span>,</span><br><span class="line">      <span class="comment">// loader 运用</span></span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span>,</span><br><span class="line">        <span class="comment">// 占位符</span></span><br><span class="line">        options: &#123;</span><br><span class="line">          <span class="comment">// 定义文件的名字：原来的名字_哈希值.原来的后缀</span></span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          <span class="comment">// 图片输出路径</span></span><br><span class="line">          outputPath:<span class="string">'./images/'</span></span><br><span class="line">        &#125;          </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者是用方法的方式</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 开发还是生产环境</span></span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  <span class="comment">// 进口</span></span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  <span class="comment">// 模块处理</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 规则</span></span><br><span class="line">    rules: [&#123;</span><br><span class="line">      <span class="comment">// 匹配</span></span><br><span class="line">      test: <span class="regexp">/\.jpg$/</span>,</span><br><span class="line">      <span class="comment">// loader 运用</span></span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span>,</span><br><span class="line">        <span class="comment">// 占位符</span></span><br><span class="line">        options: &#123;</span><br><span class="line">          <span class="comment">// 定义文件的名字：原来的名字_哈希值.原来的后缀</span></span><br><span class="line">        name(file)&#123;</span><br><span class="line">            <span class="keyword">if</span>(process.env.NODE_ENV === <span class="string">'development'</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="string">'[path][name].[ext]'</span>,</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'[hash][ext]'</span></span><br><span class="line">        &#125;,</span><br><span class="line">          <span class="comment">// 图片输出路径</span></span><br><span class="line">          outputPath:<span class="string">'./images/'</span></span><br><span class="line">        &#125;          </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a><strong>url-loader</strong></h3><p>会把图片打包到js 文件中，如果图片很小（1-2kb）的话就适合以base64的形式打包到js里面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          outputPath: <span class="string">'images/'</span>,</span><br><span class="line">          <span class="comment">// 限制图片的大小（Kb）,小于的会被打包到js里面，大于则打包到指定目录下</span></span><br><span class="line">          limit: <span class="number">2048</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用来处理字体文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [&#123;</span><br><span class="line">    test:<span class="regexp">/\.(eot|ttf|svg|woff)$/</span>,</span><br><span class="line">    use:&#123;</span><br><span class="line">      loader:<span class="string">'file-loader'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="style-loader、css-loader"><a href="#style-loader、css-loader" class="headerlink" title="style-loader、css-loader"></a><strong>style-loader</strong>、<strong>css-loader</strong></h3><p>处理css 样式</p><p>css-loader 分析有几个css文件以及它们之间的关系是怎么样的然后合并为一个css</p><p>style-loader 会把 css-loader 合并的内容挂载到页面上</p><p>node-sass、sass-loader：应对 sass 文件，上面的组合处理sass 文件不会报错，但是不会转义sass 特殊的语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [ &#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">    use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="postcss-loader、autoprefixer"><a href="#postcss-loader、autoprefixer" class="headerlink" title="postcss-loader、autoprefixer"></a><strong>postcss-loader</strong>、<strong>autoprefixer</strong></h3><p>自动添加css前缀</p><p>在文件的根目录配置 postcss.config.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webapck.config.js 更改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [ &#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">    use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>,<span class="string">'postcss-loader'</span>]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>如果有样式引用其他样式的情况要重新定义 css-loader 使得被引入的 scss 等有语义的css 文件可以重新跑多一次全部的 loader</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [ &#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      <span class="comment">// 当 loader 有参数配置的时候使用对象</span></span><br><span class="line">      use: [<span class="string">'style-loader'</span>, &#123;</span><br><span class="line">          loader:<span class="string">'css-loader'</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">              importLoaders:<span class="number">2</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="string">'sass-loader'</span>,<span class="string">'postcss-loader'</span>]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>开启模块化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [ &#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      <span class="comment">// 当 loader 有参数配置的时候使用对象</span></span><br><span class="line">      use: [<span class="string">'style-loader'</span>, &#123;</span><br><span class="line">          loader:<span class="string">'css-loader'</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">              importLoaders:<span class="number">2</span>,</span><br><span class="line">              <span class="comment">// css 模块化</span></span><br><span class="line">              modules:<span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="string">'sass-loader'</span>,<span class="string">'postcss-loader'</span>]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><a href="https://webpack.js.org/loaders">其他具体的loader</a></p><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>可以在webpack 运行打包到某个时刻帮你实现一些事情</p><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>会在打包结束后自动生成一个 html 文件，并把打包生成的 js 自动引入到这个 html 文件中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        <span class="comment">// 设置默认的模板</span></span><br><span class="line">        template: <span class="string">'src/index.html'</span></span><br><span class="line">    &#125;)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>打包之前去掉旧的dist 项目</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'src/index.html'</span> &#125;),</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin()</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p><a href="https://github.com/johnagan/clean-webpack-plugin/blob/master/src/clean-webpack-plugin.ts#L315">clean-webpack-plugin2.0 的新参数</a></p><h2 id="Output、Entry"><a href="#Output、Entry" class="headerlink" title="Output、Entry"></a><strong>Output、Entry</strong></h2><p>多文件输出预设的名字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">    entry:&#123;</span><br><span class="line">        main:<span class="string">'./src/index.js'</span>,</span><br><span class="line">        sub:<span class="string">'./src/index.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        <span class="comment">// 可以定义输出的跟路径，如果图片是cdn上面的，可以在从这里设置，html 引入这个js会自动加上</span></span><br><span class="line">        publicPath:<span class="string">'xx'</span>,</span><br><span class="line">        filename:<span class="string">'[name].js'</span></span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'dist'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SouceMap"><a href="#SouceMap" class="headerlink" title="SouceMap"></a>SouceMap</h2><p>development  模式下 devtool 默认是true,开启souceMap 通过映射当代码出错的时候可以找到源文件是哪里出错而不是编译后的文件哪里出错.</p><p>当然建立这种映射会影响打包速度</p><p><a href="https://webpack.js.org/configuration/devtool#devtool">具体内容</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  <span class="comment">// 这里可以关闭 sourceMap，开启则是'source-map'</span></span><br><span class="line">  devtool: <span class="string">'none'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>souce-map会在dist 自动生成一个 js.map 映射文件，而inline-souce-map 则是将这个关系包含在 打包的js文件里面。</p><p>使用 cheap-xxx–xxx 的参数会加快打包方式，但是只会提示到几行不会精确到几列。</p><p>开发环境（development）推荐使用：cheap-module-eval-source-map（module代表module里面的错误也可以检测到，eval 可以加快编译速度）</p><p>生产环境（pruduction）则是：cheap-module-source-map</p><h2 id="WebpackDevServer"><a href="#WebpackDevServer" class="headerlink" title="WebpackDevServer"></a>WebpackDevServer</h2><p>webpack-dev-server 帮助打包后的运行在自动打开的服务器，并会跟随文件的改变而改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        <span class="comment">// 要打开的文件地址</span></span><br><span class="line">        contentBase:<span class="string">'./dist'</span>,</span><br><span class="line">        <span class="comment">// 是否自动打开默认浏览器</span></span><br><span class="line">        open:<span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 端口号，默认端口是8080</span></span><br><span class="line">        port:<span class="number">8080</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"webpack-dev-server"</span>,</span><br><span class="line">    <span class="string">"watch"</span>: <span class="string">"webpack --watch"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack-dev-server 打包的时候会把打包的 dist 目录内置到内存里面而不会显示出来，可以提高编译速度</p><p><a href="https://webpack.js.org/configuration/dev-server">相关内容</a></p><p>一开始的时候webpack-dev-server 因为配置不是很完善，一般人都会自己创建一个 server.js 文件来自己建一个服务器</p><p>这里使用 express 和 webpack-dev-middleware 来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="comment">// 中间件可以监听，随着页面内容的改变而更改</span></span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>);</span><br><span class="line"><span class="comment">// 使用 webpack 的配置来返回一个编译器</span></span><br><span class="line"><span class="keyword">const</span> complier = webpack(config);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(webpackDevMiddleware(complier,&#123;</span><br><span class="line">  publicPath:config.output.publicPath</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,()=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server is running on port 3000'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"middleware"</span>: <span class="string">"node server.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面的内容是没有实现浏览器自动加载的。</p><h2 id="Hot-Module-Replacement-HMR"><a href="#Hot-Module-Replacement-HMR" class="headerlink" title="Hot Module Replacement(HMR)"></a>Hot Module Replacement(HMR)</h2><p>热模块更新，不刷新页面，重新加载css文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    <span class="comment">// 启动热模块加载</span></span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 即便 html 不生效也不会自动刷新</span></span><br><span class="line">    hotOnly: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[</span><br><span class="line"><span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只修改对应的 js 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">module</span>.hot)&#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">'./文件名.js'</span>,()=&gt;&#123;</span><br><span class="line">        <span class="comment">// 运用页面的函数</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而css 对应的代码是在 css-loader 里面底层实现了，所以不用手写 module.hot</p><h2 id="Babel-处理-ES6-语法"><a href="#Babel-处理-ES6-语法" class="headerlink" title="Babel 处理 ES6 语法"></a>Babel 处理 ES6 语法</h2><p>babel-loader 与 @babel-core(webpack与 babel 桥梁)</p><p>@babel/preset-env</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            text:<span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">            loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">                presets:[<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以将 ES6 语法转换为 ES5 语法，但是还不完善，接着在index.js里面直接引入 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'@babel/polyfill'</span></span><br></pre></td></tr></table></figure><p>@babel/polyfill 可以自动添加内容实现兼容低版本的浏览器。打包之后会发现打包的js会很大，因为它把所有低版本可能要兼容的代码都写了进去，而不是按需要来增加内容。这个时候可以通过配置来达到按需</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            text:<span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">            loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">                presets:[[<span class="string">'@babel/preset-env'</span>],&#123;</span><br><span class="line">                    useBuiltIns:<span class="string">'usage'</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack 进行打包的时候发现会报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Module not found: Error: Can't resolve 'core-js/modules/es6.array.map'</span><br></pre></td></tr></table></figure><p>之类的错误，通过查阅发现要下载一个 core-js 的插件便可以解决问题，具体可以查看 <a href="https://www.npmjs.com/package/core-js">core-js</a></p><p>而当你使用这个按需加载的时候，就会提示你去掉文件中 import ‘@babel/polyfill’ ,因为会自动加载，另外可以配置要兼容的浏览器版本来判断需要引入那些兼容代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            text:<span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">            loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">                presets:[[<span class="string">'@babel/preset-env'</span>],&#123;</span><br><span class="line">                    useBuiltIns:<span class="string">'usage'</span>,</span><br><span class="line">                    targets:&#123;</span><br><span class="line">                        chrome:<span class="string">'67'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而上面的版本的谷歌浏览器是支持 ES6 语法的，因为打包出来的文件就会很小。可以看出来上面的方式有可能会全局污染(适合小项目)，可以使用另外一种方式去配置（适合多模块）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">            loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">                plugins:[[<span class="string">'@babel/plugin-transform-runtime'</span>,&#123;</span><br><span class="line">                    corejs:<span class="number">2</span>,</span><br><span class="line">                    helpers:<span class="literal">true</span>,</span><br><span class="line">                    regenerator:<span class="literal">true</span>,</span><br><span class="line">                    useESModules:<span class="literal">false</span></span><br><span class="line">                &#125;]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置上面的内容之前需要安装以下几个依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D @babel/runtime @babel/plugin-transfrom-runtime @babel/runtime-corejs2</span><br></pre></td></tr></table></figure><p>具体可以查看<a href="https://coding.imooc.com/lesson/316.html#mid=22337">这里</a></p><p>另外可以把 babel-loader options 里面的内容放在一个单独名为 .babelrc 的文件中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"corejs"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"helpers"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"regenerator"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"useESModules"</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包-React-代码"><a href="#打包-React-代码" class="headerlink" title="打包 React 代码"></a>打包 React 代码</h2><p>安装依赖包 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D @babel/preset-react</span><br></pre></td></tr></table></figure><p>配置 .babelrc</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"targets"</span>: &#123;</span><br><span class="line">          <span class="attr">"chrome"</span>: <span class="string">"67"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-react"</span></span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的顺序也是从下往上</p><p><a href="https://babeljs.io/docs/en/babel-preset-react">具体点击这里</a></p><h2 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h2><p>development 环境，按需加载，只支持 ES Module ，底层是一个静态引入实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js 只引入 add 的打包结果</span></span><br><span class="line"><span class="comment">/*! exports provided: add, minus */</span></span><br><span class="line"><span class="comment">/*! exports used: add */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过下面的配置</span></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    optimization:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 因为只是单纯引入，挂载在全局而不用去使用里面具体的，以防止被去掉，使用这个参数可以做一个过滤不作 tree Shaking</span></span><br><span class="line">    <span class="string">"sideEffects"</span>:[<span class="string">"@babel/polyi-fill"</span>,<span class="string">"*.css"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>production 环境甚至需要 optimization 配置，会自动配置，但是 package.json 中的 sideEffects 需要保留</p><h2 id="Development-和-Production-模式的区分打包"><a href="#Development-和-Production-模式的区分打包" class="headerlink" title="Development 和 Production 模式的区分打包"></a>Development 和 Production 模式的区分打包</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server --config webpack.dev.js"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --config webpack.prod.js"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.dev.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    hotOnly: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">      loader:<span class="string">'babel-loader'</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          outputPath: <span class="string">'images/'</span>,</span><br><span class="line">          limit: <span class="number">2048</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        <span class="string">'style-loader'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'css-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            importLoaders: <span class="number">2</span>,</span><br><span class="line">            <span class="comment">// modules: true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">        <span class="string">'postcss-loader'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.(eot|ttf|svg|woff)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'src/index.html'</span> &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    usedExports:<span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">'/'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-source-map'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">      loader:<span class="string">'babel-loader'</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          outputPath: <span class="string">'images/'</span>,</span><br><span class="line">          limit: <span class="number">2048</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        <span class="string">'style-loader'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'css-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            importLoaders: <span class="number">2</span>,</span><br><span class="line">            <span class="comment">// modules: true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">        <span class="string">'postcss-loader'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.(eot|ttf|svg|woff)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'src/index.html'</span> &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">'/'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出上面有很多重复的代码，可以进行抽取优化，用 webpack-merge 进行合并</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">      loader:<span class="string">'babel-loader'</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          outputPath: <span class="string">'images/'</span>,</span><br><span class="line">          limit: <span class="number">2048</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        <span class="string">'style-loader'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'css-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            importLoaders: <span class="number">2</span>,</span><br><span class="line">            <span class="comment">// modules: true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">        <span class="string">'postcss-loader'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.(eot|ttf|svg|woff)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'src/index.html'</span> &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">'/'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// webpack.dev.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devConfig = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    hot: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    usedExports:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig,devConfig);</span><br><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-source-map'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig,prodConfig);</span><br></pre></td></tr></table></figure><h2 id="Webpack-和-Code-Splitting"><a href="#Webpack-和-Code-Splitting" class="headerlink" title="Webpack 和 Code Splitting"></a>Webpack 和 Code Splitting</h2><h3 id="同步代码"><a href="#同步代码" class="headerlink" title="同步代码"></a>同步代码</h3><p>遇到公共类库，会自动打包出来一个文件，例如 vendors~main.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    splitChunks:&#123;</span><br><span class="line">        chunks:<span class="string">'all'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步代码"><a href="#异步代码" class="headerlink" title="异步代码"></a>异步代码</h3><p>安装 babel-plugin-dynamic-import-webpack 后在 .babelrc 里面配置,这个插件不是官方的，所以不支持魔法注释</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"targets"</span>: &#123;</span><br><span class="line">          <span class="attr">"chrome"</span>: <span class="string">"67"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-react"</span></span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>:[<span class="string">"dynamic-import-webpack"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方的 @babel/plugin-syntax-dynamic-import 可以支持魔术注释</p><p>重新配置 .babelrc</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"targets"</span>: &#123;</span><br><span class="line">          <span class="attr">"chrome"</span>: <span class="string">"67"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-react"</span></span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>:[<span class="string">"@babel/plugin-syntax-dynamic-import"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack.common.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    splitChunks:&#123;</span><br><span class="line">        chunks:<span class="string">'all'</span>,</span><br><span class="line">        cacheGroups:&#123;</span><br><span class="line">            <span class="comment">// 取消名字前面的默认名称</span></span><br><span class="line">            vendors:<span class="literal">false</span>,</span><br><span class="line">            <span class="keyword">default</span>:<span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用魔法注释</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"lodash" */</span><span class="string">'lodash'</span>).then(<span class="function">(<span class="params">&#123;<span class="keyword">default</span>:_&#125;</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    element.innerHTML = _.join([<span class="string">'Dell'</span>,<span class="string">'Lee'</span>],<span class="string">'_'</span>);</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getComponent().then(<span class="function"><span class="params">element</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打包编译之后就可以看到异步引入的库被自己定义的名字打包出来了</p><h3 id="splitChunksPlugins"><a href="#splitChunksPlugins" class="headerlink" title="splitChunksPlugins"></a>splitChunksPlugins</h3><p>默认配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      <span class="comment">// 只对异步代码生效 all 则是全部代码，inintal 则是同步代码</span></span><br><span class="line">      chunks: <span class="string">'async'</span>,</span><br><span class="line">      <span class="comment">// 引入的模块/包/库 大于 30kb 则会代码分割</span></span><br><span class="line">      minSize: <span class="number">30000</span>,</span><br><span class="line">      <span class="comment">// 会尝试将 大于这个尺寸的库重新拆分为n个 maxSize 大的库，但是一般这个参数不会生效</span></span><br><span class="line">      maxSize: <span class="number">0</span>,</span><br><span class="line">      <span class="comment">// 打包生成的库的次数少于 minChunks次 则不会分割</span></span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">      maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">      <span class="comment">// 自动生成的文件的中间符</span></span><br><span class="line">      automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">      name: <span class="literal">true</span>, <span class="comment">// 配合 cacheGroups 使用</span></span><br><span class="line">      <span class="comment">// 缓存组</span></span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          <span class="comment">// 如果引入的库在 node_modules 里面，符合这个组打包出来的文件前缀会有vendors~入口.js</span></span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          <span class="comment">// 优先级 符合 在 node_modules 优先级大于在默认的，那么打包就会打包在 vendors 这个相关配置里面</span></span><br><span class="line">          priority: <span class="number">-10</span>,</span><br><span class="line">          <span class="comment">// 强制定义在同一个文件里面，可以不配置</span></span><br><span class="line">          filename:<span class="string">'vendors.js'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 默认处理途径</span></span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: <span class="number">-20</span>,</span><br><span class="line">          <span class="comment">// 如果 模块在前面打包过了就不会重复打包</span></span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span>，</span><br><span class="line">          filename:<span class="string">'common.js'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Lazy-loading-懒加载"><a href="#Lazy-loading-懒加载" class="headerlink" title="Lazy loading 懒加载"></a>Lazy loading 懒加载</h2><p>通过 import 语法来异步加载，什么时候要使用则是取决于个人</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"lodash" */</span><span class="string">'lodash'</span>).then(<span class="function">(<span class="params">&#123;<span class="keyword">default</span>:_&#125;</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    element.innerHTML = _.join([<span class="string">'Dell'</span>,<span class="string">'Lee'</span>],<span class="string">'_'</span>);</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">  getComponent().then(<span class="function"><span class="params">element</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// async await 改进</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="attr">default</span>:_&#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"lodash" */</span><span class="string">'lodash'</span>);</span><br><span class="line">  <span class="keyword">const</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  element.innerHTML = _.join([<span class="string">'Dell'</span>,<span class="string">'Lee'</span>],<span class="string">'_'</span>);</span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">  getComponent().then(<span class="function"><span class="params">element</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="打包分析"><a href="#打包分析" class="headerlink" title="打包分析"></a>打包分析</h2><p>配置 package.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"scripts"</span>:&#123;</span><br><span class="line">        <span class="attr">"dev-build"</span>:<span class="string">"webpack --profile --json &gt; stats.json --config ./build/webpack.dev.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的意思是分析webapck 打包的文件生成后生成 stats.json 。</p><p><a href="http://webpack.github.io/analyse/">点击这个网站</a>可以将这个json 文件上传，会帮你自动分析版本，时长以及相关错误，模块之间的关系等等</p><p><a href="https://webpack.js.org/guides/code-splitting/#bundle-analysis">更多相关工具</a></p><h2 id="Preloading-Prefetching"><a href="#Preloading-Prefetching" class="headerlink" title="Preloading,Prefetching"></a>Preloading,Prefetching</h2><p>在谷歌浏览器 ctrl+shift+p 输入show Coverage 点击录制后可以看到一个网站首屏加载 js 文件的利用率，以及可以优化的可能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当浏览器空闲的时候，可以先加载这个文件</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackPrefetch:true*/</span><span class="string">'./click.js'</span>).then(<span class="function">(<span class="params">&#123;<span class="keyword">default</span>:func&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    func();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个则是和核心文件一起加载</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackPreloading:true*/</span><span class="string">'./click.js'</span>).then(<span class="function">(<span class="params">&#123;<span class="keyword">default</span>:func&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    func();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>性能优化在缓存上面可以优化的地方有限，可以考虑更多是代码的使用率，将一开始不会用的代码尽量使用异步加载的方式来加载</p><h2 id="CSS-文件的代码分割"><a href="#CSS-文件的代码分割" class="headerlink" title="CSS 文件的代码分割"></a>CSS 文件的代码分割</h2><p>mini-css-extract-plugin,没有实现  HMR 需要手动配置，所以一般是适用在线上环境使用。</p><p>配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">      loader:<span class="string">'babel-loader'</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          outputPath: <span class="string">'images/'</span>,</span><br><span class="line">          limit: <span class="number">2048</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(eot|ttf|svg|woff)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'src/index.html'</span> &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">      cleanOnceBeforeBuildPatterns:[path.resolve(__dirname,<span class="string">'../dist'</span>)],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    usedExports:<span class="literal">true</span>,</span><br><span class="line">    splitChunks:&#123;</span><br><span class="line">      chunks:<span class="string">'all'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">'./'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// webpack.dev.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devConfig = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    hot: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">2</span>,</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">          <span class="string">'postcss-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">  optimization:&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig,devConfig);</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-source-map'</span>,</span><br><span class="line">  plugins:[</span><br><span class="line">      <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">        <span class="comment">// template 要引入的</span></span><br><span class="line">      filename:<span class="string">'[name].css'</span>,</span><br><span class="line">        <span class="comment">// 间接引入的走这个</span></span><br><span class="line">      chunkFilename:<span class="string">'[name].chunk.css'</span>          </span><br><span class="line">      &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">2</span>,</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">          <span class="string">'postcss-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig,prodConfig);</span><br></pre></td></tr></table></figure><p>将之前共同配置的 webpack,common.js  module rules 里面关于css 的配置移动到 webpack.dev.js 里面不作修改。然后同样复制一遍到 webpack.prod.js 里面，把关于css-loader 里面的的 style-loader 换成 MiniCssExtractPlugin.loader 作为最后一步来处理。</p><p>一个要注意的点是在公共的 optimization 里面加了一个 usedExports：true,同时也要在 package.json 里面配置 sideEffects：[‘@babel/polyfill’,’*.css’]</p><p>运行 npm run build 便可以打包分割开 css 文件了</p><h3 id="压缩-css-代码"><a href="#压缩-css-代码" class="headerlink" title="压缩 css 代码"></a>压缩 css 代码</h3><p>optimize-css-assets-webpack-plugin</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    optimization:&#123;</span><br><span class="line">        minimizer:[</span><br><span class="line">            <span class="keyword">new</span> OptimizeCSSAssetPlugin(&#123;&#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个css文件打包到同一个css里面"><a href="#多个css文件打包到同一个css里面" class="headerlink" title="多个css文件打包到同一个css里面"></a>多个css文件打包到同一个css里面</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    optimization:&#123;</span><br><span class="line">        <span class="comment">// 底层依旧是 splitChunks 实现的</span></span><br><span class="line">        splitChunks:&#123;</span><br><span class="line">            cacheGroups:&#123;</span><br><span class="line">                styles:&#123;</span><br><span class="line">                    name:<span class="string">'styles'</span>,</span><br><span class="line">                    test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">                    chunks:<span class="string">'all'</span>,</span><br><span class="line">                    enforce:<span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个css文件按入口文件来打包"><a href="#多个css文件按入口文件来打包" class="headerlink" title="多个css文件按入口文件来打包"></a>多个css文件按入口文件来打包</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    optimization:&#123;</span><br><span class="line">        splitChunks:&#123;</span><br><span class="line">            cacheGroups:&#123;</span><br><span class="line">                fooStyles:&#123;</span><br><span class="line">                    name:<span class="string">'foo'</span>,</span><br><span class="line">                    test: <span class="function">(<span class="params">m, c, entry = <span class="string">'foo'</span></span>) =&gt;</span> m.constructor.name === <span class="string">'CssModule'</span> &amp;&amp; recursiveIssuer(m) === entry,</span><br><span class="line">                    chunks:<span class="string">'all'</span>,</span><br><span class="line">                    enforce:<span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                barStyles:&#123;</span><br><span class="line">                    name:<span class="string">'bar'</span>,</span><br><span class="line">                    test: <span class="function">(<span class="params">m, c, entry = <span class="string">'foo'</span></span>) =&gt;</span> m.constructor.name === <span class="string">'CssModule'</span> &amp;&amp; recursiveIssuer(m) === entry,</span><br><span class="line">                    chunks:<span class="string">'all'</span>,</span><br><span class="line">                    enforce:<span class="literal">true</span>                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Webpack-与浏览器缓存（Caching）"><a href="#Webpack-与浏览器缓存（Caching）" class="headerlink" title="Webpack 与浏览器缓存（Caching）"></a>Webpack 与浏览器缓存（Caching）</h2><p>增加 hash 值,如果文件没有改变的话，那么打包前后几次打包出来的文件里面的哈希值就不会发生变化，浏览器的缓存也就起到了作用。如果改变了，浏览器则会去请求先的文件而不是继续用原来的缓存文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:<span class="string">'[name].[contenthash].js'</span>,</span><br><span class="line">        chunkFilename:<span class="string">'[name].[contenthash].js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置是新版本的webpack直接有的，但是旧版本的 webpack 每次打包 hash 值都会发生变化，可以在 webpack.common.js 里面配置一个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    optimization:&#123;</span><br><span class="line">        runtimeChunk:&#123;</span><br><span class="line">            name:<span class="string">'runtime'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个参数会把旧版本中的 manifest 单独抽离出来一个 runtime 开头的 js文件里面，这个 文件主要描述的是库与业务逻辑代码之间的一些关系，旧版本webpack 中这个关系会因为每次打包而发生变化。</p><h2 id="Shimming"><a href="#Shimming" class="headerlink" title="Shimming"></a>Shimming</h2><h3 id="自动引入某个库"><a href="#自动引入某个库" class="headerlink" title="自动引入某个库"></a>自动引入某个库</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">            _:<span class="string">'lodash'</span>,</span><br><span class="line">            <span class="comment">// 花式引用</span></span><br><span class="line">            _join:[<span class="string">'lodash'</span>,<span class="string">'join'</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局this-指向-window"><a href="#全局this-指向-window" class="headerlink" title="全局this 指向 window"></a>全局this 指向 window</h3><p>imports-loader</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">            use:[&#123;</span><br><span class="line">                loader:<span class="string">'babel-loader'</span></span><br><span class="line">            &#125;,&#123;</span><br><span class="line">                loader:<span class="string">'imports-loader？this=&gt;window'</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>可以考虑使用，用个人，具体是在 package.json 里面传递一个 env 参数</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev-build"</span>: <span class="string">"webpack --profile --json &gt; stats.json --config ./build/webpack.common.js"</span>,</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server --config ./build/webpack.common.js"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --env.production --config ./build/webpack.common.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 开发与生产环境的webpack 则是都放到 common 里面来判断分发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.dev.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devConfig = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    hot: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">2</span>,</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">          <span class="string">'postcss-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">'./'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    chunkFilename:<span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = devConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-source-map'</span>,</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">2</span>,</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">          <span class="string">'postcss-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    minimizer:[</span><br><span class="line">      <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename:<span class="string">'[name].css'</span>,</span><br><span class="line">      chunkFilename:<span class="string">'[name].chunk.css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">'./'</span>,</span><br><span class="line">    filename: <span class="string">'[name].[contenthash].js'</span>,</span><br><span class="line">    chunkFilename:<span class="string">'[name].[contenthash].js'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = prodConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> merge =<span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> devConfig = <span class="built_in">require</span>(<span class="string">'./webpack.dev.js'</span>);</span><br><span class="line"><span class="keyword">const</span> prodConfig = <span class="built_in">require</span>(<span class="string">'./webpack.prod.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonConfig = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">      use:[&#123;</span><br><span class="line">        loader:<span class="string">'babel-loader'</span></span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        loader:<span class="string">'imports-loader?this=&gt;window'</span></span><br><span class="line">      &#125;]</span><br><span class="line">      </span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          outputPath: <span class="string">'images/'</span>,</span><br><span class="line">          limit: <span class="number">2048</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(eot|ttf|svg|woff)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'src/index.html'</span> &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">      cleanOnceBeforeBuildPatterns:[path.resolve(__dirname,<span class="string">'../dist'</span>)],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">      _:<span class="string">'lodash'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    usedExports:<span class="literal">true</span>,</span><br><span class="line">    splitChunks:&#123;</span><br><span class="line">      chunks:<span class="string">'all'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">env</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(env &amp;&amp; env.production)&#123;</span><br><span class="line">    <span class="keyword">return</span> merge(commonConfig,prodConfig)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> merge(commonConfig,devConfig)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Library-的打包"><a href="#Library-的打包" class="headerlink" title="Library 的打包"></a>Library 的打包</h2><p>简单配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  externals: [<span class="string">'lodash'</span>],</span><br><span class="line">  output: &#123;</span><br><span class="line">    path:path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">    filename:<span class="string">'library.js'</span>,</span><br><span class="line">    <span class="comment">// 可以通过 script src=library.js 来引用这个库</span></span><br><span class="line">    library:<span class="string">'library'</span>,</span><br><span class="line">    <span class="comment">// 通用打包 CommonJS 或者 UMD，上面文件的挂载处（可以为this 或者 window）</span></span><br><span class="line">    libraryTarget:<span class="string">'umd'</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PWA-Progressive-Web-Application-的打包"><a href="#PWA-Progressive-Web-Application-的打包" class="headerlink" title="PWA(Progressive Web Application) 的打包"></a>PWA(Progressive Web Application) 的打包</h2><p>网站在被访问过一次之后，如果服务器挂掉了，浏览器还可以利用缓存来访问这个网站。</p><p>workbox-webpack-plugin</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 webpack.prod.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> WorkboxPlugin.GenerateSW(&#123;</span><br><span class="line">            clientsClaim:<span class="literal">true</span>,</span><br><span class="line">            skipWaiting:<span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后打包编译的是时候会生成多一个 service-worker.js 文件，在项目中运用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator)&#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'/service-worker.js'</span>).then(<span class="function"><span class="params">registration</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'service-worker registed'</span>);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'service-worker register error'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样配置之后，当用户访问过一次网站之后便会进行缓存，如果当服务器挂掉的时候，用户还是可以在浏览器访问到网站</p><h2 id="TypeScript-的打包配置"><a href="#TypeScript-的打包配置" class="headerlink" title="TypeScript 的打包配置"></a>TypeScript 的打包配置</h2><p>webpack基本配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">'production'</span>,</span><br><span class="line">    entry:<span class="string">'./src/index.tsx'</span>,</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            test:<span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">            use:<span class="string">'ts-loader'</span>,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:<span class="string">'bundle.js'</span>,</span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'dist'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了webpack 配置之后，在 打包 ts 的时候还必须要配置一个 tsconfig.json</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    // 出口</span><br><span class="line">    "outDir": "./dist",</span><br><span class="line">    // 要处理的模块</span><br><span class="line">    "module": "es6",</span><br><span class="line">    // 编译成es5的</span><br><span class="line">    "target": "es5",</span><br><span class="line">    // 运行在文件中引入其他的js</span><br><span class="line">    "allowJs": true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要引入其他的库，例如 lodash ，需要安装对应的说明，@types/lodash ，具体的可以<a href="https://github.com/DefinitelyTyped/DefinitelyTyped">查看这里</a></p><h2 id="WebpackDevServer-1"><a href="#WebpackDevServer-1" class="headerlink" title="WebpackDevServer"></a>WebpackDevServer</h2><h3 id="开发环境实现请求代理转发"><a href="#开发环境实现请求代理转发" class="headerlink" title="开发环境实现请求代理转发"></a>开发环境实现请求代理转发</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本配置</span></span><br><span class="line"><span class="built_in">module</span>.exports =  &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">        open: <span class="literal">true</span>,</span><br><span class="line">        port: <span class="number">8080</span>,</span><br><span class="line">        hot: <span class="literal">true</span>,</span><br><span class="line">        hotOnly: <span class="literal">true</span>,</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/react/api'</span>: &#123;</span><br><span class="line">                <span class="comment">// 代理转发的url</span></span><br><span class="line">                target: <span class="string">'https://www.dell-lee.com/'</span>,</span><br><span class="line">                <span class="comment">// 当是 https 的时候可以设置这个参数</span></span><br><span class="line">                secure: <span class="literal">false</span>,</span><br><span class="line">                <span class="comment">// 拦截</span></span><br><span class="line">                bypass: <span class="function"><span class="keyword">function</span> (<span class="params">req, res, proxyOptions</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (req.headers.accept.indexOf(<span class="string">'html'</span>) !== <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">'Shipping proxy for browser request'</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">'/index.html'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// 路径重写</span></span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    <span class="string">'header.json'</span>: <span class="string">'demo.json'</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// 配置 headers 主机名与cookie 等等</span></span><br><span class="line">                headers:&#123;</span><br><span class="line">                    host:<span class="string">'xx'</span>,</span><br><span class="line">                    cookie:<span class="string">''</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://webpack.js.org/configuration/dev-server/#devserver">具体文档</a></p><p>底层是 <a href="https://github.com/webpack/webpack-dev-middleware">webpack-dev-middleware</a></p><h3 id="解决单页面应用路由问题"><a href="#解决单页面应用路由问题" class="headerlink" title="解决单页面应用路由问题"></a>解决单页面应用路由问题</h3><p>当配置路由发现找不到内容的时候，可以配置 <a href="https://webpack.js.org/configuration/dev-server#devserverhistoryapifallback">historyApiFallback</a></p><h2 id="ESLint-的配置"><a href="#ESLint-的配置" class="headerlink" title="ESLint 的配置"></a>ESLint 的配置</h2><p>先安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i eslint -D</span><br></pre></td></tr></table></figure><p>接着是初始化配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eslint -init</span><br></pre></td></tr></table></figure><p>采用目前流行 airbnb 的方式</p><p>会看到项目生成一个 .eslintrc.js</p><p>如果没有使用vscode 只能用 eslint src 命令行来查看错误信息</p><p>可以进行基本配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">"extends"</span>: <span class="string">"airbnb"</span>,</span><br><span class="line">    <span class="string">"parser"</span>: <span class="string">"babel-eslint"</span>,</span><br><span class="line">    <span class="string">"rules"</span>: &#123;</span><br><span class="line">        <span class="string">""</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    globals:&#123;</span><br><span class="line">        <span class="built_in">document</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="eslint-loader"><a href="#eslint-loader" class="headerlink" title="eslint-loader"></a>eslint-loader</h3><p>webpack 也有先关的配置，但是会影响打包的速度，一般会建议使用这种方式来配置。还是使用 vscode 的插件式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: [</span><br><span class="line">            &#123; <span class="attr">loader</span>: <span class="string">'babel-loader'</span> &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    <span class="comment">// 自动修复</span></span><br><span class="line">                    fix: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://webpack.js.org/loaders/eslint-loader">具体点击</a></p><p>devServer 配置 overlay 可以在页面提示错误信息</p><h2 id="webpack-性能优化"><a href="#webpack-性能优化" class="headerlink" title="webpack 性能优化"></a>webpack 性能优化</h2><p>1.升级工具的版本（node,npm,yarn）</p><p>2.loader（include/exclude）在尽可能少的模块上使用</p><p>3.plugin 尽可能精简可靠</p><p>4.resolve 参数合理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    resolve:&#123;</span><br><span class="line">        extensions:[<span class="string">'.js'</span>,<span class="string">'.jsx'</span>],</span><br><span class="line">       <span class="comment">// 使用别名</span></span><br><span class="line">        alias:&#123;</span><br><span class="line">            haha:path.resolve(__dirname,<span class="string">'../src/child/'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.使用 DllPlugin 提高打包速度</p><p>add-asset-html-webpack-plugin</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.dll.js</span></span><br><span class="line"><span class="comment">// 将共用的库放到一个文件里面去单独打包，用 library 暴露出来。然后用 webpack.DllPlugin 这个插件对这些库分析出一种文件关系映射.json 文件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack =<span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendors: [<span class="string">'lodash'</span>],</span><br><span class="line">    react: [<span class="string">'react'</span>, <span class="string">'react-dom'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dll'</span>),</span><br><span class="line">    library: <span class="string">'[name]'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      name:<span class="string">'[name]'</span>,</span><br><span class="line">      path:path.resolve(__dirname,<span class="string">'../dll/[name].manifest.json'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在webpack.common.js 文件里面配置（也可以只配置生产环境）,将上面生成文件挂载到 template index.html上面</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">            filepath:path.resolve(__dirname,<span class="string">'../dll/verndors.dll.js'</span>)</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">            filepath:path.resolve(__dirname,<span class="string">'../dll/react.dll.js'</span>)</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> webpack.DllRefercencePlugin(&#123;</span><br><span class="line">            mainfest:path.resolve(__dirname,<span class="string">'../dll/vendors.mainfest.json'</span>)</span><br><span class="line">        &#125;),</span><br><span class="line">                <span class="keyword">new</span> webpack.DllRefercencePlugin(&#123;</span><br><span class="line">            mainfest:path.resolve(__dirname,<span class="string">'../dll/react.mainfest.json'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进行优化自动注入</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> plugins = [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template:<span class="string">'src/index.html'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">      cleanOnceBeforeBuildPatterns: [path.resolve(__dirname, <span class="string">'../dist'</span>)],</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> files = fs.readdirSync(path.resolve(__dirname,<span class="string">'../dll'</span>))</span><br><span class="line">files.forEach(<span class="function"><span class="params">file</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/.*\.dll.js/</span>.test(file))&#123;</span><br><span class="line">        plugins.push(<span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">            filepath:path.resolve(__dirname,<span class="string">'../dll'</span>,file)</span><br><span class="line">        &#125;)) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/.*\.mainfest.json/</span>.test(file))&#123;</span><br><span class="line">        plugins.push(<span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">            filepath:path.resolve(__dirname,<span class="string">'../dll'</span>,file)</span><br><span class="line">        &#125;)) </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.控制包文件的大小</p><p>7.thread-loader,parallel-webpack,happypack 多进程打包</p><p>8.合理使用 sourceMap(信息越详细打包越久)</p><p>9.结合打包分析 stats.json 优化分析</p><p>10.开发环境内存编译，无用插件剔除</p><h2 id="多页面打包配置"><a href="#多页面打包配置" class="headerlink" title="多页面打包配置"></a>多页面打包配置</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">      main: <span class="string">'./src/index.js'</span>,</span><br><span class="line">      list: <span class="string">'./src/list.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123; </span><br><span class="line">          filename:<span class="string">'index.html'</span>,</span><br><span class="line">          template: <span class="string">'src/index.html'</span>,</span><br><span class="line">          chunks:[<span class="string">'runtime'</span>,<span class="string">'vendors'</span>,<span class="string">'main'</span>]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123; </span><br><span class="line">          filename:<span class="string">'list.html'</span>,</span><br><span class="line">          template: <span class="string">'src/index.html'</span>,</span><br><span class="line">          chunks:[<span class="string">'runtime'</span>,<span class="string">'vendors'</span>,<span class="string">'list'</span>]</span><br><span class="line">        &#125;),        </span><br><span class="line">    ] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="keyword">const</span> configs  = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    list: <span class="string">'./src/list.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 其他所有配置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> makePlugins = <span class="function">(<span class="params">configs</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> plugins = [<span class="string">'其他的plugins'</span>];</span><br><span class="line">    <span class="built_in">Object</span>.keys(configs.entry).forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        plugins.push(</span><br><span class="line">            <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">                template:<span class="string">'src/index.html'</span>,</span><br><span class="line">                filename:<span class="string">`<span class="subst">$&#123;item&#125;</span>.html`</span>,</span><br><span class="line">                chunks:[<span class="string">'runtime'</span>,<span class="string">'vendors'</span>,<span class="string">'item'</span>]</span><br><span class="line">            &#125;)</span><br><span class="line">        )</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上面优化的代码</span></span><br><span class="line">    <span class="keyword">const</span> files = fs.readdirSync(path.resolve(__dirname,<span class="string">'../dll'</span>))</span><br><span class="line">    files.forEach(<span class="function"><span class="params">file</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="regexp">/.*\.dll.js/</span>.test(file))&#123;</span><br><span class="line">            plugins.push(<span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">                filepath:path.resolve(__dirname,<span class="string">'../dll'</span>,file)</span><br><span class="line">            &#125;)) </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="regexp">/.*\.mainfest.json/</span>.test(file))&#123;</span><br><span class="line">            plugins.push(<span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">                filepath:path.resolve(__dirname,<span class="string">'../dll'</span>,file)</span><br><span class="line">            &#125;)) </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;)  </span><br><span class="line">    <span class="keyword">return</span> plugins;</span><br><span class="line">&#125;</span><br><span class="line">configs.plugins = makePlugins(configs);</span><br><span class="line"><span class="built_in">module</span>.export = configs;</span><br></pre></td></tr></table></figure><h2 id="如何编写一个-Loader"><a href="#如何编写一个-Loader" class="headerlink" title="如何编写一个 Loader"></a>如何编写一个 Loader</h2><h3 id="简单的实现"><a href="#简单的实现" class="headerlink" title="简单的实现"></a>简单的实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// replaceLoader.js </span></span><br><span class="line"><span class="comment">// loader-utils 是官方一个符合 loader 规范的工具</span></span><br><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> source.replace(<span class="string">'haha'</span>, <span class="string">'world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// replaceLoaderAsync.js </span></span><br><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">const</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = source.replace(<span class="string">'lbh'</span>, options.name);</span><br><span class="line">    callback(<span class="literal">null</span>, result);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello lbh'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// loader 的位置，先查找 node_modules 如果没有就往下找，那么自定义的 loader 就不用写全路径了</span></span><br><span class="line">  resolveLoader: &#123;</span><br><span class="line">    modules: [<span class="string">'node_modules'</span>, <span class="string">'./loaders'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js?$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">'replaceLoader.js'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'replaceLoaderAsync.js'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">'haha'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义 loader 的用途很多，可以拿来做一个简单的错误检验</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> source.replace(<span class="string">'haha'</span>, <span class="string">'world'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者是国际化,在相关页面弄一个占位符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Node全局变量 === <span class="string">'中文'</span>)&#123;</span><br><span class="line">       source.replace(<span class="string">'&#123;&#123;title&#125;&#125;'</span>, <span class="string">'中文标题'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       source.replace(<span class="string">'&#123;&#123;title&#125;&#125;'</span>, <span class="string">'engilsh title'</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以具体参数可以<a href="https://webpack.js.org/api/loaders">点击这里</a></p><h2 id="如何编写一个-Plugin"><a href="#如何编写一个-Plugin" class="headerlink" title="如何编写一个 Plugin"></a>如何编写一个 Plugin</h2><p>简单的实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugin/copyright-webpack-plugin</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CopyRightWebpackPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//compiler:webpack 的实例</span></span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">// 同步</span></span><br><span class="line">    compiler.hooks.compile.tap(<span class="string">'CopyRightWebpackPlugin'</span>, (compilation) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'compiler'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 异步</span></span><br><span class="line">    compiler.hooks.emit.tapAsync(<span class="string">'CopyRightWebpackPlugin'</span>, (compilation, cb) =&gt; &#123;</span><br><span class="line">      <span class="keyword">debugger</span>;</span><br><span class="line">      compilation.assets[<span class="string">'copyright.txt'</span>]=&#123;</span><br><span class="line">        source:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'copyright by hahaha'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        size:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cb();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = CopyRightWebpackPlugin;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> CopyRightWebpackPlugin = <span class="built_in">require</span>(<span class="string">'./plugin/copyright-webpack-plugin.js'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">'main'</span>: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CopyRightWebpackPlugin(&#123;</span><br><span class="line">      name:<span class="string">'haha'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"plugin"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack"</span>,</span><br><span class="line">    <span class="attr">"debug"</span>: <span class="string">"node --inspect --inspect-brk node_modules/webpack/bin/webpack.js"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.30.0"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>npm run debug </p><p>进入下一步，添加 watch compilation 可以对一些类似这样的参数进行调试观察</p><p>具体的可以<a href="https://webpack.js.org/api/compiler-hooks">点击这里</a></p><h2 id="Bundler-源码编写（模块分析）"><a href="#Bundler-源码编写（模块分析）" class="headerlink" title="Bundler 源码编写（模块分析）"></a>Bundler 源码编写（模块分析）</h2><p>文件目录src 下面有三个文件，分别是 index.js message.js word.js ，引用关系是从左到右导入下一个的文件，具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// word.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> word = <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// message.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; word &#125; <span class="keyword">from</span> <span class="string">'./word.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">`say <span class="subst">$&#123;word&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> message; </span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> message <span class="keyword">from</span> <span class="string">'./message.js'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本配置</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">'@babel/parser'</span>);</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">'@babel/traverse'</span>).default;</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'@babel/core'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口文件的分析</span></span><br><span class="line"><span class="keyword">const</span> moduleAnalyser = <span class="function">(<span class="params">filename</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> content = fs.readFileSync(filename, <span class="string">'utf-8'</span>);</span><br><span class="line">  <span class="comment">// 抽象语法树</span></span><br><span class="line">  <span class="keyword">const</span> ast = parser.parse(content, &#123;</span><br><span class="line">    sourceType: <span class="string">'module'</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 依赖文件，键值对，键：依赖文件的相对路径，值：依赖文件的相对于bundler 的路径（绝对路径）</span></span><br><span class="line">  <span class="keyword">const</span> dependencies = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 分析抽象语法树</span></span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    <span class="comment">// 入口声明</span></span><br><span class="line">    ImportDeclaration(&#123; node &#125;) &#123;</span><br><span class="line">      <span class="comment">// 路径转换</span></span><br><span class="line">      <span class="keyword">const</span> dirname = path.dirname(filename);</span><br><span class="line">      <span class="keyword">const</span> newFile = <span class="string">'./'</span> + path.join(dirname, node.source.value)</span><br><span class="line">      dependencies[node.source.value] = newFile</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 抽象语法树的转换，提取可以在浏览器运行的代码</span></span><br><span class="line">  <span class="keyword">const</span> &#123; code &#125; = babel.transformFromAst(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">    <span class="comment">// 插件的集合</span></span><br><span class="line">    presets: [<span class="string">"@babel/preset-env"</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    filename,</span><br><span class="line">    dependencies,</span><br><span class="line">    code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依赖图谱</span></span><br><span class="line"><span class="keyword">const</span> makeDependenciesGraph = <span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> entryModule = moduleAnalyser(entry)</span><br><span class="line">  <span class="keyword">const</span> graphArray = [entryModule];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; graphArray.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = graphArray[i];</span><br><span class="line">    <span class="comment">// 获取依赖关系</span></span><br><span class="line">    <span class="keyword">const</span> &#123; dependencies &#125; = item;</span><br><span class="line">    <span class="keyword">if</span> (dependencies) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j <span class="keyword">in</span> dependencies) &#123;</span><br><span class="line">        graphArray.push(</span><br><span class="line">          moduleAnalyser(dependencies[j])</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 格式转换</span></span><br><span class="line">  <span class="keyword">const</span> graph = &#123;&#125;</span><br><span class="line">  graphArray.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    graph[item.filename] = &#123;</span><br><span class="line">      dependencies: item.dependencies,</span><br><span class="line">      code: item.code</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成浏览器可以用的代码</span></span><br><span class="line"><span class="keyword">const</span> generateCode = <span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 转为字符串</span></span><br><span class="line">  <span class="keyword">const</span> graph = <span class="built_in">JSON</span>.stringify(makeDependenciesGraph(entry));</span><br><span class="line">  <span class="comment">// graph code 里面有 exports 跟 require 的方法,但是浏览器没有这两个函数，需要我们自己去实现</span></span><br><span class="line">  <span class="built_in">console</span>.log(graph);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">  (function (graph) &#123;</span></span><br><span class="line"><span class="string">    function require(module) &#123;</span></span><br><span class="line"><span class="string">      function localRequire(relativePath) &#123;</span></span><br><span class="line"><span class="string">        return require(graph[module].dependencies[relativePath])</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      var exports = &#123;&#125;;</span></span><br><span class="line"><span class="string">      (function (require, exports, code) &#123;</span></span><br><span class="line"><span class="string">        eval(code)</span></span><br><span class="line"><span class="string">      &#125;)(localRequire, exports, graph[module].code);</span></span><br><span class="line"><span class="string">      return exports;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    require('<span class="subst">$&#123;entry&#125;</span>')</span></span><br><span class="line"><span class="string">  &#125;)(<span class="subst">$&#123; graph&#125;</span>)</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Info = generateCode(<span class="string">'./src/index.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Info);</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node bundler.js | highlight</span><br></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">graph</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">module</span>) </span>&#123; <span class="comment">// ./message.js 通过相对路径来拿到绝对路径</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">localRequire</span>(<span class="params">relativePath</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">require</span>(graph[<span class="built_in">module</span>].dependencies[relativePath])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> exports = &#123;&#125;;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, code</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">eval</span>(code)</span><br><span class="line">    &#125;)(localRequire, exports, graph[<span class="built_in">module</span>].code);</span><br><span class="line">    <span class="keyword">return</span> exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./src/index.js'</span>)</span><br><span class="line">&#125;)(&#123;<span class="string">"./src/index.js"</span>:&#123;<span class="string">"dependencies"</span>:&#123;<span class="string">"./message.js"</span>:<span class="string">"./src\\message.js"</span>&#125;,<span class="string">"code"</span>:<span class="string">"\"use strict\";\n\nvar _message = _interopRequireDefault(require(\"./message.js\"));\n\nfunction _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; \"default\": obj &#125;; &#125;\n\nconsole.log(_message[\"default\"]);"</span>&#125;,<span class="string">"./src\\message.js"</span>:&#123;<span class="string">"dependencies"</span>:&#123;<span class="string">"./word.js"</span>:<span class="string">"./src\\word.js"</span>&#125;,<span class="string">"code"</span>:<span class="string">"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", &#123;\n  value: true\n&#125;);\nexports[\"default\"] = void 0;\n\nvar _word = require(\"./word.js\");\n\nvar message = \"say \".concat(_word.word);\nvar _default = message;\nexports[\"default\"] = _default;"</span>&#125;,<span class="string">"./src\\word.js"</span>:&#123;<span class="string">"dependencies"</span>:&#123;&#125;,<span class="string">"code"</span>:<span class="string">"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", &#123;\n  value: true\n&#125;);\nexports.word = void 0;\nvar word = 'hello';\nexports.word = word;"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>复制粘贴到浏览器便可以运行</p><p>graph 输出内容是</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"./src/index.js"</span>: &#123;</span><br><span class="line">    <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">      <span class="attr">"./message.js"</span>: <span class="string">"./src\\message.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"code"</span>: <span class="string">"\"use strict\";\n\nvar _message = _interopRequireDefault(require(\"./message.js\"));\n\nfunction _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; \"default\": obj &#125;; &#125;\n\nconsole.log(_message[\"default\"]);"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"./src\\message.js"</span>: &#123;</span><br><span class="line">    <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">      <span class="attr">"./word.js"</span>: <span class="string">"./src\\word.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"code"</span>: <span class="string">"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", &#123;\n  value: true\n&#125;);\nexports[\"default\"] = void 0;\n\nvar _word = require(\"./word.js\");\n\nvar message = \"say \".concat(_word.word);\nvar _default = message;\nexports[\"default\"] = _default;"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"./src\\word.js"</span>: &#123;</span><br><span class="line">    <span class="attr">"dependencies"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"code"</span>: <span class="string">"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", &#123;\n  value: true\n&#125;);\nexports.word = void 0;\nvar word = 'hello';\nexports.word = word;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 code 里面的内容有一个require 函数和一个 exports 对象，所以为了这些代码能够在浏览器运行，我们需要自己创建一个 require函数和exports 空对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://coding.imooc.com/learn/list/316.html&quot;&gt;DellLee 老师的 webpack 学习与记录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;知识点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Loader&lt;/code&gt; 
      
    
    </summary>
    
      <category term="webpack" scheme="http://laibh.top/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://laibh.top/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题目汇总摘录（浏览器与性能基础篇）</title>
    <link href="http://laibh.top/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E6%91%98%E5%BD%95-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87.html"/>
    <id>http://laibh.top/前端面试题目汇总摘录-浏览器基础篇.html</id>
    <published>2019-04-08T01:30:54.000Z</published>
    <updated>2020-07-11T03:24:57.647Z</updated>
    
    <content type="html"><![CDATA[<p>温故而知新，保持空杯心态.续 <a href="https://yuchengkai.cn/docs/frontend">前端面试之道</a>继续复习浏览器相关内容</p><h2 id="浏览器基础"><a href="#浏览器基础" class="headerlink" title="浏览器基础"></a>浏览器基础</h2><h3 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h3><h4 id="事件触发三阶段"><a href="#事件触发三阶段" class="headerlink" title="事件触发三阶段"></a>事件触发三阶段</h4><ul><li>window 往事件 触发处传播，遇到注册的捕获事件会触发</li><li>传播到事件触发处时触发注册的事件</li><li>从事件触发处往 window 传播，遇到注册的冒泡事件会触发</li></ul><p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面会先打印冒泡然后捕获</span></span><br><span class="line">node.addEventListener(</span><br><span class="line">    <span class="string">'click'</span>,</span><br><span class="line">    event =&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">node.addEventListener(</span><br><span class="line"><span class="string">'click'</span>,</span><br><span class="line">    event =&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'捕获'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">true</span>    </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h4><p>addEventListener 注册事件，改函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false。useCapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用下面几个属性：</p><ul><li>capture ，布尔值，和 useCapture 作用一样</li><li>once,布尔值，值为 true 表示该回调值调用一次，调用后会移除监听</li><li>passive，布尔值，表示永远不会调用 preventDefault</li></ul><p>如果我们希望事件只触发在目标上，可以调用 stopPropagation 来阻止事件的进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation 同样也可以实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">node.addEventListener(</span><br><span class="line">    <span class="string">'click'</span>,</span><br><span class="line">    event =&gt;&#123;</span><br><span class="line">        event.stopImmediatePropagation()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 点击 node 只会执行上面的函数，下面的不会执行</span></span><br><span class="line">node.addEventListener(</span><br><span class="line">    <span class="string">'click'</span>,</span><br><span class="line">    event =&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'捕获'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h4><p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#ul'</span>);</span></span><br><span class="line"><span class="javascript">    ul.addEventListener(<span class="string">'click'</span>,event=&gt;&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.target);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>事件代理的方法相对于直接给目标注册事件来说，有以下优点：</p><ul><li>节省内存</li><li>不需要给子节点注销事件</li></ul><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSONP 原理很简单，就是利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。通过 <code>&lt;script&gt;</code> 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯的时候</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(data)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JSONP 使用简单且兼容性不错，但是只限于 get 请求</p><p>在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP ，下面是简单的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url,jsonpCallback,success</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.src = url;</span><br><span class="line">    script.async = <span class="literal">true</span>;</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span></span><br><span class="line">    <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        success &amp;&amp; success(data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">jsonp(<span class="string">'http://xxx'</span>,<span class="string">'callback'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>CORS 需要浏览器和后端同时支持，IE8 和 9 需要通过 XDomainRequest 来实现</p><p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端，只要后端实现了 CORS 就实现了跨域。</p><p>服务端设置了 Access-Control-Allow-Origin 就可以开启 CORS ,该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都是可以访问资源的。</p><p>会在发送请求时出现两种情况，分别为简单请求和复杂请求</p><p><strong>简单请求</strong></p><p>以Ajax 为例，当满足下面的条件的时候会触发简单请求</p><p>1.使用 Get,HEAD,POST </p><p>2.Content-type 的值仅限 text/plain,multipart/form-data,application/x-www-form-urlencoded 之一</p><p>请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器，也可以使用 XMLHttpRequest.upload 属性访问</p><p><strong>复杂请求</strong></p><p>对于复杂的请求，首先会发起一个预检请求，该请求是 option 方法，通过该请求来指点服务端是否运行跨域请求。</p><p>对于预检请求，使用 Node 来设置 CORS 的话，可能会遇到一个坑，以 express 为例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Origin'</span>,<span class="string">'*'</span>)</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Methods'</span>,<span class="string">'PUT,POST,GET,DELETE,OPTIONS'</span>)</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-headers'</span>,<span class="string">'Origin,X-Requested-With,Content-Type,Accept,Authorization,Access-Control-Allow-Credentials'</span>)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的这个代码会验证 Authorization 子段，如果没有话的就会报错</p><p>当前端发起了复杂请求，返回的结果永远是报错的。因为预检请求也会进入到回调中，也会触发 next 方法，因为预检请求并不包含 Authorization 子弹，所以服务端也会报错。想要解决这个问题很简单，只要在 回调中过滤掉 option 就可以了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res.statusCode = <span class="number">204</span>;</span><br><span class="line">res.setHeader(<span class="string">'Content-Length'</span>,<span class="string">'0'</span>);</span><br><span class="line">res.send();</span><br></pre></td></tr></table></figure><h4 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h4><p>该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。</p><p>只需要给页面添加 document.domian = ‘test.com’ 表示二级域名都相同就可以实现跨域</p><h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h4><p>这种方式通常用于获取嵌入页面中的第三方页面数据，一个页面发送消息，另一个页面判断来源并接受消息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息端</span></span><br><span class="line"><span class="built_in">window</span>.parent.postMessage(<span class="string">'message'</span>,<span class="string">'http://test.com'</span>);</span><br><span class="line"><span class="comment">// 接受消息端</span></span><br><span class="line"><span class="keyword">const</span> mc = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">mc.addEventListener(<span class="string">'message'</span>,event=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> origin = event.origin || event.originalEvent.origin;</span><br><span class="line">    <span class="keyword">if</span>(origin === <span class="string">'http://test.com'</span>)&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'验证通过'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h3><p>JS 是门非阻塞单线程语言</p><p>JS 在执行过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task(有多种 task) 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure><p>以上代码虽然 <code>setTimeout</code> 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第二个参数不得小于 4 毫秒，不足会自动增加。所以 <code>setTimeout</code> 还是会在 <code>script end</code> 之后打印。</p><p>不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 <code>jobs</code>，macrotask 称为 <code>task</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure><p>微任务包括 <code>process.nextTick</code> ，<code>promise</code> ，<code>Object.observe</code> ，<code>MutationObserver</code></p><p>宏任务包括 <code>script</code> ， <code>setTimeout</code> ，<code>setInterval</code> ，<code>setImmediate</code> ，<code>I/O</code> ，<code>UI rendering</code></p><p>宏任务中包括了 <code>script</code> ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。</p><p>正确的一次 Event Loop 顺序是这样的</p><ol><li>执行同步代码，属于宏观任务</li><li>执行栈为空，查询是否有微任务需要执行</li><li>执行所有微任务</li><li>必要的话渲染 UI</li><li>然后开始下一轮 Event Loop ，执行宏任务中的异步代码</li></ol><p>如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的界面响应，可以把操作 DOM 放入 微任务中。</p><h4 id="Node-的-Event-loop"><a href="#Node-的-Event-loop" class="headerlink" title="Node 的 Event loop"></a>Node 的 Event loop</h4><p>Node 中的 Event loop 和浏览器的不相同</p><p>Node 中的 Event loop 分成了6个阶段，它们会按照顺序反复执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><h4 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h4><p>timer 阶段会执行 setTimeout 和 setInterval</p><p>一个 timer 指定的时间并不是准确的时间，而是达到这个事件后尽快执行回调，可能会因为系统正在执行别的事务而延迟</p><p>下限的时间有一个范围：[1,2147483647]，如果设置的时间不在范围内，将被设置为 1.</p><h4 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h4><p>I/O 阶段会执行除了 close 事件，定时器和 setImmediate 的回调</p><h4 id="idle-prepare"><a href="#idle-prepare" class="headerlink" title="idle,prepare"></a>idle,prepare</h4><p>idle，prepare 阶段内部实现</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll 阶段很重要，在这一阶段中，系统会做两件事情</p><ol><li>执行到点的定时器</li><li>执行 poll 队列中的事件</li></ol><p>并且当 poll 中没有定时器的情况下，会发现以下两件事情</p><ul><li>如果poll队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制</li><li>如果poll队列为空,会发生两件事情<ul><li>如果有 setImmediate 需要执行的时候，poll 阶段会停止并且进入到 check 阶段执行 setImmediate</li><li>如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调</li></ul></li></ul><h4 id="check"><a href="#check" class="headerlink" title="check"></a>check</h4><p>check 阶段执行 setImmediate</p><h4 id="close-callbacks"><a href="#close-callbacks" class="headerlink" title="close callbacks"></a>close callbacks</h4><p>close callbacks 阶段执行 close 事件</p><p>并且在 Node 中，有些情况下的定时器执行顺序是随机的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>); </span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这里可能会输出 setTimeout，setImmediate</span></span><br><span class="line"><span class="comment">// 可能也会相反的输出，这取决于性能</span></span><br><span class="line"><span class="comment">// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate</span></span><br><span class="line"><span class="comment">// 否则会执行 setTimeout</span></span><br></pre></td></tr></table></figure><p>当然在这种情况下，执行顺序是相同的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 因为 readFile 的回调在 poll 中执行</span></span><br><span class="line"><span class="comment">// 发现有 setImmediate ，所以会立即跳到 check 阶段执行回调</span></span><br><span class="line"><span class="comment">// 再去 timer 阶段执行 setTimeout</span></span><br><span class="line"><span class="comment">// 所以以上输出一定是 setImmediate，setTimeout</span></span><br></pre></td></tr></table></figure><p>上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码在浏览器和 node 中打印情况是不同的</span></span><br><span class="line"><span class="comment">// 浏览器中一定打印 timer1, promise1, timer2, promise2</span></span><br><span class="line"><span class="comment">// node 中可能打印 timer1, timer2, promise1, promise2</span></span><br><span class="line"><span class="comment">// 也可能打印 timer1, promise1, timer2, promise2</span></span><br></pre></td></tr></table></figure><p>Node 中的 <code>process.nextTick</code> 会先于其他 microtask 执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// nextTick, timer1, promise1</span></span><br></pre></td></tr></table></figure><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><h4 id="cookie-localStorage-sessionStorage-indexDB"><a href="#cookie-localStorage-sessionStorage-indexDB" class="headerlink" title="cookie,localStorage,sessionStorage,indexDB"></a>cookie,localStorage,sessionStorage,indexDB</h4><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:center">cookie</th><th style="text-align:center">localStorage</th><th style="text-align:center">sessionStorage</th><th style="text-align:center">indexDB</th></tr></thead><tbody><tr><td style="text-align:left">数据生命周期</td><td style="text-align:center">一般由服务器生成，可以设置过期时间</td><td style="text-align:center">除非被清理，否则一直都在</td><td style="text-align:center">页面关闭就清理</td><td style="text-align:center">除非被处理，否则一直都在</td></tr><tr><td style="text-align:left">数据存储大小</td><td style="text-align:center">4K</td><td style="text-align:center">5M</td><td style="text-align:center">5M</td><td style="text-align:center">无限</td></tr><tr><td style="text-align:left">与服务端通信</td><td style="text-align:center">每次都会携带在 header 中，对于请求性能影响</td><td style="text-align:center">不参与</td><td style="text-align:center">不参与</td><td style="text-align:center">不参与</td></tr></tbody></table><p>cookie 不建议用于存储，如果没有大量的数据存储需求的话，可以使用 localStorage 和 sessionStorage。对于不怎么改变的数据使用 localStorage 存储，否则可以用 sessionStorage 存储。</p><p>对于 cookie 我们还需要 注意安全性</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>value</td><td>如果用于保存用户登录状态，应该将该值加密，不能使用明文的用户标识</td></tr><tr><td>http-only</td><td>不能通过 JS 访问 Cookie，减少 XSS 攻击</td></tr><tr><td>secure</td><td>只能在协议为 HTTPS 的请求中携带</td></tr><tr><td>same-site</td><td>规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击</td></tr></tbody></table><h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><blockquote><p>Service Worker 是运行在浏览器后面的独立线程，一般可以用来实现缓存功能，使用 Service Worker 传输协议必须为 HTTPS，以为 Service Worker 中涉及到拦截，所以必须使用 HTTPS 协议来保障安全。</p><p>Service Worker 实现缓存功能一般分成三个步骤：首先你需要先注册 Service Worker ，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查找是否存在缓存。，存在缓存的话就可以直接读取缓存文件，否则就去请求数据，下面是这个步骤的实现：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">if</span>(navigator.serviceWorker)&#123;</span><br><span class="line">   navigator.serviceWorker.register(<span class="string">'sw.js'</span>)</span><br><span class="line">     .then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'service worker 注册成功'</span>);</span><br><span class="line">   &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'service worker 注册失败'</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sw.js</span></span><br><span class="line"><span class="comment">// 监听 install 事件，回调中缓存所需文件</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>,e=&gt;&#123;</span><br><span class="line">    e.waitUntil(</span><br><span class="line">        caches.open(<span class="string">'my-cache'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cache.addAll([<span class="string">'./index.html'</span>,<span class="string">'./index.js'</span>])</span><br><span class="line">        &#125;);</span><br><span class="line">    )</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截所有请求</span></span><br><span class="line"><span class="comment">// 如果缓存中已经有请求的数据就直接用缓存，否则就去请求数据</span></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>,e=&gt;&#123;</span><br><span class="line">    e.respondWith(</span><br><span class="line">        cache.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(response) <span class="keyword">return</span> response;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'fetch source'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个内容在 我的一篇 webpack4.x从基础到实战笔记中也有提及</p><h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>性能优化领域相关面试题目</p><p>缓存是性能优化中简单高效的一种优化方式，可以显著减少网络传输带来的损耗</p><p>对于一个数据来说，可以分成网络请求，后端处理，浏览器响应三个步骤。浏览器缓存可以帮助我们在第一步和第三步中优化性能。如果直接使用缓存而不发起请求，或者发送了请求但是后端存储的数据和前端的一样，那么就没有必要再将数据回传过来，这样就减少了响应数据。</p><p>可以分几个部分来讲这个浏览器缓存机制：</p><h4 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h4><ol><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li><li>网络请求</li></ol><p><strong>Service Worker</strong></p><p>Service Worker 的缓存与浏览器中其他内建的缓存机制是不同的，它可以让我们自由控制缓存文件，如何匹配、读取缓存，并且缓存是持续性的。</p><p>当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</p><p><strong>Memory Cache</strong></p><p>Memory Cache 也就是内存中的缓存，读取内存中的数据肯定比磁盘的块。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放，一旦我们关闭了 Tag 页面，内存中的缓存也就被释放了。</p><p><strong>Dish Cache</strong></p><p>Disk Cache 也就是存储在硬盘中的缓存，读取速度是慢点，但是什么都能存储在磁盘中，与 Memory Cache 相比胜在容量和 存储时效性上面。</p><p>在所有浏览器中，Disk Cache 覆盖面基本是最大的，它会根据 HTTP Header 中的字段来判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且及时在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</p><p><strong>Push Cache</strong></p><p>Push Cache 是 HTTP/2 中的内容。当以上三种缓存都没有命中时才会被使用，并且缓存时间也很短暂，只会在会话 （session）中存在，一旦会话结束便会被释放。</p><ul><li>所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好</li><li>可以推送 <code>no-cache</code> 和 <code>no-store</code> 的资源</li><li>一旦连接被关闭，Push Cache 就被释放</li><li>多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存</li><li>Push Cache 中的缓存只能被使用一次</li><li>浏览器可以拒绝接受已经存在的资源推送</li><li><p>你可以给其他域名推送资源</p><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fjakearchibald.com%2F2017%2Fh2-push-tougher-than-i-thought%2F">HTTP/2 push is tougher than I thought</a> </p></li></ul><p><strong>网络请求</strong></p><p>如果所有缓存都没有命中的话，那么只能发起网络请求来获取资源了。</p><p>在性能上面考虑，大部分接口都应该选择好缓存策略</p><h4 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h4><p>通常浏览器的缓存策略分成两种，强缓存和协商缓存，并且缓存策略都是通过设置 HTTP  Header 来实现的。</p><p><strong>强缓存</strong></p><p>强缓存可以设置两种 HTTP Header 来实现：Expires 和 Cache-Control。强缓存表示在缓存期间不需要请求，state code 为 200</p><p><strong>Expires</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Expires</span>:  Sat,20,Apr 2019 10:06:00 GMT</span><br></pre></td></tr></table></figure><p>Expires 是 HTTP/1 的产物，表示资源会在 Sat,20,Apr 2019 10:06:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p><p><strong>Cache-Control</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control:max-age=30</span><br></pre></td></tr></table></figure><p>Cache-Control 出现于 HTTP/1.1，优先级高于 Expires，该属性值表示资源会在 30秒后过去，需要再次请求。</p><p>Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令。比如希望资源能被缓存下来，并且是客户端是代理服务器都能缓存，还能设置缓存失效时间等。</p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>public</td><td>表示响应可以被客户端和代理服务器缓存</td></tr><tr><td>private</td><td>表示响应只可以被客户端缓存</td></tr><tr><td>max-age=30</td><td>缓存30秒后失效，需要重新请求</td></tr><tr><td>s-maxage=30</td><td>覆盖 max-age 作用是一样的，只在代理服务器中生效</td></tr><tr><td>no-store</td><td>不缓存任何响应</td></tr><tr><td>no-cache</td><td>资源被缓存，但是立即失效，下次会发起请求验证资源是否过期</td></tr><tr><td>max-stale=30</td><td>30秒内，即使缓存失效了，也使用该缓存</td></tr><tr><td>min-fresh=30</td><td>希望30秒内获取最新的响应</td></tr></tbody></table><p><strong>协商缓存</strong></p><p>如果缓存过期了，就需要发起请求验证资源是否需要更新。协商缓存可以通过设置两种 Http header 来实现：Last-Modifier 和 ETag</p><p>当浏览器发起请求验证资源的时候，如果资源没有做改变，那么服务器就会返回 304 状态码，并且更新浏览器缓存的有效期。</p><p><strong>Last-Modified 和 If-Modified-Since</strong></p><p>Last-Modified 表示本地文件最后修改日期。If-Modifier-Since 会将 Last-Modifier 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码</p><p>但是 Last-Modifier 存在一些弊端：</p><ul><li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 <code>Last-Modified</code> 被修改，服务端不能命中缓存导致发送相同的资源</li><li>因为 <code>Last-Modified</code> 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li></ul><p>因为这些弊端所有出现了 ETag</p><p><strong>ETag 和 If-None-Match</strong></p><p>ETag 类似于文件指纹，If-None-Match 会将当前的 Etag 发送给服务器，询问该资源 ETag 是否发生了变化，如果有变动的话就将新的资源发送回来。并且 ETag 的优先级比 Last-Modifier 搞。</p><p>那么如果什么缓存策略都没有设置，浏览器会怎么处理？</p><p>对于这种情况，浏览器会采用一个启发式算法，通常会取响应头的 Date 减去 Last-Modifier 值的 10% 作为缓存时间。</p><h4 id="实际场景引用缓存策略"><a href="#实际场景引用缓存策略" class="headerlink" title="实际场景引用缓存策略"></a>实际场景引用缓存策略</h4><p><strong>频繁变动的资源</strong></p><p>首先使用 Cache-Control：no-cache 使得浏览器每次都请求服务器，然后配合 ETag 和 Last-Modifier 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小</p><p><strong>代码文件</strong></p><p>指除了 HTML 之外的代码的文件。因为HTML 文件一般不缓存或者缓存时间很短。</p><p>一般来说，都会使用打包工具，webpack 等等来对文件名进行哈希处理，只有当代码修改过后才会生成新的文件名。这样我们就可以给文件设置一个缓存有效期一年 Cache-Control:max-age=31536000 这样就只有当 HTML 文件引入的文件名发生了改变的时候才会去下载最新的代码文件，否则就会一直使用缓存。</p><h4 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h4><p>其实除了缓存的优化可以让性能显著提高，另外一个很重要点的是在开发阶段，尽量使用按需加载的原则来开发，增加代码的使用率从源头来优化性能，可能效果会更加显著。</p><h3 id="在浏览器地址栏键入-URL，按下回车之后会经历一下流程"><a href="#在浏览器地址栏键入-URL，按下回车之后会经历一下流程" class="headerlink" title="在浏览器地址栏键入 URL，按下回车之后会经历一下流程"></a>在浏览器地址栏键入 URL，按下回车之后会经历一下流程</h3><ol><li>解析 url 到 dns 服务器</li><li>dns 服务器返回 ip 地址到浏览器</li><li>跟随协议将 ip 发送到网络中</li><li>经过局域网达到服务器</li><li>进入服务器的 MVC 架构 controller</li><li>经过逻辑处理，请求分发，调用 Model</li><li>Model 与数据 进行交互，然后读取数据库，将结果通过 view 层返回到网络回到浏览器</li><li>浏览器根据请求回来的 html 和关联的css js 文件进行渲染</li><li>在渲染的过程中，浏览器根据 html 生成 dom 树，根据 css 生成 css 树</li><li>将 dom 树和 css 树进行整合，最终知道 dom 节点的样式，在页面上进行样式渲染</li><li>浏览器去执行 js 脚本</li><li>最终展示页面</li></ol><h3 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h3><h4 id="HTML-gt-DOM-树"><a href="#HTML-gt-DOM-树" class="headerlink" title="HTML=&gt;DOM 树"></a>HTML=&gt;DOM 树</h4><p>打开一个网页时，浏览器会去请求对应的 HTML 文件，拿到 JS/CSS/HTML  文件的字符串，但是计算机是不理解这些字符串的，在网络中传输的内容都是01 字节数据。当浏览器接收到这些字节数据后，它会将这些字节数据转换为字符串，也就是我们写的代码。</p><p>当数据被转换成字符以后，浏览器会将这些字符串通过词法分析转换为标记（Token），这一过程叫做标价化（tokenization）</p><p>打标记会将代码分成一块块，然后打上标记，便于理解这些最小单位的代码的含义。结束标记化后开始转换为 Node，最后这些 Node 会根据不同 Node 之间的联系构建为一颗 DOM 树</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字节数据 =&gt; 字符串 =&gt; Token =&gt; Node =&gt; DOM</span><br></pre></td></tr></table></figure><h4 id="CSS-gt-CSSDOM-树"><a href="#CSS-gt-CSSDOM-树" class="headerlink" title="CSS =&gt; CSSDOM 树"></a>CSS =&gt; CSSDOM 树</h4><p>与上面的过程是类似的。在这一过程中浏览器会确定下每一个节点的样式是什么，并且在这一过程中是很消耗资源的。浏览器得递归 CSSDOM 树，然后确定具体的元素到底是什么样式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字节数据 =&gt; 字符串 =&gt; Token =&gt; Node =&gt; CSSDOM</span><br></pre></td></tr></table></figure><h4 id="生成渲染树"><a href="#生成渲染树" class="headerlink" title="生成渲染树"></a>生成渲染树</h4><p>将 DOM 与 CSSOM 合并为一个渲染树</p><p>这一过程不是简单将两者结合，渲染树只会包括㤇显示的节点和这些节点样式信息，如果某个节点是 display:none 的，那么就不会在渲染树中显示</p><p>当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），然后调用 GPU 绘制，合成图层，显示在屏幕上。</p><h4 id="浏览器的渲染机制一般分成下面几个步骤"><a href="#浏览器的渲染机制一般分成下面几个步骤" class="headerlink" title="浏览器的渲染机制一般分成下面几个步骤"></a>浏览器的渲染机制一般分成下面几个步骤</h4><ol><li>处理 HTML 并构建 DOM 树</li><li>处理 CSS 构建 CSSOM 树</li><li>将 DOM 与 CSSOM 合并为一个渲染树</li><li>根据渲染树来布局，计算每个节点位置</li><li>调用 GPU 绘制，合成图层，显示在屏幕上</li></ol><h4 id="经典面试题目：插入几万个-DOM，如何实现页面不卡顿？"><a href="#经典面试题目：插入几万个-DOM，如何实现页面不卡顿？" class="headerlink" title="经典面试题目：插入几万个 DOM，如何实现页面不卡顿？"></a>经典面试题目：插入几万个 DOM，如何实现页面不卡顿？</h4><p>因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。</p><p>对于这道题目来说，首先我们肯定不能一次性把几万个 DOM 全部插入，这样肯定会造成卡顿，所以解决问题的重点应该是如何分批次部分渲染 DOM。大部分人应该可以想到通过 <code>requestAnimationFrame</code>的方式去循环的插入 DOM，其实还有种方式去解决这个问题：<strong>虚拟滚动</strong>（virtualized scroller）。</p><p><strong>这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。</strong></p><p>当我们滚动页面的时候就会实时去更新 DOM，这个技术就能顺利解决这道经典面试题。了解更多点击 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fbvaughn%2Freact-virtualized">react-virtualized</a>。</p><p><a href="https://juejin.im/post/5ca1ac256fb9a05e6938d2d1#heading-23">掘金上的方案</a></p><p>方案一：分页，懒加载，把数据分页，然后每次接受一定的数据，避免一次性接收太多</p><p>方案二：setInterval，setTimeout，requestAnimationFrame 分批渲染，让数据在不同帧内去做渲染</p><p>方案三：使用 virtual-scroll，虚拟滚动。</p><p>virtual-scroll 虚拟滚动，这种方式是指根据容器元素的高度以及列表项元素的高度来显示长列表数据中的某一个部分，而不是去完整地渲染长列表，以提高无限滚动的性能。</p><p>virtual-scroll 原理，在用户滚动时，改变列表可视区域的渲染部分</p><ul><li>计算当前可见区域起始数据的 startIndex</li><li>计算当前可见区域结束数据的 endIndex</li><li>计算当前可见区域的数据，并渲染到页面中</li><li>计算 startIndex 对应的数据在整个列表中的偏移位置 startOffset 并设置到列表上</li><li>计算 endIndex 对应的数据相对于可滚动区域最底部的偏移位置 endOffset，并设置到 列表上</li></ul><p>startOffset 和 endOffset 会撑开容器元素的内容高度，让其可持续的滚动；此外，还能保持滚动条处于一个正确的位置。</p><h4 id="阻塞渲染的情况"><a href="#阻塞渲染的情况" class="headerlink" title="阻塞渲染的情况"></a>阻塞渲染的情况</h4><p>首先渲染是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染，如果想要渲染更快，就应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。</p><p>然后当浏览器在解析到 script 标签的时候，会暂停构建 DOM ，完成之后才会从暂停的地方重新开始。也就是说，，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 <code>script</code> 标签放在 <code>body</code> 标签底部的原因。</p><p>也可以给 <code>script</code> 标签添加 <code>defer</code> 或者 <code>async</code> 属性。当 <code>script</code> 标签加上 <code>defer</code> 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 <code>script</code> 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 <code>async</code> 属性，表示 JS 文件下载和解析不会阻塞渲染。</p><h4 id="Load-和-DOMContentLoaded-区别"><a href="#Load-和-DOMContentLoaded-区别" class="headerlink" title="Load 和 DOMContentLoaded 区别"></a>Load 和 DOMContentLoaded 区别</h4><p>Load 事件触发代表页面中的 DOM ，CSS ，JS ,图片已经全部加载完毕</p><p>DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS 和图片加载.</p><h4 id="图层"><a href="#图层" class="headerlink" title="图层"></a>图层</h4><p>一般来说，可以把普通文档流看做是一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。</p><p>通常下面几个常用属性可以生成新图层</p><ul><li>3D 变换：translate3d，translateZ</li><li>will-change</li><li>video,iframe 标签</li><li>通过动画实现的 opacity 动画转换</li><li>position：fixed</li></ul><h4 id="重绘（Repaint）-和-回流（Reflow）"><a href="#重绘（Repaint）-和-回流（Reflow）" class="headerlink" title="重绘（Repaint） 和 回流（Reflow）"></a>重绘（Repaint） 和 回流（Reflow）</h4><p>重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。</p><ul><li>重绘是当节点需要更改外观而不影响布局的时候，比如改变 color ，就叫做重绘</li><li>回流是布局或者几何属性需要改变就成为回流</li></ul><p>回流必定会引起重绘，重绘不一定会引起回流。回流所需要的成本比重绘高德多，改变深层次的节点很可能会导致父节点的一系列回流。</p><p>所以一下几个动作可能会导致性能问题：</p><ul><li>改变 window 大小</li><li>改变字体</li><li>添加或者删除样式</li><li>文字改变</li><li>定位或者浮动</li><li>盒模型</li></ul><p>重绘和回流其实和 Event Loop 有关</p><ol><li>当 Event Loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为 浏览器是 60HZ 的刷新率，也就是 16.6ms 才会更新一次</li><li>判断是否有 resize 或者 scroll ，有点话就回去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。</li><li>判断是否触发了 media query</li><li>更新动画并且发送时间</li><li>判断是否有全屏操作事件</li><li>执行 requestAnimationFrame 回调</li><li>执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上面，但是兼容性不是很好</li><li>更新界面</li><li>以上就是一帧中可能会做的事情，如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调</li></ol><h4 id="减少重绘和回流"><a href="#减少重绘和回流" class="headerlink" title="减少重绘和回流"></a>减少重绘和回流</h4><p>使用 translate 替代 top</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'test'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.test</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">position</span><span class="selector-pseudo">:absolute</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">top</span><span class="selector-pseudo">:10px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span><span class="selector-pseudo">:red</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 引起回流</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.querySelector(<span class="string">'.test'</span>).style.top = <span class="string">'100px'</span>;</span></span><br><span class="line"><span class="undefined">    &#125;,1000);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 visibility 替代 display:none，因为前者只会引起重绘，后者会引起回流（改变了布局）</p><p>把 DOM 离线后修改。比如：先 把 DOM 给 display:none(有一次回流)，然后你修改100次，然后再把它显示出来。</p><p>不要把 DOM 结点的属性值放在一个循环里当做循环里的变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">    <span class="comment">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">'.test'</span>).style.offsetTop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要使用 table 布局，可能一个很小的改动都会造成整个 table 的重新布局</p><p>动画实现的速度的选择，动画速度越快，回流次数越多，也可以使用 requestAnimationFrame </p><p>CSS 选择符从右往左匹配查找，避免 DOM 深度过深</p><p>将频繁运行的动画变成图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变成图层</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><h4 id="DNS-预解析"><a href="#DNS-预解析" class="headerlink" title="DNS 预解析"></a>DNS 预解析</h4><p>DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//xxx.cn"</span>&gt;</span><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>缓存对于前端性能优化来说是一个重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。</p><p>通常浏览器缓存策略分成两种：强缓存和协商缓存。</p><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>实现强缓存可以通过两种响应头实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code 为 200</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires:Tue,09 Apr 2019 08:39:00 GMT</span><br></pre></td></tr></table></figure><p>Expires 是 HTTP/1.0 的产物，表示资源会在上述时间后过期，需要再次请求，并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-control:max-age=30</span><br></pre></td></tr></table></figure><p>Cache-control 出现于 HTTP/1.1 优先级高于 Expires。该属性表示自愿会在 30秒后过期，需要再次请求。</p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304,、</p><p>协商缓存需要客户和服务端共同实现，和强缓存一样，也有两种实现方式。</p><p><strong>Last-Modified 和 If-Modified-Since</strong></p><p>Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。</p><p>但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP/1.1 出现了 ETag</p><p><strong>ETag 和 If-None-Match</strong></p><p>ETag 类似于文件指纹，If-None-Match 会将 当前的 Etag 发送给服务器，询问该资源 Etag 是否变动，如果有变动的话就将新的资源发送回来，并且 ETag 优先级比 Last-Modified 高。</p><h4 id="选择合适的缓存策略"><a href="#选择合适的缓存策略" class="headerlink" title="选择合适的缓存策略"></a>选择合适的缓存策略</h4><p>对于大部分的场景都可以使用强缓存配合协商缓存来解决，但是有一些特殊的地方可能需要选择特殊的缓存策略：</p><ul><li>对于某些不需要缓存的资源，可以使用 Cache-control:no-store 来表示该资源不需要缓存</li><li>对于频繁变动的资源，可以使用 Cache-control:no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li><li>对于代码文件来说，通常使用 Cache-control:max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li></ul><h4 id="使用-HTTP-2-0"><a href="#使用-HTTP-2-0" class="headerlink" title="使用 HTTP/2.0"></a>使用 HTTP/2.0</h4><p>因为浏览器会有并发请求的限制，在 HTTP/1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间</p><p>在 HTTP/2.0 中引入了多路复用，能够让多个请求使用同个 TCP 链接，极大的加快了网页的加载速度。还支持 Header 压缩，进一步叫上了请求的数据大小</p><p>预加载</p><p>预加载是声明式的 fetch，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使用下面的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"xxx.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>预加载可以一定程度上降低首屏的时间，因为可以将一些不响应首屏但是重要的文件延后，唯一的缺点就是兼容性不好。</p><h4 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h4><p>可以通过预渲染将下载的文件预先在后台渲染，可以使用下面的代码开启：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">ref</span>=<span class="string">"prerender"</span> <span class="attr">href</span>=<span class="string">"xxx.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>预渲染可以提高页面的架子啊速度，但是要确保该页面百分之百会被用户之后打开，否则就白白浪费资源了。</p><h3 id="优先渲染过程"><a href="#优先渲染过程" class="headerlink" title="优先渲染过程"></a>优先渲染过程</h3><h4 id="懒执行"><a href="#懒执行" class="headerlink" title="懒执行"></a>懒执行</h4><p>懒执行就是将某些逻辑延后到使用时再计算。该即使可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的回调来唤醒</p><h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><p>懒加载就是将不关键的资源延后加载</p><p>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西，对于图片来说，先设置图片的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域的时候，就将自定义属性替换成 src 属性，这样图片就会下载资源，实现了图片的懒加载。</p><p>懒加载不仅可以用于图片，也可以使用在别的资源上，比如进入可视区域才开始播放视频等等。</p><h3 id="文件优化"><a href="#文件优化" class="headerlink" title="文件优化"></a>文件优化</h3><h4 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h4><h4 id="计算图片大小"><a href="#计算图片大小" class="headerlink" title="计算图片大小"></a>计算图片大小</h4><p>对于一张100*100 的像素的图片来说，有 10000 个像素点，如果每个像素点都是用 RGBA 存储的话，每个像素有四个通道，每个通道有 1 个字节（8位=1个字节），所以图片的大小大概为39KB（10000x1x4/1024）</p><p>但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来对应缩小图片的大小。</p><p>大致有两个思路：</p><ol><li>减少像素点</li><li>减少每个像素点能够显示的颜色</li></ol><h4 id="图片加载优化"><a href="#图片加载优化" class="headerlink" title="图片加载优化"></a>图片加载优化</h4><ol><li>不用图片，能用 CSS 显示的尽量不要使用图片</li><li>移动端来说，一般图片都用 CDN 加载，可以计算出适配屏幕宽度，然后去请求对应裁剪好的图片</li><li>小图使用 base64 格式</li><li>将多个图片整合在一张雪碧图</li><li>选择正确的图片格式<ol><li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为这个格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差别的图片质量，缺点就是兼容性不好。</li><li>小图使用 Png，其实对于大部分图标这种图片，可以使用 SVG 代替</li><li>照片使用 JPEG</li></ol></li></ol><h4 id="其他文件优化"><a href="#其他文件优化" class="headerlink" title="其他文件优化"></a>其他文件优化</h4><ul><li>CSS 文件放在 head 中</li><li>服务端开启文件压缩功能</li><li>将 script 标签放在 body 的底部，因为 JS 文件执行会阻塞渲染，当然也可以将 script 放在任何地方，然后加上 defer ,表示该文件并行下载，但是会放在 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件加上 async 表示加载和渲染文档元素的过程和 JS 文件的加载与执行并行无序进行</li><li>执行 JS 代码过长会卡住渲染，对于需要时间计算的代码可以考虑使用 Webworker 。它可以让我们另开一个线程执行脚本而不影响渲染。</li></ul><h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><p>静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意的是 CDN 域名要与主站不同，否在每次请求都会带上主站的 cookie</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="使用-Webpack-优化项目"><a href="#使用-Webpack-优化项目" class="headerlink" title="使用 Webpack 优化项目"></a>使用 Webpack 优化项目</h4><ul><li>对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩</li><li>使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码</li><li>优化图片，对于小图可以使用 base64 的方式写入文件中</li><li>按照路由拆分代码，实现按需加载</li><li>给打包出来的文件名添加哈希，实现浏览器缓存文件</li></ul><h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><p>对于代码运行错误，通常的办法是使用 <code>window.onerror</code> 拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外</p><ul><li>对于跨域的代码运行错误会显示 <code>Script error.</code> 对于这种情况我们需要给 <code>script</code> 标签添加 <code>crossorigin</code> 属性</li><li>对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 <code>arguments.callee.caller</code> 来做栈递归</li></ul><p>对于异步代码来说，可以使用 <code>catch</code> 的方式捕获错误。比如 <code>Promise</code> 可以直接使用 <code>catch</code> 函数，<code>async await</code> 可以使用 <code>try catch</code></p><p>但是要注意线上运行的代码都是压缩过的，需要在打包时生成 sourceMap 文件便于 debug。</p><p>对于捕获的错误需要上传给服务器，通常可以通过 <code>img</code> 标签的 <code>src</code> 发起一个请求。</p><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p><strong>如何渲染几万条数据并不卡住页面</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> total = <span class="number">100000</span>;</span><br><span class="line">  <span class="keyword">const</span> once = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">const</span> loopCount = total / once;</span><br><span class="line">  <span class="keyword">let</span> countOfRender = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 优化性能，插入不会造成回流</span></span><br><span class="line">    <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; once; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">      li.innerHTML = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * total);</span><br><span class="line">      fragment.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line">    ul.appendChild(fragment);</span><br><span class="line">    countOfRender += <span class="number">1</span>;</span><br><span class="line">    loop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (countOfRender &lt; loopCount) &#123;</span><br><span class="line">      <span class="built_in">window</span>.requestAnimationFrame(add);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  loop();</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p><strong>跨网站指令码</strong>（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程式的安全漏洞攻击，是<a href="https://www.wikiwand.com/zh-hans/%E4%BB%A3%E7%A2%BC%E6%B3%A8%E5%85%A5">代码注入</a>的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言。</p><p>XSS 分为三种：反射型，存储型和 DOM-based</p><h4 id="如何攻击"><a href="#如何攻击" class="headerlink" title="如何攻击"></a>如何攻击</h4><p>XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站</p><p>例如通过 URL 获取某些参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述 URL 输入可能会将 HTML 改为 <code>&lt;div&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/div&gt;</code> ，这样页面中就凭空多了一段可执行脚本。这种攻击类型是反射型攻击，也可以说是 DOM-based 攻击。</p><p>也有另一种场景，比如写了一篇包含攻击代码 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 的文章，那么可能浏览文章的用户都会被攻击到。这种攻击类型是存储型攻击，也可以说是 DOM-based 攻击，并且这种攻击打击面更广。</p><h4 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h4><p>最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    str = str.replace(<span class="regexp">/&amp;/g</span>,<span class="string">'&amp;amp;'</span>)</span><br><span class="line">    str = str.replace(<span class="regexp">/&lt;/g</span>,<span class="string">'&amp;lt;'</span>)</span><br><span class="line">    str = str.replace(<span class="regexp">/&gt;/g</span>,<span class="string">'&amp;gt;'</span>)</span><br><span class="line">    str = str.replace(<span class="regexp">/"/g</span>,<span class="string">'&amp;quto;'</span>) </span><br><span class="line">    str = str.replace(<span class="regexp">/'/g</span>,<span class="string">'&amp;#39;'</span>)</span><br><span class="line">    str = str.replace(<span class="regexp">/`/g</span>,<span class="string">'&amp;#96;'</span>)</span><br><span class="line">    str = str.replace(<span class="regexp">/\//g</span>,<span class="string">'&amp;#x2F;'</span>)</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过转义可以将攻击代码 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 变成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt;</span></span><br><span class="line"><span class="built_in">escape</span>(<span class="string">'&lt;script&gt;alert(1)&lt;/script&gt;'</span>)</span><br></pre></td></tr></table></figure><p>对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xss = <span class="built_in">require</span>(<span class="string">'xss'</span>)</span><br><span class="line"><span class="keyword">var</span> html = xss(<span class="string">'&lt;h1 id="title"&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert("xss");&lt;/script&gt;'</span>)</span><br><span class="line"><span class="comment">// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert("xss");&amp;lt;/script&amp;gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(html)</span><br></pre></td></tr></table></figure><p>以上示例使用了 <code>js-xss</code> 来实现。可以看到在输出中保留了 <code>h1</code> 标签且过滤了 <code>script</code> 标签</p><h4 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h4><p>内容安全策略 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/CSP">CSP</a>) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/XSS">XSS</a>) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。</p><p>我们可以通过 CSP 来尽量减少 XSS 攻击。CSP 本质上也是建立白名单，规定了浏览器只能够执行特定来源的代码。</p><p>通常可以通过 HTTP Header 中的 <code>Content-Security-Policy</code> 来开启 CSP</p><p>只允许加载本站资源</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy:default-src 'self'</span><br></pre></td></tr></table></figure><p>只允许加载 HTTPS 协议图片</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy:img-src https://*</span><br></pre></td></tr></table></figure><p>允许加载任何来源框架</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy:child-src 'none'</span><br></pre></td></tr></table></figure><p>更多属性可以查看 <a href="https://content-security-policy.com/">这里</a></p><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p><strong>跨站请求伪造</strong>（英语：Cross-site request forgery），也被称为 <strong>one-click attack</strong>或者 <strong>session riding</strong>，通常缩写为 <strong>CSRF</strong> 或者 <strong>XSRF</strong>， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。<a href="https://www.wikiwand.com/zh/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0#citenoteRistic1">[1]</a> 跟<a href="https://www.wikiwand.com/zh/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC">跨網站指令碼</a>（XSS）相比，<strong>XSS</strong> 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p><p>简单点说，CSRF 就是利用用户的登录态发起恶意请求。</p><h4 id="如何攻击-1"><a href="#如何攻击-1" class="headerlink" title="如何攻击"></a>如何攻击</h4><p>假设网站中有一个通过 Get 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.domain.com/xxx?comment='attack'"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>如果接口是 Post 提交的，就相对麻烦点，需要用表单来提交接口</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://www.domain.com/xxx"</span> <span class="attr">id</span>=<span class="string">"CSRF"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"comment"</span> <span class="attr">value</span>=<span class="string">"attack"</span> <span class="attr">type</span>=<span class="string">"hidden"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="如何防御-1"><a href="#如何防御-1" class="headerlink" title="如何防御"></a>如何防御</h4><p>防范 CSRF 可以遵循以下几种规则：</p><ol><li>Get 请求不对数据进行修改</li><li>不让第三方网站访问到用户的 Cookie</li><li>阻止第三方网站请求接口</li><li>请求时附带验证信息，比如验证码或者是 token</li></ol><p><strong>SameSite</strong></p><p>可以对 Cookie 设置 SameSite 属性，该属性设置 Cookie 不随着跨域请求发送，该属性可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容的</p><p><strong>验证 Referer</strong></p><p>对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的</p><p><strong>Token</strong></p><p>服务器下发一个随机 Token （算法不能复杂），每次发起请求时都将 Token 携带上，服务器验证 Token 是否有效</p><h3 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h3><p>是一种视觉欺骗的攻击手段</p><h4 id="如何攻击-2"><a href="#如何攻击-2" class="headerlink" title="如何攻击"></a>如何攻击</h4><p>攻击者将需要攻击的网站通过 <code>iframe</code> 嵌套的方式嵌入自己的网页中，并将 <code>iframe</code> 设置为透明，在页面中透出一个按钮诱导用户点击。</p><h4 id="如何防御-2"><a href="#如何防御-2" class="headerlink" title="如何防御"></a>如何防御</h4><p><strong>X-FRAME-OPTIONS</strong></p><p>是一个 HTTP 响应头，为了防御用 iframe 嵌套的点击劫持攻击。</p><p>可以设置三个值，分别是</p><ul><li>DENY,表示页面不允许通过 iframe 的方式来展示</li><li>SAMEORIGHT,表示页面在相同的域名下来通过 iframe 的方式展示</li><li>ALLOW-FROM,表示页面可以在指定来源的 iframe 中展示</li></ul><h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。</p><p>通常来说不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。</p><p>当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。</p><h3 id="密码安全"><a href="#密码安全" class="headerlink" title="密码安全"></a>密码安全</h3><h4 id="加盐"><a href="#加盐" class="headerlink" title="加盐"></a>加盐</h4><p>也就是给原来的密码添加字符串，增加原密码的长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sha256(sha1(md5(salt+password+salt)))</span><br></pre></td></tr></table></figure><p>但是加盐并不能阻止别人盗窃账号，只能确保即使数据库泄露，也不会暴露用户的真实密码。一旦攻击者得到了用户的账号，可以通过暴力破解的方式破解密码。对于这种情况，通常使用验证码增加延时或者限制尝试次数的方式。并且一旦用户输入了错误的密码，也不能直接提示用户输错密码，而是账号或者密码错误</p><h3 id="从-V8-中看性能优化"><a href="#从-V8-中看性能优化" class="headerlink" title="从 V8 中看性能优化"></a>从 V8 中看性能优化</h3><p>测试性能工具：Chrome Audits 以及 Perfomance</p><p>V8引擎引入了 TurboFan 编译器，会在特定的情况下进行优化，将代码编译成执行效率更高的 Machine  Code，当然这个编译器并不是 JS 必须需要的，只是为了提高代码执行性能，所以总的 来说 JS 更偏向于 解释型语言。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JavaScript Source Code =&gt; [Parser] =&gt; Abstract Syntax Tree =&gt; [interpreter Ignition ] =&gt; [Complier TurboFan]</span><br><span class="line">      ||       ||</span><br><span class="line">         ByteCode     &lt;=   Optimized Machine Code</span><br></pre></td></tr></table></figure><p>JS 会首先被解析为 AST ，解析过程比较慢，代码越多，解析的过程也就耗费越长，这也是我们为什么要压缩代码的原因。另外一个减少解析时间的方式是预解析，作用于未执行的函数。另外尽可能避免嵌套函数声明，可以避免重复解析。</p><p>Ignition 负责将 AST 转换为 Bytecode ,然后 TurboFan 负责编译优化后的 Machine Code，并 Machine Code 在执行效率上优于 Bytecode.</p><p>JS 是一门动态类型的语言，而且有一堆的规则，简单的加法运算代码，内容就要考虑好几种规则，比如数字相加、字符串相加、对象和字符串等等。这种情况就会导致内部要增加很多判断逻辑，降低运行效率。</p><p>如果固定了类型，就不需要执行很多判断逻辑，代码可以编译为 Machine Code。ts 的好处？</p><p>如果我们一旦传入的参数类型改变，那么 Machine Code 就会被 DeOptimized 为 ByteCode，这样就有性能上的一个损耗。所以我们如果希望diam能多的编译为 Machine Code 并且 DeOptimized 的次数减少，就应该尽可能保证传入的类型一致。</p><h2 id="框架通识"><a href="#框架通识" class="headerlink" title="框架通识"></a>框架通识</h2><h3 id="MVVM-View-Model-ViewModel"><a href="#MVVM-View-Model-ViewModel" class="headerlink" title="MVVM(View+Model+ViewModel)"></a>MVVM(View+Model+ViewModel)</h3><p>传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染，当有用户输入的时候，会通过控制器去更新模型，并且通知视图进行更新，但是 MVC 架构的一个巨大的缺项就是控制承担的责任太大了，随着项目的愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况。</p><p>MVVM 由三个内容组成：</p><ul><li>View：界面</li><li>Model：数据模型</li><li>ViewModel：作为桥梁负责沟通 View 和 Model</li></ul><p>在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合。</p><p>ViewModel 只关心数据和业务的处理，不关心 View 是怎么处理数据的，这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。以 Vue 框架为例子，ViewModel 就是组件的实例，View 就是模板，Model 在引入了 Vuex 的情况下是完全可以和组件分离的。在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定，在Vue 中，这个隐式的 Binder 层就是Vue 通过解析模板中的插值和指令从而实现 View 和 ViewModel 的绑定。</p><p>在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持。</p><h4 id="脏数据监测"><a href="#脏数据监测" class="headerlink" title="脏数据监测"></a>脏数据监测</h4><p>当触发了指定事件后会进入脏数据检测，这时会调用 <code>$digest</code> 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 <code>$watch</code> 函数，然后再次调用 <code>$digest</code> 循环直到发现没有变化。循环至少为二次 ，至多为十次。</p><p>脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数。所以低效也是相对的，这就仁者见仁智者见智了。</p><h4 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h4><p>Vue 内部使用了 <code>Object.defineProperty()</code> 来实现双向绑定，通过这个函数可以监听到 <code>set</code> 和 <code>get</code> 的事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;<span class="attr">name</span>:<span class="string">'yck'</span>&#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="keyword">let</span> name = data.name</span><br><span class="line">data.name = <span class="string">'yyy'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!obj || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">        defineReactive(obj,key,obj[key]);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj,key,val</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 递归子属性</span></span><br><span class="line">    observe(val);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">        enumerable:<span class="literal">true</span>,</span><br><span class="line">        configurable:<span class="literal">true</span>,</span><br><span class="line">        get:<span class="function"><span class="keyword">function</span> <span class="title">rectiveGetter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'get value'</span>);</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set:<span class="function"><span class="keyword">function</span> <span class="title">rectiveSetter</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'change value'</span>);</span><br><span class="line">            val = newVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码简单的实现了如何监听数据的 <code>set</code> 和 <code>get</code> 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在解析如上模板代码时，遇到 <code></code> 就会给属性 <code>name</code> 添加发布订阅。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过Dep 解耦</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.subs = []</span><br><span class="line">    &#125;</span><br><span class="line">    addSub(sub)&#123;</span><br><span class="line">        <span class="comment">// sub 是 Watcher 实例</span></span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">    notify()&#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span>=&gt;</span>&#123;</span><br><span class="line">            sub.update()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局属性，通过该属性配置 Watcher</span></span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>).innerText = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(obj,key,cb)&#123;</span><br><span class="line">        <span class="comment">// Dep.target 指向自己，然后触发属性的 getter 添加监听，最后将 Dep.target 置空</span></span><br><span class="line">        Dep.target = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">this</span>.cb = cb;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">        <span class="keyword">this</span>.value = obj[key]</span><br><span class="line">        Dep.target = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    update()&#123;</span><br><span class="line">        <span class="comment">// 获得新值</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.obj[<span class="keyword">this</span>.key];</span><br><span class="line">        <span class="comment">// 调用 update 方法更新 dom</span></span><br><span class="line">        <span class="keyword">this</span>.cb(<span class="keyword">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data = &#123;<span class="attr">name</span>:<span class="string">'yck'</span>&#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="comment">// 模拟解析到 &#123;&#123;name&#125;&#125; 触发的操作</span></span><br><span class="line"><span class="keyword">new</span> Watcher(data,<span class="string">'name'</span>,update)</span><br><span class="line"><span class="comment">// update dom innerHtml</span></span><br><span class="line">data.name = <span class="string">'yyy'</span></span><br></pre></td></tr></table></figure><p>接下来,对 <code>defineReactive</code> 函数进行改造</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj,key,val</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 递归子属性</span></span><br><span class="line">    observe(val)</span><br><span class="line">    <span class="keyword">let</span> db = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">        enumerable:<span class="literal">true</span>,</span><br><span class="line">        configurable:<span class="literal">true</span>,</span><br><span class="line">        get:<span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'get value'</span>);</span><br><span class="line">            <span class="comment">// 将 Watcher 添加到 订阅</span></span><br><span class="line">            <span class="keyword">if</span>(Dep.traget)&#123;</span><br><span class="line">               dp.addSub(Dep.target)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set:<span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'change value'</span>);</span><br><span class="line">            val = newVal;</span><br><span class="line">            <span class="comment">// 执行 watcher 的 update 方法</span></span><br><span class="line">            dp.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加。</p><h4 id="Proxy-与-Object-defineProperty-对比"><a href="#Proxy-与-Object-defineProperty-对比" class="headerlink" title="Proxy 与 Object.defineProperty 对比"></a>Proxy 与 Object.defineProperty 对比</h4><p><code>Object.defineProperty</code> 虽然已经能够实现双向绑定了，但是他还是有缺陷的。</p><ol><li>只能对属性进行数据劫持，所以需要深度遍历整个对象</li><li>对于数组不能监听到数据的变化</li></ol><p>虽然 Vue 中确实能检测到数组数据的变化，但是其实是使用了 hack 的办法，并且也是有缺陷的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"><span class="comment">// hack 以下几个函数</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获得原生函数</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用原生函数</span></span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// 触发更新</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>反观 Proxy 就没以上的问题，原生支持监听数组变化，并且可以直接对整个对象进行拦截，所以 Vue 也将在下个大版本中使用 Proxy 替换 Object.defineProperty</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> onWatch = <span class="function">(<span class="params">obj, setBind, getLogger</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">    get(target, property, receiver) &#123;</span><br><span class="line">      getLogger(target, property)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, property, value, receiver) &#123;</span><br><span class="line">      setBind(value)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, property, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> value</span><br><span class="line"><span class="keyword">let</span> p = onWatch(</span><br><span class="line">  obj,</span><br><span class="line">  v =&gt; &#123;</span><br><span class="line">    value = v</span><br><span class="line">  &#125;,</span><br><span class="line">  (target, property) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Get '<span class="subst">$&#123;property&#125;</span>' = <span class="subst">$&#123;target[property]&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">p.a = <span class="number">2</span> <span class="comment">// bind `value` to `2`</span></span><br><span class="line">p.a <span class="comment">// -&gt; Get 'a' = 2</span></span><br></pre></td></tr></table></figure><h4 id="路由原理"><a href="#路由原理" class="headerlink" title="路由原理"></a>路由原理</h4><p>前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式</p><ul><li>hash 模式</li><li>history 模式</li></ul><p><a href="http://www.text.com/##/">www.text.com/##/</a> 就是 Hash URL ，当 ## 后面的 哈希值发生变化的时候，不会向服务器请求数据，可以通过 hashchaneg 事件来监听到 URL 的变化，从而进行跳转页面。</p><p><img src="http://user-gold-cdn.xitu.io/2018/7/11/164888109d57995f?w=942&amp;h=493&amp;f=png&amp;s=39581" alt="hash 模式"></p><p>History 模式是 HTML5 新推出的功能，比之 Hash URL 更加美观</p><p><img src="http://user-gold-cdn.xitu.io/2018/7/11/164888478584a217?w=1244&amp;h=585&amp;f=png&amp;s=59637" alt="History 模式"></p><h3 id="Virtual-Dom"><a href="#Virtual-Dom" class="headerlink" title="Virtual Dom"></a>Virtual Dom</h3><h4 id="为什么需要-Virtual-Dom"><a href="#为什么需要-Virtual-Dom" class="headerlink" title="为什么需要 Virtual Dom"></a>为什么需要 Virtual Dom</h4><p>操作 DOM 是一件很耗费性能的事情，可以通过 JS 对象来模拟 DOM 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ul = &#123;</span><br><span class="line">    tag:<span class="string">'ul'</span>,</span><br><span class="line">    props:&#123;</span><br><span class="line">        class:'list'</span><br><span class="line">    &#125;,</span><br><span class="line">    children:&#123;</span><br><span class="line">        tag:<span class="string">'li'</span>,</span><br><span class="line">        children:<span class="string">'1'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="comment">/** &lt;ul class='list'&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;1&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设这里模拟一个 ul，其中包含了 5 个 li</span></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>][</span><br><span class="line">  <span class="comment">// 这里替换上面的 li</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>从上述例子中，我们一眼就可以看出先前的 ul 中的第三个 li 被移除了，四五替换了位置。</p><p>如果以上操作对应到 DOM 中，那么就是以下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除第三个 li</span></span><br><span class="line">ul.childNodes[<span class="number">2</span>].remove()</span><br><span class="line"><span class="comment">// 将第四个 li 和第五个交换位置</span></span><br><span class="line"><span class="keyword">let</span> fromNode = ul.childNodes[<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> toNode = node.childNodes[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> cloneFromNode = fromNode.cloneNode(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">let</span> cloenToNode = toNode.cloneNode(<span class="literal">true</span>)</span><br><span class="line">ul.replaceChild(cloneFromNode, toNode)</span><br><span class="line">ul.replaceChild(cloenToNode, fromNode)</span><br></pre></td></tr></table></figure><p>当然在实际操作中，我们还需要给每个节点一个标识，作为判断是同一个节点的依据。所以这也是 Vue 和 React 中官方推荐列表里的节点使用唯一的 <code>key</code> 来保证性能。</p><p>那么既然 DOM 对象可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM</p><p>以下是一个 JS 对象模拟 DOM 对象的简单实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @param &#123;String&#125; tag 'div'</span></span><br><span class="line"><span class="comment">  * @param &#123;Object&#125; props &#123;class:'item'&#125;</span></span><br><span class="line"><span class="comment">  * @param &#123;Array&#125; child [Element1,'text]</span></span><br><span class="line"><span class="comment">  * @param &#123;String&#125; key option</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">constructor</span>(tag, props, children, key) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tag = tag;</span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.children = children;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isString(children)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.key = children;</span><br><span class="line">      <span class="keyword">this</span>.children = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key) <span class="keyword">this</span>.key = key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 渲染</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> root = <span class="keyword">this</span>._createElement(</span><br><span class="line">      <span class="keyword">this</span>.tag,</span><br><span class="line">      <span class="keyword">this</span>.props,</span><br><span class="line">      <span class="keyword">this</span>.children,</span><br><span class="line">      <span class="keyword">this</span>.key</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(root)</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">  create() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._createElement(<span class="keyword">this</span>.tag, <span class="keyword">this</span>.props, <span class="keyword">this</span>.children, <span class="keyword">this</span>.key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建节点</span></span><br><span class="line">  _createElement(tag, props, child, key) &#123;</span><br><span class="line">    <span class="comment">// 通过 tag 创建节点</span></span><br><span class="line">    <span class="keyword">let</span> el = <span class="built_in">document</span>.createElement(tag);</span><br><span class="line">    <span class="comment">// 设置节点属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      <span class="keyword">if</span> (props.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="keyword">const</span> value = props[key];</span><br><span class="line">        el.setAttribute(key, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">      el.setAttribute(<span class="string">'key'</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归添加子节点</span></span><br><span class="line">    <span class="keyword">if</span> (child) &#123;</span><br><span class="line">      child.forEach(<span class="function"><span class="params">elememt</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> child;</span><br><span class="line">        <span class="keyword">if</span> (element <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">          child = <span class="keyword">this</span>._createElement(</span><br><span class="line">            elememt.tag,</span><br><span class="line">            elememt.props,</span><br><span class="line">            elememt.children,</span><br><span class="line">            elememt.key</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          child = <span class="built_in">document</span>.createTextNode(elememt)</span><br><span class="line">        &#125;</span><br><span class="line">        el.appendChild(child)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> el;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Virtual-Dom-算法简述"><a href="#Virtual-Dom-算法简述" class="headerlink" title="Virtual Dom 算法简述"></a>Virtual Dom 算法简述</h4><p>DOM 是多叉树结构，如果需要完整的对比两棵树的差异，那么需要的时间复杂度是 O(n ^ 3)。React 团队优化了算法，实现了  O(n) 的复杂度来对比差异。</p><p>关键在于只是对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少回去跨层移动 DOM 元素。</p><p>判断差异算法分成了两步</p><ul><li>首先从上到下，从左到右遍历对象，要就是树的深度遍历，这一步会给每个节点添加索引，便于后面渲染差异</li><li>一旦节点有子元素，就去判断子元素是否有不同</li></ul><h4 id="Virtual-Dom-算法实现"><a href="#Virtual-Dom-算法实现" class="headerlink" title="Virtual Dom 算法实现"></a>Virtual Dom 算法实现</h4><p><strong>树的递归</strong></p><p>首先实现树的递归遍历，在实现该算法前，考虑两个节点对比出现的几种情况：</p><ol><li>新的节点 tagName 或者 key 和旧的不同，这种情况代表需要替换旧的节点，并也不再需要遍历新旧子元素了，因为整个旧节点都被删除掉了。</li><li>新的节点的 tagName 和 key （可能都没有）和旧的相同，开始遍历子树</li><li>没有新的节点，那么什么都不用做</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; StateEnums, isString, move &#125; <span class="keyword">from</span> <span class="string">'./util'</span></span><br><span class="line"><span class="keyword">import</span> Element <span class="keyword">from</span> <span class="string">'./element'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">oldDomTree, newDomTree</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用于记录差异</span></span><br><span class="line">  <span class="keyword">let</span> pathchs = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 一开始的索引为0</span></span><br><span class="line">  dfs(oldDomTree, newDomTree, <span class="number">0</span>, pathchs)</span><br><span class="line">  <span class="keyword">return</span> pathchs</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">oldNode, newNode, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用于保存子树的更改</span></span><br><span class="line">  <span class="keyword">let</span> curPatches = [];</span><br><span class="line">  <span class="comment">// 需要判断三种情况：</span></span><br><span class="line">  <span class="comment">// 1.没有新的节点，那么什么都不做</span></span><br><span class="line">  <span class="comment">// 2.新的节点的 tagName 和 key（可能都没有）和旧的相同，开始遍历子树</span></span><br><span class="line">  <span class="comment">// 3.没有新的节点，那么什么都不用做</span></span><br><span class="line">  <span class="keyword">if</span> (!newNode) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNode.tag === oldNode.tag &amp;&amp; newNode.key === oldNode.key) &#123;</span><br><span class="line">    <span class="comment">// 判断属性是否变更</span></span><br><span class="line">    <span class="keyword">let</span> props = diffProps(oldNode.props, newNode.props)</span><br><span class="line">    <span class="keyword">if</span> (props.length) curPatches.push(&#123; <span class="attr">type</span>: StateEnums.ChangeProps, props &#125;)</span><br><span class="line">    <span class="comment">// 遍历子树</span></span><br><span class="line">    diffChildren(oldNode.children, newNode.children, index, patches)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 节点不同，需要替换</span></span><br><span class="line">    curPatches.push(&#123; <span class="attr">type</span>: StateEnums.Replace, <span class="attr">node</span>: newNode &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (curPatches.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (patches[index]) &#123;</span><br><span class="line">      patches[index] = patches[index].concat(curPatches)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      patches[index] = curPatches;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断属性的更改</strong></p><p>判断属性的更改也分成三个步骤</p><ol><li>遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中</li><li>遍历新的属性列表，判断两个列表中都存在的属性的值是否存在变化</li><li>在第二步中同时查看是否有属性不存在与旧的属性列列表中</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffProps</span>(<span class="params">oldProps, newProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> change = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldProps.hasOwnProperty(key) &amp;&amp; !newProps[key]) &#123;</span><br><span class="line">      change.push(&#123; <span class="attr">prop</span>: key &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newProps.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="keyword">const</span> prop = newProps[key];</span><br><span class="line">      <span class="keyword">if</span> (oldProps[key] &amp;&amp; oldProps[key] !== newProps[key]) &#123;</span><br><span class="line">        change.push(&#123;</span><br><span class="line">          prop: key,</span><br><span class="line">          value: newProps[key]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!oldProps[key]) &#123;</span><br><span class="line">        change.push(&#123;</span><br><span class="line">          prop: key,</span><br><span class="line">          value: newProps[key]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> change;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断列表差异算法实现</strong></p><p>整个 Virtual Dom 中最核心的算法，这里的主要步骤其实和判断属性差异是类似的，也是分成三个步骤：</p><ol><li>遍历旧的节点列表，查看每个节点是否还存在新的节点列表中</li><li>遍历新的节点列表，判断是否有新的节点</li><li>在第二步中同时判断节点是否有移动</li></ol><p>该算法只对有 key 的节点做处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listDiff</span>(<span class="params">oldList, newList, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为了遍历方便，先取出两个 list 中所有的 keys</span></span><br><span class="line">  <span class="keyword">let</span> oldKeys = getKeys(oldList);</span><br><span class="line">  <span class="keyword">let</span> newKeys = getKeys(newList);</span><br><span class="line">  <span class="keyword">let</span> changes = [];</span><br><span class="line">  <span class="comment">// 用于保存变更后的节点数据，使用该数组保存有以下好处，</span></span><br><span class="line">  <span class="comment">// 1.可以正确获取被删除节点索引</span></span><br><span class="line">  <span class="comment">// 2.交换位置只需要操作一遍 dom</span></span><br><span class="line">  <span class="comment">// 3.用于 diffChildren 函数中的判断，只需要遍历</span></span><br><span class="line">  <span class="comment">// 两个树中都存在的节点，对于新增或者删除的节点来说，完全没有必要再去判断一次</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> list = [];</span><br><span class="line">  oldList &amp;&amp; oldList.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> key = item.key;</span><br><span class="line">    <span class="keyword">if</span> (isString(item)) &#123;</span><br><span class="line">      key = item</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻找新的 children 中是否含有当前节点，没有的话需要删除</span></span><br><span class="line">    <span class="keyword">let</span> index = newKeys.indexOf(key);</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">-1</span>) &#123;</span><br><span class="line">      list.push(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      list.push(key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 遍历变更后的数组</span></span><br><span class="line">  <span class="keyword">let</span> length = list.length;</span><br><span class="line">  <span class="comment">// 因为删除数组元素是会更改索引的，所以从后往前删可以保证索引不变</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 判断当前元素是否为空，为空则表示要删除</span></span><br><span class="line">    <span class="keyword">if</span> (!list[i]) &#123;</span><br><span class="line">      list.splice(i, <span class="number">1</span>)</span><br><span class="line">      changes.push(&#123; <span class="attr">type</span>: StateEnums.Remove, <span class="attr">index</span>: i &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历新的list 判断是否节点新增或者是移动，同时也对 list 做节点的新增或者是移动</span></span><br><span class="line">  newList &amp;&amp; newList.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> key = item.key;</span><br><span class="line">    <span class="keyword">if</span> (isString(item)) &#123;</span><br><span class="line">      key = item</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻找旧的 children 中是否含有当前节点，没有的话需要插入</span></span><br><span class="line">    <span class="keyword">let</span> index = list.indexOf(key);</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">-1</span> || index == <span class="literal">null</span>) &#123;</span><br><span class="line">      changes.push(&#123; <span class="attr">type</span>: StateEnums.Insert, <span class="attr">node</span>: item, <span class="attr">index</span>: i &#125;);</span><br><span class="line">      list.splice(i, <span class="number">0</span>, key)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 找到了，需要判断是否需要移动</span></span><br><span class="line">      <span class="keyword">if</span> (index !== i) &#123;</span><br><span class="line">        changes.push(&#123; <span class="attr">type</span>: StateEnums.Move, <span class="attr">from</span>: index, <span class="attr">to</span>: i &#125;);</span><br><span class="line">        move(list, index, i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    changes, list</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getKeys</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = [];</span><br><span class="line">  <span class="keyword">let</span> text;</span><br><span class="line">  list &amp;&amp; list.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> key;</span><br><span class="line">    <span class="keyword">if</span> (isString(item)) &#123;</span><br><span class="line">      key = [item]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">      key = item.key;</span><br><span class="line">    &#125;</span><br><span class="line">    keys.push(key)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> keys</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>遍历子元素打标识</strong></p><p>对于整个函数来说，主要的功能就两个</p><ol><li>判断两个列表差异</li><li>给节点打上标记</li></ol><p>总体来说，该函数的实现很简单</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">oldChild, newChild, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; changes, list &#125; = listDiff(oldChild, newChild, index, patches)</span><br><span class="line">  <span class="keyword">if</span> (changes.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (patches[index]) &#123;</span><br><span class="line">      patches[index] = patches[index].concat(changes)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      patches[index] = changes;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录上一次遍历过的节点</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="literal">null</span>;</span><br><span class="line">  oldChild &amp;&amp; oldChild.forEach(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> child = item &amp;&amp; item.children;</span><br><span class="line">    <span class="keyword">if</span> (child) &#123;</span><br><span class="line">      index = last &amp;&amp; last.children ? index + last.children.length + <span class="number">1</span> : index + <span class="number">1</span></span><br><span class="line">      <span class="keyword">let</span> keyIndex = list.indexOf(item.key);</span><br><span class="line">      <span class="keyword">let</span> node = newChild[keyIndex];</span><br><span class="line">      <span class="comment">// 只遍历新旧节点都存在的节点，其他新增或者删除的没有必要遍历</span></span><br><span class="line">      <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        dfs(item, node, index, patches)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      index += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    last = item;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>渲染差异</strong></p><p>通过之前的算法，我们已经可以得出两个树的差异了。既然知道了差异，就需要局部去更新 DOM 了，下面就让我们来看看 Virtual Dom 算法的最后一步骤</p><p>这个函数主要两个功能</p><ol><li>深度遍历树，将需要做变更操作的取出来</li><li>局部更新 DOM</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">node, patchs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> changes = patchs[index]</span><br><span class="line">  <span class="keyword">let</span> childNodes = node &amp;&amp; node.childNodes</span><br><span class="line">  <span class="comment">// 这里的深度遍历和 diff 中是一样的</span></span><br><span class="line">  <span class="keyword">if</span> (!childNodes) index += <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> (changes &amp;&amp; changes.length &amp;&amp; patchs[index]) &#123;</span><br><span class="line">    changeDom(node, changes)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> last = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (childNodes &amp;&amp; childNodes.length) &#123;</span><br><span class="line">    childNodes.forEach(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">      index =</span><br><span class="line">        last &amp;&amp; last.children ? index + last.children.length + <span class="number">1</span> : index + <span class="number">1</span></span><br><span class="line">      patch(item, patchs)</span><br><span class="line">      last = item</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeDom</span>(<span class="params">node, changes, noChild</span>) </span>&#123;</span><br><span class="line">  changes &amp;&amp;</span><br><span class="line">    changes.forEach(<span class="function"><span class="params">change</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> &#123; type &#125; = change</span><br><span class="line">      <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> StateEnums.ChangeProps:</span><br><span class="line">          <span class="keyword">let</span> &#123; props &#125; = change</span><br><span class="line">          props.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.value) &#123;</span><br><span class="line">              node.setAttribute(item.prop, item.value)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              node.removeAttribute(item.prop)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> StateEnums.Remove:</span><br><span class="line">          node.childNodes[change.index].remove()</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> StateEnums.Insert:</span><br><span class="line">          <span class="keyword">let</span> dom</span><br><span class="line">          <span class="keyword">if</span> (isString(change.node)) &#123;</span><br><span class="line">            dom = <span class="built_in">document</span>.createTextNode(change.node)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (change.node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            dom = change.node.create()</span><br><span class="line">          &#125;</span><br><span class="line">          node.insertBefore(dom, node.childNodes[change.index])</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> StateEnums.Replace:</span><br><span class="line">          node.parentNode.replaceChild(change.node.create(), node)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> StateEnums.Move:</span><br><span class="line">          <span class="keyword">let</span> fromNode = node.childNodes[change.from]</span><br><span class="line">          <span class="keyword">let</span> toNode = node.childNodes[change.to]</span><br><span class="line">          <span class="keyword">let</span> cloneFromNode = fromNode.cloneNode(<span class="literal">true</span>)</span><br><span class="line">          <span class="keyword">let</span> cloenToNode = toNode.cloneNode(<span class="literal">true</span>)</span><br><span class="line">          node.replaceChild(cloneFromNode, toNode)</span><br><span class="line">          node.replaceChild(cloenToNode, fromNode)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>Virtul Dom 算法的实现也是下面三个步骤：</p><ol><li>通过JS 来模拟创建 DOM 对象</li><li>判断两个对象的差异</li><li>渲染差异</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test4 = <span class="keyword">new</span> Element(<span class="string">'div'</span>, &#123; <span class="attr">class</span>: <span class="string">'my-div'</span> &#125;, [<span class="string">'test4'</span>])</span><br><span class="line"><span class="keyword">let</span> test5 = <span class="keyword">new</span> Element(<span class="string">'ul'</span>, &#123; <span class="attr">class</span>: <span class="string">'my-div'</span> &#125;, [<span class="string">'test5'</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test1 = <span class="keyword">new</span> Element(<span class="string">'div'</span>, &#123; <span class="attr">class</span>: <span class="string">'my-div'</span> &#125;, [test4])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test2 = <span class="keyword">new</span> Element(<span class="string">'div'</span>, &#123; <span class="attr">id</span>: <span class="string">'11'</span> &#125;, [test5, test4])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> root = test1.render()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pathchs = diff(test1, test2)</span><br><span class="line"><span class="built_in">console</span>.log(pathchs)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'开始更新'</span>)</span><br><span class="line">  patch(root, pathchs)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'结束更新'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><p>涉及的面试题目：前端路由原理，两种实现方式有什么区别？</p><p>前端路由实现起来不难，本质就是监听 URL 的变化，然后匹配路由规则，显示对应的页面，并且无须刷新页面，目前前端使用的路由大概有两种方式：</p><ul><li>hash 模式</li><li>History 模式</li></ul><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p><code>www.test.com/#/</code> 就是 Hash URL，当 <code>#</code> 后面的哈希值发生变化时，可以通过 <code>hashchange</code> 事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是 <code>www.test.com</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'haschange'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="comment">// 具体逻辑...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Hash 模式相对简单，并且兼容性更好</p><h4 id="History"><a href="#History" class="headerlink" title="History"></a>History</h4><p>History 模式 是 HTML5 推出的新功能，主要使用 history.pushState 和 history.replaceState 改变 URL。</p><p>通过 History 模式改变 URL 同样不会引起浏览器的刷新，只会更新浏览器的历史记录</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增历史记录</span></span><br><span class="line">history.pushState(stateObj,title,URL);</span><br><span class="line"><span class="comment">// 替换当前的历史记录</span></span><br><span class="line">history.replaceState(stateObj,title,URL);</span><br></pre></td></tr></table></figure><p>当用户做出浏览器动作的时候，比如点击后退按钮会触发 popState 事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>,e=&gt;&#123;</span><br><span class="line">    <span class="comment">// e.state 就是 push(stateObject) 中的 stateObject</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.state);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="两种模式对比"><a href="#两种模式对比" class="headerlink" title="两种模式对比"></a>两种模式对比</h4><ul><li>Hash 模式只可以更改 # 号后面的内容。History 模式可以通过 API 设置任意的同源的 URL</li><li>History 模式可以通过 API 添加任意的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串</li><li>Hash 模式无需后置配置，并且兼容性好。History 模式在用户输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 index.html 用于匹配不到静态资源的时候</li></ul><h3 id="Vue-常考的基本知识点"><a href="#Vue-常考的基本知识点" class="headerlink" title="Vue 常考的基本知识点"></a>Vue 常考的基本知识点</h3><h4 id="声明周期钩子函数"><a href="#声明周期钩子函数" class="headerlink" title="声明周期钩子函数"></a>声明周期钩子函数</h4><p>在 beforeCreate 钩子函数使用的时候，是获取不到 props 或者 data中的数据的，因为这些数据都在 initState 中</p><p>然后会执行 created 钩子函数，这一步可以访问到之前不能访问到的数据，但是这时候，组件还没有被挂载。</p><p>beforeMount 钩子函数，开始构建 VDOM，最后执行 mounted 钩子函数，并将 VDOM 渲染为真实的 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有组件全部挂载完毕，才会执行根组件的挂载钩子。</p><p>数据更新时会调用钩子函数 beforeUpdate 和 updated ，分别是在数据更新前后会调用</p><p>keep-alive 独有的生命周期，activated 和 deactivated。用 keep-alive 包裹的组件切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数,命中缓存渲染后会执行 atived 钩子函数</p><p>最后就是销毁组件的钩子函数 beforeDestory 和 destroyed .前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题，然后进行一系列的销操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕之后才会执行根组件的 destroyed 钩子函数</p><h4 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h4><p>一般有一下几种情况</p><ul><li>父子组件</li><li>兄弟组件</li><li>跨多层次组件</li><li>任意组件</li></ul><h4 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h4><p>父组件通过 props 传递给子组件，子组件通过 emit 发送事件传递数据给父组件，这两种方式是常用的父子通信实现方法</p><p>这种父子组件就是典型的单向数据流，父组件通过 props 传递数据，子组件不能直接修改 props,而是必须通过发送事件的方式告知父组件修改数据。</p><p>另外这两种方式还可以使用语法糖 v-model 来直接实现，因为 v-model 会解析成名为  value 的 prop 和 input 的事件。这种语法糖的方式是典型的双向绑定，常用于  UI控件上面，但是根本上还是通过事件的方法来让父组件修改数据。</p><p>还可以通过 \$parent 或者是 \$children 对象来访问组件实例中方法和数据。</p><p>另外使用 Vue2.3 以上的版本还可以使用 \$ listeners 和 .sycn 两个属性</p><p>\$ listeners 属性会将父组件中（不含 .native 修饰器的）v-on 事件监听器传递给子组件，子组件可以通过访问 \$listeners 来自定义监听器</p><p>.sync 属性是语法糖，可以很简单实现子组件和父组件的通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--父组件中---&gt;</span><br><span class="line">&lt;input :value.sync=&quot;value&quot;&gt;</span><br><span class="line">&lt;!--上面写法等同于--&gt;</span><br><span class="line">&lt;input :value=&quot;value&quot; @update:value=&quot;v=&gt;value=v&quot;&gt;&lt;/comp&gt;</span><br><span class="line">&lt;!--子组件中--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    this.$emit(&apos;update:value&apos;,1)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h4><p>可以通过查找父组件中的子组件的实现，就是 <code>this.$parent.$children</code> 在 <code>$children</code>中可以通过 name 查询到需要的组件实例，然后进行通信</p><h4 id="跨多层组件通信"><a href="#跨多层组件通信" class="headerlink" title="跨多层组件通信"></a>跨多层组件通信</h4><p>可以使用 Vue2.2 新增的 API provide/inject ，虽然在文档中不支持使用在业务中，但是如果用得好的话还是有用的</p><p>假设有父组件 A 然后有一个跨多层级的子组件B</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件A</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    provide:&#123;</span><br><span class="line">        data:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件 B</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    inject:[<span class="string">'data'</span>],</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        <span class="comment">// 无论跨几层都能获取到父组件的 data 属性</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.data); <span class="comment">//=&gt;1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="任意组件"><a href="#任意组件" class="headerlink" title="任意组件"></a>任意组件</h4><p>这种方式可以通过 Vuex 或者 Event Bus 解决，另外如果不怕麻烦的话，可以使用这种方式来解决上述的所有通信情况</p><h4 id="extend-能做什么"><a href="#extend-能做什么" class="headerlink" title="extend 能做什么"></a>extend 能做什么</h4><p>作用是扩展㢟生成一个构造器，通常会与 <code>$mount</code>一起使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建组件构造器</span></span><br><span class="line"><span class="keyword">let</span> Component = Vue.extend(&#123;</span><br><span class="line">    template:<span class="string">'&lt;div&gt;test&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 挂载到 #app 上</span></span><br><span class="line"><span class="keyword">new</span>.Component().$mount(<span class="string">'#app'</span>);</span><br><span class="line"><span class="comment">// 除了上面方式还可以来扩展原来的组件</span></span><br><span class="line"><span class="keyword">let</span> SuperComponent = Vue.extend(Component)</span><br><span class="line"><span class="keyword">new</span> SuperComponent(&#123;</span><br><span class="line">    created()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> SuperComponent().$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><h4 id="mixin-和-mixins-的区别"><a href="#mixin-和-mixins-的区别" class="headerlink" title="mixin 和 mixins 的区别"></a>mixin 和 mixins 的区别</h4><p>mixin 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    beforeCreate()&#123;</span><br><span class="line">        <span class="comment">// 逻辑，这种方式会影响到所有组件的 beforeCreate 钩子函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>文档不建议直接在应用中使用 mixin ，但是不滥用的话，可以全局混入装好的 ajax 或者一些工具函数等等</p><p>mixins 应该是我们最常使用的扩展组件的方式了，如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种等等。</p><p>另外要注意的是 mixins 混入的钩子函数会先于组件的钩子函数执行，并且在晕倒同名选项的时候也会有选择性的进行合并。</p><h4 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="headerlink" title="computed 和 watch 的区别"></a>computed 和 watch 的区别</h4><p>computed 是计算属性，依赖其他属性来计算，并且 computed 的值有缓存，只有当值变化才会返回内容。</p><p>watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</p><p>所以一般来说需要依赖别的属性来动态获得值的时候就可以使用 computed ，对于监听到值的变化需要做的一些复杂业务逻辑的时候可以使用 watch</p><p>另外这两者都支持对象的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vm.$watch(<span class="string">'obj'</span>,&#123;</span><br><span class="line">    <span class="comment">// 深度遍历</span></span><br><span class="line">    deep:<span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 立即触发</span></span><br><span class="line">    immediate:<span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 执行函数</span></span><br><span class="line">    handler:<span class="function"><span class="keyword">function</span>(<span class="params">val,oldVal</span>)</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data:&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">        aPlus:&#123;</span><br><span class="line">            <span class="comment">// this.aPlus 的时候触发</span></span><br><span class="line">            get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// this.aPlus = 1时触发</span></span><br><span class="line">            set:<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.a = v - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="keep-alive组件的作用"><a href="#keep-alive组件的作用" class="headerlink" title="keep-alive组件的作用"></a>keep-alive组件的作用</h4><p>需要需要在组件切换时，保存一些组件的状态防止多次渲染，可以使用 keep-alive 组件包裹需要保存的组件</p><p>对于 keep-alive 组件来说，它拥有两个独有的声明周期函数，分别是  activated 和 deactivated ，用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数</p><h4 id="v-show-和-v-if-的区别"><a href="#v-show-和-v-if-的区别" class="headerlink" title="v-show 和 v-if 的区别"></a>v-show 和 v-if 的区别</h4><p>v-show 只是在 display：none 和 display：block 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留的，所以总的来说，v-show 在初始渲染有更高的开销，但是切换开销小，更适合于频繁切换的场景</p><p>v-if 的话就涉及 Vue 底层的编译，当属性初始为 false，组件就不会被渲染，直到条件为 true，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换开销更高，更适合不经常切换的场景，并且基于 v-if 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。</p><h4 id="组件中-data-什么时候可以使用对象"><a href="#组件中-data-什么时候可以使用对象" class="headerlink" title="组件中 data 什么时候可以使用对象"></a>组件中 data 什么时候可以使用对象</h4><p>组件复用时所有的实例都会共享 data ，如果data 是对象的话，就会造成一个组件修改 data 之后会影响到其他所有的组件，所以我们需要将 data 写成函数，每次用到就调用一次函数来获得新的数据</p><p>当我们使用 new Vue() 的方式的时候，无论我们将 data 设置为对象还是函数都是可以的，因为 new Vue（） 的方式是生成一个根组件，也就不存在共享 data 的情况了。</p><h4 id="进阶知识点"><a href="#进阶知识点" class="headerlink" title="进阶知识点"></a>进阶知识点</h4><h4 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h4><p>Vue 内部使用了 Object.defineProperty() 来实现数据响应式，通过函数可以监听到 set 和 get 事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">name</span>: <span class="string">'lbh'</span> &#125;</span><br><span class="line">observe(data);</span><br><span class="line"><span class="keyword">let</span> &#123; name &#125; = data;</span><br><span class="line">data.name = <span class="string">'haha'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断类型</span></span><br><span class="line">    <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      defineReactive(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  observe(val);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="comment">// 可枚举</span></span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 可配置</span></span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 自定义函数</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get val'</span>);</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'change val'</span>);</span><br><span class="line">      val = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码简单实现了如何监听数据的 set 和 get 事件，因为自定义函数一开始是不会执行的，只有先执行了依赖收集，才能在属性更新的时候派发更新，所以我们接下来需要先触发依赖收集</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;&#123;name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在解析上面的模板代码时候，会遇到 <code></code>就会进行依赖收集</p><p>实现一个 Dep 类，用于解耦属性的依赖收集和派发更新操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加依赖</span></span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局属性，通过该属性配置 watcher</span></span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>当需要收集依赖的时候调用 addSub,当需要派发更新的时候调用 notify()</p><p>下面简单了解 Vue 组件挂载时添加响应式的过程。在组件挂载时，会先对所有需要的属性调用 Object.defineProperty(),然后实例化 Watcher，传入组件更新的回调，在实例化中，会对模板中的属性进行求值，触发依赖收集。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(obj, key, cb) &#123;</span><br><span class="line">    <span class="comment">// 将 Dep.target 指向自己，然后出发属性的 getter 添加监听，最后将 Dep.target 置空</span></span><br><span class="line">    Dep.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb;</span><br><span class="line">    <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = obj[value];</span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="comment">// 获得新值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.obj[<span class="keyword">this</span>.key];</span><br><span class="line">    <span class="comment">// 调用 update 方法更新 Dom</span></span><br><span class="line">    <span class="keyword">this</span>.cb(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是 Wathcer 的简单实现，在执行构造函数的时候将 Dep.target 指向自身，从而使得收集到了对应的 Watcher,在派发更新的时候取出对应的 Watcher 然后执行 update 函数</p><p>接下来，需要对 defineReactive 函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  observe(val);</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="comment">// 可枚举</span></span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 可配置</span></span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 自定义函数</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get val'</span>);</span><br><span class="line">      <span class="comment">// 将Watcher 添加到订阅中</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dp.addSub(Dep.target)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'change val'</span>);</span><br><span class="line">      val = newVal;</span><br><span class="line">      <span class="comment">// 执行 watcher 的 update 方法</span></span><br><span class="line">      dp.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码实现了一个简易的数据响应式，核心思路就是手动触发一次属性的 getter 来实现依赖收集。</p><p>测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">name</span>: <span class="string">'lbh'</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>).innerText = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作</span></span><br><span class="line"><span class="keyword">new</span> Watcher(data, <span class="string">'name'</span>, update)</span><br><span class="line"><span class="comment">// update Dom innerText</span></span><br><span class="line">data.name = <span class="string">'haha'</span> </span><br><span class="line"><span class="comment">// get val</span></span><br><span class="line"><span class="comment">// change val</span></span><br><span class="line"><span class="comment">// get val</span></span><br></pre></td></tr></table></figure><h4 id="Object-defineProperty-的缺陷"><a href="#Object-defineProperty-的缺陷" class="headerlink" title="Object.defineProperty 的缺陷"></a>Object.defineProperty 的缺陷</h4><p>如果通过下标的方式修改数据或者给对象新增属性并不会触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作，更精确的来说，对于数组来说，大部分操作都是拦截不到的，只是 vue 内部通过重写函数的方式改写了这个问题。</p><p>Vue 提供了一个 API 解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">target: Array&lt;any&gt; | Object, key: any, val: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否为数组且下标是否有效</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    <span class="comment">// 调用 splice 函数触发派发更新</span></span><br><span class="line">    <span class="comment">// 该函数已被重写</span></span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">    target.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断 key 是否已经存在</span></span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line">  <span class="comment">// 如果对象不是响应式对象，就赋值返回</span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 进行双向绑定</span></span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  <span class="comment">// 手动派发更新</span></span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于数组而言，Vue 内部重写了以下函数实现派发更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得数组原型</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"><span class="comment">// 重写以下函数</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存原生函数</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  <span class="comment">// 重写函数</span></span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先调用原生函数获得结果</span></span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="comment">// 调用以下几个函数时，监听新数据</span></span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// 手动派发更新</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>Vue 会通过编译器将模板通过几个阶段最终编成为 render 函数，然后通过执行 render 函数生成 Virtual DOM 最终映射为真实 DOM </p><p>这个阶段分成三部分：</p><ol><li>将模板解析为 AST</li><li>优化 AST</li><li>将 AST 转换为 render 函数</li></ol><p>第一个阶段，通过正则表达式去匹配模板中的内容，然后将内容提取出来做各种逻辑操作，接着会生成一个基本的 AST 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    type：<span class="number">1</span>，</span><br><span class="line">    <span class="comment">// 标签</span></span><br><span class="line">    tag,</span><br><span class="line">    <span class="comment">// 属性列表</span></span><br><span class="line">    attrsList:attrs,</span><br><span class="line">    <span class="comment">// 属性映射</span></span><br><span class="line">    attrsMap:makeAttrsMap（attrs）,</span><br><span class="line">    <span class="comment">// 父节点</span></span><br><span class="line">    parent,</span><br><span class="line">    <span class="comment">// 子节点</span></span><br><span class="line">    children:[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会根据这个最基本的 AST对象的属性，进一步扩展 AST</p><p>当然在这一阶段中，还会进行其他的一些判断逻辑。比如说对比前后开闭标签是否一致，判断根组件是否只存在一个，判断是否符合 HTML5 <a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FGuide%2FHTML%2FContent_categories">Content Model</a> 规范等等问题。</p><p>优化 AST 阶段，对节点进行了静态内容提取，将永远不会变动的节点拿出来，实现复用 Virtual DOM,跳过对比算法的功能。</p><p>最后一个阶段，通过 AST 生成 render 函数，主要的目的是遍历整个 AST,根据不同的条件生成不同的代码</p><h4 id="NextTick-原理浅析"><a href="#NextTick-原理浅析" class="headerlink" title="NextTick 原理浅析"></a>NextTick 原理浅析</h4><p>nextTick 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM</p><p>默认使用 microtasks，但是特殊情况下会使用 macrotasks，比如 v-on</p><p>对于实现 macrotasks，会先判断是否能使用 setImmediate，不能的话就降级为 MessageChannel，以上都不行的话就使用 setTimeout</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> MessageChannel !== <span class="string">'undefined'</span> &amp;&amp; (isNative(MessageChannel) || MessageChannel.toString() === <span class="string">'[object MessageChannelConstructor]'</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">  <span class="keyword">const</span> port = channel.port2;</span><br><span class="line">  channel.port1.onmessage = flushCallbacks;</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    port.postMessage(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="React-常考的基本知识点"><a href="#React-常考的基本知识点" class="headerlink" title="React 常考的基本知识点"></a>React 常考的基本知识点</h3><h4 id="声明周期"><a href="#声明周期" class="headerlink" title="声明周期"></a>声明周期</h4><p>v16 版本中引入了 Fiber 机制，这个机制一定程度上影响了部分生命周期函数的调用，也引入了新的两个 API 来解决问题。<a href="http://www.ayqy.net/blog/dive-into-react-fiber/">关于 Fiber</a></p><p>之前版本的 react如果嵌套太多层，会导致调用栈过长，再加上复杂的操作，就可能导致长时间阻塞主线程，带来不好的用户体验。就类似潜水员，只有潜到底才会回到水面。而如果水面这时候发生了其他优先级更高的事情，也要等潜水员潜到底后再重新上来。</p><p>Fiber 就是为了解决这个问题而生的，它本质上是一个虚拟的堆栈帧，新的调度器hi根据优先级自由调用这些帧，从而将之前的同步渲染变成了异步渲染，在不影响体验的情况下去分段计算更新。</p><p>优先级的区别，对于动画这种优先性别很高的东西，16ms 必须渲染一次保证不卡顿的情况下，react 会每 16ms 以内暂停一次更新，返回来继续渲染动画。潜水员不再一直潜到底，而是潜到一定深度后在该点设置一个传送点后浮出水面，然后传回去传送点继续下潜。</p><p>对于异步渲染，有三个阶段：reconcliiation 和 commit ，前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。</p><p>Reconciliation 阶段</p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li></ul><p>Commit 阶段</p><ul><li>componentDidMount</li><li>componentDidUpdate</li><li>componentWillUnmount</li></ul><p>因为前者是可以被打断的，所以 Reconciliation  阶段会执行的声明周期函数就可能会出现调用多次的情况，从而引起 bug。因此对于 Reconciliation 阶段调用的几个函数，除了 shouldComponentUpdate 之外，其他都应该避免去使用，并且 V16 中也引入了新的 API 来解决这个问题</p><p>getDerivedStateFromProps 用于替换 componentWillReciveProps，这个函数会在初始化和 update 时候被调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Initialize state in constructor,</span></span><br><span class="line">  <span class="comment">// Or with a property initializer.</span></span><br><span class="line">  state = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevState.someMirroredValue !== nextProps.someValue) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        derivedData: computeDerivedState(nextProps),</span><br><span class="line">        someMirroredValue: nextProps.someValue</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return null to indicate no change to state.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getSnapshotBeforeUpdate</code> 用于替换 <code>componentWillUpdate</code> ，该函数会在 <code>update</code> 后 DOM 更新前被调用，用于读取最新的 DOM 数据。</p><h4 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h4><p>setState 是异步的，调用这个函数不会马上引起 state 的变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handle()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count); <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>:<span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>:<span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>:<span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count) <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码等同于下面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;<span class="attr">count</span>:<span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">count</span>:<span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">count</span>:<span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以通过下面的方式来实现我们原来的目的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handle()&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>)=&gt;</span>(&#123;<span class="attr">count</span>:prevState.state.count+<span class="number">1</span>&#125;));</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>)=&gt;</span>(&#123;<span class="attr">count</span>:prevState.state.count+<span class="number">1</span>&#125;));</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>)=&gt;</span>(&#123;<span class="attr">count</span>:prevState.state.count+<span class="number">1</span>&#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每次 setState 后取得正确的 state，可以这样实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handle()&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState((prevState)=&gt;(&#123;count:prevState.count+<span class="number">1</span>&#125;),()=&gt;&#123;</span><br><span class="line">        console.log(<span class="keyword">this</span>.state);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>在 <code>shouldComponentUpdate</code> 函数中我们可以通过返回布尔值来决定当前组件是否需要更新。</p><p>通过 immutable 或者 immer 这些库来生成不可变对象。这类库对于操作大规模的数据来说会提升不错的性能，并且一旦改变数据就会生成一个新的对象，对比前后 <code>state</code> 是否一致也就方便多了。</p><p>单纯的浅比较一下，可以直接使用 <code>PureComponent</code>，底层就是实现了浅比较 <code>state</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        PureComponent</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>V16 之后可以使用 React.memo 来实现相同的功能</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Test = React.memo(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        PureComponent</span><br><span class="line">      &lt;<span class="regexp">/div&gt;    </span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><p>通过这种方式我们就可以既实现了 <code>shouldComponentUpdate</code> 的浅比较，又能够使用函数组件。</p><h4 id="组件通信-1"><a href="#组件通信-1" class="headerlink" title="组件通信"></a>组件通信</h4><p>同样的情况：</p><ul><li>父子组件</li><li>兄弟组件</li><li>跨多层次组件</li><li>任意组件</li></ul><h4 id="父子组件"><a href="#父子组件" class="headerlink" title="父子组件"></a>父子组件</h4><p>父组件通过 props 传递数据给子组件，子组件通过调用父组件传来函数传递给父组件，这两种方式是最常用的父子通信的方法。</p><p>这种父子通信方式也就是典型的单向数据流，父组件通过 props 传递数据，子组件不能直接修改 props,而是必须通过调用父组件函数的方式来告知父组件修改数据</p><h4 id="兄弟组件"><a href="#兄弟组件" class="headerlink" title="兄弟组件"></a>兄弟组件</h4><p>与这种情况可以通过共同的父组件来管理状态和事件函数。比如其中给一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件</p><h4 id="跨多层次组件"><a href="#跨多层次组件" class="headerlink" title="跨多层次组件"></a>跨多层次组件</h4><p>使用 Context API</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Context，可以在开始就传入值</span></span><br><span class="line"><span class="keyword">const</span> StateContext = React.createContext();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="comment">// value 就是传入 Context 中的值</span></span><br><span class="line">        &lt;StateContext.Provider value=<span class="string">'haha'</span>&gt;</span><br><span class="line">            &lt;Child/&gt;</span><br><span class="line">        &lt;<span class="regexp">/StateContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Child extends React.Component&#123;</span></span><br><span class="line"><span class="regexp">    render()&#123;</span></span><br><span class="line"><span class="regexp">        return(</span></span><br><span class="line"><span class="regexp">            &lt;ThemeContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">                /</span><span class="regexp">/ 取出值</span></span><br><span class="line"><span class="regexp">                &#123;context=&gt;&#123;</span></span><br><span class="line"><span class="regexp">                    name is &#123;context&#125;</span></span><br><span class="line"><span class="regexp">                &#125;&#125;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>ThemeContext.Consumer&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="任意组件-1"><a href="#任意组件-1" class="headerlink" title="任意组件"></a>任意组件</h4><p>这种方式可以通过 Redux、Mobx 等工具 或者 Event Bus 解决。</p><h4 id="HOC-是什么？相比-mixins-有什么优点"><a href="#HOC-是什么？相比-mixins-有什么优点" class="headerlink" title="HOC 是什么？相比 mixins 有什么优点"></a>HOC 是什么？相比 mixins 有什么优点</h4><p>例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给这个 add 函数添加一个输出结果的功能，实现优雅并且可以复用和扩展：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLog</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wrapper</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> result = fn(a,b);</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> withLogAdd = withLog(add);</span><br><span class="line">withLogAdd();</span><br></pre></td></tr></table></figure><p>这种做法在函数式编程里面被称为高阶函数。高阶组件和高阶函数就是同一个东西，实现一个函数，传入一个组件，然后在函数内部再实现一个函数切扩展传入的组件，最后返回一个新的组件，这就是高阶组件的概念，作用是为了更好的复用代码。</p><p>HOC 和 Vue 中的 mixins 作用是一致的，并且在早期的 React 也是使用 mixins 的方式。但是在使用 class 的方式创建组件以后，mixins 的方式就不能使用了，并且其实 mixins 也是存在一些问题的，比如：</p><ul><li>隐含了一些依赖，多人开发，我写了某个state 并且在 mixins 中使用了，这就存在一个依赖关系。其他人要移除就要去 mixins 里面查找依赖</li><li>多个 mixin 中可能存在同名的函数，会造成函数重写</li><li>雪球效应，一个mixin 被多个组件使用，会由于需求使得 mixin 变得臃肿。</li></ul><p>HOC 解决了这些问题，并且它们达成的效果也是一致的，同时也更加函数式了。</p><h4 id="事件机制-1"><a href="#事件机制-1" class="headerlink" title="事件机制"></a>事件机制</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Test = <span class="function">(<span class="params">&#123;list,handleClick&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    list.map(<span class="function">(<span class="params">item,index</span>)=&gt;</span>(</span><br><span class="line">        &lt;span onClick=&#123;handleClick&#125; key=&#123;index&#125;&gt;&#123;index&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    ))</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>JSX 上写的事件并没有绑定在对应真实的 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在 document上，这样的方式不仅可以减少内存的损耗，还能在组件挂载时统一订阅和移除事件。</p><p>另外冒泡到  document 上的事件也不是原生的浏览器事件，而是 React自己实现的合成事件（SyntheticEvnet）。因此我们不想要事件冒泡的话，可以使用 event.preventDefault</p><p>合成事件的目的：</p><ul><li>抹平了浏览器之间的兼容问题，另外一个是跨浏览器原生事件包装器，赋予了跨浏览器开发的能力</li><li>对于原生浏览器来说，浏览器会给监听器创建一个事件对象，如果有很多事件监听就要分配很多事件对象会造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用的时候，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下一次复用事件对象。</li></ul><h2 id="Webpack性能优化"><a href="#Webpack性能优化" class="headerlink" title="Webpack性能优化"></a>Webpack性能优化</h2><h3 id="减少webpack-打包时间"><a href="#减少webpack-打包时间" class="headerlink" title="减少webpack 打包时间"></a>减少webpack 打包时间</h3><h3 id="优化-loader"><a href="#优化-loader" class="headerlink" title="优化 loader"></a>优化 loader</h3><p>影响打包效率第一个必定是 babel，因为 babel hi将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率越低。</p><p>可以优化 loader 的文件搜索范围</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:&#123;</span><br><span class="line">            <span class="comment">// 只对 js 文件使用 babel</span></span><br><span class="line">            test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">            loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">            <span class="comment">// 只在 src 文件夹下查找</span></span><br><span class="line">            include:[resolve(<span class="string">'src'</span>)],</span><br><span class="line">            exclude:<span class="regexp">/node_module/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以将 babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件就可以了,这样可以大幅度加快打包速度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loader:<span class="string">'babel-loader?cacheDirectory=true'</span></span><br></pre></td></tr></table></figure><h3 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h3><p>受限于 Node 是单线程的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。</p><p>HappyPack 可以将 loader 的同步执行转换为并行的，这样就可以充分利用系统的资源来加快打包效率了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    loaders:[&#123;</span><br><span class="line">        test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">        include:[resolve(<span class="string">'src'</span>)],</span><br><span class="line">        exclude:<span class="regexp">/node_module/</span>,</span><br><span class="line">        <span class="comment">// id 后面的内容对应下面的</span></span><br><span class="line">        loader:<span class="string">'happypack/loader?id=happybabel'</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">        id:<span class="string">'happybabel'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    loaders:[<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">    <span class="comment">// 开启四个线程</span></span><br><span class="line">    threads:<span class="number">4</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="DllPlugin"><a href="#DllPlugin" class="headerlink" title="DllPlugin"></a>DllPlugin</h3><p>DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要打包，并且也实现了将公告代码抽离出成单独文件的优化方案。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单独配置在一个文件中</span></span><br><span class="line"><span class="comment">// webpack.dll.conf.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">    enrty:&#123;</span><br><span class="line">        vendor:[<span class="string">'react'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">            <span class="comment">// 与 output.library 一致</span></span><br><span class="line">            name:<span class="string">'[name]-[hash]'</span>,</span><br><span class="line">            <span class="comment">// 与 DllReferencePlugin 中一致</span></span><br><span class="line">            context:__dirname,</span><br><span class="line">            path:path.join(__dirname,<span class="string">'dist'</span>,<span class="string">'[name]-mainfest.json'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    output:&#123;</span><br><span class="line">        path:path.join(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">        filename:<span class="string">'[name].dll.js'</span>,</span><br><span class="line">        library:<span class="string">'[name]-[hash]'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后运行这个配置文件生成依赖文件，使用 DllReferencePlugin 将依赖文件引入项目中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.conf.js</span></span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">    <span class="comment">// 省略其他配置</span></span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">            context:__dirname,</span><br><span class="line">            <span class="comment">// 之前打包出来的 json文件</span></span><br><span class="line">            mainfest:<span class="built_in">require</span>(<span class="string">'./dist/vendor-mainfest.json'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="减少webpack-打包后的体积"><a href="#减少webpack-打包后的体积" class="headerlink" title="减少webpack 打包后的体积"></a>减少webpack 打包后的体积</h3><p><strong>按需加载</strong></p><p>SPA 项目中都会存在十几甚至更多的路由页面。如果我们将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，我们肯定是希望首页能加载的文件体积越小越好，<strong>这时候我们就可以使用按需加载，将每个路由页面单独打包为一个文件</strong>。当然不仅仅路由可以按需加载，对于 <code>loadash</code> 这种大型类库同样可以使用这个功能。</p><p>底层的机制都是当使用的时候再去加载对应的文件，返回一个 Promis ，当 Promise 成功以后去执行回调</p><p><strong>Scope Hoisting</strong></p><p>Scope Hoisting 会分析出来模块之间的依赖关系，尽可能的把打包的模块合并到一个函数中去</p><p>比如打包两个文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br></pre></td></tr></table></figure><p>打包出来的代码是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="comment">/* 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;    </span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>但是如果我们使用 Scope Hoisting 的话，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="comment">/* 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在webpack4 中只要启用 optimization.concatenateModules 就可以了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    optimization:&#123;</span><br><span class="line">        concatenateModules:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tree Shaking</strong></p><p>Tree Shaking 可以实现删除项目中未被引用的代码，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br></pre></td></tr></table></figure><p>对于以上情况，<code>test</code> 文件中的变量 <code>b</code> 如果没有在项目中使用到的话，就不会被打包到文件中。</p><p>如果你使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;温故而知新，保持空杯心态.续 &lt;a href=&quot;https://yuchengkai.cn/docs/frontend&quot;&gt;前端面试之道&lt;/a&gt;继续复习浏览器相关内容&lt;/p&gt;
&lt;h2 id=&quot;浏览器基础&quot;&gt;&lt;a href=&quot;#浏览器基础&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="前端面试" scheme="http://laibh.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端面试题" scheme="http://laibh.top/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题目汇总摘录（JS 基础篇2）</title>
    <link href="http://laibh.top/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E6%91%98%E5%BD%95-JS%20%E5%9F%BA%E7%A1%80%E7%AF%872.html"/>
    <id>http://laibh.top/前端面试题目汇总摘录-JS 基础篇2.html</id>
    <published>2019-04-01T01:30:54.000Z</published>
    <updated>2020-07-11T03:24:57.643Z</updated>
    
    <content type="html"><![CDATA[<p>温故而知新，保持空杯心态,复习到一半的时间，突然发现了 <a href="https://yuchengkai.cn/docs/frontend">前端面试之道</a>，从第二道题目开始按学习这本书的路径来</p><h2 id="JS-基础2"><a href="#JS-基础2" class="headerlink" title="JS 基础2"></a>JS 基础2</h2><h3 id="React-Vue-项目时为什么要在组件中写-key，其作用是什么？"><a href="#React-Vue-项目时为什么要在组件中写-key，其作用是什么？" class="headerlink" title="React/Vue 项目时为什么要在组件中写 key，其作用是什么？"></a>React/Vue 项目时为什么要在组件中写 key，其作用是什么？</h3><blockquote><p>key是给每一个vnode的唯一id,可以<code>依靠key</code>,更<code>准确</code>, 更<code>快</code>的拿到oldVnode中对应的vnode节点。</p></blockquote><p>key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度。</p><p>Vue 和 React 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 中的 diff 函数，交叉对比中，当新节点跟旧节点 <code>头尾交叉对比</code>没有结果的时候，会根据新节点的 key 对比旧节点数组中的 key，从而找到对应旧节点。如果没有找到就认为是一个新增节点。而如果没有 key，那么就会采用遍历查找的方法找到对应的旧节点。。一种一个map 映射，另一种是遍历查找。相比之下，map 映射的速度更快。</p><p>vue 部分源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// oldCh 是一个旧虚拟节点数组</span></span><br><span class="line"><span class="keyword">if</span>(isUndef(oldKeyToIdx))&#123;</span><br><span class="line">   oldKeyToIdx = createKeyToOldIdx(oldCh,oldStartIdx,oldEndIdx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isDef(newStartVnode.key))&#123;</span><br><span class="line">   <span class="comment">// map 方式获取</span></span><br><span class="line">   idxInOld = oldKeyToIdx[newStartVnode.key]</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 遍历方式获取</span></span><br><span class="line">  idxInOld = findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 map 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createKeyToOldIdx</span>(<span class="params">children,beginIdx,endIdx</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i,key;</span><br><span class="line">    <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i = beginIdx;i &lt;= endIdx,++i)&#123;</span><br><span class="line">        key = children[i].key;</span><br><span class="line"><span class="keyword">if</span>(isDef(key) map[key] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历寻找</span></span><br><span class="line"><span class="comment">// sameVnode 是对比新旧节点是否相同的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findIdxInOld</span>(<span class="params">node,oldCh,start,end</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> c = oldCh[i];</span><br><span class="line">        <span class="keyword">if</span>(isDef(c) &amp;&amp; sameVnode(node,c)) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="“1”-”2”-”3”-map-parseInt-解析"><a href="#“1”-”2”-”3”-map-parseInt-解析" class="headerlink" title="[“1”,”2”,”3”].map(parseInt)解析"></a>[“1”,”2”,”3”].map(parseInt)解析</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>].map(<span class="built_in">parseInt</span>); <span class="comment">// [10,NaN,2,3,4]</span></span><br></pre></td></tr></table></figure><p><code>parseInt(string,radix)</code></p><p>参数：</p><p><code>string</code>:要被解析的值，如果参数不是一个字符串，则将其转换成字符串。字符串开头的空白符会被忽略。</p><p><code>radix</code>:一个介于2 和 36 的整数，表示上述字符串的基数。比如参数10 表示我们通常用的十进制数值系统。始终指定该参数可以消除阅读的困惑并且保证转换结果可预测。当未指定基数时，不同的实现会产生不同的结果，通常将值默认是10.</p><p><code>返回值</code>:返回解析的整数值。如果被解析参数的第一个字符无法被转换为数值类型，则返回 <code>NaN</code></p><p>注意：<code>radix</code>参数为n 会把第一个参数看做是一个数的 n 进制表示，而返回的值是十进制的。</p><ul><li>如果字符串string 是以 ‘0x‘ 或者 ‘0X’开头，则基数是16进制</li><li>如果字符串 string 是以 ’0‘ 开头，基数是8进制或者10进制。ES5 规定用10进制。</li><li>如果字符串string 以其他任何值开头，则默认是十进制</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>,<span class="number">10</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>,<span class="number">2</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p><code>map</code></p><p>map() 方法会创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数返回的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> new_array = arr.map(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[,index[,array]]</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// return element for new_array;</span></span><br><span class="line">&#125;[,thisArg]);</span><br></pre></td></tr></table></figure><p><code>callback</code>回调函数需要三个参数，我们通常只用了第一个参数（其他两个是可选的）</p><p><code>currentValue</code>:是 callback 数组中正在处理的当前元素。</p><p><code>index</code>:可选，是 callback 数组中正在处理的当前元素的索引</p><p><code>array</code>:可选，是 callback map 方法被调用的数组</p><p>另外还有 <code>thisAry</code>:执行 callback 函数使用的 this 值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>].map(<span class="built_in">parseInt</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">[<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>].map(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(item,index);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 即是</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>,<span class="number">0</span>); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>,<span class="number">1</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>,<span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>,<span class="number">3</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>,<span class="number">4</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>那么原题目也是同样的道理。</p><p>如果要将字符串数组循环变成数组可使用下面的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>].map(<span class="built_in">Number</span>);</span><br><span class="line"><span class="comment">// [10,10,10,10,10]</span></span><br></pre></td></tr></table></figure><h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p>JS 中分为7种内置类型，内置类型又分为两大类型：基本类型和对象（Object）[Function,Object,Array,Boolean,Number,String,Date,Error,RegExp,全局对象]</p><p>基本类型有：<code>null</code>,<code>undefined</code>,<code>string</code>,<code>number</code>,<code>boolean</code>,<code>symbol</code></p><p>其中 JS 的数字类型是浮点类型，没有整型。<code>NaN</code>也是 <code>number</code>类型，并且 <code>NaN</code>等于自身</p><p>对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会被会转换为对应的类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">111</span>; <span class="comment">// 这只是字面量，不是 number 类型</span></span><br><span class="line">a.toString(); <span class="comment">// 使用的时候才会被转换成为对象类型</span></span><br></pre></td></tr></table></figure><p>对象（Object ）是引用类型，在使用过程中会遇到浅拷贝和深拷贝的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">name</span>:<span class="string">'haha'</span>&#125;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b.name = <span class="string">'haha2'</span></span><br><span class="line">a.name; <span class="comment">// haha2</span></span><br></pre></td></tr></table></figure><h3 id="Typeof"><a href="#Typeof" class="headerlink" title="Typeof"></a>Typeof</h3><p>typeof 对于基本类型，除了 null 都可以显示正确的类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">//'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'1'</span>; <span class="comment">//'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">//'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">//'null'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">//'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(); <span class="comment">//'symbol'</span></span><br><span class="line"><span class="keyword">typeof</span> b <span class="comment">// b 没有声明，但是还会显示 undefined</span></span><br></pre></td></tr></table></figure><p>typeof 对于对象，除了函数都会显示 Object</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> []; <span class="string">'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="string">'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log; <span class="string">'function'</span></span><br></pre></td></tr></table></figure><p>对于 null 来说，虽然它是基本类型。但是会显示 object ，这是一个存在很久的 Bug。在JS 的最初版本，使用的是32位系统，为了性能问题使用低位储存了变量的内部信息，<code>000</code> 开头代表对象，然后 <code>null</code> 表示全为零，所以将它错误的判断为 object 。虽然现在内部类型判断代码已经更改了，但是这个 bug 却是一直流传下来的。</p><p>如果想要获得一个变量的正确类型，可以通过 <code>Object.prototype.call(xx)</code>，这样就可以获得类似 <code>[object type]</code>的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let a</span><br><span class="line"><span class="comment">// 我们也可以这样判断 undefined</span></span><br><span class="line">a === undefined</span><br><span class="line"><span class="comment">// 但是 undefined 不是保留字，能够在低版本浏览器被赋值</span></span><br><span class="line">let undefined = <span class="number">1</span></span><br><span class="line"><span class="comment">// 这样判断就会出错</span></span><br><span class="line"><span class="comment">// 所以可以用下面的方式来判断，并且代码量更少</span></span><br><span class="line"><span class="comment">// 因为 void 后面随便跟上一个组成表达式</span></span><br><span class="line"><span class="comment">// 返回就是 undefined</span></span><br><span class="line">a === <span class="keyword">void</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="转Boolean"><a href="#转Boolean" class="headerlink" title="转Boolean"></a><strong>转Boolean</strong></h4><p>在条件判断时，除了 <code>undefined</code>,<code>null</code>,<code>false</code>,<code>NaN</code>,<code>&#39;&#39;</code>,<code>0</code>,<code>-0</code> 其他所有值都转为 true,包括所有对象。</p><h4 id="对象转基本类型"><a href="#对象转基本类型" class="headerlink" title="对象转基本类型"></a><strong>对象转基本类型</strong></h4><p>对象转基本类型时，首先会调用 <code>valueOf</code>然后调用 <code>toString</code>，并且这个两个方法是可以重写的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    valueOf()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以重写 <code>Symbol.toPrimitive</code>，该方法在转基本类型时调用优先级最高</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a =&#123;</span><br><span class="line">    valueOf()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    toString()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'1'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span> + a <span class="comment">// 3</span></span><br><span class="line"><span class="string">'1'</span> + a <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><h4 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a><strong>四则运算符</strong></h4><p>加法运算规则：</p><ol><li>其中一方是字符串类型，另外一方亦然</li><li>其中一方是数字类型，另外一方亦然</li><li>只会触发三种类型转换：值 =&gt; 原始值, =&gt; 数字，=&gt; 字符串</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">'1'</span> <span class="comment">// 11</span></span><br><span class="line"><span class="number">2</span> * <span class="string">'2'</span> <span class="comment">// 4</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>] +[<span class="number">2</span>,<span class="number">1</span>] <span class="comment">// '1,22,1'</span></span><br><span class="line"><span class="comment">// [1,2].toString -&gt; '1,2'</span></span><br><span class="line"><span class="comment">// [2,1].toString -&gt; '2,1'</span></span><br><span class="line"><span class="string">'1,2'</span>+ <span class="string">'2,1'</span> = <span class="string">'1,22,1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于加号要注意表达式 'a'++'b'</span></span><br><span class="line"><span class="string">'a'</span>++ <span class="string">'b'</span> <span class="comment">// 'aNaN'</span></span><br><span class="line"><span class="comment">// 因为 + 'b' 等于 NaN</span></span><br></pre></td></tr></table></figure><h4 id="操作符"><a href="#操作符" class="headerlink" title="== 操作符"></a><strong>== 操作符</strong></h4><p>比较运算 x==y,其中 x 和 y 是值，产生 true 或者 false ，这样的比较按下面的方式进行：</p><ol><li>若Type(x) 和 Type(y)相同，则<ol><li>若 Type(x) 为 undefined,返回 true</li><li>若 Type(x) 为 Null,返回 true</li><li>若 Type(x) 为 Number,则<ol><li>若 x 为 NaN,返回 false</li><li>若 y 为 NaN,返回 false</li><li>若 x 与 y 为相等数值，返回 true</li><li>若 x 为 +0, y 为 -0，返回 true</li><li>若 x 为 -0, y 为 +0，返回 true</li><li>返回 false</li></ol></li><li>若 Type(x) 为 String,则 x 和 y 为完全相同的字符序列（长度相等且相同字符在相同位置）时返回 true,否则，返回 false</li><li>若 Type(x) 为 Boolean,当 x 和 y 同为 true 或者同为 false 时返回 true,否则，返回 false。</li><li>当 x 和 y 为引用同一对象时返回 true,否则返回 false.</li></ol></li><li>若 x 为 null 且 y 为 undefined ，返回 true</li><li>若 x 为 undefined 且 y 为 null ,返回 true</li><li>若 Type(x) 为 Number,且 Type(y) 为 String,返回比较 x == toNumber(y) 的结果</li><li>若 Type(x) 为 String 且 Type(y) 为 Number,返回比较 ToNumber(x) == y 的结果</li><li>若 Type(x) 为 Boolean，返回 比较 ToNumber(x) ==y 的结果</li><li>若 Type(y) 为 Boolean,返回比较 ToNumber(y) ==x 的结果</li><li>若 Type(x) 为 String 或者 Number，且 Type(y) 为 Object,返回比较 x==ToPrimitive(y) 的结果</li><li>若 Type(y) 为 String 或者 Number，且 Type(x) 为 Object,返回比较 y==ToPrimitive(x) 的结果</li><li>返回 false</li></ol><p>toPrimitive 就是对象转基本类型</p><p>对照上面的规则，分析下面的案例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[] == ![] <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 由于 ！优先级大于 ==，所以先运算右边，[] 为 true, ![] 取反为 false，得出</span></span><br><span class="line">[] == <span class="literal">false</span></span><br><span class="line"><span class="comment">// 根据第7条规则 ToNumber(y) ==x ，得出</span></span><br><span class="line">[] == <span class="number">0</span></span><br><span class="line"><span class="comment">// 根据第9条规则， y==ToPrimitive(x)，得出</span></span><br><span class="line">ToPrimitive([]) == <span class="number">0</span></span><br><span class="line"><span class="comment">// 即是</span></span><br><span class="line">[].toString() == <span class="number">0</span></span><br><span class="line"><span class="comment">// 得出</span></span><br><span class="line"><span class="string">''</span> == <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 根据第5条规则，ToNumber(x) == y 得出</span></span><br><span class="line"><span class="number">0</span> == <span class="number">0</span> <span class="comment">// -&gt;true</span></span><br></pre></td></tr></table></figure><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a><strong>比较运算符</strong></h4><ol><li>如果是对象，就通过 toPrimitive 转换对象</li><li>如果是字符串，就通过 unicode 字符索引来比较</li></ol><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p><img src="./images/前端面试题目汇总摘录-JS 基础篇2-原型.png" alt="原型"></p><p>每个函数都有 prototype 属性，除了 Function.prototype.bind() 该属性指向原型。</p><p>每个对象都有 <code>__proto__</code>属性，指向了创建该对象的构造函数的原型，其实这个属性指向了 <code>[[proptotype]]</code>，但是 <code>[[proptotype]]</code>是内部属性，我们并不能访问到，所以使用 <code>__proto__</code>来访问。对象可以通过 <code>__proto__</code>来寻找不属于该对象的属性，<code>__proto__</code>将对象连接起来形成了原型链。</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><ol><li>新生成了一个对象</li><li>链接到原型</li><li>绑定 this</li><li>返回新对象</li></ol><p>在调用 new 的过程会发生上面四种事情，下面是自己实现的一个 new</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">// 获得构造函数</span></span><br><span class="line">    <span class="keyword">let</span> Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 链接到原型</span></span><br><span class="line">    Obj.__proto__. = Con.prototype;</span><br><span class="line">    <span class="comment">// 绑定 this,执行构造函数</span></span><br><span class="line">    <span class="keyword">let</span> result = Con.apply(obj,<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 确保 new 出来的是个对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result == <span class="string">'Object'</span> ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于实例对象来说，都是通过 new 产生的，无论是 function Foo(){} 还是 let a = {b:1}</p><p>对于创建一个对象来说，更推荐使用字面量的方式来创建对象（无论是性能上还是可读性）。使用 new Object 方式创建对象需要通过作用域链一层层找到 Object，但是使用字面量就没有这个困扰</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">// function 就是个语法糖，相当于 new Function()</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">b</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// 这个字面量也是使用了 new Object();</span></span><br></pre></td></tr></table></figure><p>对于 new 来说，还需要注意下面的运算符优先级</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Foo.getName(); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>可以看出 new Foo() 优先级大于 new Foo,所以代码可以这样划分执行顺序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (Foo.getName())</span><br><span class="line">(<span class="keyword">new</span> Foo).getName();</span><br></pre></td></tr></table></figure><p>对于第一个函数来说，先执行了 Foo.getName 所以结果为1，对于后者来说，先 new Foo() 产生了一个实例，然后通过原型链找到了 Foo 上面的 getName 函数，所以结果为 2</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof 可以正确判断对象的类型，因为内部机制是通过判断对象的原型链是不是能找到类型的 prototype </p><p>我们也可以试着实现:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceof</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 获得类型的原型</span></span><br><span class="line">    <span class="keyword">let</span> prototype = right.prototype;</span><br><span class="line">    <span class="comment">// 获得对象的原型</span></span><br><span class="line">    left = left.__Proto__;</span><br><span class="line">    <span class="comment">// 判断对象的类型是否等于类型的原型</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left === <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prototype === left)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        left = left.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this 记住几个规则就可以了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">foo();</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span>,</span><br><span class="line">    foo:foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面两种情况 this 只依赖调用函数前的对象，优先级是第二个情况大于第一个情况</span></span><br><span class="line"><span class="comment">// 下面的优先级是最高的，this 只会绑定在c 上面，不会被任何方式修改 this 指向</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> foo();</span><br><span class="line">c.a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c.a); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//还有一种情况是利用 call,apply或者 bind 改变 this，这个优先级仅次于 new</span></span><br></pre></td></tr></table></figure><p>箭头函数中的 this </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a()()());</span><br></pre></td></tr></table></figure><p>箭头函数其实是没有 this，这个函数中的 this 只取决于外面的第一个不是箭头函数的函数的this 。在上面的例子中，因为调用 a 符合前面代码的第一种情况，所以 this 是 window，并且一旦 this 绑定上下文了，就不会被任何代码改变。</p><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>当执行 JS 代码的时候，会产生三种执行上下文</p><ul><li>全局执行上下文</li><li>函数执行上下文</li><li>eval 执行上下文</li></ul><p>每个执行上下文都有三个重要的属性</p><ul><li>变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问</li><li>作用域链（JS 采用词法作用域，也就是说变量的作用域是在定义时就决定的）</li><li>this</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>对于上述代码，执行栈中有两个上下文：全局上下文和函数 foo 上下文</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack = [</span><br><span class="line">    globalContext,</span><br><span class="line">    fooContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>对于全局上下文来说，VO 大概是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">globalContext.VO === global</span><br><span class="line">globalContext.VO = &#123;</span><br><span class="line">    a:<span class="literal">undefined</span>,</span><br><span class="line">    foo:<span class="xml"><span class="tag">&lt;<span class="name">Function</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>对于 函数 foo 来说，VO 不能被访问，只能访问到活动对象（AO）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fooContext.VO === foo.AO</span><br><span class="line">fooContext.AO = &#123;</span><br><span class="line">    i:<span class="literal">undefined</span>,</span><br><span class="line">    b:<span class="literal">undefined</span>,</span><br><span class="line">    <span class="built_in">arguments</span>:<span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// arguments 是函数底油的对象（箭头函数没有），这个对象是一个伪数组，有 length 属性可以通过下标访问元素，该对象的 callee 属性代表函数本身，caller 属性代表函数的调用者</span></span><br></pre></td></tr></table></figure><p>对于作用域链，可以把它理解为包含自身变量对象和上级变量对象的列表，通过 [[Scope]] 属性查找上级变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fooContext.[[Scope]] = [ globalContext.VO ]</span><br><span class="line">fooContext.Scope = fooContext.[[Scope]] + fooContext.VO</span><br><span class="line">fooContext.Scope = [</span><br><span class="line">    fooContext.Vo,</span><br><span class="line">    globalContext.Vo</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>举个例子，var</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b(); <span class="comment">// hehe</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'haha'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hehe'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的结果是因为函数和变量提升的原因。通常替身的解释是说将生命的代码移到了顶部，这其实没有什么错误，便于理解。但是更准确的解释应该是：在生成执行上下文时，会有两个阶段。第一个阶段是创建的阶段（具体步骤是创建 VO），JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数放入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码的执行阶段，我们可以直接提前使用。</p><p>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b(); <span class="comment">//2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'haha'</span>;</span><br></pre></td></tr></table></figure><p>var 会产生很多错误，所以现在 ES6 中引入了 let，let 不能在声明前使用，但是这并不是常说的 let 不会提升，let 提升了声明但是没有赋值，因为临时死区导致了并不能在声明前使用</p><p>对于非匿名立即执行函数需要注意下面的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    foo = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**ƒ foo() &#123;</span></span><br><span class="line"><span class="comment">    foo = 10</span></span><br><span class="line"><span class="comment">    console.log(foo)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>因为当 JS 解释器在遇到非匿名的理解执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 foo，但是这个值又是只读的，所以对它的赋值并不会生效，所以打印出来的还是这个函数，并且外部的值也没有任何改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">specialObject = &#123;&#125;</span><br><span class="line">Scope = specialObject + Scope;</span><br><span class="line">foo = <span class="keyword">new</span> FunctionExpression;</span><br><span class="line">foo.[[Scope]] = Scope;</span><br><span class="line">specialObject.foo = foo; <span class="comment">// &#123;DontDelete&#125;, &#123;ReadOnly&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> Scope[<span class="number">0</span>]; <span class="comment">// remove specialObject from the front of scope chain</span></span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包的定义很简单：函数 A 返回一个函数 B，并且函数 B 中使用了 函数 A 的变量，函数 B就被称为闭包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 A 中的变量这时候是存储在堆上的，JS 引擎可以通过逃逸分析辨别哪些变量需要存储在对上，哪些需要存储在栈上。</p><p>循环中使用闭包解决 var 定义函数的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，因为 setTimeout 是异步函数，所以回先把所有U型你换全部执行完毕，这时候 i 就是 6了，所以会输出一堆 6.</p><p>解决的方法有两种，第一种是使用闭包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j)</span><br><span class="line">        &#125;,j*<span class="number">1000</span>);</span><br><span class="line">    &#125;)(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种是使用 setTimeout 的第三个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;,i*<span class="number">1000</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种就是使用 let 定义 i</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为对于 let 来说，会创建一个块级作用域，相当于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 形成块级作用域</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> ii = i;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(ii);</span><br><span class="line">        &#125;,i*<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> ii = i</span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> ii = i</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">a.age = <span class="number">2</span>;</span><br><span class="line">b.age; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>从上述例子可以看出，如果给一个变量赋值一个对象，那么两者的值会是同一引用，其中一方改变，另一方也会相应改变。</p><p>通常在开发中，我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个问题。</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a><strong>浅拷贝</strong></h4><p>首先可以通过 <code>Object.assign</code> 来解决这个问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;,a);</span><br><span class="line">a.age = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.age); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>也可通过展开运算符（…）来解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">    ...a</span><br><span class="line">&#125;</span><br><span class="line">a.age = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.age); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>通常拷贝能解决大部分问题，但是当我们遇到下面的情况就需要使用深拷贝了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="number">1</span>,</span><br><span class="line">    jobs:&#123;</span><br><span class="line">        first:<span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">    ...a</span><br><span class="line">&#125;</span><br><span class="line">a.job.first = <span class="string">'native'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first); <span class="comment">// native</span></span><br></pre></td></tr></table></figure><p>浅拷贝只解决了第一层问题，如果接下去的值中还有对象的话，那么两者又享有相同的引用，要解决这个问题，要引入深拷贝。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a><strong>深拷贝</strong></h4><p>这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code>来解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="number">1</span>,</span><br><span class="line">    jobs:&#123;</span><br><span class="line">        first:<span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line">a.jobs.first = <span class="string">'native'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first); <span class="comment">// 'FE'</span></span><br></pre></td></tr></table></figure><p>但是该方法也是有局限性的：</p><ul><li>会忽略 <code>undefined</code></li><li>会忽略 <code>symbol</code></li><li>不能序列化函数</li><li>不能解决循环引用的对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">        c:<span class="number">2</span>,</span><br><span class="line">        d:<span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.c = obj.b;</span><br><span class="line">obj.e = obj.a;</span><br><span class="line">obj.b.c = obj.c</span><br><span class="line">obj.b.d = obj.b</span><br><span class="line">obj.b.e = obj.b.c</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(newObj);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Converting circular structure to JSON</span></span><br><span class="line"><span class="comment">//   at JSON.stringify (&lt;anonymous&gt;)</span></span><br><span class="line"><span class="comment">//   at &lt;anonymous&gt;:14:30</span></span><br></pre></td></tr></table></figure><p>在遇到函数、undefined或者 symbol 的时候，该对象也不能正常的序列化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="literal">undefined</span>,</span><br><span class="line">    sex:<span class="built_in">Symbol</span>(<span class="string">'male'</span>),</span><br><span class="line">    jobs:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    name:<span class="string">'haha'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// &#123;name:'haha'&#125;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，该方法会忽略掉函数和 <code>undefined</code></p><p>但是在通常情况下，复杂数据是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。数据中含有以上三种情况下，可以使用 <a href="https://lodash.com/docs##cloneDeep">lodash 的深拷贝函数</a>。</p><p>如果所需要拷贝的对象含有内置类型并且不包括函数的，可以使用 MessageChannel</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">structuralClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;port1,port2&#125; = <span class="keyword">new</span> MessageChannel;</span><br><span class="line">        port2.onmessage = <span class="function"><span class="params">ev</span> =&gt;</span> resolve(ev.data);</span><br><span class="line">        port1.postMessage(obj)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">       c:b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该方法是异步的</span></span><br><span class="line"><span class="comment">// 可以循环处理 undefined 和循环引用对象</span></span><br><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> clone = <span class="keyword">await</span> structualClone(obj)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>我们也可以自己创建一个 deepClone 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字 字符串 function 不需要拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCline</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value == <span class="literal">null</span>) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> value !== <span class="string">'object'</span>) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(value);</span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value)</span><br><span class="line">    <span class="comment">// 判断是数组还是对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> value.constructor;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> ket <span class="keyword">in</span> value)&#123;</span><br><span class="line">        obj[key] = deepClone(value[key])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>在有 Babel 的情况下， 可以直接使用 ES6 的模块化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file a.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;a,b&#125; <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"><span class="keyword">import</span> XXX <span class="keyword">from</span> <span class="string">'./b.js'</span></span><br></pre></td></tr></table></figure><h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a><strong>CommonJS</strong></h4><p>CommonJS 是 Node 独有的规范，浏览器中使用就需要用到 Broserify 解析</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    a:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span>.a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="built_in">module</span>.a <span class="comment">// -&gt; log 1</span></span><br></pre></td></tr></table></figure><p>在上述代码中，module.export 和 export 很容易混淆，看看大致的内部实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="built_in">module</span>.a</span><br><span class="line"><span class="comment">// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，重要的是 module 这里，module 是 Node 独有的一个变量</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    a:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 基本实现</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">    exports:&#123;&#125; <span class="comment">// exports 就是空对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这也是为什么 exports 和 module.exports 用法相似的原因</span></span><br><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports;</span><br><span class="line"><span class="keyword">var</span> load = <span class="function"><span class="keyword">function</span>(<span class="params">module</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">module</span>.exports = a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>module.exports 和 exports 用法其实是相似的，但是不能对 exports 直接赋值，不会有任何效果。</p><p>对于 CommonJS 和 ES6 的模块化的两者区别是：</p><ul><li>前者支持动态导入，也就是 require(${path}/xx.js),后者不支持，但是已有提案</li><li>前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li><li>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想要更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li><li>后者会编译成 require/exports 来执行</li></ul><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a><strong>AMD</strong></h4><p>AMD 是由 RequireJS 提出的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'./a.js'</span>,<span class="string">'./b.js'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    a.do();</span><br><span class="line">    b.do();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require,exports,module</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line">    b.doSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="节流和防抖的理解"><a href="#节流和防抖的理解" class="headerlink" title="节流和防抖的理解"></a>节流和防抖的理解</h3><p>防抖和节流都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于 wait，防抖的情况只会调用一次，而节流的情况会隔一定时间（参数wait）调用函数</p><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a><strong>防抖</strong></h4><p>在滚动事件中需要做一个复杂计算或者是实现一个按钮防止第二次点击操作。这些需求都可以通过函数防抖来实现，尤其是第一个需求，如果在频繁的时间回调中做复杂计算，很有可能会导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。</p><p>通俗化：如果用手指一直按着弹簧，它将不会弹起知道你松手为止</p><p>袖珍版的防抖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func 是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">// wait 是等待时间</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">func,wait = <span class="number">50</span></span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 缓存一个定时器id</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 返回的函数是每次用户实际调用防抖函数，如果已经设定过定时器就清空上一次的定时器，开始一个新的定时器，延迟用户传入的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">..args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            func.apply(<span class="keyword">this</span>,args);</span><br><span class="line">        &#125;,wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不难看出来如果用户调用该函数间隔小于 wait 的情况下，上一次时间还未到就被清除了，并不会执行函数。</span></span><br></pre></td></tr></table></figure><p>这是一个简单的防抖，但是有缺陷，在于它只能最后调用。一般的防抖会有 immediate 选项，表示是否立即调用。这两者的区别：</p><ul><li>例如在搜索引擎搜索问题的时候，我们当然希望用户输入完最后一个字才调用查询接口，这个时候用 <code>延迟执行</code> 的防抖函数，它总是在一连串（间隔小于 wait）函数触发之后调用</li><li>例如用户给项目点 star 的时候，我们希望用户点第一下的时候就去调用接口，并成功之后改变 star 按钮的样子，用户就可以立马得到反馈是否 star 成功了，这个情况使用 <code>立即调用</code>的防抖函数，它总在第一次调用，并且下一次调用必须和前一次调用的时间间隔大于 wait 才会触发。</li></ul><p>带有立即执行的防抖函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个用来获取当前时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">now</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 防抖函数，返回函数连续调用，空闲时间必须大于或者等于 wait,func 才会执行</span></span><br><span class="line"><span class="comment">* @param &#123;function&#125; func 回调函数</span></span><br><span class="line"><span class="comment">* @param &#123;number&#125; wait 表示窗口的间隔</span></span><br><span class="line"><span class="comment">* @param &#123;boolean&#125; immediate 设置为 true时，是否立即调用函数</span></span><br><span class="line"><span class="comment">* @return &#123;function&#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait=<span class="number">50</span>,immediate=true</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer,context,args;</span><br><span class="line">    <span class="comment">// 延迟执行函数</span></span><br><span class="line">    <span class="keyword">const</span> later = <span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 延迟执行函数执行完毕，清除缓存的定时器序号</span></span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 延迟执行的情况下，函数会在延时函数中执行，使用到之前缓存的参数和上下文</span></span><br><span class="line">        <span class="keyword">if</span>(!immediate)&#123;</span><br><span class="line">           func.apply(context,args);</span><br><span class="line">            context = args = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,wait)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里返回的函数是每次实际调用的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...params</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 如果没有创建样式执行函数（later）,那就创建一个</span></span><br><span class="line">        <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">           timer = later();</span><br><span class="line">           <span class="comment">// 如果是立即执行，调用函数，否则缓存参数和调用上下文</span></span><br><span class="line">            <span class="keyword">if</span>(immediate)&#123;</span><br><span class="line">               func.apply(<span class="keyword">this</span>,params);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                context = <span class="keyword">this</span>;</span><br><span class="line">                args = params</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 如果已有延迟执行函数（later） ，调用的时候清除原来的并重新设定一个</span></span><br><span class="line">        <span class="comment">// 这样做延迟函数会重新计时</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = later();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结一下：</p><ul><li>对于按钮点击来说的实现:如果函数是立即执行的，就理解调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中执行，一旦开始一个定时器，只要定时器还在，每次点击都会重新计时。一旦定时器时间到了，定时器重置为null,就可以再次点击了。</li><li>对于延迟函数来说的实现：清除定时器ID，如果是延迟调用就调用函数</li></ul><h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a><strong>节流</strong></h4><p>防抖和节流本质上是不一样的。防抖是将多次执行变成最后一次执行，节流是将多次执行变成每隔一段时间执行。</p><p>通俗化：如果将水龙头拧紧直到水是以水滴的形式流出，那么你会发现隔一段时间，就会有一滴水溜出来。也就是会预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个周期</p><p>袖珍版实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">wait,func</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> curr = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">if</span>(curr - last &gt; wait)&#123;</span><br><span class="line">           func.apply(<span class="keyword">this</span>,args);</span><br><span class="line">            last = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* underscore 节流函数，返回函数连续调用，func 执行频率是 次/wait</span></span><br><span class="line"><span class="comment">* @param &#123;function&#125; func 回调函数</span></span><br><span class="line"><span class="comment">* @param &#123;number&#125; wait 表示窗口的间隔</span></span><br><span class="line"><span class="comment">* @param &#123;object&#125; options 如果想忽略开始函数的调用，传入&#123;leading:false&#125;,如果想忽略结尾函数则是&#123;trailing:false&#125;,两者不能共存，否则函数不执行。</span></span><br><span class="line"><span class="comment">* @return &#123;function&#125; 返回客户调用的函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">_.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func,wait,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context,args,result;</span><br><span class="line">    <span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 之间的时间戳</span></span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果 options 没传则设置为空对象</span></span><br><span class="line">    <span class="keyword">if</span>(!options) options = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 定时器回调函数</span></span><br><span class="line">    <span class="keyword">const</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 如果设置了 leading,就将 previous 设为0，用于下一个函数的第一个 if 判断</span></span><br><span class="line">        previous = options.length === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</span><br><span class="line">        <span class="comment">// 置空是为了防止内存泄露，也是为了下面定时器的判断</span></span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        result = func.apply(context,args);</span><br><span class="line">        <span class="keyword">if</span>(!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 获得当前的时间戳</span></span><br><span class="line">        <span class="keyword">const</span> now = _.now;</span><br><span class="line">        <span class="comment">// 首先进入前者肯定要为 true,如果需要第一次不执行函数，就将上次时间戳设定为当前的，就下来的计算中 remaining 的值时会大于0</span></span><br><span class="line">        <span class="keyword">if</span>(previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">        <span class="comment">// 计算剩下的时间</span></span><br><span class="line">        <span class="keyword">const</span> remaining = wait - (now - previous);</span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="comment">// 如果当前调用给意见大于上次时间 + wait，或者用户手动调了事件，如果设置 trailing，只会进入这个条件</span></span><br><span class="line">        <span class="keyword">if</span>(remaining &lt;= <span class="number">0</span> || remaining &gt; wait)&#123;</span><br><span class="line">            <span class="comment">// 如果存在定时器就清理掉否则会调用二次回调</span></span><br><span class="line">            <span class="keyword">if</span>(timeout)&#123;</span><br><span class="line">               clearTimeout(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            result = func.apply(context,args);</span><br><span class="line">            <span class="keyword">if</span>(!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!timeout &amp;&amp;options.trailing !== <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="comment">// 判断是否设置了定时器和 trailing ，没有的话就开启一个定时器，并且不能同时设置 leading 和 trailing</span></span><br><span class="line">            timeout = setTimeout(later,remaining);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在 ES5 中，可以使用下面的方式解决继承的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Super.prototype.getNumber = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Sub();</span><br><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype,&#123;</span><br><span class="line">    <span class="keyword">constructor</span>:&#123;</span><br><span class="line">        value:Sub,</span><br><span class="line">        enumerable:<span class="literal">false</span>,</span><br><span class="line">        writable:<span class="literal">true</span>,</span><br><span class="line">        configurable:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的继承实现思路就是将子类的原型设置为父类的原型</p><p>在 ES6 中，可以通过 class 语法糖解决这个问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span> <span class="keyword">extends</span> <span class="title">Date</span></span>&#123;</span><br><span class="line">    test()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myDate = <span class="keyword">new</span> MyDate();</span><br><span class="line">myDate.test();</span><br></pre></td></tr></table></figure><h3 id="call-apply-bind-区别"><a href="#call-apply-bind-区别" class="headerlink" title="call,apply,bind 区别"></a>call,apply,bind 区别</h3><p>call 和 apply 都是为了解决改变 this  的指向，作用都是相同的，只是传参的方式不同，除了第一个参数外，call 可以接受一个参数列表，apply 只接受一个参数数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a =&#123;</span><br><span class="line">    value:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line">getValue.call(a,<span class="string">'haha'</span>,<span class="string">'24'</span>);</span><br><span class="line">getValue.apply(a,[<span class="string">'haha'</span>,<span class="string">'24'</span>]);</span><br></pre></td></tr></table></figure><h4 id="模拟实现-call-和-apply"><a href="#模拟实现-call-和-apply" class="headerlink" title="模拟实现 call 和 apply"></a><strong>模拟实现 call 和 apply</strong></h4><p>可以从下面几点来考虑如何实现</p><ul><li>不传入第一个参数，那么默认可以为 window</li><li>改变了 this 指向，让新的对象可以执行该函数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    <span class="comment">// 给 context 添加一个属性</span></span><br><span class="line">    <span class="comment">// getValue.call(a,'haha',24) -&gt; a.fn('haha','24');</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 将 context 后面的参数取出来</span></span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除 fn</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>apply 的实现也是类似的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="comment">// 判断是否存在第二个参数，如果存在就把第二个参数展开</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>])&#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>]);   </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bind 和其他两个方法作用也是一样的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化</p><p>模拟实现 bind</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'undefined'</span>)&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> F)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> _this(..args,...arguments);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context,args.concat(...arguments));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-实现"><a href="#Promise-实现" class="headerlink" title="Promise 实现"></a>Promise 实现</h3><p>Promise 是 ES6 新增的语法，解决了回调地狱的问题。</p><p>可以把 Promise 看成一个状态机。初始状态是 pending 状态，可以通过函数 resolve 和 reject ，将状态转变为 resolved 和 rejected 状态，状态一旦改变就不能再发生变化了。</p><p>then 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。因为 Promise 规范规定了 pending 状态，其他状态是不可以改变的，如果返回的是同一个实例的话，多个 then 调用就失去意义了。</p><p>对于 then 来说，本质上可以把它看成 flatMap</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line">  <span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span>;</span><br><span class="line">  <span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// promise 接受一个函数参数，该函数会理解执行</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    _this.currentState = PENDING;</span><br><span class="line">    _this.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 用于保存 then 中的回调，只有当 promise 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">    _this.resolvedCallbacks = [];</span><br><span class="line">    _this.rejectedCallbacks = [];</span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">        <span class="comment">// 如果 value 是个 Promise ，递归执行</span></span><br><span class="line">        <span class="keyword">return</span> value.then(_this.resolve, _this.reject);</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 异步执行，保证执行顺序</span></span><br><span class="line">        <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">          _this.currentState = RESOLVED;</span><br><span class="line">          _this.value = value;</span><br><span class="line">          _this.resolvedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">          _this.currentState = REJECTED;</span><br><span class="line">          _this.value = reason;</span><br><span class="line">          _this.rejectedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于解决下面的问题</span></span><br><span class="line">    <span class="comment">// new Promise(()=&gt; throw Error('error'))</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fn(_this.resolve, _this.reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      _this.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// then 函数的作用是为 Promise 实例添加状态改变时的回调函数。then 方法的第一个参数是 resolved 状态的回调函数，第二个参数（可选）是 rejected 状态的回调函数。</span></span><br><span class="line"><span class="comment">// then 方法返回的是一个新的 promise 实例，因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。</span></span><br><span class="line">  MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// then 必须返回一个新的 promise</span></span><br><span class="line">    <span class="keyword">let</span> promise2;</span><br><span class="line">    <span class="comment">// 如果 onResolved 和 onRejected 都为可选参数，如果类型不是函数需要忽略，同时也实现了透传</span></span><br><span class="line">    <span class="comment">// Promise.resolve(4).then().then((value)=&gt;console.log(value))</span></span><br><span class="line">    onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">'function'</span> ? onResolved : <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">r</span> =&gt;</span> &#123; <span class="keyword">throw</span> r &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self.currentState === RESOLVED) &#123;</span><br><span class="line">      <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onResolve(self.value);</span><br><span class="line">            resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (self.currentState === REJECTED) &#123;</span><br><span class="line">      <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(self.value);</span><br><span class="line">            resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (self.currentState === PENDING) &#123;</span><br><span class="line">      <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        self.rejectedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(self.value);</span><br><span class="line">            resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (r) &#123;</span><br><span class="line">            reject(r)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        self.resolvedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onResolved(self.value);</span><br><span class="line">            resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (r) &#123;</span><br><span class="line">            reject(r)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolutionProcedure</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// x 不能与 promise2 相同，避免循环</span></span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">      <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 x 为 Promise ，状态为 pending 需要继续等待否则执行</span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x.currentState === PENDING) &#123;</span><br><span class="line">        x.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 再次调用该函数是为了确认 x resolve 的 参数是什么类型，如果是基本类型就再次 resolve，把值传给下一个 then</span></span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">        &#125;, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x.then(resolve, reject);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reject 或者 resolve 其中一个执行得过的话，忽略其他的</span></span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 判断 x 是否为对象或者是函数</span></span><br><span class="line">    <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">      <span class="comment">// 如果不能取出 then ，就 reject</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> then = x.then;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">          then.call(</span><br><span class="line">            x,</span><br><span class="line">            y =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">              called = <span class="literal">true</span>;</span><br><span class="line">              resolutionProcedure(promise2, y, resolve, reject);</span><br><span class="line">            &#125;,</span><br><span class="line">            e =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">              called = <span class="literal">true</span>;</span><br><span class="line">              reject(e);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(x)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Generator-实现"><a href="#Generator-实现" class="headerlink" title="Generator 实现"></a>Generator 实现</h3><p>Generator 是 ES6 中新增的语法，和 Promise 一样，都可以用异步来编程。</p><p>Generator 函数也可以理解成为一个状态机，封装了多个内部状态。</p><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p>形式上，Generator 函数是一个普通函数，但是有两个特征。一个是 function 关键字与函数名之间有一个 星号，二是函数内部使用 yield 表达式，表示不同的内部状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 * 表示这是一个 Generator 函数</span></span><br><span class="line"><span class="comment">// 内部可以使用 yield 暂停代码</span></span><br><span class="line"><span class="comment">// 调用 next 恢复执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = test();</span><br><span class="line">b.next(); <span class="comment">// &#123;value:2,done:false&#125;</span></span><br><span class="line">b.next(); <span class="comment">// &#123;value:3,done:false&#125;</span></span><br><span class="line">b.next(); <span class="comment">// &#123;value:undefined,done:true&#125;</span></span><br></pre></td></tr></table></figure><p>上述代码可以发现，加上 * 的函数执行后拥有了 next 函数，也就是说函数执行后返回了一个对象。每次调用 next 函数可以继续执行被暂停的代码，下面是 Generator 的简单实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cb 也就是编译的 test 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyGerenator</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> object = &#123;</span><br><span class="line">      next: <span class="number">0</span>,</span><br><span class="line">      stop: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> ret = cb(obj);</span><br><span class="line">        <span class="keyword">if</span> (ret === <span class="literal">undefined</span>) <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: ret,</span><br><span class="line">          done: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 babel 编译后可以发现 test 函数变成了这样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a;</span><br><span class="line">  <span class="keyword">return</span> MyGerenator(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> ((_context.prev = _context.next)) &#123;</span><br><span class="line">        <span class="comment">// 可以发现通过 yield 将代码分成了几块，每次执行 next 函数就执行一块代码，并且表明下次需要执行哪块代码</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">          _context.next = <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">          _context.next = <span class="number">6</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'end'</span>:</span><br><span class="line">          <span class="keyword">return</span> _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一道题目"><a href="#一道题目" class="headerlink" title="一道题目"></a>一道题目</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span>(x+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">let</span> z = <span class="keyword">yield</span>(y/<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> (x+y+z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(it.next())   <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)) <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)) <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>分析：</p><ul><li>首先 <code>Generator</code> 函数调用和普通函数不同，它会返回一个迭代器</li><li>当执行第一次 <code>next</code> 时，传参会被忽略，并且函数暂停在 <code>yield (x + 1)</code> 处，所以返回 <code>5 + 1 = 6</code></li><li>当执行第二次 <code>next</code> 时，传入的参数等于上一个 <code>yield</code> 的返回值，如果你不传参，<code>yield</code> 永远返回 <code>undefined</code>。此时 <code>let y = 2 * 12</code>，所以第二个 <code>yield</code> 等于 <code>2 * 12 / 3 = 8</code></li><li>当执行第三次 <code>next</code> 时，传入的参数会传递给 <code>z</code>，所以 <code>z = 13, x = 5, y = 24</code>，相加等于 <code>42</code></li></ul><h3 id="Map、FlatMap-和-Reduce"><a href="#Map、FlatMap-和-Reduce" class="headerlink" title="Map、FlatMap 和 Reduce"></a>Map、FlatMap 和 Reduce</h3><p>Map 的作用是生成一个数组，遍历原数组，将每个元素拿出来然后做一些变换然后 append 到新的数组中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">v</span>=&gt;</span>v+<span class="number">1</span>);</span><br><span class="line"><span class="comment">// [2,3,4]</span></span><br></pre></td></tr></table></figure><p>Map 有三个参数，分别是当前索引元素，索引，原数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>].map(<span class="built_in">parseInt</span>);</span><br><span class="line"><span class="comment">// parseInt('1',0) -&gt; 1</span></span><br><span class="line"><span class="comment">// parseInt('2',1) -&gt; NaN</span></span><br><span class="line"><span class="comment">// parseInt('3',2) -&gt; NaN</span></span><br></pre></td></tr></table></figure><p>FlatMap 和 map 的作用几乎是相同的，但是对于多维数组来说，会将原数组降维。可以将 FlatMap 看成是 map + flatten ，目前该函数在浏览器中还不支持。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,[<span class="number">2</span>],<span class="number">3</span>].flatMap(v=v+<span class="number">1</span>);</span><br><span class="line"><span class="comment">// [2,3,4]</span></span><br></pre></td></tr></table></figure><p>如果想将一个多维数组彻底的降维，可以这样实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flattenDeep = <span class="function"><span class="params">arr</span> =&gt;</span> <span class="built_in">Array</span>.isArray(arr) ? arr.reduce(<span class="function">(<span class="params">a,b</span>)=&gt;</span>[...a,...flattenDeep(b)],[]):[arr];</span><br><span class="line">flattenDeep([<span class="number">1</span>,[[<span class="number">2</span>],[<span class="number">3</span>,[<span class="number">4</span>]],<span class="number">5</span>]]);</span><br><span class="line"><span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><p>Reduce 作用是数组中的值组合起来，最终得到一个值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">[a,b].reduce(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a(b()));</span><br></pre></td></tr></table></figure><h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h3><p>一个函数如果加上 async,那么该函数就会返回一个 Promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test()); <span class="comment">// -&gt; Promise &#123;&lt;resolved&gt;: "1"&#125;</span></span><br></pre></td></tr></table></figure><p>可以把 async 看成函数返回值使用 Promise.resolve() 包裹了下。</p><p>await 只能在 async 函数中使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'finish'</span>);</span><br><span class="line">            resolve(<span class="string">'sleep'</span>);</span><br><span class="line">        &#125;,<span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">await</span> sleep();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'object'</span>);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>上面代码会先打印 <code>finish</code> 然后再打印 <code>object</code> 。因为 <code>await</code> 会等待 <code>sleep</code> 函数 <code>resolve</code> ，所以即使后面是同步代码，也不会先去执行同步代码再来执行异步代码。</p><p>async 和 await 相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码。缺点在于滥用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖前者，但仍然需要等待前者完成，导致代码失去了并发性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">async</span>() =&gt;&#123;</span><br><span class="line">    a = a + <span class="keyword">await</span> <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>,a);</span><br><span class="line">    a = (<span class="keyword">await</span> <span class="number">10</span>) + a;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>,a);</span><br><span class="line">&#125;</span><br><span class="line">b();</span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>,a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// VM3859:10 1 1</span></span><br><span class="line"><span class="comment">// VM3859:4 2 10</span></span><br><span class="line"><span class="comment">// VM3859:6 3 20</span></span><br></pre></td></tr></table></figure><ul><li>首先函数 b 执行，在执行到了 await 10 之前 a 的变量还是 0，因为在 await 内部实现了generators ,generators 会保留堆栈中东西，a=0 被保存下来。</li><li>因为 await 是异步操作，遇到 await 会立即返回一个 pending 状态的 promise 对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行 同步代码 console.log(‘1’,a);</li><li>同步代码之后就是异步代码，将保存下来的值拿出来用，这时候 a = 10</li><li>后面就是常规的执行代码了</li></ul><h3 id="常用的定时器函数"><a href="#常用的定时器函数" class="headerlink" title="常用的定时器函数"></a>常用的定时器函数</h3><p>相关面试题：setTimeout、setInterval、requestAnimationFrame 各有什么特点？</p><h4 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a><strong>requestAnimationFrame</strong></h4><p>请求动画帧。屏幕刷新频率，也就是屏幕上的图像每秒钟出现的次数，它的单位是赫兹（HZ）。当对着电脑屏幕什么也不做的情况下，显示器也会以每秒60次的频率在不断更新屏幕上的图像。我们之所以感觉不到变化的原因是因为人的眼睛有视觉停留效应，画之间间隔时间只有16.7ms（1000/60)，所以我们会觉得屏幕上的图像是静止不动的。</p><p>动画的本质就是要让人眼看到图像被刷新而引起的变化的视觉效果，这个变化要以连贯的平滑的方式过渡。</p><p>我们在每次刷新前，将图像的位置移动一个像素，这样一来，屏幕每次刷新出来的图像位置都比前一个要差一个像素。因为你会看到图像在移动，由于人眼的视觉停留效应，当前位置的图像停留在大脑的影响还没有消失，紧接着图像又被移到了下一个位置，因为你会看到图像在流畅地移动，这就是视觉效果上形成的动画。</p><p>requestAnimationFrame最大的优势就是系统决定的回调函数的执行时机，大概的意思就是回调函数会随着屏幕刷新的频率的变化而产生对应的变化。它能保证回调函数在屏幕每一次的刷新间隔中只执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。</p><p>简单的调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> progress = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    progress +=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(progress&lt;<span class="number">100</span>)&#123;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame(render)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一帧渲染</span></span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(render);</span><br></pre></td></tr></table></figure><p>另外它还有两个优势：</p><ul><li>Cpu节能：使用 setTimeout 实现的动画，当页面被隐藏到最小化时，仍然会在后台执行动画人物，由于此时页面处于不可见或者不可用状态，刷新画面也是没有意义的，完全是浪费资源。而 requestAnimationFrame 则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新人物也会被系统暂停，有效节省CPU 开销</li><li>函数节流：在高频率（resize,scroll）中吗，为了防止在一个刷新间隔内发生多出函数执行，使用 requestAnimationFrame 可以保证每个刷新的间隔内，函数只被执行一次，这样既可以保证流畅性，也能更好的节省函数执行的开销。一个刷新间隔内函数执行多次是没有意义的，因为显示器刷新的频率是一定的，多次绘制不会在屏幕上体现出来。</li></ul><p>由于浏览器兼容问题，需要优雅降级做兼容，具体代码,摘自 <a href="https://github.com/darius/requestAnimationFrame/blob/master/requestAnimationFrame.js">requestAnimationFrame</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Date</span>.now) &#123;</span><br><span class="line">  <span class="built_in">Date</span>.now = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> vendors = [<span class="string">'webkit'</span>, <span class="string">'moz'</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vendors.length &amp;&amp; !<span class="built_in">window</span>.requestAnimationFrame; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> vp = vendors[i];</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame = <span class="built_in">window</span>[vp + <span class="string">'RequestAnimationFrame'</span>];</span><br><span class="line">    <span class="built_in">window</span>.cancelAnimationFrame = <span class="built_in">window</span>[vp + <span class="string">'CancelAnimationFrame'</span>] || <span class="built_in">window</span>[vp + <span class="string">'CancelRequestAnimationFrame'</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/iP(ad|hone|od).*OS 6/</span>.test(<span class="built_in">window</span>.navigator.userAgent) || !<span class="built_in">window</span>.requestAnimationFrame || !<span class="built_in">window</span>.cancelAnimationFrame) &#123;</span><br><span class="line">      <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">window</span>.requestAnimationFrame = <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">var</span> nextTime = <span class="built_in">Math</span>.max(lastTime + <span class="number">16</span>, now);</span><br><span class="line">        <span class="keyword">return</span> setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          cb(lastTime = nextTime)</span><br><span class="line">        &#125;, nextTime - now)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">window</span>.cancelAnimationFrame = clearTimeout;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a><strong>setTimeout</strong></h4><p>设置某个时间后执行某个动作，表示延时执行某个动作</p><h4 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a><strong>setInterval</strong></h4><p>设置每隔多久执行某个动作，循环的。setInterval 将注册函数植入 Event Queue,如果前面的任务耗能太久，那么就需要等待。</p><p>因为JS 单线程的问题，setTimeout 可能不会按期执行，可以通过代码去修正 setTimeout ，从而使定时器相对准确</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> period = <span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime + period;</span><br><span class="line"><span class="keyword">let</span> interval = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">let</span> currentInterval = interval;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="comment">// 代码执行所消耗的时间</span></span><br><span class="line">  <span class="keyword">let</span> offset = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * interval);</span><br><span class="line">  <span class="keyword">let</span> diff = end - <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="keyword">let</span> h = <span class="built_in">Math</span>.floor(diff / (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>))</span><br><span class="line">  <span class="keyword">let</span> hdiff = diff % (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>);</span><br><span class="line">  <span class="keyword">let</span> m = <span class="built_in">Math</span>.floor(hdiff / (<span class="number">60</span> * <span class="number">1000</span>));</span><br><span class="line">  <span class="keyword">let</span> mdiff = hdiff % (<span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">let</span> s = mdiff / (<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">let</span> sCeil = <span class="built_in">Math</span>.ceil(s);</span><br><span class="line">  <span class="keyword">let</span> sFloor = <span class="built_in">Math</span>.floor(s);</span><br><span class="line">  <span class="comment">// 得出下一次循环所消耗的时间</span></span><br><span class="line">  currentInterval = interval - offset;</span><br><span class="line">  setTimeout(loop, currentInterval);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'时：'</span> + h, <span class="string">'分：'</span> + m, <span class="string">'毫秒：'</span> + s, <span class="string">'秒向上取整：'</span> + sCeil, <span class="string">'代码执行时间：'</span> + offset, <span class="string">'下次循环间隔'</span> + currentInterval)</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(loop, currentInterval)</span><br></pre></td></tr></table></figure><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy 是 ES6 中新增的功能，可以用来自定义对象中的操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,handler)</span><br><span class="line"><span class="comment">// target 代表需要添加代理的对象</span></span><br><span class="line"><span class="comment">// Handler 用来自定义对象中的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以很方便使用 Proxy 来实现一个数据的绑定和监听</span></span><br><span class="line"><span class="keyword">let</span> onWatch = <span class="function">(<span class="params">obj,setBind,getLogger</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> handler = &#123;</span><br><span class="line">        get(target,property,receiver)&#123;</span><br><span class="line">            getLogger(target,property)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target,property,receiver);</span><br><span class="line">        &#125;,</span><br><span class="line">        set(target,property,value,receiver)&#123;</span><br><span class="line">            setBind(value);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target,property,value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj,handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> value;</span><br><span class="line"><span class="keyword">let</span> pw = onWatch(obj,(v)=&gt;&#123;</span><br><span class="line">    value = v</span><br><span class="line">&#125;,(target,property)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Get <span class="subst">$&#123;property&#125;</span> = <span class="subst">$&#123;target[property]&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">pw.a = <span class="number">2</span>; <span class="comment">// bind value to 2</span></span><br><span class="line">pw.a <span class="comment">// get a = 2</span></span><br></pre></td></tr></table></figure><h3 id="为什么-0-1-0-2-0-3"><a href="#为什么-0-1-0-2-0-3" class="headerlink" title="为什么 0.1 + 0.2 != 0.3"></a>为什么 0.1 + 0.2 != 0.3</h3><p>因为 JS 采用 IEEE 754 双精度版本（64位）,并且只要采用 IEEE 754 的语言都有该问题</p><p>原生解决方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>((<span class="number">0.1</span>+<span class="number">0.2</span>).toFixed(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><table><thead><tr><th>元字符</th><th>作用</th></tr></thead><tbody><tr><td>.</td><td>匹配任意字符除了换行符和回车符</td></tr><tr><td>[]</td><td>匹配方括号内的任意字符。比如 [0-9] 就可以用来匹配任意数字</td></tr><tr><td>^</td><td>^9 这样使用匹配以 9 开头，[^9] 这样使用代表不匹配方括号内除了9的字符</td></tr><tr><td>{1,2}</td><td>匹配1到2位字符</td></tr><tr><td>(yck)</td><td>只匹配 yck 相同字符串</td></tr><tr><td>\</td><td></td><td>匹配 \</td><td>前后任意字符</td></tr><tr><td>\</td><td>转义</td></tr><tr><td>*</td><td>只匹配出现0次及以上 *前的字符</td></tr><tr><td>+</td><td>只匹配出现1次及以上 +前的字符</td></tr><tr><td>?</td><td>？ 之前字符可选</td></tr></tbody></table><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><table><thead><tr><th>修饰语</th><th>作用</th></tr></thead><tbody><tr><td>i</td><td>忽略大小写</td></tr><tr><td>g</td><td>全局搜索</td></tr><tr><td>m</td><td>多行</td></tr></tbody></table><h4 id="字符简写"><a href="#字符简写" class="headerlink" title="字符简写"></a>字符简写</h4><table><thead><tr><th>简写</th><th>作用</th></tr></thead><tbody><tr><td>\w</td><td>匹配字母数字或下划线</td></tr><tr><td>\W</td><td>与上面相反</td></tr><tr><td>\s</td><td>匹配任意的空白符</td></tr><tr><td>\S</td><td>与上面相反</td></tr><tr><td>\d</td><td>匹配数字</td></tr><tr><td>\D</td><td>与上面相反</td></tr><tr><td>\b</td><td>匹配单词的开始或结束</td></tr><tr><td>\B</td><td>与上面相反</td></tr></tbody></table><h3 id="V8下的垃圾回收机制"><a href="#V8下的垃圾回收机制" class="headerlink" title="V8下的垃圾回收机制"></a>V8下的垃圾回收机制</h3><p>V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为了新生代和老生代两部分</p><h4 id="新生代算法"><a href="#新生代算法" class="headerlink" title="新生代算法"></a>新生代算法</h4><p>新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。</p><p>在新生代空间中，内存空间分为了两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满的时候，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成将 From 空间和 To 空间互换，这样 GC 就结束了。</p><h4 id="老生代算法"><a href="#老生代算法" class="headerlink" title="老生代算法"></a>老生代算法</h4><p>老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。</p><p>什么情况下对象会出现在老生代空间中：</p><ul><li>新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。</li><li>To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中</li></ul><p>老生代中的空间很复杂，有如下几个空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum AllocationSpace &#123;</span><br><span class="line">  // TODO(v8:7464): Actually map this space's memory as read-only.</span><br><span class="line">  RO_SPACE,    // 不变的对象空间</span><br><span class="line">  NEW_SPACE,   // 新生代用于 GC 复制算法的空间</span><br><span class="line">  OLD_SPACE,   // 老生代常驻对象空间</span><br><span class="line">  CODE_SPACE,  // 老生代代码对象空间</span><br><span class="line">  MAP_SPACE,   // 老生代 map 对象</span><br><span class="line">  LO_SPACE,    // 老生代大空间对象</span><br><span class="line">  NEW_LO_SPACE,  // 新生代大空间对象</span><br><span class="line"></span><br><span class="line">  FIRST_SPACE = RO_SPACE,</span><br><span class="line">  LAST_SPACE = NEW_LO_SPACE,</span><br><span class="line">  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,</span><br><span class="line">  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在老生代中，以下情况会先启动标记清除算法：</p><ul><li>某一个空间没有分块的时候</li><li>空间中被对象超过一定限制</li><li>空间不能保证新生代中的对象移动到老生代中</li></ul><p>在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，你可以点击 <a href="https://v8project.blogspot.com/2018/06/concurrent-marking.html">该博客</a> 详细阅读。</p><p>清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。</p><h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p>两个名词都是 CPU 工作时间片的一个描述。</p><p>进程描述了 CPU 在运行指令以及记载和保存上下文所需的时间，放在应用上来说就代表了一个程序。</p><p>线程是进程中更小的单位，描述了一段指令所需要的时间。</p><p>在浏览器中，打开一个 Tab 页面，就是创建了一个进程，一个进程里面可以有多个线程，例如渲染线程，JS 引擎线程，HTTP 请求线程。当发起一个请求时，就是在创建一个线程，当请求结束的时候，该线程就可能会被销毁掉。</p><p>众所周知，JS 运行时会阻止 UI 渲染，这两个线程是互斥的，因为 JS 可以修改 Dom ，如果在 JS 执行的时候 Ui 线程还在工作，就可能会导致不能正常安全渲染 UI。这也是单线程的一个好处，得益于 JS 是单线程与很像的，可以达到节省呢欧村，节约上下文切换时间，没有锁的问题的好处。</p><h4 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h4><p>可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</p><h4 id="浏览器中的-Event-Loop"><a href="#浏览器中的-Event-Loop" class="headerlink" title="浏览器中的 Event Loop"></a>浏览器中的 Event Loop</h4><p>当遇到异步代码的时候，会被挂起并在需要执行的时候加入到 Task  队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要你执行的代码并放入执行栈中执行，所以本质上 JS 中的异步还是同步行为。</p><p>不同的任务源会被分配到不同的 Task 队列中，任务源可以分成 微任务（mocrotask） 和 宏任务（macrotask)。在 ES6 规范中，macrotask 被称为 task,microtask 被称为 jobs 。下面举个例子看看代码的执行顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure><p>当我们调用 async1 函数的时候，会马上输出 async2 end,并且函数返回一个 Promise，接下来在遇到 await 的时候就让出线程开始执行 async1 外的代码，可以完全把 await 看成是让出线程的标志。</p><p>然后当同步代码全部执行完毕以后，就会执行所有的异步代码，那么就会又回到 await 的位置执行返回的 Promise 的 resolve 函数，这又会把 resolve 丢到微任务队列中，接下来执行 then 中的回调，当两个 then 中的回调全部执行完毕后，回到 await 的位置处理返回值，这时候可以看成 <code>Promise.resolve(返回值).then()</code>，然后 await 后的代码全部被包裹进了 then 的回调中，所以 <code>console.log(&#39;async1 end&#39;)</code> 会优先执行于 <code>setTimeout</code>。</p><p>微任务包括 <code>process.nextTick</code> ，<code>promise</code> ，<code>MutationObserver</code>。</p><p>宏任务包括 <code>script</code> ， <code>setTimeout</code> ，<code>setInterval</code> ，<code>setImmediate</code> ，<code>I/O</code> ，<code>UI rendering</code>。</p><p>Event Loop 执行顺序如下所示：</p><ul><li>首先执行同步代码，这属于宏任务</li><li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li><li>执行所有微任务</li><li>当执行完所有微任务后，如有必要会渲染页面</li><li>然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 <code>setTimeout</code> 中的回调函数</li></ul><p>Node 中的 Event Loop</p><p>涉及的面试题：Node 中 Event Loop 和 浏览器的有什么不同？process.nextTick 执行顺序</p><p>Node 中的 Event Loop 分成6个阶段，它们会按照顺序反复运行，每当进入某一个阶段的时候，都会从对应的回调队列取出函数去执行。当队列为空或者执行的回调函数数量达到系统设定的阈值，就会进入下一个阶段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><p><strong>timer</strong></p><p>timer 阶段会执行 setTimeout 和 setInerval 回调，并是由 poll 阶段控制的</p><p> 同样，在 Node 中定时器指定的时间也不是准确的时间，只是尽快执行。</p><p><strong>I/O</strong></p><p>I/O 阶段会处理上一轮循环中少数未执行的的 I/O 回调</p><p><strong>dle,prepare</strong></p><p>idle,prepare 阶段内部实现</p><p><strong>poll</strong></p><p>poll 阶段很重要，在这一阶段中，系统会做两件事情</p><ol><li>执行到点的定时器</li><li>执行 poll 队列中的事件</li></ol><p>并且当 poll 中没有定时器的情况下，会发现以下两件事情</p><ul><li>如果poll队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制</li><li>如果poll队列为空,会发生两件事情<ul><li>如果有 setImmediate 需要执行的时候，poll 阶段会停止并且进入到 check 阶段执行 setImmediate</li><li>如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</li></ul></li></ul><p>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</p><p><strong>check</strong></p><p>check 阶段执行 <code>setImmediate</code></p><p><strong>close callbacks</strong></p><p>close callbacks 阶段执行了 close 事件。</p><p>首先在有些情况下，定时器的执行顺序其实是<strong>随机</strong>的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;setImmediate&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于以上代码来说，<code>setTimeout</code> 可能执行在前，也可能执行在后</p><ul><li>首先 <code>setTimeout(fn, 0) === setTimeout(fn, 1)</code>，这是由源码决定的</li><li>进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 <code>setTimeout</code> 回调</li><li>那么如果准备时间花费小于 1ms，那么就是 <code>setImmediate</code> 回调先执行了</li></ul><p>当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：</p><p>当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;timeout&apos;);</span><br><span class="line">    &#125;, 0)</span><br><span class="line">    setImmediate(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;immediate&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>setImmediate</code> 永远<strong>先执行</strong>。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 <code>setImmediate</code> 回调，所以就直接跳转到 check 阶段去执行回调了。</p><p><strong>process.nextTick</strong></p><p>这个函数是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成之后，如果存在 nextTick 阶段，就会清空队列中的所有回调函数，并优于其他 microtask 执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line"></span><br><span class="line"> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line"> process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">   process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">     process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// nextTick</span></span><br><span class="line"><span class="comment">// nextTick</span></span><br><span class="line"><span class="comment">// nextTick</span></span><br><span class="line"><span class="comment">// nextTick</span></span><br><span class="line"><span class="comment">// timer1</span></span><br><span class="line"><span class="comment">// promise1</span></span><br></pre></td></tr></table></figure><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md">前端面试题目已经答案汇总</a></p><p><a href="https://yuchengkai.cn/docs/frontend/#%E9%98%B2%E6%8A%96">防抖</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;温故而知新，保持空杯心态,复习到一半的时间，突然发现了 &lt;a href=&quot;https://yuchengkai.cn/docs/frontend&quot;&gt;前端面试之道&lt;/a&gt;，从第二道题目开始按学习这本书的路径来&lt;/p&gt;
&lt;h2 id=&quot;JS-基础2&quot;&gt;&lt;a href=&quot;#JS-
      
    
    </summary>
    
      <category term="前端面试" scheme="http://laibh.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端面试题" scheme="http://laibh.top/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Mongoose</title>
    <link href="http://laibh.top/2019-03-26-mongoose.html"/>
    <id>http://laibh.top/2019-03-26-mongoose.html</id>
    <published>2019-03-26T08:30:00.000Z</published>
    <updated>2020-07-11T03:24:57.639Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p><p>Mongoose是在node.js环境下对mongodb进行便捷操作的对象模型工具</p><p><a href="https://cn.mongoosedoc.top/docs/guide.html">学习链接</a></p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p><em>请先安装 MongoDB 和 Node.js。</em></p><p>下一步，<code>npm</code>安装Mongoose:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mongoose</span><br></pre></td></tr></table></figure><p>连接数据库test</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line">mongoose.connect(<span class="string">'mongodb://localhost/test'</span>);</span><br></pre></td></tr></table></figure><p><code>connect()</code>返回一个状态待定（pending）的连接，接着我们加上成功和失败的提醒：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db = mongoose.connection;</span><br><span class="line">db.on(<span class="string">'error'</span>,<span class="built_in">console</span>.error.bind(<span class="built_in">console</span>,<span class="string">'connection error:'</span>));</span><br><span class="line">db.once(<span class="string">'open'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// .. </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>连接成功的时候，回调函数会被调用，假设下面所有函数都在这个回调函数里面。</p><p>Mongoose 里面一切始于 Schema。看一个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> KittySchema = mongoose.Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们得到了一个带有 <code>String</code>类型的 <code>name</code> 属性的 schema,接着把这个 schema 编译成一个 Model:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Kitten = mongoose.model(<span class="string">'Kitten'</span>,kittySchema);</span><br></pre></td></tr></table></figure><p>model 是我们创造的 document 的 Class。在例子中，每个 document 都是一个实例，它的属性和行为都会被声明在 schema 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> felyne = <span class="keyword">new</span> Kitten(&#123;<span class="attr">name</span>:<span class="string">'Felyne'</span>&#125;);</span><br><span class="line">felyne.name <span class="comment">// 'Felyne';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 document 加一个 speak 方法</span></span><br><span class="line">KittySchema.methods.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> greeting = <span class="keyword">this</span>.name ?  <span class="string">"Meow name is "</span> + <span class="keyword">this</span>.name: <span class="string">"I don't have a name"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(greeting);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Kitten = mongoose.model(<span class="string">'Kitten'</span>,kittySchema);</span><br></pre></td></tr></table></figure><p>加在 schema 的 <code>methods</code> 属性的函数会编译到 <code>Model</code> 的prototype,也会暴露搭配每个 document 实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Kitten(&#123;<span class="attr">name</span>:<span class="string">'A'</span>&#125;);</span><br><span class="line">a.speak(); <span class="comment">// Meow name is A</span></span><br></pre></td></tr></table></figure><p>每个 document 会在调用它的 save 方法后保存到数据库中，注意回调函数的第一个参数永远是 error</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.save(<span class="function"><span class="keyword">function</span>(<span class="params">err,A</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    A.speak();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果有很多个实例，可以用下面的方法来获取 model 里面的所有数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Kitten.find(<span class="function"><span class="keyword">function</span>(<span class="params">err,kittens</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    <span class="built_in">console</span>.log(kittens);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="模式（Schemas）"><a href="#模式（Schemas）" class="headerlink" title="模式（Schemas）"></a>模式（Schemas）</h2><h4 id="定义一个schema"><a href="#定义一个schema" class="headerlink" title="定义一个schema"></a>定义一个schema</h4><p>Mongoose 的一切始于 Schema,每个 schama 都会映射到一个 MongoDB collection，并定义这个 collection 里面的文档的构成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema;</span><br><span class="line"><span class="keyword">const</span> blog = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    title:<span class="built_in">String</span>,</span><br><span class="line">    author:<span class="built_in">String</span>,</span><br><span class="line">    body:<span class="built_in">String</span>,</span><br><span class="line">    comments:[&#123;<span class="attr">body</span>:<span class="built_in">String</span>,<span class="attr">date</span>:<span class="built_in">Date</span>&#125;],</span><br><span class="line">    date:&#123;</span><br><span class="line">        type:<span class="built_in">Date</span>,</span><br><span class="line">        defalut:<span class="built_in">Date</span>.now</span><br><span class="line">    &#125;,</span><br><span class="line">    hidden:<span class="built_in">Boolean</span>,</span><br><span class="line">    meta:&#123;</span><br><span class="line">        votes:<span class="built_in">Number</span>,</span><br><span class="line">        favs:<span class="built_in">Number</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>document 里面的每个属性都会被转换成在 blogSchema 里面对应的 SchemaType。例如 <code>title</code> 属性会被转换成为 SchemaType String,而 <code>date</code>属性会被转换成为 SchemaType Date。还可以像 <code>meta</code>属性一样，更加详细地指定嵌套在里面的属性类型。</p><p>运行使用的 SchemaTypes 有：</p><ul><li>String</li><li>Number</li><li>Boolean</li><li>Date</li><li>Buffer</li><li>Mixed</li><li>ObjectId</li><li>Array</li></ul><p>Schema 的功能不只是定义文档结构和属性类型，还可以定义</p><ul><li>document 的 instance methods</li><li>model 的 static Model methods</li><li>复合索引</li><li>文档的生命周期钩子，也称为中间件</li></ul><h4 id="创建一个-model"><a href="#创建一个-model" class="headerlink" title="创建一个 model"></a>创建一个 model</h4><p><code>mongoose.model(modelName,schema)</code> 函数把 schema 转换为一个 Model:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Blog = mongoose.model(<span class="string">'Blob'</span>,blogSchema);</span><br></pre></td></tr></table></figure><h4 id="实例方法（method）"><a href="#实例方法（method）" class="headerlink" title="实例方法（method）"></a>实例方法（method）</h4><p>document 是 Models 的实例。Document 有很多自带的实例方法，当然也可以自定义我们自己的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个 schema</span></span><br><span class="line"><span class="keyword">const</span> animalSchema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>,<span class="attr">type</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line"></span><br><span class="line">animalSchema.methods.findSimilarTypes = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.model(<span class="string">'Animal'</span>).find(&#123;<span class="attr">type</span>:<span class="keyword">this</span>.type&#125;,cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在所有的 <code>animal</code> 实例都有 <code>findSimilarTypes</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Animal = mongoose.model(<span class="string">'Animal'</span>,animalSchema);</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Animal(&#123;type：<span class="string">'dog'</span>&#125;);</span><br><span class="line"></span><br><span class="line">dog.findSimilarTypes(<span class="function"><span class="keyword">function</span>(<span class="params">err,dogs</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(dogs); <span class="comment">// woof</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>重写 mongoose 的默认方法会造成无法预料的结果</li><li>不要在自定义方法中使用 ES6 箭头函数，会造成 this 指向错误</li></ul><h4 id="静态方法（static）"><a href="#静态方法（static）" class="headerlink" title="静态方法（static）"></a>静态方法（static）</h4><p>添加 <code>Model</code> 的静态方法也十分简单，继续使用 <code>animalSchema</code> 举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">animalSchema.statics.findByName = <span class="function"><span class="keyword">function</span>(<span class="params">name,cb</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.find(&#123;<span class="attr">name</span>:<span class="keyword">new</span> <span class="built_in">RegExp</span>(name,<span class="string">'i'</span>)&#125;,cb)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Animal = mongoose.model(<span class="string">'Animal'</span>,animalSchema);</span><br><span class="line">Animal.findByName(<span class="string">'fido'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,animals</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animals);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同样注意的是不要在静态方法中使用 ES6 的箭头函数</p><h4 id="查询助手（query-helper）"><a href="#查询助手（query-helper）" class="headerlink" title="查询助手（query helper）"></a>查询助手（query helper）</h4><p>查询助手作用于 query 实例，方便自定义扩展链式查询</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">animalSchema.query.byName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.find(&#123;<span class="attr">name</span>:<span class="keyword">new</span> <span class="built_in">RegExp</span>(name,<span class="string">'i'</span>)&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Animal = mongoose.model(<span class="string">'Animal'</span>,animalSchema);</span><br><span class="line">Animal.find().byName(<span class="string">'fido'</span>).exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,animal</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animals);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="索引（index）"><a href="#索引（index）" class="headerlink" title="索引（index）"></a>索引（index）</h4><p>MongoDB 支持 secondary indexes。在 mongoose 中，我们在 Schema 定义索引。索引分字段级别和 schema 级别，复合索引需要在 schema 级别定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animalSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    type:<span class="built_in">String</span>,</span><br><span class="line">    tags:&#123;</span><br><span class="line">        type:[<span class="built_in">String</span>],</span><br><span class="line">        index:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">animalSchema.index(&#123;<span class="attr">name</span>:<span class="number">1</span>,<span class="attr">type</span>:<span class="number">-1</span>&#125;);</span><br></pre></td></tr></table></figure><p>应用启动的时候，Mongoose 会自动调用 <code>createIndex</code> 初始化定义的索引。Mongoose 顺序处理每一个 createIndex，然后在 model 触发 ‘index’ 事件。在生产中建议禁止这种行为，因为创建索引会对性能造成重大影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://user:pass@localhost:port/database'</span>,&#123;<span class="attr">autoIndex</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">mongoose.createConnection(<span class="string">'mongodb://user:pass@localhost:port/database'</span>,&#123;<span class="attr">autoIndex</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">autoIndex</span>:<span class="literal">false</span>&#125;);</span><br></pre></td></tr></table></figure><p>索引创建完成或者失败，Mongoose 会触发 index 事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Will cause an error because mongodb has an _id index by default that is not sparse</span></span><br><span class="line">animalSchema.index(&#123;<span class="attr">_id</span>:<span class="number">1</span>&#125;,&#123;<span class="attr">sparse</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Animal = mongoose.model(<span class="string">'Animal'</span>,animalSchema);</span><br><span class="line">Animal.on(<span class="string">'index'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// _id index cannot be sparse</span></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="虚拟值（Virtual）"><a href="#虚拟值（Virtual）" class="headerlink" title="虚拟值（Virtual）"></a>虚拟值（Virtual）</h4><p>Virtual 是 document 的属性，但是不会被保存到 MongoDB.getter 可以用于格式化和组合字段数据，setter 可以很方便地分解一个值到多个字段。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> personSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        first:<span class="built_in">String</span>,</span><br><span class="line">        last:<span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Person = mongoose.model(<span class="string">'Person'</span>,personSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> axl = <span class="keyword">new</span> Person(&#123;</span><br><span class="line">    name:&#123;<span class="attr">first</span>:<span class="string">'Axl'</span>,<span class="attr">last</span>:<span class="string">'Rose'</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(axl.name.first + <span class="string">' '</span> + axl.name.last); <span class="comment">//Axl Rose</span></span><br></pre></td></tr></table></figure><p>但是每次都要这样拼接就太麻烦了，使用 virtual property getter 这个方法允许定义一个 fullName 属性，但不必保存到数据库。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">personSchema.virtual(<span class="string">'fullName'</span>).get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name.first + <span class="string">' '</span> + <span class="keyword">this</span>.name.last</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(axl.fullName); <span class="comment">// Axl Rose</span></span><br></pre></td></tr></table></figure><p>如果对 document 使用 <code>toJSON（）</code> 或 <code>toObject()</code> 默认不包括虚拟值，需要额外向 toObject 或者 toJSON 传入参数 <code>{virtuals:true}</code></p><p>也可以设定虚拟值的 setter，下面的例子中，当赋值到虚拟值的时候，会自动拆分到其他属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">personSchema.virtual(<span class="string">'fullName'</span>).get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name.first + <span class="string">' '</span> + <span class="keyword">this</span>.name.last</span><br><span class="line">&#125;).set(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name.first = v.substr(<span class="number">0</span>,v.indexOf(<span class="string">' '</span>));</span><br><span class="line">    <span class="keyword">this</span>.name.last = v.substr(v.indexOf(<span class="string">' '</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">axl.fullName = <span class="string">'William Rose'</span> <span class="comment">// Now `axl.name.first` is "William"</span></span><br></pre></td></tr></table></figure><p>需要注意的是，虚拟值不能用于查询和字段选择，因为虚拟值不存储在 MongoDB</p><h4 id="别名（Alias）"><a href="#别名（Alias）" class="headerlink" title="别名（Alias）"></a>别名（Alias）</h4><p>Aliase 是一种特殊的虚拟值，它的getter 和 setter 会无缝链接到另一个值，这是一个节省带宽的做法，可以存储一个更短的属性名到数据库，同时在调用的时候保持可读性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> personSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    n:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        alias:<span class="string">'name'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(&#123;<span class="attr">name</span>:<span class="string">'Val'</span>&#125;);</span><br><span class="line">person <span class="comment">//&#123;n:'Val'&#125;</span></span><br><span class="line">person.toObject(&#123;<span class="attr">virtuals</span>:<span class="literal">true</span>&#125;) <span class="comment">//&#123;n:'Val',name:'Val'&#125;</span></span><br><span class="line">person.name <span class="comment">// Val</span></span><br><span class="line">person.name = <span class="string">'Not Val'</span>;</span><br><span class="line">person <span class="comment">// &#123;n:'Not Val'&#125;</span></span><br></pre></td></tr></table></figure><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><p>Schema 有很多可配置选项，可以在构造时传入或者直接 set</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Schema(&#123;...&#125;,options);</span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;...&#125;);</span><br><span class="line"></span><br><span class="line">schema.set(option,value);</span><br></pre></td></tr></table></figure><p>有效的选项：</p><ul><li>autoIndex</li><li>bufferCommands</li><li>capped</li><li>collection</li><li>id</li><li>_id</li><li>minimize</li><li>read</li><li>shardKey</li><li>strict</li><li>strictQuery</li><li>toJSON</li><li>toObject</li><li>typekey</li><li>validateBeforeSave</li><li>versionKey</li><li>skipVersioning</li><li>timestamps</li><li>useNestedStrict</li></ul><p><strong>option：autoIndex</strong></p><p>应用启动的时候，Mongoose 自动发送 <code>createIndex</code> 指令，schema 里面的每个 index 都会被创建，如果需要关闭自动创建功能或者需要在创建后进行一系列操作，可以把 <code>autoIndex</code> 设为 <code>false</code>，然后对 model 调用 ensureIndexes：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">autoIndex</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Clock = mongoose.model(<span class="string">'Clock'</span>,schema);</span><br><span class="line">Clock.ensureIndexes(callback);</span><br></pre></td></tr></table></figure><p><strong>option：bufferCommands</strong></p><p>默认情况下，mongoose buffers会在连接中断时发出命令，直到驱动程序重新连接为止。若要禁用缓冲，请将bufferCommands设置为false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">bufferCommands</span>:<span class="literal">false</span>&#125;);</span><br></pre></td></tr></table></figure><p>schema 的bufferCommands 会重写全局的 bufferCommands 选项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mongoose.set(<span class="string">'bufferCommands'</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">bufferCommands</span>:<span class="literal">false</span>&#125;);</span><br></pre></td></tr></table></figure><p><strong>option：capped</strong></p><p>Mongoose 支持 MongoDB 的 capped collections ，要从底层把 collection 设定为 capped(封顶)，可以把collection 的最大容量设定到 <code>capped</code> 选项（单位 bytes）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">capped</span>:<span class="number">1024</span>&#125;);</span><br></pre></td></tr></table></figure><p>如果要传递多个选项，capped 也可以作为对象传递.这个试试需要显式传入必要值 <code>size</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">size</span>:<span class="number">1024</span>,<span class="attr">max</span>:<span class="number">1000</span>,<span class="attr">autoIndexId</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p><strong>option：collection</strong></p><p>Mongoose 通过 utils.toCollectionName 方法，默认生成 collection 的名称（生成 model 名称的复数形式）。设置这个选项可以自定义名称</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataSchema = <span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">collection</span>:<span class="string">'data'</span>&#125;);</span><br></pre></td></tr></table></figure><p><strong>option：id</strong></p><p>Mongoose 会默认生成一个虚拟值 <code>id</code>，指向文档的 <code>_id</code>字段。如果你不需要 <code>id</code> 虚拟值，可以通过这个选项禁用此功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认行为</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Page = mongoose.model(<span class="string">'Page'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Page(&#123;<span class="attr">name</span>:<span class="string">'mongodb.org'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p.id); <span class="comment">// 50341373e894ad16347efe01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//禁止 id</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;,&#123;<span class="attr">id</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Page = mongoose.model(<span class="string">'Page'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Page(&#123;<span class="attr">name</span>:<span class="string">'mongodb.org'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p.id); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><strong>option：_id</strong></p><p>Mongoose 默认给你的 Schema 赋值一个 <code>_id</code>，这个值的类型是 ObjectId，这与 MongoDB 的默认表现一致。如果需要，可以禁止</p><p>此选项<strong>只能</strong>用于 subdocument。 Mongoose 不能保存没有id的文档，如果硬是要这么做，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认行为</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Page = mongoose.model(<span class="string">'Page'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Page(&#123;<span class="attr">name</span>:<span class="string">'mongodb.org'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// &#123; _id: '50341373e894ad16347efe01', name: 'mongodb.org' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止 _id</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;,&#123;<span class="attr">_id</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Page = mongoose.model(<span class="string">'Page'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Page(&#123;<span class="attr">name</span>:<span class="string">'mongodb.org'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// &#123; name: 'mongodb.org' &#125;</span></span><br></pre></td></tr></table></figure><p><strong>option：minimize</strong></p><p>Mongoose 默认不保存空对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>,<span class="attr">inventory</span>:&#123;&#125;&#125;);</span><br><span class="line"><span class="keyword">const</span> Character = mongoose.model(<span class="string">'Character'</span>,schema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> frodo = <span class="keyword">new</span> Character(&#123;<span class="attr">name</span>:<span class="string">'Frodo'</span>,<span class="attr">inventory</span>:&#123;<span class="attr">ringOfPower</span>:<span class="number">1</span>&#125;&#125;);</span><br><span class="line">Character.findOne(&#123;<span class="attr">name</span>:<span class="string">'Frodo'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,character</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(character); <span class="comment">// &#123;name: 'Frodo', inventory: &#123; ringOfPower: 1 &#125;&#125;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Sam = <span class="keyword">new</span> Character(&#123;<span class="attr">name</span>:<span class="string">'Sam'</span>,<span class="attr">inventory</span>:&#123;&#125;&#125;);</span><br><span class="line">Character.findOne(&#123;<span class="attr">name</span>:<span class="string">'Sam'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,character</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(character); <span class="comment">// &#123;name: 'Sam'&#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果把 minimize 设定为 false,Mongoose 将保存空对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sam = <span class="keyword">new</span> Character(&#123;<span class="attr">name</span>:<span class="string">'Sam'</span>,<span class="attr">inventory</span>:&#123;&#125;&#125;,&#123;<span class="attr">minimize</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">Character.findOne(&#123;<span class="attr">name</span>:<span class="string">'Sam'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,character</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(character); <span class="comment">// &#123;name: 'Sam',inventory:&#123;&#125;&#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>option：read</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">read</span>: <span class="string">'primary'</span> &#125;);<span class="comment">// also aliased as 'p'</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">read</span>: <span class="string">'primaryPreferred'</span> &#125;);<span class="comment">// aliased as 'pp'</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">read</span>: <span class="string">'secondary'</span> &#125;);<span class="comment">// aliased as 's'</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">read</span>: <span class="string">'secondaryPreferred'</span> &#125;);<span class="comment">// aliased as 'sp'</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">read</span>: <span class="string">'nearest'</span> &#125;);<span class="comment">// aliased as 'n'</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123; <span class="attr">replset</span>: &#123; <span class="attr">strategy</span>: <span class="string">'ping'</span> &#125;&#125;;</span><br><span class="line">mongoose.connect(uri, options);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">read</span>: [<span class="string">'nearest'</span>, &#123; <span class="attr">disk</span>: <span class="string">'ssd'</span> &#125;] &#125;);</span><br><span class="line">mongoose.model(<span class="string">'JellyBean'</span>, schema);</span><br></pre></td></tr></table></figure><p><strong>option：shardKey</strong></p><p>分片相关.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Schema(&#123; .. &#125;, &#123; <span class="attr">shardKey</span>: &#123; <span class="attr">tag</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="number">1</span> &#125;&#125;)</span><br></pre></td></tr></table></figure><p><strong>option：strict</strong></p><p>Strict 选项默认为 true，这意味着你不能 <code>save</code> schema 里没有声明的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thingSchema = <span class="keyword">new</span> Schema(&#123;..&#125;)</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, thingSchema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(&#123; <span class="attr">iAmNotInTheSchema</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">thing.save(); <span class="comment">// iAmNotInTheSchema is not saved to the db</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set to false..</span></span><br><span class="line"><span class="keyword">const</span> thingSchema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">strict</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(&#123; <span class="attr">iAmNotInTheSchema</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">thing.save(); <span class="comment">// iAmNotInTheSchema is now saved to the db!!</span></span><br></pre></td></tr></table></figure><p><code>doc.set()</code> 也受该选项影响：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thingSchema = <span class="keyword">new</span> Schema(&#123;..&#125;)</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, thingSchema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing;</span><br><span class="line">thing.set(<span class="string">'iAmNotInTheSchema'</span>, <span class="literal">true</span>);</span><br><span class="line">thing.save(); <span class="comment">// iAmNotInTheSchema is not saved to the db</span></span><br></pre></td></tr></table></figure><p>这个值可以在 model 级别重写，在第二个参数值传入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(doc, <span class="literal">true</span>);  <span class="comment">// enables strict mode</span></span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(doc, <span class="literal">false</span>); <span class="comment">// disables strict mode</span></span><br></pre></td></tr></table></figure><p>还可以将strict选项设置为“throw”，这将导致产生错误，而不是删除坏数据。</p><p>注意:在 schema 中不存在的实例上设置的任何键/值总是被忽略，不管模式选项是什么。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thingSchema = <span class="keyword">new</span> Schema(&#123;..&#125;)</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, thingSchema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing;</span><br><span class="line">thing.iAmNotInTheSchema = <span class="literal">true</span>;</span><br><span class="line">thing.save(); <span class="comment">// iAmNotInTheSchema is never saved to the db</span></span><br></pre></td></tr></table></figure><p><strong>option：strictQuery</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">field</span>: <span class="built_in">Number</span> &#125;, &#123; <span class="attr">strict</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> MyModel = mongoose.model(<span class="string">'Test'</span>, mySchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mongoose will **not** filter out `notInSchema: 1`, despite `strict: true`</span></span><br><span class="line">MyModel.find(&#123; <span class="attr">notInSchema</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure><p>严格的选择适用于更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose will strip out `notInSchema` from the update if `strict` is not `false`</span></span><br><span class="line">MyModel.updateMany(&#123;&#125;, &#123; <span class="attr">$set</span>: &#123; <span class="attr">notInSchema</span>: <span class="number">1</span> &#125; &#125;);</span><br></pre></td></tr></table></figure><p>Mongoose 有一个单独的 strictQuery 选项，用于将过滤器参数的strict模式切换到查询。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">field</span>: <span class="built_in">Number</span> &#125;, &#123;</span><br><span class="line">  strict: <span class="literal">true</span>,</span><br><span class="line">  strictQuery: <span class="literal">true</span> <span class="comment">// Turn on strict mode for query filters</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> MyModel = mongoose.model(<span class="string">'Test'</span>, mySchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mongoose will strip out `notInSchema: 1` because `strictQuery` is `true`</span></span><br><span class="line">MyModel.find(&#123; <span class="attr">notInSchema</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure><p><strong>option：toJSON</strong></p><p>与toObject选项完全相同，但仅在调用documents toJSON方法时才适用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line">schema.path(<span class="string">'name'</span>).get(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v +<span class="string">' is my name'</span>;</span><br><span class="line">&#125;);</span><br><span class="line">schema.set(<span class="string">'toJSON'</span>,&#123;<span class="attr">getters</span>:<span class="literal">true</span>,<span class="attr">virituals</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> M = mongoose.model(<span class="string">'Person'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> M(&#123;<span class="attr">name</span>:<span class="string">'Max Headroom'</span>&#125;);     </span><br><span class="line">m.toObject(); <span class="comment">// &#123;_id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom' &#125;</span></span><br><span class="line">m.toJSON(); <span class="comment">//  &#123;_id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom is my name' &#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringfy(m); <span class="comment">// &#123; "_id": "504e0cd7dd992d9be2f20b6f", "name": "Max Headroom is my name" &#125;</span></span><br></pre></td></tr></table></figure><p><strong>option：toObject</strong></p><p>Documents 的 toObject 方法可以把文档转换成一个 plain javascript object （也就是去掉里面的方法）。 这是一个可以接收多个参数的方法，我们可以在 schemas 定义这些参数。</p><p>例如要打印出虚拟值，可以向 <code>toObject</code> 传入 <code>{ getters: true }</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line">schema.path(<span class="string">'name'</span>).get(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v + <span class="string">'is my name'</span></span><br><span class="line">&#125;);</span><br><span class="line">schema.set(<span class="string">'toObject'</span>,&#123;<span class="attr">getters</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> M = mongoose.model(<span class="string">'Person'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> M(&#123;<span class="attr">name</span>:<span class="string">'HAHA'</span>&#125;);</span><br><span class="line">m <span class="comment">// &#123; _id: 504e0cd7dd992d9be2f20b6f, name: 'HAHA is my name' &#125;</span></span><br></pre></td></tr></table></figure><p><strong>option：typekey</strong></p><p>类型声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">loc</span>:&#123;<span class="attr">type</span>:<span class="built_in">String</span>,<span class="attr">coordinates</span>:[<span class="built_in">Number</span>]&#125;&#125;);</span><br></pre></td></tr></table></figure><p>对于像geoJSON这样的应用程序，“type”属性非常重要。控制使用哪个键mongoose来查找类型声明，要设置“typeKey”模式选项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    loc:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        coordinates:[<span class="built_in">Number</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    name:&#123;</span><br><span class="line">        $type:<span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,&#123;<span class="attr">typeKey</span>:<span class="string">'$type'</span>&#125;);</span><br></pre></td></tr></table></figure><p><strong>option：validateBeforeSave</strong></p><p>默认情况下，文档在保存到数据库之前会自动验证。这是为了防止保存无效的文档。如果希望手动处理验证，并能够保存没有通过验证的对象，可以将validatebeforeave设置为false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123; <span class="attr">name</span>: <span class="built_in">String</span> &#125;);</span><br><span class="line">schema.set(<span class="string">'validateBeforeSave'</span>, <span class="literal">false</span>);</span><br><span class="line">schema.path(<span class="string">'name'</span>).validate(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v != <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> M = mongoose.model(<span class="string">'Person'</span>, schema);</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> M(&#123; <span class="attr">name</span>: <span class="literal">null</span> &#125;);</span><br><span class="line">m.validate(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// Will tell you that null is not allowed.</span></span><br><span class="line">&#125;);</span><br><span class="line">m.save(); <span class="comment">// Succeeds despite being invalid</span></span><br></pre></td></tr></table></figure><p><strong>option：versionKey</strong></p><p><code>versionKey</code> 是 Mongoose 在文件创建时自动设定的。 这个值包含文件的内部<a href="http://aaronheckmann.tumblr.com/post/48943525537/mongoose-v3-part-1-versioning">修订号</a>。 <code>versionKey</code> 是一个字符串，代表版本号的属性名， 默认值为 <code>__v</code>。如果这个值与你的计划冲突，你可以设定为其他名称：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123; <span class="attr">name</span>: <span class="string">'string'</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, schema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(&#123; <span class="attr">name</span>: <span class="string">'mongoose v3'</span> &#125;);</span><br><span class="line">thing.save(); <span class="comment">// &#123; __v: 0, name: 'mongoose v3' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// customized versionKey</span></span><br><span class="line"><span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">versionKey</span>: <span class="string">'_somethingElse'</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, schema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(&#123; <span class="attr">name</span>: <span class="string">'mongoose v3'</span> &#125;);</span><br><span class="line">thing.save(); <span class="comment">// &#123; _somethingElse: 0, name: 'mongoose v3' &#125;</span></span><br></pre></td></tr></table></figure><p>你也可以赋值为 <code>false</code> 禁用 <code>versionKey</code>。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Schema(&#123;..&#125;, &#123; <span class="attr">versionKey</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, schema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(&#123; <span class="attr">name</span>: <span class="string">'no versioning please'</span> &#125;);</span><br><span class="line">thing.save(); <span class="comment">// &#123; name: 'no versioning please' &#125;</span></span><br></pre></td></tr></table></figure><p><strong>option：collation</strong></p><p>为 查询（query）和 聚合（aggregation）设置 collation</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">    collaction:&#123;</span><br><span class="line">        locale:<span class="string">'en_US'</span>,</span><br><span class="line">        strength:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyModel = db.model(<span class="string">'MyModel'</span>,schema);</span><br><span class="line">myModel.create([&#123;<span class="attr">name</span>:<span class="string">'val'</span>,&#123;<span class="attr">name</span>:<span class="string">'Val'</span>&#125;]).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MyModel.find(&#123;<span class="attr">name</span>:<span class="string">'Val'</span>&#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">docs</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// docs 里面会包含上面两个值，因为 strength：1 代表着忽略大小写</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>option：skipVersioning</strong></p><p>跳过版本控制允许从版本控制中排除路径(例如。，即使更新了这些路径，也不会增加内部修订)。除非你知道你在做什么，否则不要这样做。对于子文档，使用完全限定路径将其包含在父文档中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">skipVersioning</span>: &#123; <span class="attr">dontVersionMe</span>: <span class="literal">true</span> &#125; &#125;);</span><br><span class="line">thing.dontVersionMe.push(<span class="string">'hey'</span>);</span><br><span class="line">thing.save(); <span class="comment">// version is not incremented</span></span><br></pre></td></tr></table></figure><p><strong>option：timestamps</strong></p><p>如果设置了 <code>timestamps</code> 选项, mongoose 会在你的 schema 自动添加 <code>createdAt</code> 和 <code>updatedAt</code> 字段， 其类型为Date。这两个字段的默认名称是 <code>createAt</code>和 <code>updateAt</code>，你可以通过设定 <code>timestamps.createAt</code> 和 <code>timestamps.updateAt</code> 自定义名称。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thingSchema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">timestamps</span>: &#123; <span class="attr">createdAt</span>: <span class="string">'created_at'</span> &#125; &#125;);</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, thingSchema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing();</span><br><span class="line">thing.save(); <span class="comment">// `created_at` &amp; `updatedAt` will be included</span></span><br></pre></td></tr></table></figure><p><strong>option：useNestedStrict</strong></p><p>在 mongoose4 中，<code>update()</code> 和 <code>findOneAndUpdate()</code>只检查顶层 schema 的严格模式设定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childSchema = <span class="keyword">new</span> Schema(&#123;&#125;, &#123; <span class="attr">strict</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> parentSchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">child</span>: childSchema &#125;, &#123; <span class="attr">strict</span>: <span class="string">'throw'</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> Parent = mongoose.model(<span class="string">'Parent'</span>, parentSchema);</span><br><span class="line">Parent.update(&#123;&#125;, &#123; <span class="string">'child.name'</span>: <span class="string">'Luke Skywalker'</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 报错！原因是父Schema设定为`strict: throw`，但是因为只检查顶层，导致</span></span><br><span class="line">  <span class="comment">// 子Schema的 `strict: false` 遭到无情忽视</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> update = &#123; <span class="string">'child.name'</span>: <span class="string">'Luke Skywalker'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> opts = &#123; <span class="attr">strict</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">Parent.update(&#123;&#125;, update, opts, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这样可以，因为重写了父Schema的 strict 选项</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果你把 <code>useNestedStrict</code> 设为 true，mongoose 就不会忽略嵌套的 strict 设定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childSchema = <span class="keyword">new</span> Schema(&#123;&#125;, &#123; <span class="attr">strict</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> parentSchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">child</span>: childSchema &#125;,</span><br><span class="line">  &#123; <span class="attr">strict</span>: <span class="string">'throw'</span>, <span class="attr">useNestedStrict</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> Parent = mongoose.model(<span class="string">'Parent'</span>, parentSchema);</span><br><span class="line">Parent.update(&#123;&#125;, &#123; <span class="string">'child.name'</span>: <span class="string">'Luke Skywalker'</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Works!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="模式类型（SchemaTypes）"><a href="#模式类型（SchemaTypes）" class="headerlink" title="模式类型（SchemaTypes）"></a>模式类型（SchemaTypes）</h3><p>SchemaTypes 是处理字段路径各种属性的定义（默认值、验证、getter、setter、查询的字段选择默认值，以及字符串和数字的其他一般特性）</p><p>下面是合法的 SchemaTypes：</p><ul><li>String</li><li>Number</li><li>Date</li><li>Buffer</li><li>Boolean</li><li>Mixed</li><li>ObjectId</li><li>Array</li><li>Decimal128</li></ul><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    binary:Buffer,</span><br><span class="line">    living:<span class="built_in">Boolean</span>,</span><br><span class="line">    updated:&#123;</span><br><span class="line">        type:<span class="built_in">Date</span>,</span><br><span class="line">        <span class="keyword">default</span>:<span class="built_in">Date</span>.now</span><br><span class="line">    &#125;,</span><br><span class="line">    age:&#123;</span><br><span class="line">        type:<span class="built_in">Number</span>,</span><br><span class="line">        min:<span class="number">18</span>,</span><br><span class="line">        max:<span class="number">65</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mixed:Schema.Types.Mixed,</span><br><span class="line">    _someId:Schema.Types.ObjectId,</span><br><span class="line">    decimal:Schema.Types.Decimal128,</span><br><span class="line">    array:[],</span><br><span class="line">    ofString:[<span class="built_in">String</span>],</span><br><span class="line">    ofNumber:[<span class="built_in">Number</span>],</span><br><span class="line">    ofDates:[<span class="built_in">Date</span>],</span><br><span class="line">    ofBuffer:[Buffer],</span><br><span class="line">    ofBoolean:[<span class="built_in">Boolean</span>],</span><br><span class="line">    ofMixed:[Schema.Types.Mixed],</span><br><span class="line">    ofObjectId:[Schema.Types.ObjectId],</span><br><span class="line">    ofArrays:[[]],</span><br><span class="line">    ofArrayOfNumbers:[[<span class="built_in">Number</span>]],</span><br><span class="line">    nested:&#123;</span><br><span class="line">        stuff:&#123;</span><br><span class="line">            type:<span class="built_in">String</span>,</span><br><span class="line">            lowercase:<span class="literal">true</span>,</span><br><span class="line">            trim:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> Thing;</span><br><span class="line">m.name = <span class="string">'haha'</span>;</span><br><span class="line">m.age = <span class="number">125</span>;</span><br><span class="line">m.updated = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">m.binary = <span class="keyword">new</span> Buffer(<span class="number">0</span>);</span><br><span class="line">m.mixed = &#123;</span><br><span class="line">    any:&#123;</span><br><span class="line">        thing:<span class="string">'i want'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">m.markModified(<span class="string">'mixed'</span>);</span><br><span class="line">m._someId = <span class="keyword">new</span> mongoose.Typed.ObjectId;</span><br><span class="line">m.array.push(<span class="number">1</span>);</span><br><span class="line">m.ofString.push(<span class="string">'strings!'</span>);</span><br><span class="line">m.ofNumber.unshift(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">m.ofDates.addToSet(<span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">m.ofBuffer.pop();</span><br><span class="line">m.ofMixed = [<span class="number">1</span>,[],<span class="string">'three'</span>,&#123;<span class="attr">four</span>:<span class="number">5</span>&#125;]</span><br><span class="line">m.nested.stuff = <span class="string">'good'</span>;</span><br><span class="line">m.save(callback);</span><br></pre></td></tr></table></figure><h4 id="SchemaType-选项"><a href="#SchemaType-选项" class="headerlink" title="SchemaType 选项"></a>SchemaType 选项</h4><p>可以直接声明 schema type 为某一种 type，或者赋值一个含有 type 属性的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    test:<span class="built_in">String</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> schema2 = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    test:&#123;</span><br><span class="line">        type:<span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>除了 type 属性，还可以对这个字段路径指定其他属性，如果要在保存之前把字母都改成小写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema2 = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    test:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        lowercase:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>lowercase</code> 属性只作用于字符串。以下有一些全部type 可用的选项和一些限定部分 type 使用的选项。</p><p><strong>全部可用</strong></p><ul><li><code>required</code>：布尔值或者函数，如果值为真，为此属性添加 required 验证器</li><li><code>default</code>：任何值或者函数设置此路径默认值，如果是函数，函数返回值为默认值</li><li><code>select</code>：布尔值执行query 默认 projections</li><li><code>validate</code>：属性验证函数</li><li><code>get</code>：函数 使用 <code>Object.defineProperty()</code> 定义自定义 getter</li><li><code>set</code>：函数 使用 <code>Object.defineProperty()</code> 定义自定义 setter</li><li><code>alias</code>：字符串 仅mongoose &gt;= 4.10.0。 为该字段路径定义虚拟值 gets/sets</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numberSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    integerOnly:&#123;</span><br><span class="line">        type:<span class="built_in">Number</span>,</span><br><span class="line">        get:<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">Math</span>.round(v),</span><br><span class="line">        set:<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">Math</span>.round(v),</span><br><span class="line">        alias:<span class="string">'i'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Number</span> = mongoose.model(<span class="string">'Number'</span>,numberSchema);</span><br><span class="line"><span class="keyword">const</span> doc = <span class="keyword">new</span> <span class="built_in">Number</span>();</span><br><span class="line">doc.integerOnly = <span class="number">2.001</span>;</span><br><span class="line">doc.integerOnly <span class="comment">// 2</span></span><br><span class="line">doc.i <span class="comment">// 2</span></span><br><span class="line">doc.i = <span class="number">3.001</span>;</span><br><span class="line">doc.integerOnly <span class="comment">//3</span></span><br><span class="line">doc.i <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p><strong>索引相关</strong></p><p>可以使用 schema type 选项定义 MongoDB  indexex</p><ul><li><code>index</code>:布尔值 是否对这个属性创建索引</li><li><code>unique</code>:布尔值 是否对这个属性创建唯一索引</li><li><code>sparse</code>:布尔值 是否对这个属性创建稀疏索引</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    test:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        index:<span class="literal">true</span>,</span><br><span class="line">        unique:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>String</p><ul><li><code>lowercase</code>: 布尔值 是否保存前对此值调用 <code>.toLowerCase()</code></li><li><code>uppercase</code>: 布尔值 是否保存前对此值调用 <code>.toUpperCase()</code></li><li><code>trim</code>: 布尔值 是否在保存前对此值调用  <code>trim()</code></li><li><code>match</code>:正则表达式 创建验证器检查这个值是否匹配给定正则表达式</li><li><code>enum</code>:数组 创建验证器检查这个值是否包含于给定数组</li></ul><p>Number </p><ul><li><code>min</code>:数值 创建验证器检查属性是否大于或者等于该值</li><li><code>max</code>:数值 创建验证器检查属性是否小于或者等于该值</li></ul><p>Date</p><ul><li><code>min</code>:Date</li><li><code>max</code>:Date</li></ul><h4 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a><strong>使用注意</strong></h4><p><strong>Dates</strong></p><p>内建的 Date 方法不会触发 mongoose 修改跟踪逻辑，如果使用 <code>setMonth()</code> 修改文档里面的 <code>Date</code>,mongoose 在 <code>doc.save()</code> 的时候是察觉不到这个文档发生了变化的，因此保存不到数据库中。如果一定要用内建的 Date 方法，需要手动调用 <code>doc.markModified(&#39;pathToYourDate&#39;)</code>告诉 mongoose 修改了数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Assignment = mongoose.model(<span class="string">'Assignment'</span>,&#123;<span class="attr">dueDate</span>:<span class="built_in">Date</span>&#125;);</span><br><span class="line">Assignment.findOne(<span class="function"><span class="keyword">function</span>(<span class="params">err,doc</span>)</span>&#123;</span><br><span class="line">    doc.dueDate.setMonth(<span class="number">3</span>);</span><br><span class="line">    doc.save(callback); <span class="comment">// 这个不会保存你的修改</span></span><br><span class="line">    doc.markModified(<span class="string">'dueDate'</span>);</span><br><span class="line">    doc.save(callback);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>Mixed</strong></p><p>一个什么都可以放的 SchemaType,虽然遍历，但是也会让数据难以维护。Mixed 可以通过 Schema.Types.Mixed 或者传入 一个空对象定义。下面三种方法效果是一致的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Any = <span class="keyword">new</span> Schema(&#123;<span class="attr">any</span>:&#123;&#125;&#125;);</span><br><span class="line"><span class="keyword">const</span> Any = <span class="keyword">new</span> Schema(&#123;<span class="attr">any</span>:<span class="built_in">Object</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Any = <span class="keyword">new</span> Schema(&#123;<span class="attr">any</span>:Schema.Types.Mixed&#125;);</span><br></pre></td></tr></table></figure><p>因为这是个 schema-less type，所以可以赋值为任意类型，但是 mongoose 无法自动检测并保存修改。要告诉它修改了 Mixed type 的值，调用文档的 <code>.markModified(path)</code> 方法，传入你的 Mixed 字段路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person.anything = &#123;<span class="attr">x</span>:[<span class="number">3</span>,<span class="number">4</span>,&#123;<span class="attr">y</span>:<span class="string">'changed'</span>&#125;]&#125;</span><br><span class="line">person.markModified(<span class="string">'anything'</span>);</span><br><span class="line">person.save(); <span class="comment">// anything will now get changed</span></span><br></pre></td></tr></table></figure><p><strong>ObjectIds</strong></p><p>要指定类型为 ObjectId，在声明中使用 <code>Schema.Types.ObjectId</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> ObjectId = mongoose.Schema.Types.ObjectId;</span><br><span class="line"><span class="keyword">const</span> Car = <span class="keyword">new</span> Schema(&#123;<span class="attr">driver</span>:ObjectId&#125;);</span><br></pre></td></tr></table></figure><p><strong>Arrays</strong></p><p>创造 SchemaTypes 或者子文档数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ToySchema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> ToyBox = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    toys:[ToySchema],</span><br><span class="line">    buffers:[Buffer],</span><br><span class="line">    string:[<span class="built_in">String</span>]，</span><br><span class="line">    number:[<span class="built_in">Number</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意：指定空数组相当于  <code>Mixed</code>,下面的操作相当于创建 <code>Mixed</code>数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Empty1 = <span class="keyword">new</span> Schema(&#123;<span class="attr">ary</span>:&#123;]&#125;&#125;);</span><br><span class="line"><span class="keyword">const</span> Empty2 = <span class="keyword">new</span> Schema(&#123;<span class="attr">any</span>:<span class="built_in">Array</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Empty3 = <span class="keyword">new</span> Schema(&#123;<span class="attr">any</span>:[Schema.Types.Mixed]&#125;);</span><br><span class="line"><span class="keyword">const</span> Empty4 = <span class="keyword">new</span> Schema(&#123;<span class="attr">any</span>:[&#123;&#125;]&#125;);</span><br></pre></td></tr></table></figure><p>数组的默认值是 <code>[]</code>（空数组）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Toy = mongoose.model(<span class="string">'Test'</span>,toySchema);</span><br><span class="line"><span class="keyword">new</span> Toy().toys <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>要手动把默认值设置为 <code>undefined</code>，从而覆盖 <code>[]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ToySchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    toys:&#123;</span><br><span class="line">        type:[ToySchema],</span><br><span class="line">        defalut:<span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="创建自定义-Type"><a href="#创建自定义-Type" class="headerlink" title="创建自定义 Type"></a><strong>创建自定义 Type</strong></h4><p>Mongoose 可以扩展自定义 SchemaType.</p><p><strong><code>schema.path()</code>函数</strong></p><p>这个函数为给定字段路径返回实例化 schema type</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sampleSchema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:&#123;<span class="attr">type</span>:<span class="built_in">String</span>,<span class="attr">require</span>:<span class="literal">true</span>&#125;&#125;);</span><br><span class="line">sampleSchema.path(<span class="string">'name'</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* SchemaString &#123;</span></span><br><span class="line"><span class="comment"> *   enumValues: [],</span></span><br><span class="line"><span class="comment"> *   regExp: null,</span></span><br><span class="line"><span class="comment"> *   path: 'name',</span></span><br><span class="line"><span class="comment"> *   instance: 'String',</span></span><br><span class="line"><span class="comment"> *   validators: ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个函数可以检查给定字段路径的检查器和类型等信息。</p><h3 id="连接（Connections）"><a href="#连接（Connections）" class="headerlink" title="连接（Connections）"></a>连接（Connections）</h3><p>可以使用 <code>mongoose.connect()</code>方法连接 MongoDB</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://localhost/myapp'</span>);</span><br></pre></td></tr></table></figure><p>这是连接本地 <code>myapp</code>数据库默认接口（27017）的最小配置。本地连接失败可以尝试 127.0.0.1.local hostname 被修改有时候会引起问题。</p><p>可以在 url 中指定多个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://username:password@host:port/database?options'</span>);</span><br></pre></td></tr></table></figure><h4 id="操作缓存"><a href="#操作缓存" class="headerlink" title="操作缓存"></a><strong>操作缓存</strong></h4><p>不必等等连接建立成功就可以使用 Mongoose models</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://localhost/myapp'</span>);</span><br><span class="line"><span class="keyword">const</span> MyModel = mongoose.model(<span class="string">'Test'</span>,<span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;));</span><br><span class="line">MyModel.findOne(<span class="function"><span class="keyword">function</span>(<span class="params">err,res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Mongoose 会缓存 model 操作。这个操作很方便，但也会引起一些疑惑，因为如果没有连上的话，Mongoose 不会抛错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyModel = mongoose.model(<span class="string">'Test'</span>,<span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;));</span><br><span class="line">MyModel.findOne(<span class="function"><span class="keyword">function</span>(<span class="params">err,res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    mongoose.connect(<span class="string">'mongodb://localhost/xxx'</span>);</span><br><span class="line">&#125;,<span class="number">6000</span>);</span><br></pre></td></tr></table></figure><p>要禁用缓存，修改 bufferCommands 配置。如果打开了这个选项连接被挂起，尝试关闭 bufferCommands 检查是否正确打开连接，也可以全局禁用 bufferCommands:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.set(<span class="string">'bufferCommands'</span>,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h4 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a><strong>选项</strong></h4><p><code>connect</code> 方法也接受 <code>options</code> 参数，这些参数会传入底层 MongoDB 驱动</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(uri,options);</span><br></pre></td></tr></table></figure><p>Mongoose 会不做修改直接把选项传到驱动，以下有一点例外</p><ul><li><code>bufferCommands</code> 是 mongoose 特有的选项，</li><li><code>user/pass</code>  用于认证的用户名和密码。mongoose 特有的，等价于 MongoDB 驱动的 <code>auth.user</code> 和 <code>auth.password</code>选项</li><li><code>autoIndex</code> 理想情况下，mongoose 在连接时会自动建立 schema 索引。这有利于开发，但是在大型生产环境中不是很理想，因为会导致性能下降。</li><li><code>dbName</code> 指定要连接的数据库名称（覆盖连接字符串）</li></ul><p>下面是一些重要的选项</p><ul><li><code>autoReconnect</code> 底层 MongoDB 驱动在连接后将自动重连。除非是管理连接池的高手，不然不建议设置为 false</li><li><code>bufferMaxEntries</code> MongoDB 驱动同样有自己的离线缓存机制。如果希望连接错误时终止数据库操作，可以设这个值为 0 以及把 bufferCommands 设为 false.</li><li><code>promiseLibrary</code> 设置底层 promise 库</li><li><code>poolSize</code> MongoDB 保持的最大 socket 连接数。默认是5.MongoDB 3.4 之前，只允许每个 socket 同时进行一个操作，所以如果有几个缓慢请求卡着后面快的请求，可以尝试增加连接数。</li></ul><p>举例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    useMongoClient:<span class="literal">true</span>,</span><br><span class="line">    autoIndex:<span class="literal">false</span>, <span class="comment">// 不要创建索引</span></span><br><span class="line">    reconnectTries:<span class="built_in">Number</span>.MAX_VALUE, <span class="comment">// 不要停止重连</span></span><br><span class="line">    reconnectInterval:<span class="number">500</span>, <span class="comment">// 每500毫秒重连</span></span><br><span class="line">    poolSize:<span class="number">10</span>, <span class="comment">// 维护最多10个socket</span></span><br><span class="line">    bufferMaxEntries:<span class="number">0</span> <span class="comment">// 如果没有连接，则立即返回错误，而不是等待重新连接</span></span><br><span class="line">&#125;</span><br><span class="line">mongoose.connect(uri,options);</span><br></pre></td></tr></table></figure><h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a><strong>回调</strong></h4><p><code>connect</code> 函数接受回调函数，或者返回一个 promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(uri,options,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line">mongoose.connect(uri,options).then(</span><br><span class="line">    ()=&gt;&#123;<span class="comment">/** ready to use. The `mongoose.connect()` promise resolves to undefined. */</span> &#125;</span><br><span class="line">    err=&gt;&#123;<span class="comment">/** handle initial connection error */</span>&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="连接字符串（Connectng-String）选项"><a href="#连接字符串（Connectng-String）选项" class="headerlink" title="连接字符串（Connectng String）选项"></a><strong>连接字符串（Connectng String）选项</strong></h4><p>可以在连接字符串填写驱动选项，这只适用于 MongoDB 驱动使用的选项，所以类似 bufferCommands 的 Mongoose 专用选项不能在连接字符串使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://localhost:27017/test?connectTimeoutMS=1000&amp;bufferCommands=false'</span>);</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">mongoose.connect(<span class="string">'mongodb://localhost:27017/test'</span>, &#123;</span><br><span class="line">  connectTimeoutMS: <span class="number">1000</span></span><br><span class="line">  <span class="comment">// Note that mongoose will **not** pull `bufferCommands` from the query string</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>把选项放在连接字符串的劣势是不便阅读。优势是简短。最佳实践是把区分生产环境和开发环境的选项，<code>socketTimeoutMS</code> 、 <code>connectTimeoutMS</code> 放在 uri ， 把通用的常量如 <code>connectTimeoutMS</code> 、 <code>poolSize</code> 放在选项对象里。</p><h4 id="keepAlive注意事项"><a href="#keepAlive注意事项" class="headerlink" title="keepAlive注意事项"></a><strong>keepAlive注意事项</strong></h4><p>对于长期运行的后台引用，启用毫秒级 <code>keepAlive</code>是一个精明的操作。不这么做偶尔会经常收到看似没有什么原因的 <code>connection closed</code> 错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(uri,&#123;<span class="attr">keepAlive</span>:<span class="number">120</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="副本集（Replica-Set）连接"><a href="#副本集（Replica-Set）连接" class="headerlink" title="副本集（Replica Set）连接"></a><strong>副本集（Replica Set）连接</strong></h4><p>要连接到副本集，可以使用逗号分隔开，传入多个地址：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]'</span> [, options]);</span><br></pre></td></tr></table></figure><p>连接到单节点副本集，需要指定 <code>relicaSet</code> 选项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://host1:port1/?replicaSet=rsName'</span>);</span><br></pre></td></tr></table></figure><h4 id="多-mongos-支持"><a href="#多-mongos-支持" class="headerlink" title="多 mongos 支持"></a><strong>多 mongos 支持</strong></h4><p>使用高性能分片集群，需要连接<a href="https://docs.mongodb.com/manual/reference/program/mongos/">多个 mongos（MongoDB Shard） 实例</a>。 在 mongoose 5.x 中， 你在连接多个 mongos 时<a href="http://mongodb.github.io/node-mongodb-native/3.0/tutorials/connect/#connect-to-sharded-cluster">不需要传入任何特殊选项</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connect to 2 mongos servers</span></span><br><span class="line">mongoose.connect(<span class="string">'mongodb://mongosA:27501,mongosB:27501'</span>, cb);</span><br></pre></td></tr></table></figure><h4 id="多个连接"><a href="#多个连接" class="headerlink" title="多个连接"></a><strong>多个连接</strong></h4><p>之前我们了解如何使用 Mongoose 默认连接方法连接到 MongoDB。但有时候我们需要权限不同的多个连接， 或是连接到不同数据库。这个情况下我们可以使用 <code>mongoose.createConnection()</code>， 它接受之前提到的所有参数，给你返回一个新的连接。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> conn = mongoose.createConnection(<span class="string">'mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]'</span>, options);</span><br></pre></td></tr></table></figure><p>connection对象后续用于创建和检索models。 models 的范围总是局限于单个连接。</p><p>调用 <code>mongoose.connect()</code> 时，Mongoose 会自动创建<strong>默认连接</strong>。 你可以使用 <code>mongoose.connection</code> 访问默认连接。</p><h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a><strong>连接池</strong></h4><p>无论是使用 <code>mongoose.connect</code> 或是 <code>mongoose.createConnection</code> 创建的连接， 都被纳入默认最大为 5 的连接池，可以通过 poolSize 选项调整：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With object options</span></span><br><span class="line">mongoose.createConnection(uri, &#123; <span class="attr">poolSize</span>: <span class="number">4</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uri = <span class="string">'mongodb://localhost/test?poolSize=4'</span>;</span><br><span class="line">mongoose.createConnection(uri);</span><br></pre></td></tr></table></figure><h3 id="模型（Models）"><a href="#模型（Models）" class="headerlink" title="模型（Models）"></a>模型（Models）</h3><p>Models 是从 Schema 编译来的构造函数，它们的实例就代表着可以从数据保存和读取 documents，从数据创建和读取 document 的所有操作都是通过 model 进行的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="string">'string'</span>,<span class="attr">size</span>:<span class="string">'string'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Tank = mongoose.model(<span class="string">'Tank'</span>,schema);</span><br></pre></td></tr></table></figure><p>第一个参数是跟 model 对应的集合（collection） 名字的单数形式。Mongoose 会自动找到名称是 model 名字复数形式的 collection。对于上例，Tank 这个model 就对应 数据库中 tanks 这个 collection.<code>.model()</code> 这个函数是对 <code>schema</code> 做了拷贝（生成了model）。要确保在调用 <code>.model()</code> 之前把所有需要的东西都加进去 <code>schema</code>里面。</p><h4 id="构造-documents"><a href="#构造-documents" class="headerlink" title="构造 documents"></a><strong>构造 documents</strong></h4><p>Documents 是 model 的实例，创建它们并保存到数据库非常简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Tank = mongoose.model(<span class="string">'Tank'</span>,yourSchema);</span><br><span class="line"><span class="keyword">const</span> small = <span class="keyword">new</span> Tank(&#123;<span class="attr">size</span>:<span class="string">'small'</span>&#125;);</span><br><span class="line">small.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Tank.create(&#123;<span class="attr">size</span>:<span class="string">'small'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,small</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>要注意，知道 model 使用的数据连接（connection）被打开，tanks 才会被创建/删除，每个 model 都有一个绑定的连接。如果model 是通过调用 <code>mongoose.model()</code> 生成的，它将使用 mongoose 的默认连接。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'localhost'</span>,<span class="string">'gettingstarted'</span>)</span><br></pre></td></tr></table></figure><p>如果自行创建了连接，就需要使用 connection 的 <code>model</code>函数代替 mongoose 的 <code>model</code>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> connection = mongoose.createConnection(<span class="string">'mongodb://localhost:27017/test'</span>);</span><br><span class="line"><span class="keyword">const</span> Tank = connection.model(<span class="string">'Tank'</span>,yourSchema);</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a><strong>查询</strong></h4><p>用 mongoose 查询文档相当容易，它支持 mongoDB的高级查询语法（rich），查询文档可以使用 <code>model</code>的 find,findById,findOne,where 这些静态方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tank.find(&#123;<span class="attr">size</span>:<span class="string">'small'</span>&#125;).where(<span class="string">'createDate'</span>).gt(oneYearAgo).exec(callback);</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a><strong>删除</strong></h4><p><code>model</code>的 <code>remove</code>方法可以删除所有匹配查询条件的文档</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tank.remove(&#123;<span class="attr">size</span>:<span class="string">'large'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a><strong>更新</strong></h4><p><code>model</code>的 <code>update</code>方法可以修改数据库中的文档，不过不会把文档返回给应用层。</p><p>如果想更新单独一条文档并且返回给应用层，可以使用 findOneAndIUpdate 方法</p><h3 id="文档（Documents）"><a href="#文档（Documents）" class="headerlink" title="文档（Documents）"></a>文档（Documents）</h3><p>Mongoose documents代表着MongoDB 文档的一对一映射，每个 document 都是他的 Model 实例。</p><h4 id="检索"><a href="#检索" class="headerlink" title="检索"></a><strong>检索</strong></h4><p>MongoDB  有很多检索数据的方法。</p><h4 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a><strong>更新</strong></h4><p>Document 更新的方法同样也有很多,最基本的 findById</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Tank.findById(id,<span class="function"><span class="keyword">function</span>(<span class="params">err,tank</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    tank.size = <span class="string">'large'</span>;</span><br><span class="line">    tank.save(<span class="function"><span class="keyword">function</span>(<span class="params">err,updateTank</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">        res.send(updateTank);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>也可以用 <code>.set()</code> 修改 document 。在底层，<code>tank.size = &#39;large&#39;</code>，用 <code>tank.set({size:&#39;large&#39;})</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Tank.findById(id,<span class="function"><span class="keyword">function</span>(<span class="params">err,tank</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    tank.set(&#123;<span class="attr">size</span>:<span class="string">'large'</span>&#125;);</span><br><span class="line">    tank.save(<span class="function"><span class="keyword">function</span>(<span class="params">err,updateTank</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">        res.send(updateTank);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个方法先检索了数据，接着更新（使用了<code>save</code>）。如果我们仅仅需要更新而不是获取该数据，<code>model#update</code>就很适合我们：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tank.update(&#123;<span class="attr">_id</span>:id&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="attr">size</span>:<span class="string">'large'</span>&#125;&#125;,callback);</span><br></pre></td></tr></table></figure><p>如果我们确实需要返回文档，下面的方法更加适合：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tank.findByIdAndUpdate(id,&#123;<span class="attr">$set</span>:&#123;<span class="attr">size</span>:<span class="string">'large'</span>&#125;&#125;,&#123;<span class="attr">new</span>:<span class="literal">true</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,tank</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    res.send(tank);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>findAndUpdate/Remove</code>系列静态方法查找并返回最多1个文档，模式的方法有不少。</p><p>注意：<code>findAndUpdata/Remove</code>不会修改数据库时执行任何钩子或者验证。可以使用 <code>runValidators</code> 选项获取一个验证的限制子集。但是需要钩子和全文档验证的，还是先query 在save </p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h4><p>Document 会在被保存之前验证。</p><h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a><strong>覆盖</strong></h4><p>可以用 <code>.set()</code> 覆盖整个文档。如果要修改在中间件中被保存的文档，这样就很方便了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tank.findById(id,<span class="function"><span class="keyword">function</span>(<span class="params">err,tank</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError();</span><br><span class="line">    <span class="comment">// otherTank 是 tank 的副本</span></span><br><span class="line">    otherTank.set(tank)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="子文档（Subdocuments）"><a href="#子文档（Subdocuments）" class="headerlink" title="子文档（Subdocuments）"></a>子文档（Subdocuments）</h3><p>子文档是指嵌套在另一个文档中的文档。在 Mongoose 中，这意味着可以在 里面嵌套一个 schema 。Mongoose 子文档有两种不同的概念：子文档数组和单个嵌套子文档。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childSchema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="string">'string'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> parentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    children:[childSchema],</span><br><span class="line">    <span class="comment">// Single nested subdocuments. Caveat: single nested subdocs only work in mongoose &gt;= 4.2.0</span></span><br><span class="line">    child:childSchema</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>子文档和普通 docuemnt 类似。嵌套 schema 可以有自己的中间件，自定义检索逻辑、虚拟值已经其他顶层 schemas 可用的特性，两者主要的不同点是子文档不能单独保存，他们会在他们的顶级文档保存时保存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Parent = mongoose.model(<span class="string">'Parent'</span>,parentSchema);</span><br><span class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> Parent([children:[&#123;<span class="attr">name</span>:<span class="string">'Matt'</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'Sarah'</span>&#125;]]);</span><br><span class="line">parent.children[<span class="number">0</span>].name = <span class="string">'HaHa'</span>;</span><br><span class="line"><span class="comment">// parent.children[0].save() 无操作，虽然他触发了中间件，但是没有保存文档，需要 save 他的文档、</span></span><br><span class="line">parent.save(callback);</span><br></pre></td></tr></table></figure><p>子文档跟普通文档一样有 save 和 validate 中间件，调用福文档的 save 会触发所有子文档的 save 中间件， validate 中间件同理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">childSchema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">'invalid'</span> == <span class="keyword">this</span>.name)&#123;</span><br><span class="line">       <span class="keyword">return</span> next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'#sadpanda'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> Parent(&#123;<span class="attr">children</span>:[&#123;<span class="attr">name</span>:<span class="string">'invalid'</span>&#125;]&#125;);</span><br><span class="line">parent.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.message); <span class="comment">//#sadpanda</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>子文档的 <code>pre(&#39;save&#39;)</code> 和 <code>pre(&#39;validate&#39;)</code>中间件执行于顶层 document <code>pre(&#39;save&#39;)</code> 之前，顶层 document 的 <code>pre(&#39;validate&#39;)</code>之后。因为 <code>save()</code>前的验证就是一个中间件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childSchema = <span class="keyword">new</span> mongoose.Schema(&#123;<span class="attr">name</span>:<span class="string">'string'</span>&#125;);</span><br><span class="line">childSchema.pre(<span class="string">'validate'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">childSchema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> parentSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    child:childSchema</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">parentSchema.pre(<span class="string">'validate'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">parentSchema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 2 3 4</span></span><br></pre></td></tr></table></figure><h4 id="查找子文档"><a href="#查找子文档" class="headerlink" title="查找子文档"></a><strong>查找子文档</strong></h4><p>每个子文档都有一个默认 <code>_id</code>，Mongoose document 数组有一个特别的 id 方法，这个方法只要传入 <code>_id</code>就能返回文档数组中特定文档。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doc = parent.children.id(_id);</span><br></pre></td></tr></table></figure><h4 id="添加子文档到数组"><a href="#添加子文档到数组" class="headerlink" title="添加子文档到数组"></a><strong>添加子文档到数组</strong></h4><p>Mongoose 数组方法有 push、unshift、addToSet 等等：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Parent = mongoose.model(<span class="string">'Parent'</span>);</span><br><span class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> Parent;</span><br><span class="line"></span><br><span class="line">parent.children.push(&#123;<span class="attr">name</span>:<span class="string">'Haha'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> subdoc = parent.children[<span class="number">0</span>];</span><br><span class="line">subdoc; <span class="comment">//  _id: '501d86090d371bab2c0341c5', name: 'Haha' &#125;</span></span><br><span class="line">subdoc.isNew; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">parent.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Success'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>create 方法可以新建文档但是不加入数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newdoc = parent.children.create(&#123;<span class="attr">name</span>:<span class="string">'Haha'</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="删除子文档"><a href="#删除子文档" class="headerlink" title="删除子文档"></a><strong>删除子文档</strong></h4><p>每个子文档都有 remove 方法，另外，对于子文档数组，有一个等效的方法<code>.pull()</code>。对于单个嵌套子文档，remove 与把这个文档的值设为 null 等效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等效 parent.children.pull(_id)</span></span><br><span class="line">parent.children.id(_id).remove()</span><br><span class="line"><span class="comment">// 或者 parent.child = null</span></span><br><span class="line">parent.child.remove();</span><br><span class="line">parent.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'the subdocs were removed'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>代替声明语法的写法</strong></p><p>如果用对象的数组创建 schema,mongoose 会自动把对象转成 schema：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    children:[&#123;<span class="attr">name</span>:<span class="string">'string'</span>&#125;]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">const</span> parentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    children:[<span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="string">'string'</span>&#125;)]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="查询（queries）"><a href="#查询（queries）" class="headerlink" title="查询（queries）"></a>查询（queries）</h3><p>Model 的多个静态辅助方法都可以查询文档。</p><p>Model 的方法中包含查询条件参数的（find findById count update）都可以按照下面两种方式执行：</p><ol><li>传入 callback 参数，操作会被立即执行，查询结果被传给回调函数（callback）</li><li>不传 callback 参数，Query 的一个实例（一个 query对象）被返回，这个 query 提供了 构建查询器的特殊接口。</li></ol><p>Query 实例有一个 <code>.then()</code>函数，用法类似 promise</p><p>如果执行查询时传入 callback,就需要用 JSON 文档的格式指定查询条件，JSON 文档的语法跟 MongoDB shell  一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Parent = mongoose.model(<span class="string">'Person'</span>,mySchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询 last name 是 haha 的 person,选中 name 和 occupation 字段</span></span><br><span class="line">Person.findOne(&#123;<span class="string">'name.last'</span>:<span class="string">'haha'</span>&#125;,<span class="string">'name occupation'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,person</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(person.name.first,person.name.last,person.occupation);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的查询被立即执行，查询结果被传入回调函数。Mongoose 中所有的调用函数都是用 <code>callback(error,result)</code>这种模式。如果查询发生错误，<code>error</code>参数即是错误文档，<code>result</code>参数会是 null。如果查询成功，<code>error</code>参数是 null，<code>result</code>即是查询结果。</p><p>查询结果的格式取决于做什么操作：findOne() 是单个文档（或者null），find() 是文档列表，count() 是文档数量， update() 是被修改的文档数量。</p><p>下面看看不传入 callback 这个参数会是怎么样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找每个  last name 是 haha 的 person</span></span><br><span class="line"><span class="keyword">const</span> query = Person.findOne(&#123;<span class="string">'name.last'</span>:<span class="string">'haha'</span>&#125;);</span><br><span class="line"><span class="comment">// 选择 name 和 occupation 字段</span></span><br><span class="line">query.select(<span class="string">'name occupation'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后执行查询</span></span><br><span class="line">query.exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,person</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(person.name.first,person.name.last,person.occupation);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码中，query 是 Query 类型的变量，Query 能够用链式语法构建查询器，无需要执行 JSON 对象。下面2个实例等效：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Person.find(&#123;</span><br><span class="line">    occupation:<span class="regexp">/host/</span>,</span><br><span class="line">    <span class="string">'name.last'</span>:<span class="string">'haha'</span>,</span><br><span class="line">    age:&#123;<span class="attr">$gt</span>:<span class="number">17</span>,<span class="attr">$lt</span>:<span class="number">66</span>&#125;,</span><br><span class="line">    likes:&#123;<span class="attr">$in</span>:[<span class="string">'vaporizing'</span>,<span class="string">'talking'</span>]&#125;</span><br><span class="line">&#125;).limit(<span class="number">10</span>).sort(&#123;<span class="attr">occupation</span>:<span class="number">-1</span>&#125;).</span><br><span class="line">select(&#123;<span class="attr">name</span>:<span class="number">1</span>,<span class="attr">ouccupation</span>:<span class="number">1</span>&#125;).</span><br><span class="line">exec(callback);</span><br><span class="line"></span><br><span class="line">Person.find(&#123;<span class="attr">occupation</span>:<span class="regexp">/host/</span>&#125;).</span><br><span class="line">where(<span class="string">'name.last'</span>).equals(<span class="string">'haha'</span>).</span><br><span class="line">where(<span class="string">'age'</span>).gt(<span class="number">17</span>).lt(<span class="number">66</span>).</span><br><span class="line">where(<span class="string">'likes'</span>).in([<span class="string">'vaporizing'</span>,<span class="string">'talking'</span>]).</span><br><span class="line">limit(<span class="number">10</span>).</span><br><span class="line">sort(<span class="string">'-occupation'</span>).</span><br><span class="line">select(<span class="string">'name occupation'</span>).</span><br><span class="line">exec(callback)</span><br></pre></td></tr></table></figure><h4 id="引用其他文档"><a href="#引用其他文档" class="headerlink" title="引用其他文档"></a><strong>引用其他文档</strong></h4><p>MongoDB 中没有表连接，但引用其他结合的文档有时候也会需要。population 就是这样当升的。</p><p><strong>Streaming</strong></p><p>可以用 流式处理 MongoDB 的查询结果，需要调用 Query.cursor() 函数获得 QueryCursor 的一个实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cursor = Person.find(&#123;<span class="attr">occupation</span>:<span class="regexp">/host/</span>&#125;).cursor();</span><br><span class="line"></span><br><span class="line">cursor.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">doc</span>)</span>&#123;<span class="comment">/**Called once for every document*/</span>&#125;);</span><br><span class="line">cursor.on(<span class="string">'close'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/**Called when done*/</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="验证（validation）"><a href="#验证（validation）" class="headerlink" title="验证（validation）"></a>验证（validation）</h3><p>需要先注意下面几点：</p><ul><li>验证定义于 SchemaType</li><li>验证是一个中间件，它默认作为 <code>pre(save)</code>钩子注册在 schema 上</li><li>可以使用 <code>doc.validate(callback)</code>或者 <code>doc.validateSync()</code>手动验证</li><li>验证器不对未定义的值进行验证，唯一例外就是 require 验证器</li><li>验证是异步递归的。当调用 Model#save,子文档也会执行，出错的话 Model#save 回调会接受错误</li><li>验证是可以定制的。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="built_in">require</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> Cat = db.model(<span class="string">'Cat'</span>,schema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line">cat.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    assert.equal(error.errors[<span class="string">'name'</span>].message,<span class="string">'Path `name` is required.'</span>);</span><br><span class="line">    error = cat.validateSync();</span><br><span class="line">    assert.equal(error.errors[<span class="string">'name'</span>].message,<span class="string">'Path `name` is required.'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="内建-Validators"><a href="#内建-Validators" class="headerlink" title="内建 Validators"></a><strong>内建 Validators</strong></h4><p>Mongoose 有一些内建验证器</p><ul><li>所有 SchemaTypes 都有内建的 required 验证器。required 验证器使用 <code>checkRequired（）</code>函数判定这个值是否满足 required 验证器</li><li>Numbers 有 min 和 max 验证器</li><li>String 有 enum、match、maxlength 和 minlength 验证器</li></ul><p>上面的链接提供了使用和错误处理相关的详细信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> breakfastSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    eggs:&#123;</span><br><span class="line">        type:<span class="built_in">Number</span>,</span><br><span class="line">        min:[<span class="number">6</span>,<span class="string">'Too few eggs'</span>],</span><br><span class="line">        max:<span class="number">12</span></span><br><span class="line">    &#125;,</span><br><span class="line">    bacon:&#123;</span><br><span class="line">        type:<span class="built_in">Number</span>,</span><br><span class="line">        required:[<span class="literal">true</span>,<span class="string">'Why no bacon'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    drink:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        enum:[<span class="string">'Coffee'</span>,<span class="string">'Tea'</span>],</span><br><span class="line">        required:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.bacon &gt; <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> Breakfast = db.model(<span class="string">'Breakfast'</span>,breakfastSchema);</span><br><span class="line"><span class="keyword">const</span> badBreakfast = <span class="keyword">new</span> Breakfast(&#123;</span><br><span class="line">    eggs:<span class="number">2</span>,</span><br><span class="line">    bacon:<span class="number">0</span>,</span><br><span class="line">    drink:<span class="string">'Milk'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> error = badBreakfast.validateSync();</span><br><span class="line">assert.equal(error.errors[<span class="string">'eggs'</span>].message,<span class="string">'Too few eggs'</span>);</span><br><span class="line">assert.ok(!error.errors[<span class="string">'bacon'</span>]);</span><br><span class="line">assert.equal(error.errors[<span class="string">'drink'</span>].message,<span class="string">'`Milk` is not a valid enum value for path `drink`'</span>);</span><br><span class="line">badBreakfast.bacon = <span class="number">5</span>;</span><br><span class="line">badBreakfast.drink = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">error = badBreakfast.validateSync();</span><br><span class="line">assert.equal(error.errors[<span class="string">'drink'</span>].message,<span class="string">'Path `drink` is required'</span>);</span><br><span class="line"></span><br><span class="line">badBreakfast.bacon = <span class="literal">null</span>;</span><br><span class="line">error = badBreakfast.validateSync();</span><br><span class="line">assert.equal(error.errors[<span class="string">'bacon'</span>].message,<span class="string">'Why no bacon'</span>);</span><br></pre></td></tr></table></figure><h4 id="unique不是验证器"><a href="#unique不是验证器" class="headerlink" title="unique不是验证器"></a><strong><code>unique</code>不是验证器</strong></h4><p>它是构建  MongoDB unique indexes 的辅助函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uniqueUsernameSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    username:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        unique:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> U1 = db.model(<span class="string">'U1'</span>,uniqueUsernameSchema);</span><br><span class="line"><span class="keyword">const</span> U2 = db.model(<span class="string">'U2'</span>,uniqueUsernameSchema);</span><br><span class="line"><span class="keyword">const</span> dup = [&#123;<span class="attr">username</span>:<span class="string">'Val'</span>&#125;,&#123;<span class="attr">username</span>:<span class="string">'val'</span>&#125;]</span><br><span class="line"></span><br><span class="line">U1.create(dup,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在保存之前需要等待索引完成构建，否则可能会违反惟一的约束。</span></span><br><span class="line">U2.once(<span class="string">'index'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    assert.ifError(err);</span><br><span class="line">    U2.create(dup,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 重复键错误</span></span><br><span class="line">        assert.ok(err);</span><br><span class="line">        assert.ok(!err.errors);</span><br><span class="line">        assert.ok(error.message.indexOf(<span class="string">'duplicate key error'</span>) != <span class="number">-1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">U2.init().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    U2.create(dup,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 重复键错误</span></span><br><span class="line">        assert.ok(err);</span><br><span class="line">        assert.ok(!err.errors);</span><br><span class="line">        assert.ok(error.message.indexOf(<span class="string">'duplicate key error'</span>) != <span class="number">-1</span>);</span><br><span class="line">    &#125;);   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="自定义验证器"><a href="#自定义验证器" class="headerlink" title="自定义验证器"></a><strong>自定义验证器</strong></h4><p>如果内建检验器不够用了，可以定义满足自己需要的验证器</p><p>自定义验证器通过传入一个验证函数来定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    phone:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        validate:&#123;</span><br><span class="line">            validator:<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="regexp">/\d&#123;3&#125;-d&#123;3&#125;-d&#123;4&#125;/</span>.test(v);</span><br><span class="line">            &#125;,</span><br><span class="line">            message:<span class="string">'&#123;VALUE&#125; is not a valid phone number!'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        required:[<span class="literal">true</span>,<span class="string">'User phone number required'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = db.model(<span class="string">'user'</span>,userSchema);</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="keyword">let</span> error;</span><br><span class="line"></span><br><span class="line">user.phone = <span class="string">'555.0123'</span>;</span><br><span class="line">error = user.validateSync();</span><br><span class="line">assert.equal(error.errors[<span class="string">'phone'</span>].message,<span class="string">'555.0123 is not a valid phone number!'</span>);</span><br><span class="line"></span><br><span class="line">user.phone = <span class="string">''</span>;</span><br><span class="line">rror = user.validateSync();</span><br><span class="line">assert.equal(error.errors[<span class="string">'phone'</span>].message,<span class="string">'User phonse number required!'</span>);</span><br><span class="line"></span><br><span class="line">user.phone = <span class="string">'201-555-0123'</span>;</span><br><span class="line">rror = user.validateSync();</span><br><span class="line">assert.equal(error,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h4 id="异步自定义验证器"><a href="#异步自定义验证器" class="headerlink" title="异步自定义验证器"></a><strong>异步自定义验证器</strong></h4><p>自定义验证器可以是异步的，如果检验函数返回 promise (像 <code>async</code>函数)，mongoose 将会等待该 promise 完成。如果更喜欢使用回调函数，设置 <code>isAsync</code>选项，mongoose 会将回调函数作为验证函数的第二个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">// 可以通过返回一个promise使验证器异步。如果返回一个promise，不要指定' isAsync '选项。</span></span><br><span class="line">        validate:<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                   resolve(<span class="literal">false</span>) </span><br><span class="line">                &#125;,<span class="number">5</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    phone:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        validate:&#123;</span><br><span class="line">            isAsync:<span class="literal">true</span>,</span><br><span class="line">            validator:<span class="function"><span class="keyword">function</span>(<span class="params">v,cb</span>)</span>&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                   <span class="keyword">const</span> phoneRegex = <span class="regexp">/\d&#123;3&#125;-d&#123;3&#125;-d&#123;4&#125;/</span>;</span><br><span class="line">                   <span class="keyword">const</span> msg = v + <span class="string">'is not a valid phone number!'</span>;</span><br><span class="line">                    <span class="comment">// 第一个参数是布尔值代表验证结果</span></span><br><span class="line">                    <span class="comment">// 第二个参数是报错信息</span></span><br><span class="line">                    cb(phoneRegex.test(v),msg);</span><br><span class="line">                &#125;,<span class="number">5</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 默认报错信息会被 cb 的第二个参数覆盖</span></span><br><span class="line">            message:<span class="string">'Default error message'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        required:[<span class="literal">true</span>,<span class="string">'User phone number required'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = db.model(<span class="string">'User'</span>,userSchema);</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="keyword">let</span> error;</span><br><span class="line">user.phone = <span class="string">'555.0123'</span>;</span><br><span class="line">user.name = <span class="string">'test'</span>;</span><br><span class="line">user.validate(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    assert.ok(error);</span><br><span class="line">assert.equal(error.errors[<span class="string">'phone'</span>].message,<span class="string">'555.0123 is not a valid phone number!'</span>);</span><br><span class="line">    assert.equal(error.errors[<span class="string">'name'</span>].message,<span class="string">'Validator failed for path `name` with value `test`'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="验证错误"><a href="#验证错误" class="headerlink" title="验证错误"></a><strong>验证错误</strong></h4><p>验证失败返回 的err 包含一个 <code>ValidatorError</code>对象。每一个 ValidatorError 都有 kind、path、value 和 message 属性。ValidatorError 也有可能有 reason 属性如果验证器抛出错误，这个属性会包含该错误原因。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toySchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    color:<span class="built_in">String</span>,</span><br><span class="line">    name:<span class="built_in">String</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> validator = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/red|white|gold/i</span>.test(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">toySchema.path(<span class="string">'color'</span>）.validate(validator,<span class="string">'Color `&#123;VALUE&#125;` not valid'</span>,<span class="string">'Invalid color'</span>);</span><br><span class="line">toySchema.path(<span class="string">'name'</span>).validate(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v !== <span class="string">'Turbo Man'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Need to get a Turbo Man for Christmas'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;,<span class="string">'Name `&#123;VALUE&#125;` is not valid'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Toy = db.model(<span class="string">'Toy'</span>,toySchema);</span><br><span class="line"><span class="keyword">const</span> toy = <span class="keyword">new</span> Toy(&#123;<span class="attr">color</span>:<span class="string">'Green'</span>,<span class="attr">name</span>:<span class="string">'Power Ranger'</span>&#125;);</span><br><span class="line">toy.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    assert.equal(err.errors.color.message, <span class="string">'Color `Green` not valid'</span>);</span><br><span class="line">    assert.equal(err.errors.color.kind, <span class="string">'Invalid color'</span>);</span><br><span class="line">    assert.equal(err.errors.color.path, <span class="string">'color'</span>);</span><br><span class="line">    assert.equal(err.errors.color.value, <span class="string">'Green'</span>);</span><br><span class="line">    assert.equal(err.errors.name.message,<span class="string">'Need to get a Turbo Man for Christmas'</span>);</span><br><span class="line">    assert.equal(err.errors.name.value, <span class="string">'Power Ranger'</span>);</span><br><span class="line">assert.equal(err.errors.name.reason.message,<span class="string">'Need to get a Turbo Man for Christmas'</span>);</span><br><span class="line">    assert.equal(err.name, <span class="string">'ValidationError'</span>);    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="嵌套对象中的-Required-验证器"><a href="#嵌套对象中的-Required-验证器" class="headerlink" title="嵌套对象中的 Required 验证器"></a><strong>嵌套对象中的 Required 验证器</strong></h4><p>定义嵌套对象的验证器需要特别注意</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        first:<span class="built_in">String</span>,</span><br><span class="line">        last:<span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">assert.throws(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 这里会报错，因为 name 不是完整路径</span></span><br><span class="line">    personSchema.path(<span class="string">'name'</span>).required(<span class="literal">true</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要让嵌套对象 required 要使用单独的嵌套 schema</span></span><br><span class="line"><span class="keyword">const</span> nameSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:nameSchema,</span><br><span class="line">        required:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">personSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:nameSchema,</span><br><span class="line">        required:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = db.model(<span class="string">'Person'</span>,personSchema);</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">const</span> error = person.validateSync();</span><br><span class="line">assert.ok(error.errors[<span class="string">'name'</span>]);</span><br></pre></td></tr></table></figure><h4 id="Update-验证器"><a href="#Update-验证器" class="headerlink" title="Update 验证器"></a><strong>Update 验证器</strong></h4><p>Mongoose 还支持验证 update() 和 findOneAndUpdate() 操作，Update 验证器默认关闭，如果需要打开，需要配置 runValidators</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toySchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">      color: <span class="built_in">String</span>,</span><br><span class="line">      name: <span class="built_in">String</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Toy = db.model(<span class="string">'Toys'</span>, toySchema);</span><br><span class="line"></span><br><span class="line">Toy.schema.path(<span class="string">'color'</span>).validate(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/blue|green|white|red|orange|periwinkle/i</span>.test(value);</span><br><span class="line">&#125;, <span class="string">'Invalid color'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> opts = &#123; <span class="attr">runValidators</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">Toy.update(&#123;&#125;, &#123; <span class="attr">color</span>: <span class="string">'bacon'</span> &#125;, opts, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  assert.equal(err.errors.color.message,<span class="string">'Invalid color'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Update-验证器-与-this"><a href="#Update-验证器-与-this" class="headerlink" title="Update 验证器 与 this"></a><strong>Update 验证器 与 <code>this</code></strong></h4><p>update 验证器和 document 验证器有很多不同。上面的颜色验证函数，this 指向验证中的 document，然后update 验证器运行时，被更新文档不一定存在于服务器内存，所以 this 值未定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toySchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  color: <span class="built_in">String</span>,</span><br><span class="line">  name: <span class="built_in">String</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">toySchema.path(<span class="string">'color'</span>).validate(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在运行“validate()”或“validateSync()”时</span></span><br><span class="line">  <span class="comment">// 验证器可以使用“this”访问文档。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.name.toLowerCase().indexOf(<span class="string">'red'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value !== <span class="string">'red'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Toy = db.model(<span class="string">'ActionFigure'</span>, toySchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toy = <span class="keyword">new</span> Toy(&#123; <span class="attr">color</span>: <span class="string">'red'</span>, <span class="attr">name</span>: <span class="string">'Red Power Ranger'</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> error = toy.validateSync();</span><br><span class="line">assert.ok(error.errors[<span class="string">'color'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> update = &#123; <span class="attr">color</span>: <span class="string">'red'</span>, <span class="attr">name</span>: <span class="string">'Red Power Ranger'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> opts = &#123; <span class="attr">runValidators</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">Toy.update(&#123;&#125;, update, opts, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// The update validator throws an error:</span></span><br><span class="line">  <span class="comment">// "TypeError: Cannot read property 'toLowerCase' of undefined",</span></span><br><span class="line">  <span class="comment">// because `this` is **not** the document being updated when using</span></span><br><span class="line">  <span class="comment">// update validators</span></span><br><span class="line">  assert.ok(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="context选项"><a href="#context选项" class="headerlink" title="context选项"></a><strong><code>context</code>选项</strong></h4><p>context 选项运行把 update 验证器的 this 设定为 query</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">toySchema.path(<span class="string">'color'</span>).validate(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// When running update validators with the `context` option set to</span></span><br><span class="line">    <span class="comment">// 'query', `this` refers to the query object.</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.getUpdate().$set.name.toLowerCase().indexOf(<span class="string">'red'</span>) !== <span class="number">-1</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> value == <span class="string">'red'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Toy = db.model(<span class="string">'Figure'</span>,toySchema);</span><br><span class="line"><span class="keyword">const</span> update = &#123;<span class="attr">color</span>:<span class="string">'blue'</span>,<span class="attr">name</span>:<span class="string">'haha'</span>&#125;</span><br><span class="line"><span class="comment">// Note the context option</span></span><br><span class="line"><span class="keyword">const</span> opts = &#123;<span class="attr">runValidators</span>:<span class="literal">true</span>,<span class="attr">context</span>:<span class="string">'query'</span>&#125;</span><br><span class="line">Toy.update(&#123;&#125;,update,opts,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    assert.ok(error.errors[<span class="string">'color'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Update-验证器字段路径"><a href="#Update-验证器字段路径" class="headerlink" title="Update 验证器字段路径"></a><strong>Update 验证器字段路径</strong></h4><p>另一个关键不同点是 update 验证器只运行于更新的字段。 下例中，因为 ‘name’ 在更新操作未被指定，所以此次更新操作成功。</p><p>使用 update 验证器的时候， <code>required</code> 验证器<strong>只会</strong>在你对某个字段显式使用 <code>$unset</code> 才会触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> kittenSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  name: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  age: <span class="built_in">Number</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Kitten = db.model(<span class="string">'Kitten'</span>, kittenSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> update = &#123; <span class="attr">color</span>: <span class="string">'blue'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> opts = &#123; <span class="attr">runValidators</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">Kitten.update(&#123;&#125;, update, opts, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 即使 'name' 没有指定也操作成功了</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unset = &#123; <span class="attr">$unset</span>: &#123; <span class="attr">name</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line">Kitten.update(&#123;&#125;, unset, opts, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 'name' required， 操作失败</span></span><br><span class="line">  assert.ok(err);</span><br><span class="line">  assert.ok(err.errors[<span class="string">'name'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Update-验证器只运行于指定字段路径"><a href="#Update-验证器只运行于指定字段路径" class="headerlink" title="Update 验证器只运行于指定字段路径"></a><strong>Update 验证器只运行于指定字段路径</strong></h4><p>最后要注意的是：update 验证器<strong>只</strong>运行于下列更新操作：</p><ul><li><code>$set</code></li><li><code>$unset</code></li><li><code>$push</code> (&gt;= 4.8.0)</li><li><code>$addToSet</code> (&gt;= 4.8.0)</li><li><code>$pull</code> (&gt;= 4.12.0)</li><li><code>$pullAll</code> (&gt;= 4.12.0)</li></ul><p>例如，以下 update 成功执行，不管 <code>number</code> 的值，因为 update 验证器 无视 <code>$inc</code> 。同样， <code>$push</code>、<code>$addToSet</code>、 <code>$pull</code>和 <code>$pullAll</code> 验证器 不会对数组自身验证，只会对数组中的元素验证。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  number: &#123; <span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">max</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  arr: [&#123; <span class="attr">message</span>: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">maxlength</span>: <span class="number">10</span> &#125; &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update 验证器不会作检查，所以你再仍然可以 `$push` 两个元素到数组 </span></span><br><span class="line"><span class="comment">// 只要他们的 `message` 没有超长</span></span><br><span class="line">testSchema.path(<span class="string">'arr'</span>).validate(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v.length &lt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Test = db.model(<span class="string">'Test'</span>, testSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> update = &#123; <span class="attr">$inc</span>: &#123; <span class="attr">number</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> opts = &#123; <span class="attr">runValidators</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">Test.update(&#123;&#125;, update, opts, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里不会报错</span></span><br><span class="line">  update = &#123; <span class="attr">$push</span>: [&#123; <span class="attr">message</span>: <span class="string">'hello'</span> &#125;, &#123; <span class="attr">message</span>: <span class="string">'world'</span> &#125;] &#125;;</span><br><span class="line">  Test.update(&#123;&#125;, update, opts, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里也不会报错</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="push-和-addToSet"><a href="#push-和-addToSet" class="headerlink" title="\$push 和 \$addToSet"></a><strong>\$push 和 \$addToSet</strong></h4><p>4.8.0 新特性： update 验证器也运行于 <code>$push</code> 和 <code>$addToSet</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  numbers: [&#123; <span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">max</span>: <span class="number">0</span> &#125;],</span><br><span class="line">  docs: [&#123;</span><br><span class="line">    name: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Test = db.model(<span class="string">'TestPush'</span>, testSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> update = &#123;</span><br><span class="line">  $push: &#123;</span><br><span class="line">    numbers: <span class="number">1</span>,</span><br><span class="line">    docs: &#123; <span class="attr">name</span>: <span class="literal">null</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> opts = &#123; <span class="attr">runValidators</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">Test.update(&#123;&#125;, update, opts, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  assert.ok(error.errors[<span class="string">'numbers'</span>]);</span><br><span class="line">  assert.ok(error.errors[<span class="string">'docs'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="中间件（middleware）"><a href="#中间件（middleware）" class="headerlink" title="中间件（middleware）"></a>中间件（middleware）</h3><p>中间件（pre 和 post）是在异步函数执行时函数传入的控制函数。中间件在 Schema 上指定，在写插件时很有用。Mongoose 4.x 有四种中间件：document、model、aggregate、query 中间件。对于 document 中间件，this 指向当前的 document，Document 中间件支持下面的 document 操作：</p><ul><li>init</li><li>validate</li><li>save</li><li>remove</li></ul><p>对于 query中间件，this 指向 query。Query 中间件支持一下 Model 和 Query 操作：</p><ul><li>count</li><li>find</li><li>findOne</li><li>findOneAndRemove</li><li>findOneAndUpdate</li><li>update</li></ul><p>Aggregate 中间件作用于 MyModel.aggregat(),它会在对 aggregate 对象调用 exec() 时执行。对于 aggregate 中间件，this 也是指向 aggregation 对象。</p><ul><li>aggregate</li></ul><p>对于 model 中间件来说，this 是指向当前的model.Model 中间件支持下面的操作：</p><ul><li>insertMany</li></ul><p>所有的中间件支持 pre 和 post 钩子，下面解释这两个钩子的细节。</p><p>注意：Query 是没有 remove 钩子的，只有 document有，如果设定了 remove 钩子，将会在调用 myDoc.remove()而不是MyModel.remove 的时候触发。只有 create() 函数会触发 save() 钩子。</p><h4 id="Pre"><a href="#Pre" class="headerlink" title="Pre"></a><strong>Pre</strong></h4><p>pre 钩子分为串行和并行两种。</p><p><strong>串行</strong></p><p>串行中间件一个接一个地执行，具体来说，上一个中间件调用 next 函数的时候，下一个执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;);</span><br><span class="line"></span><br><span class="line">schema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 5.x 版本中，除了手动调用 next ，可以返回一个 promise ，甚至是 async/await。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">schema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doStuff().then(<span class="function"><span class="params">()</span>=&gt;</span>doMoreStuff())</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 或者 Node.js &gt;= 7.6.0:</span></span><br><span class="line">schema.pre(<span class="string">'save'</span>,<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> doStuff();</span><br><span class="line">    <span class="keyword">await</span> doMoreStuff();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>next() 不会阻止剩余代码的运行，可以使用提前 return 模式来阻止 next () 后面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;);</span><br><span class="line">schema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(foo())&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'calling next'</span>);</span><br><span class="line">       <span class="comment">// `return next();` will make sure the rest of this function doesn't run</span></span><br><span class="line">       next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Unless you comment out the `return` above, 'after next' will print</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'after next'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>并行</strong></p><p>并行中间件提供细粒度流控制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;);</span><br><span class="line"><span class="comment">// true 代表这是一个并行中间件，如果要使用并行中间件，必须指定 true 为第二个参数</span></span><br><span class="line">schema.pre(<span class="string">'save'</span>,<span class="literal">true</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next,done</span>)</span>&#123;</span><br><span class="line">    next();</span><br><span class="line">    setTimeout(done,<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述的例子中，save 方法将在所有中间件都调用了 done 的时候才会执行。</p><p>使用场景：</p><p>中间件对原子化模型逻辑很有帮助，这里有一些其他建议：</p><ul><li>复杂的数据校验</li><li>删除依赖文档（删除用户后删除其他所有文章）</li><li>某个操作触发的异步任务</li></ul><p>错误处理：</p><p>如果 pre 钩子出错，momgoose 将不会执行后面的函数。Mongoose 会向回调函数传入 err 参数，或者 reject 返回的 promise 。下面是几个错误的处理的方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">schema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'something went gone'</span>);</span><br><span class="line">    next(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">schema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'something went gone'</span>))</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">schema.pre(<span class="string">'save'</span>,<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'something went gone'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myDoc.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>多次调用 next 是无效的，如果调用 next 带有错误参数 err1 ，然后再抛出一个 err2，mongoose 只会传递 err1</p><h4 id="Post中间件"><a href="#Post中间件" class="headerlink" title="Post中间件"></a><strong>Post中间件</strong></h4><p>post 中间件在方法执行之后调用，这个时候每个 pre 中间件都已经完成了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">schema.post(<span class="string">'init'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'%s has been initialized from the db'</span>, doc._id);</span><br><span class="line">&#125;);</span><br><span class="line">schema.post(<span class="string">'validate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'%s has been validated (but not saved yet)'</span>, doc._id);</span><br><span class="line">&#125;);</span><br><span class="line">schema.post(<span class="string">'save'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'%s has been saved'</span>, doc._id);</span><br><span class="line">&#125;);</span><br><span class="line">schema.post(<span class="string">'remove'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'%s has been removed'</span>, doc._id);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="异步-Post-钩子"><a href="#异步-Post-钩子" class="headerlink" title="异步 Post 钩子"></a><strong>异步 Post 钩子</strong></h4><p>如果给回调函数传入两个参数，mongoose 会认为第二个参数 next 函数，可以通过 next 触发下一个中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">schema.post(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">doc,next</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'post1'</span>);</span><br><span class="line">        next();</span><br><span class="line">    &#125;,<span class="number">10</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 直到第一个中间件执行 next() 才会执行</span></span><br><span class="line">schema.post(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">doc,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'post2'</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Save-Validate钩子"><a href="#Save-Validate钩子" class="headerlink" title="Save/Validate钩子"></a><strong>Save/Validate钩子</strong></h4><p>save() 函数触发 validate 钩子，mongoose validate() 其实就是 pre(‘save’)钩子，这意味着所有 pre(‘validate’) 和 post(‘validate’)都会在 pre(‘save’)钩子之前调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">schema.pre(<span class="string">'validate'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this gets printed first'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">schema.post(<span class="string">'validate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this gets printed second'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">schema.pre(<span class="string">'save'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this gets printed third'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">schema.post(<span class="string">'save'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this gets printed fourth'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="finAndUpdate-与-Query-中间件使用注意"><a href="#finAndUpdate-与-Query-中间件使用注意" class="headerlink" title="finAndUpdate() 与 Query 中间件使用注意"></a><strong>finAndUpdate() 与 Query 中间件使用注意</strong></h4><p>pre 和 post save() 钩子都不执行于 update ,findOneAndUpdate 等情况。Mongoose4.0 为这些函数制定了新钩子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">schema.pre(<span class="string">'find'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> <span class="keyword">instanceof</span> mongoose.Query); <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">this</span>.start = <span class="built_in">Date</span>.now()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">schema.post(<span class="string">'find'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span> <span class="keyword">instanceof</span> mongoose.Query); <span class="comment">// true</span></span><br><span class="line">  <span class="comment">// prints returned documents</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'find() returned '</span> + <span class="built_in">JSON</span>.stringify(result));</span><br><span class="line">  <span class="comment">// prints number of milliseconds the query took</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'find() took '</span> + (<span class="built_in">Date</span>.now() - <span class="keyword">this</span>.start) + <span class="string">' millis'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Query 中间件不同于 document 中间件，document 中间件中，this 指向被更新 document,query 中间件中，this 指向query 对象而不是被更新 document</p><p>例如，如果要每次 update 之前更新 updateAt 时间戳，可以使用 pre 钩子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">schema.pre(<span class="string">'update'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.update(&#123;&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="attr">updateAt</span>:<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a><strong>错误处理中间件</strong></h4><p>错误处理中间件比普通中间件多一个 <code>error</code> 参数，并且 <code>err</code> 作为第一个参数传入。 而后错误处理中间件可以让你自由地做错误的后续处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">// // Will trigger a MongoError with code 11000 when you save a duplicate</span></span><br><span class="line">        unique:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理函数必须传入3个参数：发生的错误，返回文件，以及 next 函数</span></span><br><span class="line">schema.post(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error,doc,next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(error.name === <span class="string">'MongoError'</span> &amp;&amp; error.code === <span class="number">11000</span>)&#123;</span><br><span class="line">        next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'There was a duplicate key error'</span>))</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Will trigger the `post('save')` error handler</span></span><br><span class="line">Person.create([&#123;<span class="attr">name</span>:<span class="string">'Axl Rose'</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'Axl Rose'</span>&#125;]);</span><br></pre></td></tr></table></figure><p>对于query 中间件也可以使用错误处理，可以定义一个 post update 钩子，它可以捕获 MongoDB 重复 key 错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">schema.post(<span class="string">'update'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(error.name === <span class="string">'MongoError'</span> &amp;&amp; error.code === <span class="number">11000</span>)&#123;</span><br><span class="line">        next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'There was a duplicate key error'</span>))</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> people = [&#123;<span class="attr">name</span>:<span class="string">'Axl Rose'</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'Axl Rose'</span>&#125;];</span><br><span class="line">Person.create(people,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    Person.update(&#123;<span class="attr">name</span>:<span class="string">'haha'</span>&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="attr">name</span>:<span class="string">'Axl Rose'</span>&#125;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// error.message` will be "There was a duplicate key error"</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="填充（Populate）"><a href="#填充（Populate）" class="headerlink" title="填充（Populate）"></a>填充（Populate）</h3><p>像sql 里面的 join 的聚合操作，populate 可以让你在别的 collection 中引用 document</p><p>Population 可以自动替换 document 中的指定字段，替换内容从其他 collection 获取。我们可以填充单个或者每个 document、单个或者多个纯对象，甚至是 query 返回的一切对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema;</span><br><span class="line"><span class="keyword">const</span> personSchema = Schema(&#123;</span><br><span class="line">    _id:Schema.Types.ObjectId,</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    age:<span class="built_in">Number</span>,</span><br><span class="line">    stories:[&#123;<span class="attr">type</span>:Schema.Types.ObjectId,<span class="attr">ref</span>:<span class="string">'Story'</span>&#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storySchema = Schema(&#123;</span><br><span class="line">    author:&#123;</span><br><span class="line">        type:Schema.Types.ObjectId,</span><br><span class="line">        ref:<span class="string">'Person'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    title:<span class="built_in">String</span>,</span><br><span class="line">    fans:[&#123;</span><br><span class="line">        type:Schema.Types.ObjectId,</span><br><span class="line">        ref:<span class="string">'Person'</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Story = mongoose.model(<span class="string">'Story'</span>,storySchema);</span><br><span class="line"><span class="keyword">const</span> Person = mongoose.model(<span class="string">'Person'</span>,personSchema);</span><br></pre></td></tr></table></figure><p>上面创建了两个 Model，Person model 的 stories 字段设为 ObjectId 数组。ref 选项告诉 Mongoose 在填充的时候使用哪个 model，上例中为 Story 的 model.所有存储在此的 _id 必须是 Story model 中的 document 的 _id。</p><p>注意：ObjectId、Number、String 以及 Buffer 都可以作为 refs 使用。但是最好还是用 ObjectId</p><h4 id="保存-refs"><a href="#保存-refs" class="headerlink" title="保存 refs"></a><strong>保存 refs</strong></h4><p>保存 refs 与保存普通属性一样，把 _id 的值赋给它就好了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> author = <span class="keyword">new</span> Person(&#123;</span><br><span class="line">  _id: <span class="keyword">new</span> mongoose.Types.ObjectId(),</span><br><span class="line">  name: <span class="string">'Ian Fleming'</span>,</span><br><span class="line">  age: <span class="number">50</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">author.save(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> story1 = <span class="keyword">new</span> Story(&#123;</span><br><span class="line">    title: <span class="string">'Casino Royale'</span>,</span><br><span class="line">    author: author._id    <span class="comment">// assign the _id from the person</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  story1.save(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="comment">// thats it!</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Population"><a href="#Population" class="headerlink" title="Population"></a><strong>Population</strong></h4><p>我们做的东西还是跟平时差不多，只是创建了 <code>Person</code> 和 <code>Story</code>。现在试试对query 填充 story 的 author。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Story.findOne(&#123;</span><br><span class="line">    title:<span class="string">'haha'</span></span><br><span class="line">&#125;).population(<span class="string">'author'</span>).exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,story</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The author is %s'</span>, story.author.name);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>被填充的字段已经不再是原来的 _id，而是被指定的 document 替代，这个 document 由另一条 query 从数据库返回。refs 数组的原理也是相似的。对 query 对象调用 populate 方法，就能返回装载对应 _id 的 document 数组。</p><h4 id="设置被填充字段"><a href="#设置被填充字段" class="headerlink" title="设置被填充字段"></a><strong>设置被填充字段</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Story.findOne(&#123; <span class="attr">title</span>: <span class="string">'Casino Royale'</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error, story</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="keyword">return</span> handleError(error);</span><br><span class="line">  &#125;</span><br><span class="line">  story.author = author;</span><br><span class="line">  <span class="built_in">console</span>.log(story.author.name); <span class="comment">// prints "Ian Fleming"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="字段选择"><a href="#字段选择" class="headerlink" title="字段选择"></a><strong>字段选择</strong></h4><p>如果我们只需要填充 document 其中一部分字段，第二个参数传入 field name syntax 就可以实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Story.</span><br><span class="line">findOne(&#123;<span class="attr">title</span>:<span class="regexp">/casino royale/i</span>&#125;).</span><br><span class="line">populate(<span class="string">'author'</span>,<span class="string">'name'</span>).<span class="comment">// only return the Persons name</span></span><br><span class="line">exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,story</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'The author is %s'</span>, story.author.name); <span class="comment">// The author is Ian Fleming</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'The author is %s'</span>, story.author.age); <span class="comment">// The authors age is null</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="填充多个字段"><a href="#填充多个字段" class="headerlink" title="填充多个字段"></a><strong>填充多个字段</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Story.</span><br><span class="line">  find(...).</span><br><span class="line">  populate(<span class="string">'fans'</span>).</span><br><span class="line">  populate(<span class="string">'author'</span>).</span><br><span class="line">  exec();</span><br></pre></td></tr></table></figure><p>如果对同一路径 populate 两次，只有最后一次生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个会覆盖第一个的</span></span><br><span class="line">Story.</span><br><span class="line">  find().</span><br><span class="line">  populate(&#123; <span class="attr">path</span>: <span class="string">'fans'</span>, <span class="attr">select</span>: <span class="string">'name'</span> &#125;).</span><br><span class="line">  populate(&#123; <span class="attr">path</span>: <span class="string">'fans'</span>, <span class="attr">select</span>: <span class="string">'email'</span> &#125;);</span><br><span class="line"><span class="comment">// The above is equivalent to:</span></span><br><span class="line">Story.find().populate(&#123; <span class="attr">path</span>: <span class="string">'fans'</span>, <span class="attr">select</span>: <span class="string">'email'</span> &#125;);</span><br></pre></td></tr></table></figure><h4 id="Query-条件与其他选项"><a href="#Query-条件与其他选项" class="headerlink" title="Query 条件与其他选项"></a><strong>Query 条件与其他选项</strong></h4><p>如果要根据年龄来填充，只填充 name,并且值返回最多5个数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Story.</span><br><span class="line">  find(...).</span><br><span class="line">  populate(&#123;</span><br><span class="line">    path: <span class="string">'fans'</span>,</span><br><span class="line">    match: &#123; <span class="attr">age</span>: &#123; <span class="attr">$gte</span>: <span class="number">21</span> &#125;&#125;,</span><br><span class="line">    <span class="comment">// Explicitly exclude `_id`, see http://bit.ly/2aEfTdB</span></span><br><span class="line">    select: <span class="string">'name -_id'</span>,</span><br><span class="line">    options: &#123; <span class="attr">limit</span>: <span class="number">5</span> &#125;</span><br><span class="line">  &#125;).</span><br><span class="line">  exec();</span><br></pre></td></tr></table></figure><h4 id="Refs-到-children"><a href="#Refs-到-children" class="headerlink" title="Refs 到 children"></a><strong>Refs 到 children</strong></h4><p>我们发现，用 author 对象没有办法获取 story 列表，因为 author.stories 没有被 pushed 任何 story 对象</p><p>我们希望 author 知道哪些 story 属于他们，通常，schema 应该通过在 多 的一方使用指向它们的父节点（parent pointer）解决一对多关系问题。另一方面，如果有充分理由得到指向子节点的数组，可以像下面代码一样把 document push() 到数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">author.stories.push(story1);</span><br><span class="line">author.save(callback);</span><br></pre></td></tr></table></figure><p>然后我们就能 find 和 populate 了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person.findOne(&#123;<span class="attr">name</span>:<span class="string">'Ian Fleming'</span>&#125;).</span><br><span class="line">populate(<span class="string">'stories'</span>).</span><br><span class="line">exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,person</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(person);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果父子节点互相指向，数据可能会在某一时刻失去同步。为此我们可以不使用填充，直接 <code>find()</code>我们需要的 story</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Story.find(&#123;<span class="attr">author</span>:author._id&#125;).</span><br><span class="line">exec(<span class="function"><span class="keyword">function</span>(<span class="params">err, stories</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The stories are an array: '</span>, stories);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>query 填充后返回的 document 功能齐全，除非设置 lean 选项，否则它就是可 remove，可 save 的。调用 remove 不单是从数组中删除也是从数据库中删除它们。</p><h4 id="填充现有-document"><a href="#填充现有-document" class="headerlink" title="填充现有 document"></a><strong>填充现有 document</strong></h4><p>document#populate()</p><h4 id="填充多个现有-document"><a href="#填充多个现有-document" class="headerlink" title="填充多个现有 document"></a><strong>填充多个现有 document</strong></h4><p>如果需要填充一个或者多个 document 对象，我们可以使用 Model.populate 方法。</p><h4 id="多级填充"><a href="#多级填充" class="headerlink" title="多级填充"></a><strong>多级填充</strong></h4><p>假设 user schema 记录了 user 的 friends</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    friends:[&#123;</span><br><span class="line">        type:ObjectId,</span><br><span class="line">        ref:<span class="string">'User'</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然可以填充得到用户的 friends 列表，但是如果要在获得他们朋友的朋友呢？指定 <code>populate</code>选项就可以了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User.findOne(&#123;<span class="attr">name</span>:<span class="string">'Val'</span>&#125;).</span><br><span class="line">populate(&#123;</span><br><span class="line">    path:<span class="string">'friends'</span>,</span><br><span class="line">    populate:&#123;</span><br><span class="line">        path:<span class="string">'friends'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="跨数据库填充"><a href="#跨数据库填充" class="headerlink" title="跨数据库填充"></a><strong>跨数据库填充</strong></h4><p>假设现在有 event schema 和 conversation schema,每个 event 对应一个 conversation 线程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    conversation:ObjectId</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> conversationSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    numMessage:<span class="built_in">Number</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>并且，event 和 conversation 保存在不同的 MongoDB 实例中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db1 = mongoose.createConnection(<span class="string">'localhost:27000/db1'</span>);</span><br><span class="line"><span class="keyword">const</span> db2 = mongoose.createConnection(<span class="string">'localhost:27001/db2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Event = db1.model(<span class="string">'Event'</span>, eventSchema);</span><br><span class="line"><span class="keyword">const</span> Conversation = db2.model(<span class="string">'Conversation'</span>, conversationSchema);</span><br></pre></td></tr></table></figure><p>这个情况就<strong>不能</strong>直接使用 <code>populate()</code> 了，因为 <code>populate()</code> 不知道应该使用什么填充。 可以显式指定一个 model</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Event.find().population(&#123;<span class="attr">path</span>:<span class="string">'conversation'</span>,<span class="attr">model</span>:Conversation&#125;).</span><br><span class="line">exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,docs</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure><h4 id="动态引用"><a href="#动态引用" class="headerlink" title="动态引用"></a><strong>动态引用</strong></h4><p>Mongoose 也可以从多个 collection 填充。假设 user schema 有一系列 connection，一个 user 可以连接到其他 user 或者组织。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    connection:[&#123;</span><br><span class="line">        kind:<span class="built_in">String</span>,</span><br><span class="line">        item:&#123;</span><br><span class="line">            type:ObjectId,</span><br><span class="line">            refPath:<span class="string">'connections.kind'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> organizationSchema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>,<span class="attr">kind</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = mongoose.model(<span class="string">'User,userSchema'</span>);</span><br><span class="line"><span class="keyword">const</span> Organization = mongoose.model(<span class="string">'Organization'</span>,organizationSchema);</span><br></pre></td></tr></table></figure><p>上面的 <code>refPath</code> 属性意味着 mongoose 会查找 <code>connections.kind</code> 路径， 以此确定 <code>populate()</code> 使用的 model。换句话说，<code>refPath</code> 属性可以让你动态寻找 <code>ref</code>。</p><h3 id="鉴别器（Discriminators）"><a href="#鉴别器（Discriminators）" class="headerlink" title="鉴别器（Discriminators）"></a>鉴别器（Discriminators）</h3><p>Discriminator 是一种 schema 继承机制。它允许在相同的底层 MongoDB  collection 上使用部分重叠的 schema 建立多个 model。</p><p>假设要在单个 collection 中记录多种 event ，每个 event 都有时间戳字段，但是 click 事件还有 URL 字段，可以用 model.discriminator 实现上面的要求。这个函数需要两个参数，model 名称和 discriminator  schema,返回 model 结合原 model 的 schema 和 discriminator schema.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123; <span class="attr">discriminatorKey</span>:<span class="string">'kind'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> eventSchema = <span class="keyword">new</span> mongoose.Schema(&#123;<span class="attr">tiem</span>:<span class="built_in">Date</span>&#125;,options);</span><br><span class="line"><span class="keyword">const</span> Event = mongoose.model(<span class="string">'Event'</span>.eventSchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClickedLinkEvent 是一个有 URL 的特别 event</span></span><br><span class="line"><span class="keyword">const</span> ClickedLinkEvent = Event.discriminator(<span class="string">'ClickedLink'</span>,</span><br><span class="line">  <span class="keyword">new</span> mongoose.Schema(&#123;<span class="attr">url</span>: <span class="built_in">String</span>&#125;, options));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当你创建通用 event，他将没有 URL 字段...</span></span><br><span class="line"><span class="keyword">const</span> genericEvent = <span class="keyword">new</span> Event(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">url</span>: <span class="string">'google.com'</span>&#125;);</span><br><span class="line">assert.ok(!genericEvent.url);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是 ClickedLinkEvent 可以有</span></span><br><span class="line"><span class="keyword">const</span> clickedEvent =</span><br><span class="line">  <span class="keyword">new</span> ClickedLinkEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">url</span>: <span class="string">'google.com'</span>&#125;);</span><br><span class="line">assert.ok(clickedEvent.url);</span><br></pre></td></tr></table></figure><h4 id="Discriminator-储存在-Event-model-的-collection"><a href="#Discriminator-储存在-Event-model-的-collection" class="headerlink" title="Discriminator 储存在 Event model 的 collection"></a><strong>Discriminator 储存在 Event model 的 collection</strong></h4><p>现在假设你要创建另一个 discriminator，记录用户注册 event。 <code>SignedUpEvent</code> 实例将跟 通用 events 和 <code>ClickedLinkEvent</code> 实例 一样储存在同一个 collection。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event1 = <span class="keyword">new</span> Event(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now()&#125;);</span><br><span class="line"><span class="keyword">const</span> event2 = <span class="keyword">new</span> ClickedLinkEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">url</span>: <span class="string">'google.com'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> event3 = <span class="keyword">new</span> SignedUpEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">user</span>: <span class="string">'testuser'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> save = <span class="function"><span class="keyword">function</span> (<span class="params">doc, callback</span>) </span>&#123;</span><br><span class="line">  doc.save(<span class="function"><span class="keyword">function</span> (<span class="params">error, doc</span>) </span>&#123;</span><br><span class="line">    callback(error, doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>.map([event1, event2, event3], save, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  Event.count(&#123;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error, count</span>) </span>&#123;</span><br><span class="line">    assert.equal(count, <span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Discriminator-keys"><a href="#Discriminator-keys" class="headerlink" title="Discriminator keys"></a><strong>Discriminator keys</strong></h4><p>Mongoose 通过 ‘discriminator key’ 识别两个不同的 discriminator， 这个值默认是 <code>__t</code> 。Mongoose 自动在你的 schema 添加 <code>__t</code> 字段， 记录你的 document 是哪个 discriminator 的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event1 = <span class="keyword">new</span> Event(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now()&#125;);</span><br><span class="line"><span class="keyword">const</span> event2 = <span class="keyword">new</span> ClickedLinkEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">url</span>: <span class="string">'google.com'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> event3 = <span class="keyword">new</span> SignedUpEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">user</span>: <span class="string">'testuser'</span>&#125;);</span><br><span class="line"></span><br><span class="line">assert.ok(!event1.__t);</span><br><span class="line">assert.equal(event2.__t, <span class="string">'ClickedLink'</span>);</span><br><span class="line">assert.equal(event3.__t, <span class="string">'SignedUp'</span>);</span><br></pre></td></tr></table></figure><h4 id="Discriminator-在查询中添加-discriminator-key"><a href="#Discriminator-在查询中添加-discriminator-key" class="headerlink" title="Discriminator 在查询中添加 discriminator key"></a><strong>Discriminator 在查询中添加 discriminator key</strong></h4><p>Discriminator model 的特别之处在于：他们会把 discriminator key 附到 query 上。换句话说，<code>find()</code>, <code>count()</code>, <code>aggregate()</code> 等方法 都能适配 discriminators。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event1 = <span class="keyword">new</span> Event(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now()&#125;);</span><br><span class="line"><span class="keyword">const</span> event2 = <span class="keyword">new</span> ClickedLinkEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">url</span>: <span class="string">'google.com'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> event3 = <span class="keyword">new</span> SignedUpEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">user</span>: <span class="string">'testuser'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> save = <span class="function"><span class="keyword">function</span> (<span class="params">doc, callback</span>) </span>&#123;</span><br><span class="line">  doc.save(<span class="function"><span class="keyword">function</span> (<span class="params">error, doc</span>) </span>&#123;</span><br><span class="line">    callback(error, doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>.map([event1, event2, event3], save, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  ClickedLinkEvent.find(&#123;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error, docs</span>) </span>&#123;</span><br><span class="line">    assert.equal(docs.length, <span class="number">1</span>);</span><br><span class="line">    assert.equal(docs[<span class="number">0</span>]._id.toString(), event2._id.toString());</span><br><span class="line">    assert.equal(docs[<span class="number">0</span>].url, <span class="string">'google.com'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Discriminator-复制-pre-post-钩子"><a href="#Discriminator-复制-pre-post-钩子" class="headerlink" title="Discriminator 复制 pre / post 钩子"></a><strong>Discriminator 复制 pre / post 钩子</strong></h4><p>Discriminator 会继承他的基础 schema 的 pre 和 post 中间件。 不过，你也可以为 discriminator 添加中间件，这不回影响到基础 schema。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;<span class="attr">discriminatorKey</span>: <span class="string">'kind'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventSchema = <span class="keyword">new</span> mongoose.Schema(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>&#125;, options);</span><br><span class="line"><span class="keyword">const</span> eventSchemaCalls = <span class="number">0</span>;</span><br><span class="line">eventSchema.pre(<span class="string">'validate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">  ++eventSchemaCalls;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> Event = mongoose.model(<span class="string">'GenericEvent'</span>, eventSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clickedLinkSchema = <span class="keyword">new</span> mongoose.Schema(&#123;<span class="attr">url</span>: <span class="built_in">String</span>&#125;, options);</span><br><span class="line"><span class="keyword">const</span> clickedSchemaCalls = <span class="number">0</span>;</span><br><span class="line">clickedLinkSchema.pre(<span class="string">'validate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">  ++clickedSchemaCalls;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> ClickedLinkEvent = Event.discriminator(<span class="string">'ClickedLinkEvent'</span>,</span><br><span class="line">  clickedLinkSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event1 = <span class="keyword">new</span> ClickedLinkEvent();</span><br><span class="line">event1.validate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  assert.equal(eventSchemaCalls, <span class="number">1</span>);</span><br><span class="line">  assert.equal(clickedSchemaCalls, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> generic = <span class="keyword">new</span> Event();</span><br><span class="line">  generic.validate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    assert.equal(eventSchemaCalls, <span class="number">2</span>);</span><br><span class="line">    assert.equal(clickedSchemaCalls, <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="处理自定义-id-字段"><a href="#处理自定义-id-字段" class="headerlink" title="处理自定义 _id 字段"></a><strong>处理自定义 _id 字段</strong></h4><p>Discriminator 的字段是基础 schema 加 discriminator schema ， 并且以 discriminator schema 的字段优先。 但有一个例外，<code>_id</code> 字段。</p><p>You can work around this by setting the <code>_id</code> option to false in the discriminator schema as shown below.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;<span class="attr">discriminatorKey</span>: <span class="string">'kind'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础 schema 有字符串格式的 `_id` 字段和 Data 格式的 `time` 字段...</span></span><br><span class="line"><span class="keyword">const</span> eventSchema = <span class="keyword">new</span> mongoose.Schema(&#123;<span class="attr">_id</span>: <span class="built_in">String</span>, <span class="attr">time</span>: <span class="built_in">Date</span>&#125;,</span><br><span class="line">  options);</span><br><span class="line"><span class="keyword">const</span> Event = mongoose.model(<span class="string">'BaseEvent'</span>, eventSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clickedLinkSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  url: <span class="built_in">String</span>,</span><br><span class="line">  time: <span class="built_in">String</span></span><br><span class="line">&#125;, options);</span><br><span class="line"><span class="comment">// 但是 Discriminator schema 有字符串格式的 `time`，并且有</span></span><br><span class="line"><span class="comment">// 隐式添加的 ObjectId 格式的 `_id`</span></span><br><span class="line">assert.ok(clickedLinkSchema.path(<span class="string">'_id'</span>));</span><br><span class="line">assert.equal(clickedLinkSchema.path(<span class="string">'_id'</span>).instance, <span class="string">'ObjectID'</span>);</span><br><span class="line"><span class="keyword">const</span> ClickedLinkEvent = Event.discriminator(<span class="string">'ChildEventBad'</span>,</span><br><span class="line">  clickedLinkSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event1 = <span class="keyword">new</span> ClickedLinkEvent(&#123; <span class="attr">_id</span>: <span class="string">'custom id'</span>, <span class="attr">time</span>: <span class="string">'4pm'</span> &#125;);</span><br><span class="line"><span class="comment">// 问题来了，clickedLinkSchema 重写了 `time` 路径，但是**没有**</span></span><br><span class="line"><span class="comment">// 重写 `_id` 路径，因为已经隐式添加（没看懂）</span></span><br><span class="line">assert.ok(<span class="keyword">typeof</span> event1._id === <span class="string">'string'</span>);</span><br><span class="line">assert.ok(<span class="keyword">typeof</span> event1.time === <span class="string">'string'</span>);</span><br></pre></td></tr></table></figure><h4 id="discriminator-与-Model-create"><a href="#discriminator-与-Model-create" class="headerlink" title="discriminator 与 Model.create()"></a><strong>discriminator 与 <code>Model.create()</code></strong></h4><p>当你使用 <code>Model.create()</code>，Mongoose 会自动帮你适配 discriminator key ~</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema;</span><br><span class="line"><span class="keyword">const</span> shapeSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  name: <span class="built_in">String</span></span><br><span class="line">&#125;, &#123; <span class="attr">discriminatorKey</span>: <span class="string">'kind'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Shape = db.model(<span class="string">'Shape'</span>, shapeSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Circle = Shape.discriminator(<span class="string">'Circle'</span>,</span><br><span class="line">  <span class="keyword">new</span> Schema(&#123; <span class="attr">radius</span>: <span class="built_in">Number</span> &#125;));</span><br><span class="line"><span class="keyword">const</span> Square = Shape.discriminator(<span class="string">'Square'</span>,</span><br><span class="line">  <span class="keyword">new</span> Schema(&#123; <span class="attr">side</span>: <span class="built_in">Number</span> &#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shapes = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'Test'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">kind</span>: <span class="string">'Circle'</span>, <span class="attr">radius</span>: <span class="number">5</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">kind</span>: <span class="string">'Square'</span>, <span class="attr">side</span>: <span class="number">10</span> &#125;</span><br><span class="line">];</span><br><span class="line">Shape.create(shapes, <span class="function"><span class="keyword">function</span>(<span class="params">error, shapes</span>) </span>&#123;</span><br><span class="line">  assert.ifError(error);</span><br><span class="line">  <span class="comment">// 重点看这里</span></span><br><span class="line">  assert.ok(shapes[<span class="number">0</span>] <span class="keyword">instanceof</span> Shape);</span><br><span class="line">  assert.ok(shapes[<span class="number">1</span>] <span class="keyword">instanceof</span> Circle);</span><br><span class="line">  assert.equal(shapes[<span class="number">1</span>].radius, <span class="number">5</span>);</span><br><span class="line">  assert.ok(shapes[<span class="number">2</span>] <span class="keyword">instanceof</span> Square);</span><br><span class="line">  assert.equal(shapes[<span class="number">2</span>].side, <span class="number">10</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="数组中的嵌套-discriminator"><a href="#数组中的嵌套-discriminator" class="headerlink" title="数组中的嵌套 discriminator"></a><strong>数组中的嵌套 discriminator</strong></h4><p>你也可以为嵌套文档数组定义 discriminator。 嵌套 discriminator 的特点是：不同 discriminator 类型储存在相同的文档而不是同一个 mongoDB collection。 换句话说，嵌套 discriminator 让你 在同一个数组储存符合不同 schema 的子文档。</p><p>最佳实践：确保你声明了钩子再使用他们。 你<strong>不应当</strong>在调用 <code>discriminator()</code> 之后调用 <code>pre()</code> 或 <code>post()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventSchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">message</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">discriminatorKey</span>: <span class="string">'kind'</span>, <span class="attr">_id</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> batchSchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">events</span>: [eventSchema] &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// `batchSchema.path('events')` gets the mongoose `DocumentArray`</span></span><br><span class="line"><span class="keyword">const</span> docArray = batchSchema.path(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 `events` 数组可以包含 2 种不同的 event 类型，</span></span><br><span class="line"><span class="comment">// 'clicked' event that requires an element id that was clicked...</span></span><br><span class="line"><span class="keyword">const</span> clickedSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  element: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    required: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123; <span class="attr">_id</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="comment">// 确定在调用 `discriminator()` **之前**</span></span><br><span class="line"><span class="comment">// 对 `eventSchema` 和 `clickedSchema` 赋予钩子</span></span><br><span class="line"><span class="keyword">const</span> Clicked = docArray.discriminator(<span class="string">'Clicked'</span>, clickedSchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... and a 'purchased' event that requires the product that was purchased.</span></span><br><span class="line"><span class="keyword">const</span> Purchased = docArray.discriminator(<span class="string">'Purchased'</span>, <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  product: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    required: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123; <span class="attr">_id</span>: <span class="literal">false</span> &#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Batch = db.model(<span class="string">'EventBatch'</span>, batchSchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new batch of events with different kinds</span></span><br><span class="line"><span class="keyword">const</span> batch = &#123;</span><br><span class="line">  events: [</span><br><span class="line">    &#123; <span class="attr">kind</span>: <span class="string">'Clicked'</span>, <span class="attr">element</span>: <span class="string">'#hero'</span>, <span class="attr">message</span>: <span class="string">'hello'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">kind</span>: <span class="string">'Purchased'</span>, <span class="attr">product</span>: <span class="string">'action-figure-1'</span>, <span class="attr">message</span>: <span class="string">'world'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Batch.create(batch).</span><br><span class="line">  then(<span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    assert.equal(doc.events.length, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    assert.equal(doc.events[<span class="number">0</span>].element, <span class="string">'#hero'</span>);</span><br><span class="line">    assert.equal(doc.events[<span class="number">0</span>].message, <span class="string">'hello'</span>);</span><br><span class="line">    assert.ok(doc.events[<span class="number">0</span>] <span class="keyword">instanceof</span> Clicked);</span><br><span class="line"></span><br><span class="line">    assert.equal(doc.events[<span class="number">1</span>].product, <span class="string">'action-figure-1'</span>);</span><br><span class="line">    assert.equal(doc.events[<span class="number">1</span>].message, <span class="string">'world'</span>);</span><br><span class="line">    assert.ok(doc.events[<span class="number">1</span>] <span class="keyword">instanceof</span> Purchased);</span><br><span class="line"></span><br><span class="line">    doc.events.push(&#123; <span class="attr">kind</span>: <span class="string">'Purchased'</span>, <span class="attr">product</span>: <span class="string">'action-figure-2'</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span> doc.save();</span><br><span class="line">  &#125;).</span><br><span class="line">  then(<span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    assert.equal(doc.events.length, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    assert.equal(doc.events[<span class="number">2</span>].product, <span class="string">'action-figure-2'</span>);</span><br><span class="line">    assert.ok(doc.events[<span class="number">2</span>] <span class="keyword">instanceof</span> Purchased);</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line">  &#125;).</span><br><span class="line">  <span class="keyword">catch</span>(done);</span><br></pre></td></tr></table></figure><h4 id="检索数组中的嵌套-discriminator"><a href="#检索数组中的嵌套-discriminator" class="headerlink" title="检索数组中的嵌套 discriminator"></a><strong>检索数组中的嵌套 discriminator</strong></h4><p>检索嵌套 discriminator</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> singleEventSchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">message</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">discriminatorKey</span>: <span class="string">'kind'</span>, <span class="attr">_id</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventListSchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">events</span>: [singleEventSchema] &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subEventSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">   sub_events: [singleEventSchema]</span><br><span class="line">&#125;, &#123; <span class="attr">_id</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SubEvent = subEventSchema.path(<span class="string">'sub_events'</span>).discriminator(<span class="string">'SubEvent'</span>, subEventSchema)</span><br><span class="line">eventListSchema.path(<span class="string">'events'</span>).discriminator(<span class="string">'SubEvent'</span>, subEventSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Eventlist = db.model(<span class="string">'EventList'</span>, eventListSchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new batch of events with different kinds</span></span><br><span class="line"><span class="keyword">const</span> list = &#123;</span><br><span class="line">  events: [</span><br><span class="line">    &#123; <span class="attr">kind</span>: <span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>: [&#123;<span class="attr">kind</span>:<span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>:[], <span class="attr">message</span>:<span class="string">'test1'</span>&#125;], <span class="attr">message</span>: <span class="string">'hello'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">kind</span>: <span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>: [&#123;<span class="attr">kind</span>:<span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>:[&#123;<span class="attr">kind</span>:<span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>:[], <span class="attr">message</span>:<span class="string">'test3'</span>&#125;], <span class="attr">message</span>:<span class="string">'test2'</span>&#125;], <span class="attr">message</span>: <span class="string">'world'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Eventlist.create(list).</span><br><span class="line">  then(<span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    assert.equal(doc.events.length, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    assert.equal(doc.events[<span class="number">0</span>].sub_events[<span class="number">0</span>].message, <span class="string">'test1'</span>);</span><br><span class="line">    assert.equal(doc.events[<span class="number">0</span>].message, <span class="string">'hello'</span>);</span><br><span class="line">    assert.ok(doc.events[<span class="number">0</span>].sub_events[<span class="number">0</span>] <span class="keyword">instanceof</span> SubEvent);</span><br><span class="line"></span><br><span class="line">    assert.equal(doc.events[<span class="number">1</span>].sub_events[<span class="number">0</span>].sub_events[<span class="number">0</span>].message, <span class="string">'test3'</span>);</span><br><span class="line">    assert.equal(doc.events[<span class="number">1</span>].message, <span class="string">'world'</span>);</span><br><span class="line">    assert.ok(doc.events[<span class="number">1</span>].sub_events[<span class="number">0</span>].sub_events[<span class="number">0</span>] <span class="keyword">instanceof</span> SubEvent);</span><br><span class="line"></span><br><span class="line">    doc.events.push(&#123;<span class="attr">kind</span>:<span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>:[&#123;<span class="attr">kind</span>:<span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>:[], <span class="attr">message</span>:<span class="string">'test4'</span>&#125;], <span class="attr">message</span>:<span class="string">'pushed'</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> doc.save();</span><br><span class="line">  &#125;).</span><br><span class="line">  then(<span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    assert.equal(doc.events.length, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    assert.equal(doc.events[<span class="number">2</span>].message, <span class="string">'pushed'</span>);</span><br><span class="line">    assert.ok(doc.events[<span class="number">2</span>].sub_events[<span class="number">0</span>] <span class="keyword">instanceof</span> SubEvent);</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line">  &#125;).</span><br><span class="line">  <span class="keyword">catch</span>(done);</span><br></pre></td></tr></table></figure><p>### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询
      
    
    </summary>
    
      <category term="数据库相关" scheme="http://laibh.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="数据库相关" scheme="http://laibh.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
</feed>
