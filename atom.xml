<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>赖同学</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://laibh.top/"/>
  <updated>2019-10-15T09:29:49.419Z</updated>
  <id>http://laibh.top/</id>
  
  <author>
    <name>赖彬鸿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于ts重构axios</title>
    <link href="http://laibh.top/2019-09-03-%E5%9F%BA%E4%BA%8Ets%E9%87%8D%E6%9E%84axios.html"/>
    <id>http://laibh.top/2019-09-03-基于ts重构axios.html</id>
    <published>2019-09-03T06:19:54.000Z</published>
    <updated>2019-10-15T09:29:49.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于ts重构axios"><a href="#基于ts重构axios" class="headerlink" title="基于ts重构axios"></a>基于ts重构axios</h1><p><strong>ustbhuangyi</strong> 老师的 <a href="https://coding.imooc.com/class/330.html">基于TypeScript从零重构axios</a>学习记录。</p><p><strong>知识点</strong></p><p>TypeScript 常用语法：</p><p><code>基础类型</code> 、 <code>函数</code> 、 <code>变量声明</code> 、 <code>接口</code> 、 <code>类</code> 、 <code>泛型</code> 、 <code>类型推新</code> 、 <code>高级类型</code> </p><p>axios js库：</p><p><code>项目脚手架</code> 、 <code>基础功能实现</code> 、 <code>异常情况处理</code> 、 <code>接口扩展</code> 、 <code>拦截器实现</code> 、 <code>配置化实现</code> 、 <code>取消功能实现</code> 、 <code>其他功能实现等等</code> </p><p>主要工具：<br><code>Jest</code> 、 <code>TSLint</code> 、 <code>Commitizen</code> 、 <code>Prettier</code> 、 <code>RollupJS</code> 、 <code>Semantic release</code> </p><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p><a href="http://laibh.top/2018-11-28-TypeScript.html">点我</a></p><h2 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h2><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ul><li>在浏览器使用 XMLHttpRequest 对象通讯</li><li>支持 Promise API</li><li>支持请求和响应的拦截器</li><li>支持请求数据和响应数据的转换</li><li>支持请求的取消</li><li>JSON数据的自动转换</li><li>客户端防止 XSRF</li></ul><h2 id="基于-XMLHttpRequest-编写基本请求代码"><a href="#基于-XMLHttpRequest-编写基本请求代码" class="headerlink" title="基于 XMLHttpRequest 编写基本请求代码"></a>基于 XMLHttpRequest 编写基本请求代码</h2><h3 id="处理请求数据：url-body-headers"><a href="#处理请求数据：url-body-headers" class="headerlink" title="处理请求数据：url/body/headers"></a>处理请求数据：url/body/headers</h3><p><strong>src/types/index.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export type Method = &apos;get&apos; | &apos;GET&apos; | &apos;delete&apos; | &apos;Delete&apos; | &apos;head&apos; | &apos;HEAD&apos; | &apos;options&apos; | &apos;OPTIONS&apos; | &apos;post&apos; | &apos;POST&apos; | &apos;put&apos; | &apos;PUT&apos; | &apos;patch&apos; | &apos;PATCH&apos;</span><br><span class="line">export interface AxiosRequestConfig &#123;</span><br><span class="line">  url: string</span><br><span class="line">  method?: Method</span><br><span class="line">  data?: any</span><br><span class="line">  params?: any</span><br><span class="line">  headers?: any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>src/xhr.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import &#123; AxiosRequestConfig &#125; from &apos;./types&apos;</span><br><span class="line"></span><br><span class="line">export default function xhr(config: AxiosRequestConfig): void &#123;</span><br><span class="line">  const &#123; data = null, url, method = &apos;get&apos;, headers &#125; = config</span><br><span class="line">  const request = new XMLHttpRequest()</span><br><span class="line">  // method,url,async</span><br><span class="line">  request.open(method.toUpperCase(), url, true)</span><br><span class="line">  Object.keys(headers).forEach(name =&gt; &#123;</span><br><span class="line">    if (data === null &amp;&amp; name.toLowerCase() === &apos;content-type&apos;) &#123;</span><br><span class="line">      delete headers[name]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      request.setRequestHeader(name, headers[name])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  request.send(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>src/index.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import &#123; AxiosRequestConfig &#125; from &apos;./types&apos;</span><br><span class="line">import &#123; buildURL &#125; from &apos;./helpers/url&apos;;</span><br><span class="line">import &#123; transformRequest &#125; from &apos;./helpers/data&apos;;</span><br><span class="line">import xhr from &apos;./xhr&apos;</span><br><span class="line">import &#123; processHeaders &#125; from &apos;./helpers/header&apos;;</span><br><span class="line"></span><br><span class="line">function axios(config: AxiosRequestConfig): void &#123;</span><br><span class="line">  processConfig(config)</span><br><span class="line">  xhr(config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function processConfig(config: AxiosRequestConfig): void &#123;</span><br><span class="line">  config.url = transformURL(config)</span><br><span class="line">  config.data = transformRequestData(config)</span><br><span class="line">  config.headers = transformHeaders(config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transformHeaders(config: AxiosRequestConfig): void &#123;</span><br><span class="line">  const &#123; headers = &#123;&#125;, data &#125; = config</span><br><span class="line">  return processHeaders(headers, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transformRequestData(config: AxiosRequestConfig): void &#123;</span><br><span class="line">  return transformRequest(config.data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transformURL(config: AxiosRequestConfig): string &#123;</span><br><span class="line">  const &#123; url, params &#125; = config;</span><br><span class="line">  return buildURL(url, params)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default axios</span><br></pre></td></tr></table></figure><h4 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h4><p><strong>data.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; isPlainObject &#125; from &quot;./util&quot;;</span><br><span class="line"></span><br><span class="line">export function transformRequest(data: any): any &#123;</span><br><span class="line">  if (isPlainObject(data)) &#123;</span><br><span class="line">    return JSON.stringify(data)</span><br><span class="line">  &#125;</span><br><span class="line">  return data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>headers.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import &#123; isPlainObject &#125; from &quot;./util&quot;</span><br><span class="line"></span><br><span class="line">function normalizeHeaderName(headers: any, normalizedName: string): void &#123;</span><br><span class="line">  if (!headers) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  Object.keys(headers).forEach(name =&gt; &#123;</span><br><span class="line">    if (name !== normalizedName &amp;&amp; name.toUpperCase() === normalizedName.toUpperCase()) &#123;</span><br><span class="line">      headers[normalizedName] = headers[name]</span><br><span class="line">      delete headers[name]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function processHeaders(headers: any, data: any): any &#123;</span><br><span class="line">  normalizeHeaderName(headers, &apos;Content-Type&apos;)</span><br><span class="line">  if (isPlainObject(data)) &#123;</span><br><span class="line">    if (headers &amp;&amp; !headers[&apos;Content-Type&apos;]) &#123;</span><br><span class="line">      headers[&apos;Content-Type&apos;] = &apos;application/json;charset=utf-8&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return headers</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>url.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123; isDate, isPlainObject &#125; from &apos;./util&apos;</span><br><span class="line"></span><br><span class="line">function encode(val: string): string &#123;</span><br><span class="line">  return encodeURIComponent(val)</span><br><span class="line">    .replace(/%40/g, &apos;@&apos;)</span><br><span class="line">    .replace(/%3A/ig, &apos;:&apos;)</span><br><span class="line">    .replace(/%24/g, &apos;**util.ts**</span><br><span class="line"></span><br><span class="line">```tsx</span><br><span class="line">const toString = Object.prototype.toString</span><br><span class="line"></span><br><span class="line">export function isDate(val: any): val is Date &#123;</span><br><span class="line">  return toString.call(val) === &apos;[object Date]&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function isPlainObject(val: any): val is Object &#123;</span><br><span class="line">  return toString.call(val) === &apos;[object Object]&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理响应数据"><a href="#处理响应数据" class="headerlink" title="处理响应数据"></a>处理响应数据</h3><p>定义响应接口</p><p><strong>types/index</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AxiosResponse &#123;</span><br><span class="line">  data: <span class="built_in">any</span></span><br><span class="line">  status: <span class="built_in">number</span></span><br><span class="line">  statusText: <span class="built_in">string</span></span><br><span class="line">  headers: <span class="built_in">any</span></span><br><span class="line">  config: AxiosRequestConfig</span><br><span class="line">  request: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AxiosPromise <span class="keyword">extends</span> Promise&lt;AxiosResponse&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理 headers 的数据</p><p><strong>helpers/header.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">export function processHeaders(headers: any, data: any): any &#123;</span><br><span class="line">  normalizeHeaderName(headers, &apos;Content-Type&apos;)</span><br><span class="line">  if (isPlainObject(data)) &#123;</span><br><span class="line">    if (headers &amp;&amp; !headers[&apos;Content-Type&apos;]) &#123;</span><br><span class="line">      headers[&apos;Content-Type&apos;] = &apos;application/json;charset=utf-8&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return headers</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function parseHeaders(headers: string): any &#123;</span><br><span class="line">  let parsed = Object.create(null)</span><br><span class="line">  if (!headers) &#123;</span><br><span class="line">    return headers</span><br><span class="line">  &#125;</span><br><span class="line">  headers.split(&apos;\r\n&apos;).forEach(line =&gt; &#123;</span><br><span class="line">    let [key, val] = line.split(&apos;:&apos;)</span><br><span class="line">    key = key.trim().toLowerCase()</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    if (val) &#123;</span><br><span class="line">      val = val.trim();</span><br><span class="line">    &#125;</span><br><span class="line">    parsed[key] = val</span><br><span class="line">  &#125;)</span><br><span class="line">  return parsed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理 响应data</p><p><strong>helpers/data.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export function transformResponse(data: any): any &#123;</span><br><span class="line">  if (typeof data === &apos;string&apos;) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      data = JSON.parse(data)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      // do nothing</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 xhr, 返回一个 Promise</p><p><strong>xhr.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import &#123; AxiosRequestConfig, AxiosPromise, AxiosResponse &#125; from &apos;./types&apos;</span><br><span class="line">import &#123; parseHeaders &#125; from &apos;./helpers/headers&apos;</span><br><span class="line"></span><br><span class="line">export default function xhr(config: AxiosRequestConfig): AxiosPromise &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    const &#123; data = null, url, method = &apos;get&apos;, headers, responseType &#125; = config</span><br><span class="line">    const request = new XMLHttpRequest()</span><br><span class="line">    if (responseType) &#123;</span><br><span class="line">      request.responseType = responseType</span><br><span class="line">    &#125;</span><br><span class="line">    // method,url,async</span><br><span class="line">    request.open(method.toUpperCase(), url, true)</span><br><span class="line"></span><br><span class="line">    request.onreadystatechange = function handleLoad() &#123;</span><br><span class="line">      if (request.readyState !== 4) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const responseHeaders = parseHeaders(request.getAllResponseHeaders())</span><br><span class="line">      const responseData = responseType &amp;&amp; responseType !== &apos;text&apos; ? request.response : request.responseText</span><br><span class="line">      const response: AxiosResponse = &#123;</span><br><span class="line">        data: responseData,</span><br><span class="line">        status: request.status,</span><br><span class="line">        statusText: request.statusText,</span><br><span class="line">        headers: responseHeaders,</span><br><span class="line">        config,</span><br><span class="line">        request</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(response)</span><br><span class="line">    &#125;</span><br><span class="line">    Object.keys(headers).forEach(name =&gt; &#123;</span><br><span class="line">      if (data === null &amp;&amp; name.toLowerCase() === &apos;content-type&apos;) &#123;</span><br><span class="line">        delete headers[name]</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        request.setRequestHeader(name, headers[name])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    request.send(data)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/LbhFront-end/ts-axios">具体代码地址</a></p><p>)</p><pre><code>.replace(/%2C/ig, &apos;,&apos;).replace(/%20/g, &apos;+&apos;).replace(/%5B/ig, &apos;[&apos;).replace(/%5D/ig, &apos;]&apos;)</code></pre><p>}</p><p>export function buildURL(url: string, params?: any): string {<br>  if (!params) {</p><pre><code>return url</code></pre><p>  }<br>  const parts: string[] = []<br>  Object.keys(params).forEach(key =&gt; {</p><pre><code>const val = params[key]if (val === null || typeof val === &apos;undefined&apos;) {  return}let values = []if (Array.isArray(val)) {  values = val  key += &apos;[]&apos;} else {  values = [val]}values.forEach(val =&gt; {  if (isDate(val)) {    val = val.toISOString()  } else if (isPlainObject(val)) {    val = JSON.stringify(val)  }  parts.push( `${encode(key)}=${encode(val)}` )})</code></pre><p>  })<br>  let serializedParams = parts.join(‘&amp;’)<br>  if (serializedParams) {</p><pre><code>const markIndex = url.indexOf(&apos;#&apos;)if (markIndex !== -1) {  url = url.slice(0, markIndex)}url += (url.indexOf(&apos;?&apos;) === -1 ? &apos;?&apos; : &apos;&amp;&apos;) + serializedParams</code></pre><p>  }<br>  return url<br>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**util.ts**</span><br><span class="line"></span><br><span class="line">```tsx</span><br><span class="line">const toString = Object.prototype.toString</span><br><span class="line"></span><br><span class="line">export function isDate(val: any): val is Date &#123;</span><br><span class="line">  return toString.call(val) === &apos;[object Date]&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function isPlainObject(val: any): val is Object &#123;</span><br><span class="line">  return toString.call(val) === &apos;[object Object]&apos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="处理响应数据-1"><a href="#处理响应数据-1" class="headerlink" title="处理响应数据"></a>处理响应数据</h3><p>定义响应接口</p><p><strong>types/index</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AxiosResponse &#123;</span><br><span class="line">  data: <span class="built_in">any</span></span><br><span class="line">  status: <span class="built_in">number</span></span><br><span class="line">  statusText: <span class="built_in">string</span></span><br><span class="line">  headers: <span class="built_in">any</span></span><br><span class="line">  config: AxiosRequestConfig</span><br><span class="line">  request: <span class="built_in">any</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> AxiosPromise <span class="keyword">extends</span> Promise&lt;AxiosResponse&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理 headers 的数据</p><p><strong>helpers/header.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">export function processHeaders(headers: any, data: any): any &#123;</span><br><span class="line">  normalizeHeaderName(headers, &apos;Content-Type&apos;)</span><br><span class="line">  if (isPlainObject(data)) &#123;</span><br><span class="line">    if (headers &amp;&amp; !headers[&apos;Content-Type&apos;]) &#123;</span><br><span class="line">      headers[&apos;Content-Type&apos;] = &apos;application/json;charset=utf-8&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return headers</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function parseHeaders(headers: string): any &#123;</span><br><span class="line">  let parsed = Object.create(null)</span><br><span class="line">  if (!headers) &#123;</span><br><span class="line">    return headers</span><br><span class="line">  &#125;</span><br><span class="line">  headers.split(&apos;\r\n&apos;).forEach(line =&gt; &#123;</span><br><span class="line">    let [key, val] = line.split(&apos;:&apos;)</span><br><span class="line">    key = key.trim().toLowerCase()</span><br><span class="line">    if (!key) &#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    if (val) &#123;</span><br><span class="line">      val = val.trim();</span><br><span class="line">    &#125;</span><br><span class="line">    parsed[key] = val</span><br><span class="line">  &#125;)</span><br><span class="line">  return parsed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理 响应data</p><p><strong>helpers/data.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">export function transformResponse(data: any): any &#123;</span><br><span class="line">  if (typeof data === &apos;string&apos;) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      data = JSON.parse(data)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      // do nothing</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return data</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 xhr, 返回一个 Promise</p><p><strong>xhr.ts</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import &#123; AxiosRequestConfig, AxiosPromise, AxiosResponse &#125; from &apos;./types&apos;</span><br><span class="line">import &#123; parseHeaders &#125; from &apos;./helpers/headers&apos;</span><br><span class="line"></span><br><span class="line">export default function xhr(config: AxiosRequestConfig): AxiosPromise &#123;</span><br><span class="line">  return new Promise(resolve =&gt; &#123;</span><br><span class="line">    const &#123; data = null, url, method = &apos;get&apos;, headers, responseType &#125; = config</span><br><span class="line">    const request = new XMLHttpRequest()</span><br><span class="line">    if (responseType) &#123;</span><br><span class="line">      request.responseType = responseType</span><br><span class="line">    &#125;</span><br><span class="line">    // method,url,async</span><br><span class="line">    request.open(method.toUpperCase(), url, true)</span><br><span class="line"></span><br><span class="line">    request.onreadystatechange = function handleLoad() &#123;</span><br><span class="line">      if (request.readyState !== 4) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      const responseHeaders = parseHeaders(request.getAllResponseHeaders())</span><br><span class="line">      const responseData = responseType &amp;&amp; responseType !== &apos;text&apos; ? request.response : request.responseText</span><br><span class="line">      const response: AxiosResponse = &#123;</span><br><span class="line">        data: responseData,</span><br><span class="line">        status: request.status,</span><br><span class="line">        statusText: request.statusText,</span><br><span class="line">        headers: responseHeaders,</span><br><span class="line">        config,</span><br><span class="line">        request</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(response)</span><br><span class="line">    &#125;</span><br><span class="line">    Object.keys(headers).forEach(name =&gt; &#123;</span><br><span class="line">      if (data === null &amp;&amp; name.toLowerCase() === &apos;content-type&apos;) &#123;</span><br><span class="line">        delete headers[name]</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        request.setRequestHeader(name, headers[name])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    request.send(data)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://github.com/LbhFront-end/ts-axios">具体代码地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于ts重构axios&quot;&gt;&lt;a href=&quot;#基于ts重构axios&quot; class=&quot;headerlink&quot; title=&quot;基于ts重构axios&quot;&gt;&lt;/a&gt;基于ts重构axios&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;ustbhuangyi&lt;/strong&gt; 老师的 &lt;
      
    
    </summary>
    
      <category term="+ TypeScript" scheme="http://laibh.top/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="http://laibh.top/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>前端必备的测试</title>
    <link href="http://laibh.top/2019-08-19-%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87%E7%9A%84%E6%B5%8B%E8%AF%95%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://laibh.top/2019-08-19-前端必备的测试学习.html</id>
    <published>2019-08-19T00:33:54.000Z</published>
    <updated>2019-10-15T09:29:49.419Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端必备的测试"><a href="#前端必备的测试" class="headerlink" title="前端必备的测试"></a>前端必备的测试</h1><p>DellLee 老师的 <a href="https://coding.imooc.com/class/372.html">前端要学的测试课 从Jest入门到TDD/BDD双实战</a>学习记录。</p><p><strong>知识点</strong></p><p>Jest 基础</p><p><code>基础API</code>、<code>异步测试</code>、<code>Mock技巧</code>、<code>快照</code>、<code>timer测试</code>、<code>Dom测试</code></p><p>实现项目</p><p><code>Vue</code>、<code>Vue-test-utils</code>、<code>React</code>、<code>Enzyme</code>、<code>TDD+单元测试</code>、<code>BDD+集成测试</code></p><h2 id="初识测试"><a href="#初识测试" class="headerlink" title="初识测试"></a>初识测试</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minus</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  add,</span><br><span class="line">  minus</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// math.test.js</span></span><br><span class="line"><span class="comment">// 简陋测试</span></span><br><span class="line"><span class="keyword">import</span> &#123; add, minus &#125; <span class="keyword">from</span> <span class="string">'./math'</span></span><br><span class="line"><span class="keyword">let</span> result</span><br><span class="line"><span class="keyword">let</span> expected</span><br><span class="line">result = add(<span class="number">3</span>, <span class="number">7</span>)</span><br><span class="line">expected = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result !== <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`3 + 7 应该等于 <span class="subst">$&#123;expected&#125;</span>,但结果却是 <span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result = minus(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">expected = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result !== <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`3 - 3 应该等于 <span class="subst">$&#123;expected&#125;</span>,但结果却是 <span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 封装版</span></span><br><span class="line"><span class="keyword">import</span> &#123; add, minus &#125; <span class="keyword">from</span> <span class="string">'./math'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">expect</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    toBe: <span class="function"><span class="keyword">function</span> (<span class="params">actual</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (result !== actual) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`预期值与实际值不相等 预期<span class="subst">$&#123;actual&#125;</span> 结果却是 <span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">desc, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;desc&#125;</span>通过测试`</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;desc&#125;</span>没有通过测试 <span class="subst">$&#123;e&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">'测试加法3 + 7'</span>, () =&gt; &#123;</span><br><span class="line">  expect(add(<span class="number">3</span>, <span class="number">7</span>)).toBe(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br><span class="line">test(<span class="string">'测试减法6 - 3'</span>, () =&gt; &#123;</span><br><span class="line">  expect(minus(<span class="number">6</span>, <span class="number">3</span>)).toBe(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="自动化框架：Jest"><a href="#自动化框架：Jest" class="headerlink" title="自动化框架：Jest"></a>自动化框架：Jest</h2><p>优点：性能、功能、易用性、速度快、Api简单、易配置、隔离性好、监控模式、IDE整合、Snapshot、多项目并行、覆盖率、Mock丰富</p><h3 id="简单配置"><a href="#简单配置" class="headerlink" title="简单配置"></a>简单配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 项目内部调用 jest</span></span><br><span class="line">npx jest --init </span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择 </span></span><br><span class="line">browser-like</span><br><span class="line"><span class="meta">#</span><span class="bash"> 随后选择自动生成报告，自动清除实例在每个<span class="built_in">test</span>之前，就会生成一下配置文件</span></span><br><span class="line">jest.config.js</span><br></pre></td></tr></table></figure><p><code>jest.config.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// For a detailed explanation regarding each configuration property, visit:</span></span><br><span class="line"><span class="comment">// https://jestjs.io/docs/en/configuration.html</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// All imported modules in your tests should be mocked automatically</span></span><br><span class="line">  <span class="comment">// 自动模拟在测试用例中的所有导入模块，在 __mocks__ 文件夹中寻找</span></span><br><span class="line">  <span class="comment">// automock: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Stop running tests after `n` failures</span></span><br><span class="line">  <span class="comment">// 默认情况下，Jest运行所有测试并在完成后将所有错误生成到控制台，bil 让 jest 在 n 失败后停止运行测试</span></span><br><span class="line">  <span class="comment">// bail: 0,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Respect "browser" field in package.json when resolving modules</span></span><br><span class="line">  <span class="comment">// false =&gt; browser | true =&gt; node</span></span><br><span class="line">  <span class="comment">// browser: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The directory where Jest should store its cached dependency information</span></span><br><span class="line">  <span class="comment">// 存放 jest 依赖信息缓存的目录</span></span><br><span class="line">  <span class="comment">// cacheDirectory: "C:\\Users\\Administrator\\AppData\\Local\\Temp\\jest",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Automatically clear mock calls and instances between every test</span></span><br><span class="line">  <span class="comment">// 自动清除模拟调用和实例在每次测试之间</span></span><br><span class="line">  clearMocks: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Indicates whether the coverage information should be collected while executing the test</span></span><br><span class="line">  <span class="comment">// 是否收集测试时的覆盖率信息，因为要带上覆盖率搜集语句访问所有执行过的文件，这可能会让测试执行速度明显减慢</span></span><br><span class="line">  <span class="comment">// collectCoverage: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of glob patterns indicating a set of files for which coverage information should be collected</span></span><br><span class="line">  <span class="comment">// 指示应收集覆盖率信息的全局模式一组文件，即使文件不存在测试，也将为其收集覆盖率信息，并且测试套件中不需要它</span></span><br><span class="line">  <span class="comment">// collectCoverageFrom: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The directory where Jest should output its coverage files</span></span><br><span class="line">  <span class="comment">// jest 输出测速覆盖率文件的目录</span></span><br><span class="line">  <span class="comment">// 运行 npx jest --coverage</span></span><br><span class="line">  coverageDirectory: <span class="string">"coverage"</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of regexp pattern strings used to skip coverage collection</span></span><br><span class="line">  <span class="comment">// 忽略测试的文件路径的正则匹配</span></span><br><span class="line">  <span class="comment">// coveragePathIgnorePatterns: [</span></span><br><span class="line">  <span class="comment">//   "\\\\node_modules\\\\"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A list of reporter names that Jest uses when writing coverage reports</span></span><br><span class="line">  <span class="comment">// coverageReporters: [</span></span><br><span class="line">  <span class="comment">//   "json",</span></span><br><span class="line">  <span class="comment">//   "text",</span></span><br><span class="line">  <span class="comment">//   "lcov",</span></span><br><span class="line">  <span class="comment">//   "clover"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An object that configures minimum threshold enforcement for coverage results</span></span><br><span class="line">  <span class="comment">// coverageThreshold: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A path to a custom dependency extractor</span></span><br><span class="line">  <span class="comment">// dependencyExtractor: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make calling deprecated APIs throw helpful error messages</span></span><br><span class="line">  <span class="comment">// errorOnDeprecated: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Force coverage collection from ignored files using an array of glob patterns</span></span><br><span class="line">  <span class="comment">// forceCoverageMatch: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A path to a module which exports an async function that is triggered once before all test suites</span></span><br><span class="line">  <span class="comment">// globalSetup: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A path to a module which exports an async function that is triggered once after all test suites</span></span><br><span class="line">  <span class="comment">// globalTeardown: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A set of global variables that need to be available in all test environments</span></span><br><span class="line">  <span class="comment">// globals: &#123;&#125;,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The maximum amount of workers used to run your tests. Can be specified as % or a number. E.g. maxWorkers: 10% will use 10% of your CPU amount + 1 as the maximum worker number. maxWorkers: 2 will use a maximum of 2 workers.</span></span><br><span class="line">  <span class="comment">// maxWorkers: "50%",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of directory names to be searched recursively up from the requiring module's location</span></span><br><span class="line">  <span class="comment">// moduleDirectories: [</span></span><br><span class="line">  <span class="comment">//   "node_modules"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of file extensions your modules use</span></span><br><span class="line">  <span class="comment">// 模块使用文件扩展名数组，当你导入的文件没有扩展名的时候，它会在这个数组里面去自动匹配</span></span><br><span class="line">  <span class="comment">// moduleFileExtensions: [</span></span><br><span class="line">  <span class="comment">//   "js",</span></span><br><span class="line">  <span class="comment">//   "json",</span></span><br><span class="line">  <span class="comment">//   "jsx",</span></span><br><span class="line">  <span class="comment">//   "ts",</span></span><br><span class="line">  <span class="comment">//   "tsx",</span></span><br><span class="line">  <span class="comment">//   "node"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A map from regular expressions to module names that allow to stub out resources with a single module</span></span><br><span class="line">  <span class="comment">// 模块名映射，类 webpack alias 以及 jsconfig.js 的 compilerOptions.paths</span></span><br><span class="line">  <span class="comment">// moduleNameMapper: &#123;&#125;,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of regexp pattern strings, matched against all module paths before considered 'visible' to the module loader</span></span><br><span class="line">  <span class="comment">// modulePathIgnorePatterns: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Activates notifications for test results</span></span><br><span class="line">  <span class="comment">// notify: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An enum that specifies notification mode. Requires &#123; notify: true &#125;</span></span><br><span class="line">  <span class="comment">// notifyMode: "failure-change",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A preset that is used as a base for Jest's configuration</span></span><br><span class="line">  <span class="comment">// preset: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run tests from one or more projects</span></span><br><span class="line">  <span class="comment">// projects: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use this configuration option to add custom reporters to Jest</span></span><br><span class="line">  <span class="comment">// reporters: undefined,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Automatically reset mock state between every test</span></span><br><span class="line">  <span class="comment">// resetMocks: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reset the module registry before running each individual test</span></span><br><span class="line">  <span class="comment">// resetModules: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A path to a custom resolver</span></span><br><span class="line">  <span class="comment">// resolver: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Automatically restore mock state between every test</span></span><br><span class="line">  <span class="comment">// restoreMocks: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The root directory that Jest should scan for tests and modules within</span></span><br><span class="line">  <span class="comment">// rootDir: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A list of paths to directories that Jest should use to search for files in</span></span><br><span class="line">  <span class="comment">// roots: [</span></span><br><span class="line">  <span class="comment">//   "&lt;rootDir&gt;"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Allows you to use a custom runner instead of Jest's default test runner</span></span><br><span class="line">  <span class="comment">// runner: "jest-runner",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The paths to modules that run some code to configure or set up the testing environment before each test</span></span><br><span class="line">  <span class="comment">// setupFiles: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A list of paths to modules that run some code to configure or set up the testing framework before each test</span></span><br><span class="line">  <span class="comment">// 运行做测试的时候使用某些垫片为运行环境做兼容</span></span><br><span class="line">  <span class="comment">// setupFilesAfterEnv: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A list of paths to snapshot serializer modules Jest should use for snapshot testing</span></span><br><span class="line">  <span class="comment">// 快照格式化</span></span><br><span class="line">  <span class="comment">// snapshotSerializers: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The test environment that will be used for testing</span></span><br><span class="line">  <span class="comment">// testEnvironment: "jest-environment-jsdom",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Options that will be passed to the testEnvironment</span></span><br><span class="line">  <span class="comment">// testEnvironmentOptions: &#123;&#125;,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Adds a location field to test results</span></span><br><span class="line">  <span class="comment">// testLocationInResults: false,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The glob patterns Jest uses to detect test files</span></span><br><span class="line">  <span class="comment">// 匹配测试文件</span></span><br><span class="line">  <span class="comment">// testMatch: [</span></span><br><span class="line">  <span class="comment">//   "**/__tests__/**/*.[jt]s?(x)",</span></span><br><span class="line">  <span class="comment">//   "**/?(*.)+(spec|test).[tj]s?(x)"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of regexp pattern strings that are matched against all test paths, matched tests are skipped</span></span><br><span class="line">  <span class="comment">// testPathIgnorePatterns: [</span></span><br><span class="line">  <span class="comment">//   "\\\\node_modules\\\\"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The regexp pattern or array of patterns that Jest uses to detect test files</span></span><br><span class="line">  <span class="comment">// testRegex: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// This option allows the use of a custom results processor</span></span><br><span class="line">  <span class="comment">// testResultsProcessor: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// This option allows use of a custom test runner</span></span><br><span class="line">  <span class="comment">// testRunner: "jasmine2",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// This option sets the URL for the jsdom environment. It is reflected in properties such as location.href</span></span><br><span class="line">  <span class="comment">// 模拟浏览器的地址</span></span><br><span class="line">  <span class="comment">// testURL: "http://localhost",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Setting this value to "fake" allows the use of fake timers for functions such as "setTimeout"</span></span><br><span class="line">  <span class="comment">// timers: "real",</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// A map from regular expressions to paths to transformers</span></span><br><span class="line">  <span class="comment">// 不同文件类型对应不同的转换器</span></span><br><span class="line">  <span class="comment">// transform: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of regexp pattern strings that are matched against all source file paths, matched files will skip transformation</span></span><br><span class="line">  <span class="comment">// transformIgnorePatterns: [</span></span><br><span class="line">  <span class="comment">//   "\\\\node_modules\\\\"</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them</span></span><br><span class="line">  <span class="comment">// unmockedModulePathPatterns: undefined,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Indicates whether each individual test should be reported during the run</span></span><br><span class="line">  <span class="comment">// verbose: null,</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// An array of regexp patterns that are matched against all source file paths before re-running tests in watch mode</span></span><br><span class="line">  <span class="comment">// watchPathIgnorePatterns: [],</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Whether to use watchman for file crawling</span></span><br><span class="line">  <span class="comment">// watchman: true,</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="babelrc"><a href="#babelrc" class="headerlink" title="babelrc"></a>babelrc</h3><p>jest 未配置转换时，默认只支持 commonjs 语法。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"targets"</span>: &#123;</span><br><span class="line">          <span class="attr">"node"</span>: <span class="string">"current"</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jest转换（commonjs -&gt; es module）大概工作原理：</p><ol><li>npm run jest</li><li>jest（babel-jest）jest 内部的</li><li>检测是有 babel-core</li><li>拿到 .babelrc 配置</li><li>再运行测试之前，结合 babel  把代码做一次转化</li><li>运行转化过的测试用例</li></ol><h2 id="常用匹配器（Matchers）"><a href="#常用匹配器（Matchers）" class="headerlink" title="常用匹配器（Matchers）"></a>常用匹配器（Matchers）</h2><h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><h4 id="toBe"><a href="#toBe" class="headerlink" title=".toBe()"></a>.toBe()</h4><h4 id="toEqual-value"><a href="#toEqual-value" class="headerlink" title=".toEqual(value)"></a>.toEqual(value)</h4><h4 id="toBeGreaterThan-number"><a href="#toBeGreaterThan-number" class="headerlink" title=".toBeGreaterThan(number)"></a>.toBeGreaterThan(number)</h4><h4 id="toBeGreaterThanOrEqual-number"><a href="#toBeGreaterThanOrEqual-number" class="headerlink" title=".toBeGreaterThanOrEqual(number)"></a>.toBeGreaterThanOrEqual(number)</h4><h4 id="toBeLessThan-number"><a href="#toBeLessThan-number" class="headerlink" title=".toBeLessThan(number)"></a>.toBeLessThan(number)</h4><h4 id="toBeLessThanOrEqual-number"><a href="#toBeLessThanOrEqual-number" class="headerlink" title=".toBeLessThanOrEqual(number)"></a>.toBeLessThanOrEqual(number)</h4><h4 id="toBeCloseTo-number-numDigits"><a href="#toBeCloseTo-number-numDigits" class="headerlink" title=".toBeCloseTo(number,numDigits?)"></a>.toBeCloseTo(number,numDigits?)</h4><p>第二个参数为精度，代表几位小数点，默认为2位</p><h4 id="toBeNaN"><a href="#toBeNaN" class="headerlink" title=".toBeNaN()"></a>.toBeNaN()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字相关</span></span><br><span class="line">test(<span class="string">'匹配器：toBe-数字相等'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBe 匹配器 matchers Object.is() ===</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">10</span></span><br><span class="line">  expect(a).toBe(<span class="number">10</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toEqual-内容相等'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toEqual 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = &#123; <span class="attr">one</span>: <span class="number">1</span> &#125;</span><br><span class="line">  expect(a).toEqual(&#123; <span class="attr">one</span>: <span class="number">1</span> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeGreaterThan-大于比较数'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeGreaterThan 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">4</span></span><br><span class="line">  expect(a).toBeGreaterThan(<span class="number">3</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeGreaterThanOrEqual-大于等于比较数'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeGreaterThanOrEqual 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">4</span></span><br><span class="line">  expect(a).toBeGreaterThanOrEqual(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeLessThan-小于比较数'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeLessThan 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">4</span></span><br><span class="line">  expect(a).toBeLessThan(<span class="number">5</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeLessThanOrEqual-小于等于比较数'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeLessThanOrEqual 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">4</span></span><br><span class="line">  expect(a).toBeLessThanOrEqual(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 浮点数</span></span><br><span class="line">test(<span class="string">'匹配器：toBeCloseTo-两个浮点数字相加'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeCloseTo 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> value = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line">  <span class="comment">// expect(value).toBe(0.3);   这句会报错，因为浮点数有舍入误差</span></span><br><span class="line">  expect(value).toBeCloseTo(<span class="number">0.3</span>); <span class="comment">// 这句可以运行</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line">test(<span class="string">'匹配器：toBeNaN-等于NaN'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="literal">NaN</span>).toBeNaN();</span><br><span class="line">  expect(<span class="number">1</span>).not.toBeNaN();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="真假"><a href="#真假" class="headerlink" title="真假"></a>真假</h3><ul><li><code>toBeNull</code>只匹配 <code>null</code></li><li><code>toBeUndefined</code>只匹配 <code>undefined</code></li><li><code>toBeDefined</code> 与 <code>toBeUndefined</code>相反</li><li><code>toBeTruthy</code> 匹配任何 <code>if</code> 语句为真</li><li><code>toBeFalsy</code>匹配任何 <code>if</code> 语句为假</li></ul><h4 id="toBeNull"><a href="#toBeNull" class="headerlink" title=".toBeNull()"></a>.toBeNull()</h4><h4 id="toBeUndefined"><a href="#toBeUndefined" class="headerlink" title=".toBeUndefined()"></a>.toBeUndefined()</h4><h4 id="toBeDefined"><a href="#toBeDefined" class="headerlink" title=".toBeDefined()"></a>.toBeDefined()</h4><h4 id="toBeTruthy"><a href="#toBeTruthy" class="headerlink" title=".toBeTruthy()"></a>.toBeTruthy()</h4><h4 id="toBeFalsy"><a href="#toBeFalsy" class="headerlink" title=".toBeFalsy()"></a>.toBeFalsy()</h4><p>在JavaScript中，有六个falsy值：<code>false</code>，<code>0</code>，<code>&#39;&#39;</code>，<code>null</code>，<code>undefined</code>，和<code>NaN</code>。其他一切都是真实的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 真假相关</span></span><br><span class="line">test(<span class="string">'匹配器：toBeNull-与null相等'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeNull 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="literal">null</span></span><br><span class="line">  expect(a).toBeNull()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeUndefined-与undefined相等'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeUndefined 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="literal">undefined</span></span><br><span class="line">  expect(a).toBeUndefined()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeDefined-被定义过的,非 undefined 的，可为 null'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeDefined 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="literal">null</span></span><br><span class="line">  expect(a).toBeDefined()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeTruthy-真值或者隐藏为true的'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeTruthy 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">  expect(a).toBeTruthy()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'匹配器：toBeFalsy-真值或者隐藏为false的'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toBeFalsy 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="literal">null</span></span><br><span class="line">  expect(a).toBeFalsy()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="否定"><a href="#否定" class="headerlink" title="否定"></a>否定</h3><h4 id="not"><a href="#not" class="headerlink" title=".not"></a>.not</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'匹配器：not-不是xx'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// not 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">  expect(a).not.toBeFalsy()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-not-arrayContaining-array"><a href="#expect-not-arrayContaining-array" class="headerlink" title="expect.not.arrayContaining(array)"></a>expect.not.arrayContaining(array)</h4><p>匹配不是接收值的子集</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'not.arrayContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = [<span class="number">1</span>];</span><br><span class="line">  it(<span class="string">'如果接收的数组不包含1就通过测试'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]).toEqual(</span><br><span class="line">      expect.not.arrayContaining(expected)</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-not-objectContaining-object"><a href="#expect-not-objectContaining-object" class="headerlink" title="expect.not.objectContaining(object)"></a>expect.not.objectContaining(object)</h4><p>匹配不包含某个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'not.objectContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = &#123; <span class="attr">haha</span>: <span class="string">'laibh.top'</span> &#125;;</span><br><span class="line">  it(<span class="string">'如果接收的对象不包含&#123; haha: laibh.top &#125;就通过测试'</span>, () =&gt; &#123;</span><br><span class="line">    expect(&#123; <span class="attr">haha</span>: <span class="string">'laibh.top1'</span> &#125;).toEqual(</span><br><span class="line">      expect.not.objectContaining(expected)</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-not-stringContaining-string"><a href="#expect-not-stringContaining-string" class="headerlink" title="expect.not.stringContaining(string)"></a>expect.not.stringContaining(string)</h4><p>匹配不包含某个字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'not.stringContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = <span class="string">'赖同学'</span>;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'如果接收的字符串不完全等于赖同学就通过测试'</span>, () =&gt; &#123;</span><br><span class="line">    expect(<span class="string">'赖'</span>).toEqual(expect.not.stringContaining(expected));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="expect-not-stringMatching-string-regexp"><a href="#expect-not-stringMatching-string-regexp" class="headerlink" title="expect.not.stringMatching(string|regexp)"></a>expect.not.stringMatching(string|regexp)</h4><p>同上，不过参数可以是正则表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'not.stringMatching'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = <span class="regexp">/赖同学/</span>;</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'如果接收的字符串赖同学就通过测试'</span>, () =&gt; &#123;</span><br><span class="line">    expect(<span class="string">'赖'</span>).toEqual(expect.not.stringMatching(expected));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="toMatch-regexpOrString"><a href="#toMatch-regexpOrString" class="headerlink" title=".toMatch(regexpOrString)"></a>.toMatch(<code>regexpOrString</code>)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">test(<span class="string">'匹配器：toMatch-正则字符串匹配'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toMatch 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> str = <span class="string">'http://laibh.top'</span></span><br><span class="line">  expect(str).toMatch(<span class="string">'laibh'</span>)</span><br><span class="line">  <span class="comment">// 使用正则</span></span><br><span class="line">  expect(str).toMatch(<span class="regexp">/laibh/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-stringContaining-string"><a href="#expect-stringContaining-string" class="headerlink" title="expect.stringContaining(string)"></a>expect.stringContaining(string)</h4><p>匹配包含某个字符串</p><h4 id="expect-stringMatching-string-regexp"><a href="#expect-stringMatching-string-regexp" class="headerlink" title="expect.stringMatching(string|regexp)"></a>expect.stringMatching(string|regexp)</h4><p>匹配字符串，可用正则</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'stringMatching in arrayContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = [</span><br><span class="line">    expect.stringMatching(<span class="regexp">/^Alic/</span>),</span><br><span class="line">    expect.stringMatching(<span class="regexp">/^[BR]ob/</span>),</span><br><span class="line">  ];</span><br><span class="line">  it(<span class="string">'matches even if received contains additional elements'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'Alicia'</span>, <span class="string">'Roberto'</span>, <span class="string">'Evelina'</span>]).toEqual(</span><br><span class="line">      expect.arrayContaining(expected),</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'does not match if received does not contain expected elements'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'Roberto'</span>, <span class="string">'Evelina'</span>]).not.toEqual(</span><br><span class="line">      expect.arrayContaining(expected),</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="expect-toContain"><a href="#expect-toContain" class="headerlink" title="expect.toContain()"></a>expect.toContain()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line">test(<span class="string">'匹配器：toContain-数组包含某项'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toContain 匹配器 matchers</span></span><br><span class="line">  <span class="keyword">const</span> arr = [<span class="string">'lai'</span>, <span class="string">'bin'</span>, <span class="string">'hong'</span>]</span><br><span class="line">  <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>(arr)</span><br><span class="line">  expect(set).toContain(<span class="string">'lai'</span>)</span><br><span class="line">  expect(arr).toContain(<span class="string">'lai'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-arrayContaining-array"><a href="#expect-arrayContaining-array" class="headerlink" title="expect.arrayContaining(array)"></a>expect.arrayContaining(array)</h4><p>匹配子集</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'arrayContaining'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> expected = [<span class="string">'1'</span>, <span class="string">'2'</span>];</span><br><span class="line">  it(<span class="string">'即使接收值包含其他参数也匹配'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>]).toEqual(expect.arrayContaining(expected));</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">'只要接收值不包含期望的值就不匹配'</span>, () =&gt; &#123;</span><br><span class="line">    expect([<span class="string">'2'</span>, <span class="string">'4'</span>]).not.toEqual(expect.arrayContaining(expected));</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="objectContaining-object"><a href="#objectContaining-object" class="headerlink" title="objectContaining(object)"></a>objectContaining(object)</h4><p>匹配任何递归预期属性的接收对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'测试onPress函数回调参数匹配对象'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> onPress = jest.fn();</span><br><span class="line">  simulatePresses(onPress)</span><br><span class="line">  expect(onPress).toBeCalledWith(</span><br><span class="line">    expect.objectContaining(&#123;</span><br><span class="line">      x: expect.any(<span class="built_in">Number</span>),</span><br><span class="line">      y: expect.any(<span class="built_in">Number</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="toHaveProperty-keyPath-value"><a href="#toHaveProperty-keyPath-value" class="headerlink" title=".toHaveProperty(keyPath,value?)"></a>.toHaveProperty(keyPath,value?)</h4><p>检查对象中各种属性存在和值，第二个参数是可选的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object containing house features to be tested</span></span><br><span class="line"><span class="keyword">const</span> houseForSale = &#123;</span><br><span class="line">  bath: <span class="literal">true</span>,</span><br><span class="line">  bedrooms: <span class="number">4</span>,</span><br><span class="line">  kitchen: &#123;</span><br><span class="line">    amenities: [<span class="string">'oven'</span>, <span class="string">'stove'</span>, <span class="string">'washer'</span>],</span><br><span class="line">    area: <span class="number">20</span>,</span><br><span class="line">    wallColor: <span class="string">'white'</span>,</span><br><span class="line">    <span class="string">'nice.oven'</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'ceiling.height'</span>: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'this house has my desired features'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// Simple Referencing</span></span><br><span class="line">  expect(houseForSale).toHaveProperty(<span class="string">'bath'</span>);</span><br><span class="line">  expect(houseForSale).toHaveProperty(<span class="string">'bedrooms'</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  expect(houseForSale).not.toHaveProperty(<span class="string">'pool'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 嵌套深层用 .</span></span><br><span class="line">  expect(houseForSale).toHaveProperty(<span class="string">'kitchen.area'</span>, <span class="number">20</span>);</span><br><span class="line">  expect(houseForSale).toHaveProperty(<span class="string">'kitchen.amenities'</span>, [</span><br><span class="line">    <span class="string">'oven'</span>,</span><br><span class="line">    <span class="string">'stove'</span>,</span><br><span class="line">    <span class="string">'washer'</span>,</span><br><span class="line">  ]);</span><br><span class="line"></span><br><span class="line">  expect(houseForSale).not.toHaveProperty(<span class="string">'kitchen.open'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 嵌套深层用 []</span></span><br><span class="line">  expect(houseForSale).toHaveProperty([<span class="string">'kitchen'</span>, <span class="string">'area'</span>], <span class="number">20</span>);</span><br><span class="line">  expect(houseForSale).toHaveProperty(</span><br><span class="line">    [<span class="string">'kitchen'</span>, <span class="string">'amenities'</span>],</span><br><span class="line">    [<span class="string">'oven'</span>, <span class="string">'stove'</span>, <span class="string">'washer'</span>],</span><br><span class="line">  );</span><br><span class="line">  expect(houseForSale).toHaveProperty([<span class="string">'kitchen'</span>, <span class="string">'amenities'</span>, <span class="number">0</span>], <span class="string">'oven'</span>);</span><br><span class="line">  expect(houseForSale).toHaveProperty([<span class="string">'kitchen'</span>, <span class="string">'nice.oven'</span>]);</span><br><span class="line">  expect(houseForSale).not.toHaveProperty([<span class="string">'kitchen'</span>, <span class="string">'open'</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Referencing keys with dot in the key itself</span></span><br><span class="line">  expect(houseForSale).toHaveProperty([<span class="string">'ceiling.height'</span>], <span class="string">'tall'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toMatchObject-object"><a href="#toMatchObject-object" class="headerlink" title=".toMatchObject(object)"></a>.toMatchObject(object)</h4><p>检查对象的属性的子集相匹配</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> houseForSale = &#123;</span><br><span class="line">  bath: <span class="literal">true</span>,</span><br><span class="line">  bedrooms: <span class="number">4</span>,</span><br><span class="line">  kitchen: &#123;</span><br><span class="line">    amenities: [<span class="string">'oven'</span>, <span class="string">'stove'</span>, <span class="string">'washer'</span>],</span><br><span class="line">    area: <span class="number">20</span>,</span><br><span class="line">    wallColor: <span class="string">'white'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> desiredHouse = &#123;</span><br><span class="line">  bath: <span class="literal">true</span>,</span><br><span class="line">  kitchen: &#123;</span><br><span class="line">    amenities: [<span class="string">'oven'</span>, <span class="string">'stove'</span>, <span class="string">'washer'</span>],</span><br><span class="line">    wallColor: expect.stringMatching(<span class="regexp">/white|yellow/</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'the house has my desired features'</span>, () =&gt; &#123;</span><br><span class="line">  expect(houseForSale).toMatchObject(desiredHouse);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><h4 id="toBeInstanceOf-Class"><a href="#toBeInstanceOf-Class" class="headerlink" title=".toBeInstanceOf(Class)"></a>.toBeInstanceOf(Class)</h4><p>检查对象是一个类的实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">expect(<span class="keyword">new</span> A()).toBeInstanceOf(A);</span><br><span class="line">expect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;).toBeInstanceOf(<span class="built_in">Function</span>);</span><br><span class="line">expect(<span class="keyword">new</span> A()).toBeInstanceOf(<span class="built_in">Function</span>); <span class="comment">// throws</span></span><br></pre></td></tr></table></figure><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><h4 id="toThrow-error"><a href="#toThrow-error" class="headerlink" title=".toThrow(error?)"></a>.toThrow(error?)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> throwNewErrorFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'this is a new error'</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异常</span></span><br><span class="line">test(<span class="string">'匹配器：toThrow-测试抛出异常'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// toThrow 匹配器 matchers</span></span><br><span class="line">  expect(throwNewErrorFunc).toThrow()</span><br><span class="line">  <span class="comment">// 测试抛出的内容</span></span><br><span class="line">  expect(throwNewErrorFunc).toThrow(<span class="string">'this is a new error'</span>)</span><br><span class="line">  <span class="comment">// 表达式也行</span></span><br><span class="line">  expect(throwNewErrorFunc).toThrow(<span class="regexp">/this is a new error/</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="任意"><a href="#任意" class="headerlink" title="任意"></a>任意</h3><h4 id="expect-anything"><a href="#expect-anything" class="headerlink" title="expect.anything()"></a>expect.anything()</h4><p>匹配除了 <code>null</code>、<code>undefined</code>的任意值，可以它使用在 <code>toEqual</code>或者 <code>toBeCalledWith</code>里面替代文字值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'map 遍历一个非空的参数'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> mock = jest.fn();</span><br><span class="line">    [<span class="number">1</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> mock(x))</span><br><span class="line">    expect(mock).toBeCalledWith(expect.anything())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-any-constructor"><a href="#expect-any-constructor" class="headerlink" title="expect.any(constructor)"></a>expect.any(constructor)</h4><p>匹配任意构造器生成的实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randocall</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn(<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">6</span> + <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line">test(<span class="string">'测试 randocall的回调函数调用了一个数字'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> mock = jest.fn();</span><br><span class="line">    randocall(mock)</span><br><span class="line">    expect(mock).toBeCalledWith(expect.any(<span class="built_in">Number</span>))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="toHaveLength-number"><a href="#toHaveLength-number" class="headerlink" title=".toHaveLength(number)"></a>.toHaveLength(number)</h4><p>检查对象有个 length 属性并将设为某一数值。这对于检查数组或字符串大小特别有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).toHaveLength(<span class="number">3</span>);</span><br><span class="line">expect(<span class="string">'abc'</span>).toHaveLength(<span class="number">3</span>);</span><br><span class="line">expect(<span class="string">''</span>).not.toHaveLength(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h4 id="toContain-item"><a href="#toContain-item" class="headerlink" title=".toContain(item)"></a>.toContain(item)</h4><p>检查项目在数组或者字符串是否是另一个字符串的子串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'the flavor list contains lime'</span>, () =&gt; &#123;</span><br><span class="line">  expect(getAllFlavors()).toContain(<span class="string">'lime'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toContainEqual-item"><a href="#toContainEqual-item" class="headerlink" title=".toContainEqual(item)"></a>.toContainEqual(item)</h4><p>检查具有特定结构和值的元素是否包含在数据中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">'test contain'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> testValue = &#123; <span class="attr">bol</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  expect([&#123; <span class="attr">bol</span>: <span class="literal">true</span> &#125;, &#123; <span class="attr">sour</span>: <span class="literal">false</span> &#125;]).toContainEqual(testValue)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="异步相关"><a href="#异步相关" class="headerlink" title="异步相关"></a>异步相关</h3><h4 id="expect-assertions"><a href="#expect-assertions" class="headerlink" title="expect.assertions()"></a>expect.assertions()</h4><p>匹配在测试用例里面使用断言的次数。确保在异步函数为了确保在回调函数里面断言被调用特别有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'异步调用所有回调'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="comment">// 确保有两个断言被调用</span></span><br><span class="line">    expect.assertions(<span class="number">2</span>)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback1</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        expect(data).toBeTruthy()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">callback2</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        expect(data).toBeTruthy();</span><br><span class="line">    &#125;</span><br><span class="line">    doAsync(callback1,callback2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="expect-hasAssertions"><a href="#expect-hasAssertions" class="headerlink" title="expect.hasAssertions()"></a>expect.hasAssertions()</h4><p>匹配在测试用例里面至少使用一次断言</p><h4 id="resolves"><a href="#resolves" class="headerlink" title=".resolves"></a>.resolves</h4><p>使用 <code>resolves</code>解开 fulfilled promise，如果 reject promise，则断言失败</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'resolves to lemon'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// make sure to add a return statement</span></span><br><span class="line">  <span class="keyword">return</span> expect(<span class="built_in">Promise</span>.resolve(<span class="string">'lemon'</span>)).resolves.toBe(<span class="string">'lemon'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>测试是异步的，需要告诉 jest 等待返回解开的断言</p><p>也可以用 <code>async/await</code>结合 <code>.resolves</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'resolves to lemon'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="built_in">Promise</span>.resolve(<span class="string">'lemon'</span>)).resolves.toBe(<span class="string">'lemon'</span>);</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="built_in">Promise</span>.resolve(<span class="string">'lemon'</span>)).resolves.not.toBe(<span class="string">'octopus'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="rejects"><a href="#rejects" class="headerlink" title=".rejects"></a>.rejects</h4><p>使用 <code>rejects</code>解开 rejected  promise,如果 fulfilled promise,则断言失败</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'rejects to octopus'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// make sure to add a return statement</span></span><br><span class="line">  <span class="keyword">return</span> expect(<span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'octopus'</span>))).rejects.toThrow(<span class="string">'octopus'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>测试是异步的，需要告诉 jest 等待返回解开的断言</p><p>同样使用  <code>async/await</code>结合 <code>.rejects</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'rejects to octopus'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'octopus'</span>))).rejects.toThrow(<span class="string">'octopus'</span>);</span><br><span class="line">  <span class="keyword">await</span> expect(<span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'octopus'</span>))).rejects.not.toThrow(<span class="string">'lemon'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><h4 id="toHaveBeenCalled-toBeCalled"><a href="#toHaveBeenCalled-toBeCalled" class="headerlink" title=".toHaveBeenCalled()|.toBeCalled()"></a>.toHaveBeenCalled()|.toBeCalled()</h4><p>确保模拟功能得到调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drinkAll</span>(<span class="params">cb, flavour</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (flavour !== <span class="string">'octopus'</span>) &#123;</span><br><span class="line">    cb(flavour)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'test drinkAll function'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'drink somthing lemon-flavour'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">    drinkAll(drink, <span class="string">'lemon'</span>)</span><br><span class="line">    expect(drink).toBeCalled();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'test drinkAll function'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'does not drink somthing octopus-flavour'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">    drinkAll(drink, <span class="string">'octopus'</span>)</span><br><span class="line">    expect(drink).not.toBeCalled();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'test drinkAll function'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'drink somthing lemon-flavour'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">    drinkAll(drink, <span class="string">'lemon'</span>)</span><br><span class="line">    expect(drink).toHaveBeenCalled();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'test drinkAll function'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'does not drink somthing octopus-flavour'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">    drinkAll(drink, <span class="string">'octopus'</span>)</span><br><span class="line">    expect(drink).not.toHaveBeenCalled();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="toHaveBeenCallTimes-number-toBeCalledTimes-number"><a href="#toHaveBeenCallTimes-number-toBeCalledTimes-number" class="headerlink" title=".toHaveBeenCallTimes(number)|.toBeCalledTimes(number)"></a>.toHaveBeenCallTimes(number)|.toBeCalledTimes(number)</h4><p>确保模拟功能得到调用次数与指定数字一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drinkEach drinks each drink'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">  drinkEach(drink, [<span class="string">'lemon'</span>, <span class="string">'octopus'</span>]);</span><br><span class="line">  expect(drink).toHaveBeenCalledTimes(<span class="number">2</span>);</span><br><span class="line">  expect(drink).toBeCalledTimes(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toHaveBeenCalledWith-arg1-arg2-…-toBeCalledWith-arg1-arg2-…"><a href="#toHaveBeenCalledWith-arg1-arg2-…-toBeCalledWith-arg1-arg2-…" class="headerlink" title=".toHaveBeenCalledWith(arg1,arg2,…)|.toBeCalledWith(arg1,arg2,…)"></a>.toHaveBeenCalledWith(arg1,arg2,…)|.toBeCalledWith(arg1,arg2,…)</h4><p>确保模拟功能被调用的具体参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calledWithArg</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  cb(<span class="string">'Arg'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'test calledWithArg'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line">  calledWithArg(fn);</span><br><span class="line">  expect(fn).toBeCalledWith(<span class="string">'Arg'</span>);</span><br><span class="line">  expect(fn).toHaveBeenCalledWith(<span class="string">'Arg'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toHaveBeenLastCalledWith-arg1-arg2-…-lastCalledWith-arg1-arg2-…"><a href="#toHaveBeenLastCalledWith-arg1-arg2-…-lastCalledWith-arg1-arg2-…" class="headerlink" title=".toHaveBeenLastCalledWith(arg1,arg2,…)|.lastCalledWith(arg1, arg2, …)"></a>.toHaveBeenLastCalledWith(arg1,arg2,…)|.lastCalledWith(arg1, arg2, …)</h4><p>确保模拟功能被最后一次调用的具体参数</p><h4 id="toHaveBeenNthCalledWith-nthCall-arg1-arg2-…-nthCalledWith-nthCall-arg1-arg2-…"><a href="#toHaveBeenNthCalledWith-nthCall-arg1-arg2-…-nthCalledWith-nthCall-arg1-arg2-…" class="headerlink" title=".toHaveBeenNthCalledWith(nthCall, arg1, arg2, ….)|.nthCalledWith(nthCall, arg1, arg2, ….)"></a>.toHaveBeenNthCalledWith(nthCall, arg1, arg2, ….)|.nthCalledWith(nthCall, arg1, arg2, ….)</h4><p>确保模拟功能多次调用的顺序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drinkEach drinks each drink'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn();</span><br><span class="line">  drinkEach(drink, [<span class="string">'lemon'</span>, <span class="string">'octopus'</span>]);</span><br><span class="line">  expect(drink).toHaveBeenNthCalledWith(<span class="number">1</span>, <span class="string">'lemon'</span>);</span><br><span class="line">  expect(drink).toHaveBeenNthCalledWith(<span class="number">2</span>, <span class="string">'octopus'</span>);</span><br><span class="line">  expect(drink).nthCalledWith(<span class="number">1</span>, <span class="string">'lemon'</span>);</span><br><span class="line">  expect(drink).nthCalledWith(<span class="number">2</span>, <span class="string">'octopus'</span>);    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>n 必须是从 1开始的正整数</p><h4 id="toHaveReturned-toReturn"><a href="#toHaveReturned-toReturn" class="headerlink" title=".toHaveReturned()|.toReturn()"></a>.toHaveReturned()|.toReturn()</h4><p>测试模拟函数成功返回(即没有抛出错误)至少一次</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'test calledWithArg'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line">  calledWithArg(fn);</span><br><span class="line">  expect(fn).toHaveReturned();</span><br><span class="line">  expect(fn).toReturn();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toHaveReturnedTimes-number-toReturnTimes-number"><a href="#toHaveReturnedTimes-number-toReturnTimes-number" class="headerlink" title=".toHaveReturnedTimes(number)|.toReturnTimes(number)"></a>.toHaveReturnedTimes(number)|.toReturnTimes(number)</h4><p>确保模拟函数返回成功的次数,抛出错误的模拟函数的任何调用都不计入函数返回的次数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'drink returns twice'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> drink = jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  drink();</span><br><span class="line">  drink();</span><br><span class="line"></span><br><span class="line">  expect(drink).toHaveReturnedTimes(<span class="number">2</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toHaveReturnedWith-value-toReturnWith-value"><a href="#toHaveReturnedWith-value-toReturnWith-value" class="headerlink" title=".toHaveReturnedWith(value)|.toReturnWith(value)"></a>.toHaveReturnedWith(value)|.toReturnWith(value)</h4><p>确保模拟函数返回特定的值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'test Return 123'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn(<span class="function"><span class="params">()</span> =&gt;</span> <span class="number">123</span>);</span><br><span class="line">  calledWithArg(fn);</span><br><span class="line">  expect(fn).toHaveReturnedWith(<span class="number">123</span>)</span><br><span class="line">  expect(fn).toReturnWith(<span class="number">123</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="toHaveLastReturnedWith-value-lastReturnedWith-value"><a href="#toHaveLastReturnedWith-value-lastReturnedWith-value" class="headerlink" title=".toHaveLastReturnedWith(value)|.lastReturnedWith(value)"></a>.toHaveLastReturnedWith(value)|.lastReturnedWith(value)</h4><p>确保模拟函数最后一次返回特定的值</p><h4 id="toHaveNthReturnedWith-nthCall-value-nthReturnedWith-nthCall-value"><a href="#toHaveNthReturnedWith-nthCall-value-nthReturnedWith-nthCall-value" class="headerlink" title=".toHaveNthReturnedWith(nthCall, value)|.nthReturnedWith(nthCall, value)"></a>.toHaveNthReturnedWith(nthCall, value)|.nthReturnedWith(nthCall, value)</h4><p>确保模拟函数第n次调用返回特定的值</p><p>第n个参数必须是从1开始的正整数。</p><h3 id="自定义扩展"><a href="#自定义扩展" class="headerlink" title="自定义扩展"></a>自定义扩展</h3><h4 id="expect-extend"><a href="#expect-extend" class="headerlink" title="expect.extend()"></a>expect.extend()</h4><p><code>pass</code>表示是否有匹配，<code>message</code>提供一个没有参数的函数，在出现错误的情况下返回消息。当<code>pass:false</code>，<code>message</code>返回 <code>expect(x).matcher()</code>失败的错误信息，<code>pass:true</code>，<code>message</code>返回当<code>expect(x).not.matcher()</code>失败时的错误消息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// expect.extend(matchers)</span></span><br><span class="line">expect.extend(&#123;</span><br><span class="line">  toBeWithinRange(reveived, floor, ceiling) &#123;</span><br><span class="line">    <span class="keyword">const</span> pass = reveived &gt;= floor &amp;&amp; reveived &lt;= ceiling;</span><br><span class="line">    <span class="keyword">if</span> (pass) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        message: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`期待 <span class="subst">$&#123;reveived&#125;</span> 不在范围<span class="subst">$&#123;floor&#125;</span>-<span class="subst">$&#123;ceiling&#125;</span>内`</span>,</span><br><span class="line">        pass,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        message: <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">`期待 <span class="subst">$&#123;reveived&#125;</span> 在范围<span class="subst">$&#123;floor&#125;</span>-<span class="subst">$&#123;ceiling&#125;</span>内`</span>,</span><br><span class="line">        pass,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'测试范围'</span>, () =&gt; &#123;</span><br><span class="line">  expect(<span class="number">100</span>).toBeWithinRange(<span class="number">90</span>, <span class="number">100</span>)</span><br><span class="line">  expect(<span class="number">101</span>).not.toBeWithinRange(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">  expect(&#123; <span class="attr">apples</span>: <span class="number">6</span>, <span class="attr">bananas</span>: <span class="number">3</span> &#125;).toEqual(&#123;</span><br><span class="line">    apples: expect.toBeWithinRange(<span class="number">1</span>, <span class="number">10</span>),</span><br><span class="line">    bananas: expect.not.toBeWithinRange(<span class="number">11</span>, <span class="number">20</span>),</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>异步扩展,需要结合 <code>async</code>和 <code>await</code>函数来使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">expect.extend(&#123;</span><br><span class="line">    <span class="keyword">async</span> toBeDivisibleByExternalValue(reveived)&#123;</span><br><span class="line">        <span class="comment">// 异步获取的除数</span></span><br><span class="line">        <span class="keyword">const</span> externalValue = <span class="keyword">await</span> getExternalValueFromRemoteSource();</span><br><span class="line">        <span class="keyword">const</span> pass = received % externalValue == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(pass)&#123;</span><br><span class="line">            <span class="keyword">return</span>&#123;</span><br><span class="line">                message:<span class="function"><span class="params">()</span>=&gt;</span><span class="string">`期待<span class="subst">$&#123;received&#125;</span>不被<span class="subst">$&#123;externalValue&#125;</span>整除`</span>,</span><br><span class="line">                pass</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span>&#123;</span><br><span class="line">                message:<span class="function"><span class="params">()</span>=&gt;</span><span class="string">`期待<span class="subst">$&#123;received&#125;</span>被<span class="subst">$&#123;externalValue&#125;</span>整除`</span>,</span><br><span class="line">                pass</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><a href="https://jestjs.io/docs/zh-Hans/expect">更多</a></p><h3 id="测试异步代码"><a href="#测试异步代码" class="headerlink" title="测试异步代码"></a>测试异步代码</h3><p>回调形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetchData.js</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'@/utils/request'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchData = <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">  request(<span class="string">'http://www.dell-lee.com/react/api/demo.json'</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.data) cb(res.data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fetchData</span><br><span class="line"><span class="comment">// fetchData.test.js</span></span><br><span class="line"><span class="keyword">import</span> fetchData <span class="keyword">from</span> <span class="string">'./fetchData'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line">test(<span class="string">'fetch 返回结果为 &#123;success: true&#125;'</span>, () =&gt; &#123;</span><br><span class="line">  fetchData(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    expect(data).toEqual(&#123;</span><br><span class="line">      success: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调类型异步函数</span></span><br><span class="line">test(<span class="string">'fetch 返回结果为 &#123;success: true&#125;'</span>, (done) =&gt; &#123;</span><br><span class="line">  fetchData(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    expect(data).toEqual(&#123;</span><br><span class="line">      success: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    done();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetchData.js</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">'@/utils/request'</span>;</span><br><span class="line"><span class="keyword">const</span> fetchData = <span class="function"><span class="params">()</span> =&gt;</span> request(<span class="string">'http://www.dell-lee.com/react/api/demo.json'</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fetchData</span><br><span class="line"></span><br><span class="line"><span class="comment">//fetchData.test.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fetchData <span class="keyword">from</span> <span class="string">'./fetchData'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line">test(<span class="string">'fetch 返回结果为 &#123;success: true&#125;'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    expect(res.data).toEqual(&#123; <span class="attr">success</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 测试404</span></span><br><span class="line">test(<span class="string">'fetchData 返回结果为404'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 要求至少跑一次 expect</span></span><br><span class="line">  expect.assertions(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> fetchData().catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    expect(e.toString().indexOf(<span class="string">'404'</span>) &gt; <span class="number">-1</span>).toBe(<span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// .resolves / .rejects</span></span><br><span class="line">test(<span class="string">'fetch 返回结果为 &#123;success: true&#125;'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> expect(fetchData()).resolves.toMatchObject(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      success: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'fetchData 返回结果为404'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> expect(fetchData()).rejects.toThrow()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Async/Await</span></span><br><span class="line">test(<span class="string">'fetch 返回结果为 &#123;success: true&#125;'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(fetchData()).resolves.toMatchObject(&#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">      success: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'fetchData 返回结果为404'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> expect(fetchData()).rejects.toThrow()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 另一种 Async/Await</span></span><br><span class="line">test(<span class="string">'fetch 返回结果为 &#123;success: true&#125;'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">await</span> fetchData()</span><br><span class="line">  expect(res.data).toEqual(&#123;</span><br><span class="line">    success: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'fetchData 返回结果为404'</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  expect.assertions(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> fetchData()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="keyword">await</span> expect(e.toString()).toEqual(<span class="string">'Error: Request failed with status code 404'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Couter.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.number = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addOne() &#123;</span><br><span class="line">    <span class="keyword">this</span>.number += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addTwo() &#123;</span><br><span class="line">    <span class="keyword">this</span>.number += <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  minusOne() &#123;</span><br><span class="line">    <span class="keyword">this</span>.number -= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  minusTwo() &#123;</span><br><span class="line">    <span class="keyword">this</span>.number -= <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Counter;</span><br><span class="line"><span class="comment">// Couter.test.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">'./Couter'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'测试 Counter'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">let</span> couter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所有测试开始之前</span></span><br><span class="line">  beforeAll(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    couter = <span class="keyword">new</span> Counter();</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 每个测试用例开始之前</span></span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 每次测试都会生成一个新的 couter</span></span><br><span class="line">    couter = <span class="keyword">new</span> Counter();</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 每个测试用例结束之后</span></span><br><span class="line">  afterEach(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;)</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 所有测试结束之后</span></span><br><span class="line">  afterAll(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  describe(<span class="string">'测试增加相关代码'</span>,()=&gt;&#123;</span><br><span class="line">    test(<span class="string">'测试 Conter 中的 addOne 方法'</span>, () =&gt; &#123;</span><br><span class="line">      couter.addOne();</span><br><span class="line">      expect(couter.number).toBe(<span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    test(<span class="string">'测试 Conter 中的 addTwo 方法'</span>, () =&gt; &#123;</span><br><span class="line">      couter.addTwo();</span><br><span class="line">      expect(couter.number).toBe(<span class="number">2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  describe(<span class="string">'测试减少相关代码'</span>,()=&gt;&#123;</span><br><span class="line">    test(<span class="string">'测试 Conter 中的 minusOne 方法'</span>, () =&gt; &#123;</span><br><span class="line">      couter.minusOne();</span><br><span class="line">      expect(couter.number).toBe(<span class="number">-1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  </span><br><span class="line">    test(<span class="string">'测试 Conter 中的 minusTwo 方法'</span>, () =&gt; &#123;</span><br><span class="line">      couter.minusTwo();</span><br><span class="line">      expect(couter.number).toBe(<span class="number">-2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>describe 里面就是一个作用域，嵌套作用域可以有多个钩子函数，钩子函数执行顺序由外到内</p><p><code>test.only</code>，只执行某个测试用例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">'测试减少相关代码'</span>,()=&gt;&#123;</span><br><span class="line">  test.only(<span class="string">'测试 Conter 中的 minusOne 方法'</span>, () =&gt; &#123;</span><br><span class="line">    couter.minusOne();</span><br><span class="line">    expect(couter.number).toBe(<span class="number">-1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  test(<span class="string">'测试 Conter 中的 minusTwo 方法'</span>, () =&gt; &#123;</span><br><span class="line">    couter.minusTwo();</span><br><span class="line">    expect(couter.number).toBe(<span class="number">-2</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Mock"><a href="#Mock" class="headerlink" title="Mock"></a>Mock</h3><ol><li>捕获函数的调用，this 指向，调用顺序</li><li>自由设置返回结果</li><li>改变内部函数的实现</li></ol><h4 id="基本模拟-导入函数"><a href="#基本模拟-导入函数" class="headerlink" title="基本模拟-导入函数"></a>基本模拟-导入函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo</span></span><br><span class="line"><span class="keyword">const</span> runCallback = <span class="function">(<span class="params">cb</span>) =&gt;</span> &#123;</span><br><span class="line">  cb();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> runCallback</span><br><span class="line"></span><br><span class="line"><span class="comment">//demo.test.js</span></span><br><span class="line"><span class="keyword">import</span> runCallback <span class="keyword">from</span> <span class="string">'./demo'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'测试 runCallback 方法'</span>, () =&gt; &#123;</span><br><span class="line">  test(<span class="string">'runCallback被调用,并只调用了一次'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="comment">// mock 函数，捕获函数的调用</span></span><br><span class="line">    <span class="keyword">const</span> func = jest.fn();</span><br><span class="line">    <span class="comment">// 方法返回一次 值 Haha，mockReturnValue则是都返回，也可以在 jest.fn(()=&gt;&#123;return 'Haha'&#125;)定义</span></span><br><span class="line">    func.mockReturnValueOnce(<span class="string">'Haha'</span>)</span><br><span class="line">    runCallback(func)</span><br><span class="line">    expect(func).toBeCalled()</span><br><span class="line">    expect(func.mock.calls.length).toBe(<span class="number">1</span>)</span><br><span class="line">    expect(func.mock.results[<span class="number">0</span>].value).toBe(<span class="string">'Haha'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(func.mock)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  ● Console</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    console.log src/lesson2/demo.test.js:14</span></span><br><span class="line"><span class="comment">      &#123; calls: [ [] ],</span></span><br><span class="line"><span class="comment">        instances: [ undefined ],</span></span><br><span class="line"><span class="comment">        invocationCallOrder: [ 1 ],</span></span><br><span class="line"><span class="comment">        results: [ &#123; type: 'return', value: 'Haha' &#125; ] &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="修改原来函数的返回"><a href="#修改原来函数的返回" class="headerlink" title="修改原来函数的返回"></a>修改原来函数的返回</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xx.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchData = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    axios.get(<span class="string">'/'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>res.data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (function()&#123;return '123' &#125;)()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> fetchData;</span><br><span class="line"><span class="comment">// xx.test.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fetchData <span class="keyword">from</span> <span class="string">'./xx.js'</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">ject.mock(<span class="string">'axios'</span>)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'fetchData 测试'</span>,()=&gt;&#123;</span><br><span class="line">    axios.get.mockResolvedValue(&#123;</span><br><span class="line">        data:<span class="string">"(function()&#123;return '123' &#125;)()"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">        expect(<span class="built_in">eval</span>(data)).toEqual(<span class="string">'123'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="mocks-文件夹"><a href="#mocks-文件夹" class="headerlink" title="__mocks__文件夹"></a><code>__mocks__</code>文件夹</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __mock__/xx.js</span></span><br><span class="line"><span class="keyword">const</span> fetchData = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolved,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        resolve(<span class="string">"(function()&#123;return '123' &#125;)()"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着改测试，模拟函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xx.test.js</span></span><br><span class="line">jest.mock(<span class="string">'./xx'</span>)</span><br><span class="line"><span class="keyword">import</span> fetchData <span class="keyword">from</span> <span class="string">'./xx.js'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'fetchData 测试'</span>,()=&gt;&#123;</span><br><span class="line">    axios.get.mockResolvedValue(&#123;</span><br><span class="line">        data:<span class="string">"(function()&#123;return '123' &#125;)()"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">        expect(<span class="built_in">eval</span>(data)).toEqual(<span class="string">'123'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述函数顶部那步模拟也可以通过在 jest.config.js 中修改配置 <code>automock：true</code> 改为自动模拟，那么引入对应的函数的时候就会自动去 <code>__mocks__</code>文件夹里面去寻找对应的模拟函数。注意一旦开启这个配置，需要启动才会生效，另外也会导致很多测试需要重新修改。</p><h4 id="同时存在-mocks-以及导入函数"><a href="#同时存在-mocks-以及导入函数" class="headerlink" title="同时存在__mocks__以及导入函数"></a>同时存在<code>__mocks__</code>以及导入函数</h4><p>在原来 xx.js 基础上面新增 一个 <code>getNumber</code>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">xx.js</span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fetchData = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    axios.get(<span class="string">'/'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>res.data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// (function()&#123;return '123' &#125;)()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getNumber = <span class="function"><span class="params">()</span>=&gt;</span> <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">fetchData,</span><br><span class="line">    getNumber</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接着修改测试用例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xx.test.js</span></span><br><span class="line">jest.mock(<span class="string">'./xx'</span>)</span><br><span class="line"><span class="keyword">import</span> fetchData <span class="keyword">from</span> <span class="string">'./xx.js'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'fetchData 测试'</span>,()=&gt;&#123;</span><br><span class="line">    axios.get.mockResolvedValue(&#123;</span><br><span class="line">        data:<span class="string">"(function()&#123;return '123' &#125;)()"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">        expect(<span class="built_in">eval</span>(data)).toEqual(<span class="string">'123'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">test(<span class="string">'getNumber 测试'</span>,()=&gt;&#123;</span><br><span class="line">expect(getNumber()).toBe(<span class="number">123</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上述代码会报错，<code>getNumebr</code> 找不到对应的函数，因为测试用例还是会去<code>__mocks__</code> 文件夹去寻找 <code>getNumber</code>。但是我们只希望模拟异步的函数，对于同步函数希望通过导入的方式来测试，那么就从原来的js文件中导入 <code>getNumber</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xx.test.js</span></span><br><span class="line">jest.mock(<span class="string">'./xx'</span>)</span><br><span class="line"><span class="keyword">import</span> fetchData <span class="keyword">from</span> <span class="string">'./xx.js'</span></span><br><span class="line"><span class="keyword">const</span> &#123; getNumber &#125; = jest.requireActual(<span class="string">'./xx'</span>)</span><br><span class="line">test(<span class="string">'fetchData 测试'</span>,()=&gt;&#123;</span><br><span class="line">    axios.get.mockResolvedValue(&#123;</span><br><span class="line">        data:<span class="string">"(function()&#123;return '123' &#125;)()"</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> fetchData().then(<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">        expect(<span class="built_in">eval</span>(data)).toEqual(<span class="string">'123'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line">test(<span class="string">'getNumber 测试'</span>,()=&gt;&#123;</span><br><span class="line">expect(getNumber()).toBe(<span class="number">123</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Mock-Timer"><a href="#Mock-Timer" class="headerlink" title="Mock Timer"></a>Mock Timer</h3><p>写一个 setTimeout 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timer.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (cb)=&gt;&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    cb()</span><br><span class="line">  &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timer.test.js</span></span><br><span class="line"><span class="keyword">import</span> timer <span class="keyword">from</span> <span class="string">'./timer'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'timer 测试'</span>,(done)=&gt;&#123;</span><br><span class="line">  timer(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    expect(<span class="number">2</span>).toBe(<span class="number">1</span>)</span><br><span class="line">    done();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的测试用例会直接通过， <code>timer</code>是一个异步函数，并不会执行函数体内的内容，需要像之前的异步函数一样，加个 done 参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timer <span class="keyword">from</span> <span class="string">'./timer'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'timer 测试'</span>,(done)=&gt;&#123;</span><br><span class="line">  timer(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    expect(<span class="number">2</span>).toBe(<span class="number">1</span>)</span><br><span class="line">    done();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接着测试用例便会运行，并报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">FAIL  src/lesson3/timer.test.js (7.997s)</span><br><span class="line"> ● Console</span><br><span class="line"></span><br><span class="line">   console.error node_modules/_jsdom@11.12.0@jsdom/lib/jsdom/virtual-console.js:29</span><br><span class="line">     Error: Uncaught [Error: expect(received).toBe(expected) // Object.is equality</span><br><span class="line">     </span><br><span class="line">     Expected: 1</span><br><span class="line">     Received: 2]</span><br><span class="line">         at reportException (F:\赖彬鸿\git-project\usual\Egret-Project\FontendTest\node_modules\_jsdom@11.12.0@jsdom\lib\jsdom\living\helpers\runtime-script-errors.js:66:24)</span><br><span class="line">         at Timeout.callback [as _onTimeout] (F:\赖彬鸿\git-project\usual\Egret-Project\FontendTest\node_modules\_jsdom@11.12.0@jsdom\lib\jsdom\browser\Window.js:680:7)</span><br><span class="line">         at ontimeout (timers.js:436:11)</span><br><span class="line">         at tryOnTimeout (timers.js:300:5)</span><br><span class="line">         at listOnTimeout (timers.js:263:5)</span><br><span class="line">         at Timer.processTimers (timers.js:223:10) &#123; Error: expect(received).toBe(expected) // Object.is equality</span><br><span class="line">     </span><br><span class="line">     Expected: 1</span><br><span class="line">     Received: 2</span><br><span class="line">         at toBe (F:\赖彬鸿\git-project\usual\Egret-Project\FontendTest\src\lesson3\timer.test.js:5:15)</span><br><span class="line">         at cb (F:\赖彬鸿\git-project\usual\Egret-Project\FontendTest\src\lesson3\timer.js:3:5)</span><br><span class="line">         at Timeout.callback [as _onTimeout] (F:\赖彬鸿\git-project\usual\Egret-Project\FontendTest\node_modules\_jsdom@11.12.0@jsdom\lib\jsdom\browser\Window.js:678:19)</span><br><span class="line">         at ontimeout (timers.js:436:11)</span><br><span class="line">         at tryOnTimeout (timers.js:300:5)</span><br><span class="line">         at listOnTimeout (timers.js:263:5)</span><br><span class="line">         at Timer.processTimers (timers.js:223:10)</span><br><span class="line">       matcherResult:</span><br><span class="line">        &#123; actual: 2,</span><br><span class="line">          expected: 1,</span><br><span class="line">          message: [Function],</span><br><span class="line">          name: 'toBe',</span><br><span class="line">          pass: false &#125; &#125;</span><br></pre></td></tr></table></figure><p>也可以通过模拟 timer 这类异步函数，来达到目的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timer.test.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> timer <span class="keyword">from</span> <span class="string">'./timer'</span></span><br><span class="line"><span class="comment">// mock timer</span></span><br><span class="line">jest.useFakeTimers()</span><br><span class="line">test(<span class="string">'timer 测试'</span>,()=&gt;&#123;    </span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line">  timer(fn)</span><br><span class="line">  <span class="comment">// 快速运行所有Timer</span></span><br><span class="line">  jest.runAllTimers();</span><br><span class="line">  expect(fn).toHaveBeenCalledTimes(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于嵌套 timer 异步函数，<code>jest.runOnlyPendingTimers</code>可以让只最外层的第一个 timer 运行。</p><p>另外还有快进时间的api,<code>jest.advanceTimersByTime(n)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timer.test.js</span></span><br><span class="line"><span class="keyword">import</span> timer <span class="keyword">from</span> <span class="string">'./timer'</span></span><br><span class="line"></span><br><span class="line">jest.useFakeTimers()</span><br><span class="line">test(<span class="string">'timer 测试'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line">  timer(fn)</span><br><span class="line">  jest.advanceTimersByTime(<span class="number">3000</span>)</span><br><span class="line">  expect(fn).toHaveBeenCalledTimes(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>嵌套 timer 的测试用例结合 钩子<code>beforeEach</code>以及两个上面讲的api的例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// timer.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (cb)=&gt;&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    cb()</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      cb()</span><br><span class="line">    &#125;,<span class="number">3000</span>)    </span><br><span class="line">  &#125;,<span class="number">3000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// timer.test.js</span></span><br><span class="line"><span class="keyword">import</span> timer <span class="keyword">from</span> <span class="string">'./timer'</span></span><br><span class="line"></span><br><span class="line">beforeEach(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">  jest.useFakeTimers()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test(<span class="string">'timer 测试-runAllTimers'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line">  timer(fn)</span><br><span class="line">  jest.runAllTimers();</span><br><span class="line">  expect(fn).toHaveBeenCalledTimes(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br><span class="line">test(<span class="string">'timer 测试-advanceTimersByTime'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">const</span> fn = jest.fn();</span><br><span class="line">  timer(fn)</span><br><span class="line">  jest.advanceTimersByTime(<span class="number">3000</span>)</span><br><span class="line">  expect(fn).toHaveBeenCalledTimes(<span class="number">1</span>)</span><br><span class="line">  jest.advanceTimersByTime(<span class="number">3000</span>)</span><br><span class="line">  expect(fn).toHaveBeenCalledTimes(<span class="number">2</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Mock-Funtions"><a href="#Mock-Funtions" class="headerlink" title="Mock Funtions"></a>Mock Funtions</h3><p>Mock 函数可以轻松测试代码之间的连接——实现方式包括：擦除函数实际实现、捕获对函数的调用（以及在这些调用中传递的参数）、在使用 <code>new</code> 实例化时捕获构造函数的实例，允许测试时配置返回值</p><h4 id="模拟函数"><a href="#模拟函数" class="headerlink" title="模拟函数"></a>模拟函数</h4><p>测试函数 <code>forEach</code>的内部实现，这个函数为传入的数组中的每个元素调用一次回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">items,callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> index=<span class="number">0</span>;index&lt;items.length;index+=<span class="number">1</span>)&#123;</span><br><span class="line">        callback(item[index])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了测试此函数，可以使用一个 mock 函数，然后检查 mock 函数的状态来确保回调函数如期调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockCallback = jest.fn(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">42</span> + x);</span><br><span class="line">forEach([<span class="number">0</span>, <span class="number">1</span>], mockCallback)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此mock函数被调用了两次</span></span><br><span class="line">expect(mockCallback.mock.calls.length).toBe(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(mockCallback)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      &#123; </span></span><br><span class="line"><span class="comment">      [Function: mockConstructor]</span></span><br><span class="line"><span class="comment">        _isMockFunction: true,</span></span><br><span class="line"><span class="comment">        getMockImplementation: [Function],</span></span><br><span class="line"><span class="comment">        mock: [Getter/Setter],</span></span><br><span class="line"><span class="comment">        mockClear: [Function],</span></span><br><span class="line"><span class="comment">        mockReset: [Function],</span></span><br><span class="line"><span class="comment">        mockRestore: [Function],</span></span><br><span class="line"><span class="comment">        mockReturnValueOnce: [Function],</span></span><br><span class="line"><span class="comment">        mockResolvedValueOnce: [Function],</span></span><br><span class="line"><span class="comment">        mockRejectedValueOnce: [Function],</span></span><br><span class="line"><span class="comment">        mockReturnValue: [Function],</span></span><br><span class="line"><span class="comment">        mockResolvedValue: [Function],</span></span><br><span class="line"><span class="comment">        mockRejectedValue: [Function],</span></span><br><span class="line"><span class="comment">        mockImplementationOnce: [Function],</span></span><br><span class="line"><span class="comment">        mockImplementation: [Function],</span></span><br><span class="line"><span class="comment">        mockReturnThis: [Function],</span></span><br><span class="line"><span class="comment">        mockName: [Function],</span></span><br><span class="line"><span class="comment">        getMockName: [Function] </span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次调用函数时的第一个参数是 0</span></span><br><span class="line">expect(mockCallback.mock.calls[<span class="number">0</span>][<span class="number">0</span>]).toBe(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(mockCallback.mock)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">      &#123; </span></span><br><span class="line"><span class="comment">      calls: [ [ 0 ], [ 1 ] ],</span></span><br><span class="line"><span class="comment">        instances: [ undefined, undefined ],</span></span><br><span class="line"><span class="comment">        invocationCallOrder: [ 1, 2 ],</span></span><br><span class="line"><span class="comment">        results:</span></span><br><span class="line"><span class="comment">         [ &#123; type: 'return', value: 42 &#125;, &#123; type: 'return', value: 43 &#125; ] </span></span><br><span class="line"><span class="comment">       &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 第二次调用函数时的第一个参数是1</span></span><br><span class="line">expect(mockCallback.mock.calls[<span class="number">1</span>][<span class="number">0</span>]).toBe(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一次函数调用的返回值是 42</span></span><br><span class="line">expect(mockCallback.mock.results[<span class="number">0</span>].value).toBe(<span class="number">42</span>)</span><br></pre></td></tr></table></figure><h4 id="mock属性"><a href="#mock属性" class="headerlink" title=".mock属性"></a><code>.mock</code>属性</h4><p>所有 mock 函数都有这个特殊的 <code>.mock</code>属性，它保存了关于此函数如何调用、调用时的返回值的信息。<code>.mock</code>属性还追踪每次调用时 <code>this</code>的值，所以我们同样也可以检视（inspect）<code>this</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMock = jest.fn();</span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> myMock();</span><br><span class="line"><span class="keyword">const</span> b = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> bound = myMock.bind(b)</span><br><span class="line">bound();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myMock.mock.instances)</span><br><span class="line"><span class="comment">// [ mockConstructor &#123;&#125;, &#123;&#125; ]</span></span><br></pre></td></tr></table></figure><h4 id="模拟返回值"><a href="#模拟返回值" class="headerlink" title="模拟返回值"></a>模拟返回值</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMock = jest.fn();</span><br><span class="line"><span class="built_in">console</span>.log(myMock())</span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">myMock</span><br><span class="line">    .mockReturnValueOnce(<span class="number">10</span>)</span><br><span class="line">.mockReturnValueOnce(<span class="string">'x'</span>)</span><br><span class="line">.mockReturnValue(<span class="literal">true</span>)</span><br><span class="line"><span class="built_in">console</span>.log(myMock(), myMock(), myMock(), myMock());</span><br><span class="line"><span class="comment">// 10, 'x', true, true</span></span><br></pre></td></tr></table></figure><p>结合一些函数灵活模拟</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> filterTestFn = jest.fn();</span><br><span class="line"></span><br><span class="line">filterTestFn.mockReturnValueOnce(<span class="literal">true</span>).mockReturnValueOnce(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = [<span class="number">11</span>,<span class="number">12</span>].filter(filterTestFn)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="comment">// [11]</span></span><br><span class="line"><span class="built_in">console</span>.log(filterTestFn.mock.calls)</span><br><span class="line"><span class="comment">// [[11],[12]]</span></span><br></pre></td></tr></table></figure><h4 id="模拟模块"><a href="#模拟模块" class="headerlink" title="模拟模块"></a>模拟模块</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// users.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Users</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> call()&#123;</span><br><span class="line">        <span class="keyword">return</span> axios.get(<span class="string">'/user.json'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>res.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Users</span><br></pre></td></tr></table></figure><p>模拟 axios.get 返回一个假的 response</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// users.test.js</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span>;</span><br><span class="line"><span class="keyword">import</span> Users <span class="keyword">from</span> <span class="string">'./users'</span>;</span><br><span class="line"></span><br><span class="line">jest.mock(axios);</span><br><span class="line">test(<span class="string">'should fetch users'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> users = [&#123;<span class="attr">name</span>:<span class="string">'Bob'</span>&#125;]</span><br><span class="line">    <span class="keyword">const</span> res = &#123;<span class="attr">data</span>:users&#125;</span><br><span class="line">    axios.get.mockResolvedValue(res)</span><br><span class="line">    <span class="keyword">return</span> Users.all().then(<span class="function"><span class="params">data</span>=&gt;</span>expect(data).toEqual(users))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h4><p>通过模拟函数 <code>jest.fn</code>或者<code>mockImplementationOnce</code>方法来完成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMockFn = jest.fn(<span class="function"><span class="params">cb</span>=&gt;</span> cb(<span class="literal">null</span>,<span class="literal">true</span>))</span><br><span class="line"></span><br><span class="line">myMockFn(<span class="function">(<span class="params">err,val</span>)=&gt;</span><span class="built_in">console</span>.log(val))</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>mockImplementation</code>当您需要定义从另一个模块创建的模拟函数的默认实现时，该方法很有用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// some implementation</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// test.js</span></span><br><span class="line"></span><br><span class="line">jest.mock(<span class="string">'../foo'</span>) <span class="comment">//  这个会自动模拟</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">'../foo'</span>)</span><br><span class="line"></span><br><span class="line">foo.mockImplementation(<span class="function"><span class="params">()</span>=&gt;</span><span class="number">42</span>)</span><br><span class="line">foo();</span><br><span class="line"><span class="comment">// 42</span></span><br></pre></td></tr></table></figure><p>当需要重新创建模拟函数的复杂行为，以便多个函数调用产生不同的结果时，可以使用 <code>mockImplementationOnce</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMockFn = jest</span><br><span class="line">.fn()</span><br><span class="line">.mockImplementationOnce(<span class="function"><span class="params">cb</span> =&gt;</span> cb(<span class="literal">null</span>,<span class="literal">true</span>))</span><br><span class="line">.mockImplementationOnce(<span class="function"><span class="params">cb</span> =&gt;</span> cb(<span class="literal">null</span>,fase))</span><br><span class="line">myMockFn(<span class="function">(<span class="params">err, val</span>) =&gt;</span> <span class="built_in">console</span>.log(val));</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">myMockFn(<span class="function">(<span class="params">err, val</span>) =&gt;</span> <span class="built_in">console</span>.log(val));</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>.mockReturnThis()</code>返回 this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myObj = &#123;</span><br><span class="line">    myMethod: jest.fn().mockReturnThis(),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 与下面实现相同</span></span><br><span class="line"><span class="keyword">const</span> otherObj = &#123;</span><br><span class="line">    myMethod: jest.fn(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="模拟函数名称"><a href="#模拟函数名称" class="headerlink" title="模拟函数名称"></a>模拟函数名称</h4><p>选择为模拟函数提供一个名称，改名称将在测试错误输出中显示，而不是 <code>jest.fn()</code>，使用这个可以快速识别在测试输出中报告错误的模拟函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myMockFn = jest</span><br><span class="line">.fn()</span><br><span class="line">.mockReturnValue(<span class="string">'default'</span>)</span><br><span class="line">.mockImplementation(<span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">42</span>)</span><br><span class="line">.mockName(<span class="string">'add42'</span>)</span><br></pre></td></tr></table></figure><h3 id="Snapshot快照"><a href="#Snapshot快照" class="headerlink" title="Snapshot快照"></a>Snapshot快照</h3><p>适合测试配置文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xx.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> generateConfig = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    server:<span class="string">'http://localhost'</span>,</span><br><span class="line">    port:<span class="number">8080</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//xx.test.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; generateConfig &#125; <span class="keyword">from</span> <span class="string">'./snopshot'</span>;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'测试 generateConfig 函数'</span>,()=&gt;&#123;</span><br><span class="line">  expect(generateConfig()).toMatchSnapshot();</span><br><span class="line">  expect(generateConfig()).toEqual(&#123;</span><br><span class="line">    server:<span class="string">'http://localhost'</span>,</span><br><span class="line">    port:<span class="number">8080</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>jest --watchAll</code>里面出现了 <code>u</code>、<code>i</code>模式分别对应 更新所有的快照跟更新单个快照</p><p>安装 <code>prettier</code>,运行 <code>toMatchInlineSnapshot</code>，会将 快照自动存到代码下面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'测试 generateConfig 函数'</span>, () =&gt; &#123;</span><br><span class="line">  expect(generateConfig()).toMatchInlineSnapshot(</span><br><span class="line">    &#123;</span><br><span class="line">      time: expect.any(<span class="built_in">Date</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 下面是自动生成的</span></span><br><span class="line">    <span class="string">`</span></span><br><span class="line"><span class="string">    Object &#123;</span></span><br><span class="line"><span class="string">      "port": 8080,</span></span><br><span class="line"><span class="string">      "server": "http://localhost",</span></span><br><span class="line"><span class="string">      "time": Any&lt;Date&gt;,</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="ES6-类"><a href="#ES6-类" class="headerlink" title="ES6 类"></a>ES6 类</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// util.js</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Util</span> </span>&#123;</span><br><span class="line">  init()&#123;&#125;</span><br><span class="line">  a()&#123;</span><br><span class="line">    <span class="comment">// 异常复杂</span></span><br><span class="line">  &#125;</span><br><span class="line">  b()&#123;</span><br><span class="line">    <span class="comment">// 异常复杂</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Util;</span><br></pre></td></tr></table></figure><p>在别的函数里面使用这个类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useUtil.js</span></span><br><span class="line"><span class="keyword">import</span> Util <span class="keyword">from</span> <span class="string">'./util'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> useUtil = <span class="function">(<span class="params">a,b</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> util = <span class="keyword">new</span> Util()</span><br><span class="line">  util.a(a)</span><br><span class="line">  util.b(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> useUtil;</span><br></pre></td></tr></table></figure><p>写这个使用类的函数的测试用例的时候，我们会发现这个函数因为使用到了类里面的函数，而函数又很复杂，直接调用会损耗性能。所以这里我们用几种方法来模拟</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useUtil.test.js</span></span><br><span class="line">jest.mock(<span class="string">'./util'</span>)</span><br><span class="line"><span class="comment">// jest.mock 发现 util 是一个类，会自动把类的构造函数方法变成 jest.fn()</span></span><br><span class="line"><span class="comment">// const Util = jest.fn();</span></span><br><span class="line"><span class="comment">// Util.a = jest.fn()</span></span><br><span class="line"><span class="comment">// Util.b = jest.fn()</span></span><br><span class="line"><span class="keyword">import</span> Util <span class="keyword">from</span> <span class="string">'./util'</span></span><br><span class="line"><span class="keyword">import</span> useUtil <span class="keyword">from</span> <span class="string">'./useUtil'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'测试 useUtil'</span>,()=&gt;&#123;</span><br><span class="line">  useUtil();</span><br><span class="line">  expect(Util).toHaveBeenCalled();</span><br><span class="line">  <span class="built_in">console</span>.log(Util.mock)</span><br><span class="line">  expect(Util.mock.instances[<span class="number">0</span>].a).toHaveBeenCalled()</span><br><span class="line">  expect(Util.mock.instances[<span class="number">0</span>].b).toHaveBeenCalled()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  ● Console</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    console.log src/lesson3/useUtil.test.js:12</span></span><br><span class="line"><span class="comment">      &#123; calls: [ [] ],</span></span><br><span class="line"><span class="comment">        instances: [ Util &#123; init: [Function], a: [Function], b: [Function] &#125; ],</span></span><br><span class="line"><span class="comment">        invocationCallOrder: [ 1 ],</span></span><br><span class="line"><span class="comment">        results: [ &#123; type: 'return', value: undefined &#125; ] &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>另一种方法就是通过在 <code>__mocks__</code>文件夹中模拟</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// __mocks__/util.js</span></span><br><span class="line"><span class="keyword">const</span> Util = jest.fn();</span><br><span class="line">Util.prototype = jest.fn();</span><br><span class="line">Util.prototype = jest.fn();</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Util</span><br></pre></td></tr></table></figure><p>还有一种写法，是在原来的测试用例修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useUtil.test.js</span></span><br><span class="line">jest.mock(<span class="string">'./util'</span>,()=&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> Util = jest.fn();</span><br><span class="line">    Util.prototype = jest.fn();</span><br><span class="line">    Util.prototype = jest.fn();</span><br><span class="line">    <span class="keyword">return</span> Util;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dom.js</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addDivToBody = <span class="function"><span class="params">()</span> =&gt;</span>&#123;</span><br><span class="line">    $(<span class="string">'body'</span>).append(<span class="string">'&lt;div/&gt;'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> addDivToBody</span><br><span class="line"></span><br><span class="line"><span class="comment">// dom.test.js</span></span><br><span class="line"><span class="comment">// node 本身不具备 dom</span></span><br><span class="line"><span class="comment">// jest 在 node 环境下模拟了一套 dom 的 api,jsDom</span></span><br><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span></span><br><span class="line"><span class="keyword">import</span> addDivToBody <span class="keyword">from</span> addDivToBody;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'测试 addDivToBody'</span>,()=&gt;&#123;</span><br><span class="line">    addDivToBody();</span><br><span class="line">    expect($(<span class="string">'body'</span>).find(<span class="string">'div'</span>).length).toBe(<span class="number">1</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="TDD（测试驱动开发）"><a href="#TDD（测试驱动开发）" class="headerlink" title="TDD（测试驱动开发）"></a>TDD（测试驱动开发）</h2><p>全称：Test Driven Development</p><h3 id="开发流程（Red-Green-Development）"><a href="#开发流程（Red-Green-Development）" class="headerlink" title="开发流程（Red-Green Development）"></a>开发流程（Red-Green Development）</h3><ol><li>编写测试用例</li><li>运行测试，测试用例无法通过测试</li><li>编写代码，使测试用例通过测试</li><li>优化代码，完成开发</li><li>重复上述步骤</li></ol><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol><li>长期减少回归 bug</li><li>代码质量更好（组织、可维护性）</li><li>测试覆盖率高</li><li>错误测试代码不容易出现</li></ol><h3 id="Vue-TDD"><a href="#Vue-TDD" class="headerlink" title="Vue TDD"></a>Vue TDD</h3><p>开始</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装脚手架</span></span><br><span class="line">npm i @vue/cli@3.8.4 -g</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装vue,可以选择默认配置，也可以自定义配置</span></span><br><span class="line">vue create vue-jest</span><br></pre></td></tr></table></figure><h4 id="vue-test-utils"><a href="#vue-test-utils" class="headerlink" title="@vue/test-utils"></a>@vue/test-utils</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorld.test.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; shallowMount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">'@/components/HelloWorld.vue'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'HelloWorld.vue'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="comment">/** 如果不使用 @vue/test-utils</span></span><br><span class="line"><span class="comment">   * import Vue from 'vue'</span></span><br><span class="line"><span class="comment">   *   it('renders props.msg when passed', () =&gt; &#123;</span></span><br><span class="line"><span class="comment">  const root = document.createElement('div')</span></span><br><span class="line"><span class="comment">  root.className = 'root'</span></span><br><span class="line"><span class="comment">  document.body.appendChild(root)</span></span><br><span class="line"><span class="comment">  new Vue(&#123;</span></span><br><span class="line"><span class="comment">    render: h =&gt; h(HelloWorld, &#123;</span></span><br><span class="line"><span class="comment">      props: &#123;</span></span><br><span class="line"><span class="comment">        msg: 'laibh'</span></span><br><span class="line"><span class="comment">      &#125;</span></span><br><span class="line"><span class="comment">    &#125;)</span></span><br><span class="line"><span class="comment">  &#125;).$mount('.root')</span></span><br><span class="line"><span class="comment">  expect(document.getElementsByClassName('hello').length).toBe(1)</span></span><br><span class="line"><span class="comment">  &#125;)</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">const</span> msg = <span class="string">'new message'</span></span><br><span class="line">  <span class="keyword">const</span> wrapper = shallowMount(HelloWorld, &#123;</span><br><span class="line">    propsData: &#123; msg &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  expect(wrapper.text()).toMatch(msg)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>shallowMount</code>浅层渲染，只渲染第一层，不渲染子组件，适合单元测试</p><p><code>mount</code>则会渲染子组件，适合集成测试</p><h4 id="开发-Header-组件"><a href="#开发-Header-组件" class="headerlink" title="开发 Header 组件"></a>开发 Header 组件</h4><p>测试用例先行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Header.test.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; shallowMount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'@/components/Header/Header.vue'</span></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'测试 Header 组件'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'Header 包含 Input 框'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(Header)</span><br><span class="line">    <span class="keyword">const</span> input = wrapper.find(<span class="string">'[data-test="input"]'</span>)</span><br><span class="line">    expect(input.exists()).toBe(<span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  it(<span class="string">'Header 中 Input 初始内容为空'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(Header)</span><br><span class="line">    <span class="keyword">const</span> inputValue = wrapper.vm.$data.inputValue</span><br><span class="line">    expect(inputValue).toBe(<span class="string">''</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'Header 中 Input 框值发生变化，值应该也跟着改变'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(Header)</span><br><span class="line">    <span class="keyword">const</span> input = wrapper.find(<span class="string">'[data-test="input"]'</span>)</span><br><span class="line">    input.setValue(<span class="string">'laibh'</span>)</span><br><span class="line">    <span class="keyword">const</span> inputValue = wrapper.vm.$data.inputValue</span><br><span class="line">    expect(inputValue).toBe(<span class="string">'laibh'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'Header 中 Input 框输入回车，无内容时无反应'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(Header)</span><br><span class="line">    <span class="keyword">const</span> input = wrapper.find(<span class="string">'[data-test="input"]'</span>)</span><br><span class="line">    input.setValue(<span class="string">''</span>)</span><br><span class="line">    input.trigger(<span class="string">'keyup.enter'</span>)</span><br><span class="line">    expect(wrapper.emitted().add).toBeFalsy()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  it(<span class="string">'Header 中 Input 框输入回车，有内容时向外触发事件,同时清空 inputValue'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = shallowMount(Header)</span><br><span class="line">    <span class="keyword">const</span> input = wrapper.find(<span class="string">'[data-test="input"]'</span>)</span><br><span class="line">    input.setValue(<span class="string">'laibh'</span>)</span><br><span class="line">    input.trigger(<span class="string">'keyup.enter'</span>)</span><br><span class="line">    expect(wrapper.emitted().add).toBeTruthy()</span><br><span class="line">    expect(wrapper.vm.$data.inputValue).toBe(<span class="string">''</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>根据测试用例写代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// Header.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input data-test=&quot;input&quot; v-model=&quot;inputValue&quot; @keyup.enter=&quot;addTodoItem&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;Header&quot;,</span><br><span class="line">  props: &#123;&#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      inputValue: &quot;&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    addTodoItem() &#123;</span><br><span class="line">      if (this.inputValue) &#123;</span><br><span class="line">        this.$emit(&quot;add&quot;, this.inputValue);</span><br><span class="line">        this.inputValue = &quot;&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style scoped lang=&quot;less&quot;&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><h4 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jest.config.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    collectCoverageFrom: [<span class="string">'**/*.&#123;js,vue&#125;'</span>, <span class="string">'!**/node_modules/**'</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"test:cov"</span>: <span class="string">"vue-cli-service test:unit --coverage"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><h3 id="React-TDD"><a href="#React-TDD" class="headerlink" title="React TDD"></a>React TDD</h3><h4 id="Enzyme"><a href="#Enzyme" class="headerlink" title="Enzyme"></a>Enzyme</h4><p><a href="https://github.com/airbnb/enzyme">github</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 </span></span><br><span class="line">npm i --save-dev enzyme enzyme-adapter-react-16</span><br></pre></td></tr></table></figure><p>同样，<code>shallow</code>适合单元测试，<code>mount</code>则是集成测试</p><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.je</span></span><br><span class="line"><span class="keyword">import</span> React from <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">App</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">     <span class="comment">// 使用的data-test=xxx 等属性可以做到解耦，不会因为改变样式名而发生改变，另外也不会被hash掉</span></span><br><span class="line">    &lt;div className=<span class="string">"app-container"</span> title=<span class="string">"laibh"</span> data-test=<span class="string">"container"</span>&gt;</span><br><span class="line">      hello world</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> App;</span><br><span class="line"><span class="comment">// App.test.js</span></span><br><span class="line"><span class="keyword">import</span> React from <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> App from <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> Enzyme, &#123; shallow &#125; from <span class="string">'enzyme'</span>;</span><br><span class="line"><span class="keyword">import</span> Adapter from <span class="string">'enzyme-adapter-react-16'</span>;</span><br><span class="line">Enzyme.configure(&#123; adapter: <span class="keyword">new</span> Adapter() &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">it(<span class="string">'renders without crashing'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = shallow(&lt;App /&gt;)</span><br><span class="line">  <span class="comment">// 输出整个内容字符串</span></span><br><span class="line">  console.log(wrapper.debug())</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    &lt;div className="app-container" title="laibh" data-test="container"&gt;</span></span><br><span class="line"><span class="comment">      hello world</span></span><br><span class="line"><span class="comment">    &lt;/div&gt;  </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  expect(wrapper.find(<span class="string">'[data-test="container"]'</span>).length).toBe(<span class="number">1</span>)</span><br><span class="line">  expect(wrapper.find(<span class="string">'[data-test="container"]'</span>).prop(<span class="string">'title'</span>)).toBe(<span class="string">'laibh'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>另外它海域一些扩展 API，例如 <a href="https://github.com/FormidableLabs/enzyme-matchers/tree/master/packages/jest-enzyme">jest-enzyme</a>，让语法易懂简洁</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// App.test.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> Enzyme, &#123; shallow &#125; <span class="keyword">from</span> <span class="string">'enzyme'</span>;</span><br><span class="line"><span class="keyword">import</span> Adapter <span class="keyword">from</span> <span class="string">'enzyme-adapter-react-16'</span>;</span><br><span class="line">Enzyme.configure(&#123; <span class="attr">adapter</span>: <span class="keyword">new</span> Adapter() &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">it(<span class="string">'renders without crashing'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>)</span></span><br><span class="line"><span class="xml">  console.log(wrapper.debug())</span></span><br><span class="line"><span class="xml">  const container = wrapper.find('[data-test="container"]')</span></span><br><span class="line"><span class="xml">  expect(container.length).toBe(1)</span></span><br><span class="line"><span class="xml">  expect(container.prop('title')).toBe('laibh')</span></span><br><span class="line"><span class="xml">  // 等同上面两句</span></span><br><span class="line"><span class="xml">  expect(container).toExist()</span></span><br><span class="line"><span class="xml">  expect(container).toHaveProp('title', 'laibh')</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure><p>别忘记在 <code>jest.config.js</code>里面进行配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    setupFilesAfterEnv: [<span class="string">'./node_modules/jest-enzyme/lib/index.js'</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开发-Header-组件-1"><a href="#开发-Header-组件-1" class="headerlink" title="开发 Header 组件"></a>开发 Header 组件</h4><p>同样测试先行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'../../index'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; shallow &#125; <span class="keyword">from</span> <span class="string">'enzyme'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> wrapper;</span><br><span class="line"><span class="keyword">let</span> inputElem;</span><br><span class="line">describe(<span class="string">'测试 Header 组件'</span>, () =&gt; &#123;</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span>)</span></span><br><span class="line"><span class="xml">    inputElem = wrapper.find('[data-test="input"]')</span></span><br><span class="line"><span class="xml">  &#125;)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('正常渲染', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    expect(wrapper).toMatchSnapshot()</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('包含一个 input', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    expect(inputElem).toExist()</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('input初始化内容应该为空', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    expect(inputElem.prop('value')).toBe('')</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('当用户输入时，input内容会跟着变化', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    const value = '哈哈哈'</span></span><br><span class="line"><span class="xml">    inputElem.simulate('change', &#123;</span></span><br><span class="line"><span class="xml">      target: &#123;</span></span><br><span class="line"><span class="xml">        value</span></span><br><span class="line"><span class="xml">      &#125;</span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml">    expect(wrapper.state('value')).toBe(value)</span></span><br><span class="line"><span class="xml">  &#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it('当用户输入后，键入回车，如果 input 没有内容，则不操作', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">    const fn = jest.fn();</span></span><br><span class="line">    const wrapper = shallow(&lt;Header addUndoItem=&#123;fn&#125; /&gt;)</span><br><span class="line">    wrapper.setState(&#123; value: '' &#125;)</span><br><span class="line">    const inputElem = wrapper.find('[data-test="input"]')</span><br><span class="line">    inputElem.simulate('keyUp', &#123;</span><br><span class="line">      keyCode: 13</span><br><span class="line">    &#125;)</span><br><span class="line">    expect(fn).not.toBeCalled()</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  it('当用户输入后，键入回车，如果 input 有内容，addUndoItem应该被调用,然后input被清空', () =&gt; &#123;</span><br><span class="line">    const fn = jest.fn();</span><br><span class="line">    const wrapper = shallow(&lt;Header addUndoItem=&#123;fn&#125; /&gt;)</span><br><span class="line">    const value = 'haha';</span><br><span class="line">    wrapper.setState(&#123; value &#125;)</span><br><span class="line">    const inputElem = wrapper.find('[data-test="input"]')</span><br><span class="line">    inputElem.simulate('keyUp', &#123;</span><br><span class="line">      keyCode: 13</span><br><span class="line">    &#125;)</span><br><span class="line">    expect(fn).toBeCalled()</span><br><span class="line">    expect(fn).toBeCalledWith(value)</span><br><span class="line">    const newInputElem = wrapper.find('[data-test="input"]')</span><br><span class="line">    expect(newInputElem.prop('value')).toBe('')</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>根据测试写代码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./index.less'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputKeyUp = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">const</span> &#123; addUndoItem &#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">if</span> (e.keyCode === <span class="number">13</span> &amp;&amp; value) &#123;</span><br><span class="line">      addUndoItem(value)</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; <span class="attr">value</span>: <span class="string">''</span> &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">value</span>: e.target.value &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;styles.header&#125;&gt;</span><br><span class="line">        &lt;div className=&#123;styles.headerContent&#125;&gt;</span><br><span class="line">          TodoList</span><br><span class="line">        &lt;input</span><br><span class="line">            className=&#123;styles.headerInput&#125;</span><br><span class="line">            data-test=<span class="string">'input'</span></span><br><span class="line">            value=&#123;value&#125;</span><br><span class="line">            onChange=&#123;<span class="keyword">this</span>.handleInputChange&#125;</span><br><span class="line">            onKeyUp=&#123;<span class="keyword">this</span>.handleInputKeyUp&#125;</span><br><span class="line">            placeholder=<span class="string">'Add Todo'</span></span><br><span class="line">          /&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Header;</span><br></pre></td></tr></table></figure><h3 id="TDD-小结"><a href="#TDD-小结" class="headerlink" title="TDD 小结"></a>TDD 小结</h3><p>优势：代码质量提高</p><p><code>单元测试</code></p><p>测试覆盖率高，业务耦合度高，代码量大，过于独立</p><h2 id="BDD（行为驱动开发）"><a href="#BDD（行为驱动开发）" class="headerlink" title="BDD（行为驱动开发）"></a>BDD（行为驱动开发）</h2><p>全称：Behavior Driven Development</p><h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue integration/todoList </span></span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'@vue/test-utils'</span></span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'../../TodoList'</span></span><br><span class="line"></span><br><span class="line">  it(<span class="string">`</span></span><br><span class="line"><span class="string">    1.用户会在 header输入框输入内容</span></span><br><span class="line"><span class="string">    2.用户会点击回车按钮</span></span><br><span class="line"><span class="string">    3.列表项应该增加用户输入内容的列表项</span></span><br><span class="line"><span class="string">  `</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">TodoList</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">      const inputElem = wrapper.findAll('[data-test="header-input"]').at(0)</span></span><br><span class="line"><span class="xml">      const content = 'haha'</span></span><br><span class="line"><span class="xml">      inputElem.setValue(content)</span></span><br><span class="line"><span class="xml">      inputElem.trigger('change')</span></span><br><span class="line"><span class="xml">      inputElem.trigger('keyup.enter')</span></span><br><span class="line"><span class="xml">      const listItems = wrapper.findAll('[data-test="list-item"]').at(0)</span></span><br><span class="line"><span class="xml">      expect(listItems.length).toBe(1)</span></span><br><span class="line"><span class="xml">      expect(listItems.at(0).text()).toContain(content)</span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// react integration/todoList </span></span><br><span class="line"><span class="xml">import React from 'react';</span></span><br><span class="line"><span class="xml">import &#123; mount &#125; from 'enzyme';</span></span><br><span class="line"><span class="xml">import TodoList from './../../index';</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">describe('集成测试：TodoList', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">  let wrapper;</span></span><br><span class="line"><span class="xml">  beforeEach(() =&gt; &#123;</span></span><br><span class="line"><span class="xml">    wrapper = mount(<span class="tag">&lt;<span class="name">TodoList</span> /&gt;</span>)</span></span><br><span class="line"><span class="xml">  &#125;)</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  it(`</span></span><br><span class="line"><span class="xml">  1.用户会在 header输入框输入内容</span></span><br><span class="line"><span class="xml">  2.用户会点击回车按钮</span></span><br><span class="line"><span class="xml">  3.列表项应该增加用户输入内容的列表项</span></span><br><span class="line"><span class="xml">  `, () =&gt; &#123;</span></span><br><span class="line"><span class="xml">      const value = 'haha'</span></span><br><span class="line"><span class="xml">      const headerInput = wrapper.find('[data-test="header-input"]')</span></span><br><span class="line"><span class="xml">      headerInput.simulate('change', &#123;</span></span><br><span class="line"><span class="xml">        target: &#123;</span></span><br><span class="line"><span class="xml">          value</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">      &#125;)</span></span><br><span class="line"><span class="xml">      // 按下回车键，keyCode为13</span></span><br><span class="line"><span class="xml">      headerInput.simulate('keyUp', &#123;</span></span><br><span class="line"><span class="xml">        keyCode: 13</span></span><br><span class="line"><span class="xml">      &#125;)</span></span><br><span class="line"><span class="xml">      // undoListItem</span></span><br><span class="line"><span class="xml">      const listItems = wrapper.find('[data-test="list-item"]')</span></span><br><span class="line"><span class="xml">      expect(listItems.length).toBe(1)</span></span><br><span class="line"><span class="xml">      expect(listItems.at(0).text()).toContain(value)</span></span><br><span class="line"><span class="xml">    &#125;)</span></span><br><span class="line"><span class="xml">&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="TDD-与-BDD-比较"><a href="#TDD-与-BDD-比较" class="headerlink" title="TDD 与 BDD 比较"></a>TDD 与 BDD 比较</h3><p><strong>TDD</strong></p><ol><li>先写测试再写代码</li><li>一般结合单元测试使用，是白盒测试</li><li>测试重点在代码</li><li>安全感低</li><li>速度快</li></ol><p><strong>BDD</strong></p><ol><li>先写代码再写测试</li><li>一般结合集成测试使用，是黑盒测试</li><li>测试重点在 UI (DOM)</li><li>安全感高</li><li>速度慢</li></ol><h3 id="Redux相关测试"><a href="#Redux相关测试" class="headerlink" title="Redux相关测试"></a>Redux相关测试</h3><p>增加 redux 在项目</p><p><code>createStore</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/store/createStore</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore, combineReducers &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="keyword">import</span> &#123; reducer <span class="keyword">as</span> todoReducer &#125; <span class="keyword">from</span> <span class="string">'../containers/TodoList/store'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reducer = combineReducers(&#123;</span><br><span class="line">  todo: todoReducer</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer, <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; <span class="built_in">window</span>.__REDUX_DEVTOOLS_EXTENSION__());</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store;</span><br></pre></td></tr></table></figure><p><code>store/actions.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CHANGE_INPUT_VALUE &#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> changeInputValue = <span class="function"><span class="params">value</span> =&gt;</span> (&#123;</span><br><span class="line">  type: CHANGE_INPUT_VALUE,</span><br><span class="line">  value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>store/constants.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> CHANGE_INPUT_VALUE = <span class="string">'CHANGE_INPUT_VALUE'</span></span><br></pre></td></tr></table></figure><p><code>store/reducer.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; CHANGE_INPUT_VALUE &#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123;</span><br><span class="line">  inputValue: <span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (state = initialState, action) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (action.type) &#123;</span><br><span class="line">    <span class="keyword">case</span> CHANGE_INPUT_VALUE:</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        inputValue: action.value</span><br><span class="line">      &#125;;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>store/index.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./reducer'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./actions'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; reducer, actions &#125;</span><br></pre></td></tr></table></figure><p><code>TodoList/index.js</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> Header <span class="keyword">from</span> <span class="string">'./../../components/Header/index'</span>;</span><br><span class="line"><span class="keyword">import</span> UndoList <span class="keyword">from</span> <span class="string">'./../../components/UndoList/index'</span>;</span><br><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./index.less'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TodoList</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      undoList: []</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handledeleteItem = <span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; undoList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">const</span> newList = undoList.filter(<span class="function">(<span class="params">item, itemIndex</span>) =&gt;</span> itemIndex !== index)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">undoList</span>: newList &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleStatusChange = <span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; undoList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="comment">// undoList.forEach((item, itemIndex) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   if (itemIndex === index) &#123;</span></span><br><span class="line">    <span class="comment">//     Object.assign(item, &#123; status: 'input' &#125;)</span></span><br><span class="line">    <span class="comment">//     return;</span></span><br><span class="line">    <span class="comment">//   &#125; Object.assign(item, &#123; status: 'div' &#125;)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="keyword">const</span> newList = undoList.map(<span class="function">(<span class="params">item, itemIndex</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (itemIndex === index) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          ...item,</span><br><span class="line">          status: <span class="string">'input'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">return</span> &#123;</span><br><span class="line">        ...item,</span><br><span class="line">        status: <span class="string">'div'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">undoList</span>: newList &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleBlur = <span class="function">(<span class="params">index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; undoList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">const</span> newList = undoList.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        ...item,</span><br><span class="line">        status: <span class="string">'div'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">undoList</span>: newList &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleInputValue = <span class="function">(<span class="params">index, value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; undoList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">const</span> newList = undoList.map(<span class="function">(<span class="params">item, itemIndex</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (itemIndex === index) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          ...item,</span><br><span class="line">          value</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">return</span> &#123;</span><br><span class="line">        ...item,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">undoList</span>: newList &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  addUndoItem = <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; undoList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      undoList: [...undoList, &#123;</span><br><span class="line">        status: <span class="string">'div'</span>,</span><br><span class="line">        value</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; undoList &#125; = <span class="keyword">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div className=&#123;styles.todoList&#125;&gt;</span><br><span class="line">        &lt;Header addUndoItem=&#123;<span class="keyword">this</span>.addUndoItem&#125; /&gt;</span><br><span class="line">        &lt;UndoList</span><br><span class="line">          list=&#123;undoList&#125;</span><br><span class="line">          deleteItem=&#123;<span class="keyword">this</span>.handledeleteItem&#125;</span><br><span class="line">          changeStatus=&#123;<span class="keyword">this</span>.handleStatusChange&#125;</span><br><span class="line">          changeBlur=&#123;<span class="keyword">this</span>.handleBlur&#125;</span><br><span class="line">          valueChange=&#123;<span class="keyword">this</span>.handleInputValue&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">export default TodoList;</span></span><br></pre></td></tr></table></figure><p><code>src/index.js</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/createStore'</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render((</span><br><span class="line">  &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">  &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">), document.getElementById('root'));</span></span><br></pre></td></tr></table></figure><p>然后修改集成测试的测试用例</p><p><code>src/containers/TodoList/__test__/integration/TodoList.test.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">'enzyme'</span>;</span><br><span class="line"><span class="keyword">import</span> TodoList <span class="keyword">from</span> <span class="string">'./../../index'</span>;</span><br><span class="line"><span class="comment">// 增加的内容</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./../../../../store/createStore'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">describe(<span class="string">'集成测试：TodoList'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> wrapper;</span><br><span class="line">  beforeEach(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    wrapper = mount(</span><br><span class="line">      &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">        &lt;TodoList /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  it(`</span></span><br><span class="line"><span class="regexp">  1.用户会在 header输入框输入内容</span></span><br><span class="line"><span class="regexp">  2.用户会点击回车按钮</span></span><br><span class="line"><span class="regexp">  3.列表项应该增加用户输入内容的列表项</span></span><br><span class="line"><span class="regexp">  `, () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      const value = 'haha'</span></span><br><span class="line"><span class="regexp">      const headerInput = wrapper.find('[data-test="header-input"]')</span></span><br><span class="line"><span class="regexp">      headerInput.simulate('change', &#123;</span></span><br><span class="line"><span class="regexp">        target: &#123;</span></span><br><span class="line"><span class="regexp">          value</span></span><br><span class="line"><span class="regexp">        &#125;</span></span><br><span class="line"><span class="regexp">      &#125;)</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 按下回车键，keyCode为13</span></span><br><span class="line"><span class="regexp">      headerInput.simulate('keyUp', &#123;</span></span><br><span class="line"><span class="regexp">        keyCode: 13</span></span><br><span class="line"><span class="regexp">      &#125;)</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ undoListItem</span></span><br><span class="line"><span class="regexp">      const listItems = wrapper.find('[data-test="list-item"]')</span></span><br><span class="line"><span class="regexp">      expect(listItems.length).toBe(1)</span></span><br><span class="line"><span class="regexp">      expect(listItems.at(0).text()).toContain(value)</span></span><br><span class="line"><span class="regexp">    &#125;)</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><h3 id="异步代码"><a href="#异步代码" class="headerlink" title="异步代码"></a>异步代码</h3><h4 id="compontDidMount"><a href="#compontDidMount" class="headerlink" title="compontDidMount"></a>compontDidMount</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        data:[</span></span><br><span class="line"><span class="comment">            &#123;status:'div',value:'haha'&#125;,</span></span><br><span class="line"><span class="comment">        ],</span></span><br><span class="line"><span class="comment">        success:true</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    axios.get(<span class="string">'/undoList.json'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            undoList:res.data</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 模拟函数</p><p><code>src/__mock__/axios.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mockUndoList = &#123;</span><br><span class="line">    data:[&#123;</span><br><span class="line">        status:<span class="string">'div'</span>,<span class="attr">value</span>:<span class="string">'haha'</span></span><br><span class="line">    &#125;],</span><br><span class="line">    success:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    get(url)&#123;</span><br><span class="line">        <span class="keyword">if</span>(url === <span class="string">'/undoList.json'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">                resolve(mockUndoList)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">it(<span class="string">`</span></span><br><span class="line"><span class="string">1.用户打开页面</span></span><br><span class="line"><span class="string">2.应该展示接口返回的数据</span></span><br><span class="line"><span class="string">`</span>,(done)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(</span><br><span class="line">        &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">            &lt;TodoList /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 解决数据异步问题</span></span><br><span class="line"><span class="regexp">      setTimeout(()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">          wrapper.update();</span></span><br><span class="line"><span class="regexp">          const listItems = wrapper.find('[data-test="list-item"]')</span></span><br><span class="line"><span class="regexp">          expect(listItems.length).toBe(1)   </span></span><br><span class="line"><span class="regexp">          done()</span></span><br><span class="line"><span class="regexp">      &#125;,0)  </span></span><br><span class="line"><span class="regexp">        </span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ node的语法</span></span><br><span class="line"><span class="regexp">      process.nextTick(()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">          wrapper.update();</span></span><br><span class="line"><span class="regexp">          const listItems = wrapper.find('[data-test="list-item"]')</span></span><br><span class="line"><span class="regexp">          expect(listItems.length).toBe(1)   </span></span><br><span class="line"><span class="regexp">          done()        </span></span><br><span class="line"><span class="regexp">      &#125;)</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount()&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        data:[</span></span><br><span class="line"><span class="comment">            &#123;status:'div',value:'haha'&#125;,</span></span><br><span class="line"><span class="comment">        ],</span></span><br><span class="line"><span class="comment">        success:true</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        axios.get(<span class="string">'/undoList.json'</span>).then(<span class="function"><span class="params">res</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                undoList:res.data</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;).catch(<span class="function"><span class="params">e</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(e)</span><br><span class="line">        &#125;)        </span><br><span class="line">    &#125;,<span class="number">5000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">jest.useFakeTimers();</span><br><span class="line"></span><br><span class="line">it(<span class="string">`</span></span><br><span class="line"><span class="string">1.用户打开页面</span></span><br><span class="line"><span class="string">2.应该展示接口返回的数据</span></span><br><span class="line"><span class="string">`</span>,(done)=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> wrapper = mount(</span><br><span class="line">        &lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">            &lt;TodoList /&gt;</span><br><span class="line">        &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">        </span></span><br><span class="line"><span class="regexp">      expect(setTimeout).toHaveBeenCalledTimes(1);</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 跑完所有 setTimeout 的时间</span></span><br><span class="line"><span class="regexp">      jest.runAllTimers();</span></span><br><span class="line"><span class="regexp">      /</span><span class="regexp">/ 解决数据异步问题</span></span><br><span class="line"><span class="regexp">      setTimeout(()=&gt;&#123;</span></span><br><span class="line"><span class="regexp">          wrapper.update();</span></span><br><span class="line"><span class="regexp">          const listItems = wrapper.find('[data-test="list-item"]')</span></span><br><span class="line"><span class="regexp">          expect(listItems.length).toBe(1)   </span></span><br><span class="line"><span class="regexp">          done()</span></span><br><span class="line"><span class="regexp">      &#125;,0)  </span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><h2 id="前端自动化测试的优势"><a href="#前端自动化测试的优势" class="headerlink" title="前端自动化测试的优势"></a>前端自动化测试的优势</h2><ol><li>更好的代码组织，项目的可维护性增强</li><li>更小的bug 出现概率，尤其是回归测试中的 Bug</li><li>修改工程质量差的项目，更加安全</li><li>项目具备潜在的文档特性</li><li>扩广前端的知识面</li></ol><h2 id="Enzyme-1"><a href="#Enzyme-1" class="headerlink" title="Enzyme"></a>Enzyme</h2><p>Enzyme 是 React 的 JavaScript 测试应用程序，可以轻松测试 React Components 的输出。还可以在给定输出的情况下，遍历以某种方式模拟运行。</p><p>主要通过模仿 Jq 用于 DOM 操作和遍历</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="at-index"><a href="#at-index" class="headerlink" title="at(index)"></a>at(index)</h4><p><code>.at(index) =&gt; shallowWrapper</code></p><p>返回当前 wrapper 中指定索引的节点</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>)</span></span><br><span class="line"><span class="xml">expect(wrapper.find(foo).at(0).props().foo).toEqual('bar')</span></span><br></pre></td></tr></table></figure><h4 id="first"><a href="#first" class="headerlink" title="first()"></a>first()</h4><p><code>.first() =&gt; ShallowWrapper</code></p><p>将匹配节点集合减少到集合中的第一个，就像<code>.at(0)</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(wrapper.find(Foo).first().props().foo).to.equal(<span class="string">'bar'</span>);</span><br></pre></td></tr></table></figure><h4 id="last"><a href="#last" class="headerlink" title="last()"></a>last()</h4><p><code>.last() =&gt; ShallowWrapper</code></p><p>将匹配节点集减少到集合中的最后一个，就像<code>.at(length - 1)</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find(Foo).last().props().foo).to.equal('bar');</span></span><br></pre></td></tr></table></figure><h4 id="childAt-index"><a href="#childAt-index" class="headerlink" title="childAt(index)"></a>childAt(index)</h4><p><code>.childAt(index) =&gt; ShallowWrapper</code></p><p>返回指定索引的子节点</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">TodoList</span> <span class="attr">items</span>=<span class="string">&#123;items&#125;/</span>&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('ul').childAt(0).type).toEqual('li')</span></span><br></pre></td></tr></table></figure><h4 id="children-selector"><a href="#children-selector" class="headerlink" title="children([selector])"></a>children([selector])</h4><p><code>.children([selector]) =&gt; ShallowWrapper</code></p><p>返回父节点某个元素的所有子节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">TodoList</span> <span class="attr">items</span>=<span class="string">&#123;items&#125;/</span>&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('ul').children.length).toEqual(items.length)</span></span><br></pre></td></tr></table></figure><h4 id="closest-selector"><a href="#closest-selector" class="headerlink" title="closest(selector)"></a>closest(selector)</h4><p><code>.closest(selector) =&gt; shallowWrapper</code></p><p>通过遍历节点祖先，返回第一个相匹配的节点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find(Foo).closest('.bar')).to.have.lengthOf(1);</span></span><br></pre></td></tr></table></figure><h4 id="contains-nodeOrNodes"><a href="#contains-nodeOrNodes" class="headerlink" title="contains(nodeOrNodes)"></a>contains(nodeOrNodes)</h4><p><code>.contains(nodeOrNodes) =&gt; Boolean</code></p><p>返回所有给定的react元素是否与渲染树中的元素匹配。它将通过检查期望元素是否与包装器元素具有相同的 props 并共享相同的值来确定包装器中的元素是否与预期元素匹配。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wrapper;</span><br><span class="line">wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div data-foo=<span class="string">"foo"</span> data-bar=<span class="string">"bar"</span>&gt;Hello&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">expect(wrapper.contains(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"bar"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">expect(wrapper.contains(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">false</span>);</span><br><span class="line">expect(wrapper.contains(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"bar"</span> <span class="attr">data-baz</span>=<span class="string">"baz"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">false</span>);</span><br><span class="line">expect(wrapper.contains(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"Hello"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">false</span>);</span><br><span class="line">expect(wrapper.contains(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"bar"</span> /&gt;</span>)).to.equal(false);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">wrapper = shallow((</span></span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span&gt;Hello&lt;/span&gt;</span><br><span class="line">    &lt;div&gt;Goodbye&lt;/div&gt;</span><br><span class="line">    &lt;span&gt;Again&lt;/span&gt;</span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">));</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">expect(wrapper.contains([</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>Goodbye<span class="tag">&lt;/<span class="name">div</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">])).to.equal(true);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">expect(wrapper.contains([</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>World<span class="tag">&lt;/<span class="name">div</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">])).to.equal(false);</span></span><br></pre></td></tr></table></figure><h4 id="containsAllMatchingElements-patternNodes"><a href="#containsAllMatchingElements-patternNodes" class="headerlink" title="containsAllMatchingElements(patternNodes)"></a>containsAllMatchingElements(patternNodes)</h4><p><code>.containsAllMatchingElements(patternNodes) =&gt; Boolean</code></p><p>返回所有给定的react元素是否<code>patternNodes</code>与包装器的渲染树中的元素匹配。每个元素<code>patternNodes</code>必须匹配一次或多次。匹配遵循规则<code>containsMatchingElement</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> style = &#123; <span class="attr">fontSize</span>: <span class="number">13</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span className=<span class="string">"foo"</span>&gt;Hello&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div style=&#123;style&#125;&gt;Goodbye&lt;/</span>div&gt;</span><br><span class="line">    &lt;span&gt;Again&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">expect(wrapper.containsAllMatchingElements([</span><br><span class="line">  &lt;span&gt;Hello&lt;<span class="regexp">/span&gt;,</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;Goodbye&lt;/</span>div&gt;,</span><br><span class="line">])).to.equal(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="containsAnyMatchingElements-patternNodes"><a href="#containsAnyMatchingElements-patternNodes" class="headerlink" title="containsAnyMatchingElements(patternNodes)"></a>containsAnyMatchingElements(patternNodes)</h4><p><code>.containsAnyMatchingElements(patternNodes) =&gt; Boolean</code></p><p>返回至少一个给定的react元素是否<code>patternNodes</code>与包装器的渲染树中的元素匹配。一个或多个元素<code>patternNodes</code>必须匹配一次或多次。匹配遵循规则<code>containsMatchingElement</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> style = &#123; <span class="attr">fontSize</span>: <span class="number">13</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span className=<span class="string">"foo"</span>&gt;Hello&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div style=&#123;style&#125;&gt;Goodbye&lt;/</span>div&gt;</span><br><span class="line">    &lt;span&gt;Again&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">expect(wrapper.containsAnyMatchingElements([</span><br><span class="line">  &lt;span&gt;Bonjour&lt;<span class="regexp">/span&gt;,</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;Goodbye&lt;/</span>div&gt;,</span><br><span class="line">])).to.equal(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="containsMatchingElement-patternNode"><a href="#containsMatchingElement-patternNode" class="headerlink" title="containsMatchingElement(patternNode)"></a>containsMatchingElement(patternNode)</h4><p><code>.containsMatchingElement(patternNode) =&gt; Boolean</code></p><p>返回<code>patternNode</code>react元素是否与渲染树中的任何元素匹配。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div data-foo=<span class="string">"foo"</span> data-bar=<span class="string">"bar"</span>&gt;Hello&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line">expect(wrapper.containsMatchingElement(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"bar"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">true</span>);</span><br><span class="line">expect(wrapper.containsMatchingElement(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">expect(wrapper.containsMatchingElement(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"bar"</span> <span class="attr">data-baz</span>=<span class="string">"baz"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">false</span>);</span><br><span class="line">expect(wrapper.containsMatchingElement(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"Hello"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>)).to.equal(<span class="literal">false</span>);</span><br><span class="line">expect(wrapper.containsMatchingElement(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-foo</span>=<span class="string">"foo"</span> <span class="attr">data-bar</span>=<span class="string">"bar"</span> /&gt;</span>)).to.equal(false);</span></span><br></pre></td></tr></table></figure><h4 id="context-key"><a href="#context-key" class="headerlink" title="context([key])"></a>context([key])</h4><p>返回包装器根节点的上下文哈希。可选地传入一个props，它将只返回该值。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(</span><br><span class="line">  &lt;MyComponent /&gt;,</span><br><span class="line">  &#123; <span class="attr">context</span>: &#123; <span class="attr">foo</span>: <span class="number">10</span> &#125; &#125;,</span><br><span class="line">);</span><br><span class="line">expect(wrapper.context().foo).to.equal(<span class="number">10</span>);</span><br><span class="line">expect(wrapper.context(<span class="string">'foo'</span>)).to.equal(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><h4 id="debug-options"><a href="#debug-options" class="headerlink" title="debug([options])"></a>debug([options])</h4><p><code>.debug([options]) =&gt; String</code></p><p>返回包装器的类似HTML的字符串，以便进行调试。当测试没有通过时，打印到控制台很有用。</p><p><code>options</code>（<code>Object</code>[可选]）：</p><ul><li><code>options.ignoreProps</code>：（<code>Boolean</code>[可选]）：是否应在结果字符串中省略props。默认情况下包含道具。</li><li><code>options.verbose</code>：（<code>Boolean</code>[可选]）：是否应该详细打印作为道具传递的数组和对象。</li></ul><h4 id="dive-options"><a href="#dive-options" class="headerlink" title="dive([options])"></a>dive([options])</h4><p><code>.dive([options]) =&gt; ShallowWrapper</code></p><p>浅呈现当前包装器的一个非DOM子项，并返回结果周围的包装器。它必须是单节点包装器，并且该节点必须是React组件。</p><p>注意：只能在单个非DOM组件元素节点的包装上调用，否则会引发错误。如果必须使用多个子节点对包装器进行浅包装，请使用<code>.shallow（）</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;div className=<span class="string">"in-bar"</span> /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function Foo() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;Bar /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">const wrapper = shallow(&lt;Foo /</span>&gt;);</span><br><span class="line">expect(wrapper.find(<span class="string">'.in-bar'</span>)).to.have.lengthOf(<span class="number">0</span>);</span><br><span class="line">expect(wrapper.find(Bar)).to.have.lengthOf(<span class="number">1</span>);</span><br><span class="line">expect(wrapper.find(Bar).dive().find(<span class="string">'.in-bar'</span>)).to.have.lengthOf(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="equals-node"><a href="#equals-node" class="headerlink" title="equals(node)"></a>equals(node)</h4><p><code>.equals(node) =&gt; Boolean</code></p><p>返回当前包装器根节点呈现树是否与传入的树相似</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line">expect(wrapper.equals(&lt;div className="foo bar" /&gt;)).to.equal(true);</span><br></pre></td></tr></table></figure><h4 id="every-selector"><a href="#every-selector" class="headerlink" title="every(selector)"></a>every(selector)</h4><p><code>.every(selector) =&gt; Boolean</code></p><p>返回包装器中的所有节点是否与提供的选择器匹配。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo qoo"</span> /&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo boo"</span> /&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo hoo"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp">expect(wrapper.find('.foo').every('.foo')).to.equal(true);</span></span><br><span class="line"><span class="regexp">expect(wrapper.find('.foo').every('.qoo')).to.equal(false);</span></span><br><span class="line"><span class="regexp">expect(wrapper.find('.foo').every('.bar')).to.equal(false);</span></span><br></pre></td></tr></table></figure><h4 id="everyWhere-fn"><a href="#everyWhere-fn" class="headerlink" title="everyWhere(fn)"></a>everyWhere(fn)</h4><p><code>.everyWhere(fn) =&gt; Boolean</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo qoo"</span> /&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo boo"</span> /&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo hoo"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp">expect(wrapper.find('.foo').everyWhere(n =&gt; n.hasClass('foo'))).to.equal(true);</span></span><br><span class="line"><span class="regexp">expect(wrapper.find('.foo').everyWhere(n =&gt; n.hasClass('qoo'))).to.equal(false);</span></span><br><span class="line"><span class="regexp">expect(wrapper.find('.foo').everyWhere(n =&gt; n.hasClass('bar'))).to.equal(false);</span></span><br></pre></td></tr></table></figure><h4 id="exists-selector"><a href="#exists-selector" class="headerlink" title="exists([selector])"></a>exists([selector])</h4><p><code>.exists([selector]) =&gt; Boolean</code></p><p>返回包装器中是否存在任何节点。或者，如果传入选择器，则该选择器是否在包装器中具有任何匹配项。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = mount(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"some-class"</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.exists('.some-class')).to.equal(true);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('.other-class').exists()).to.equal(false);</span></span><br></pre></td></tr></table></figure><h4 id="filter-selector"><a href="#filter-selector" class="headerlink" title="filter(selector)"></a>filter(selector)</h4><p><code>.filter(selector) =&gt; ShallowWrapper</code></p><p>返回一个新的包装器，其中只包含与提供的选择器匹配的当前包装器的节点。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('.foo').filter('.bar')).to.have.lengthOf(1);</span></span><br></pre></td></tr></table></figure><h4 id="filterWhere-fn"><a href="#filterWhere-fn" class="headerlink" title="filterWhere(fn)"></a>filterWhere(fn)</h4><p><code>.filterWhere(fn) =&gt; ShallowWrapper</code></p><p>返回一个新的包装器，它只包含当前包装器的节点，当传递给提供的谓词函数时，返回true</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">const complexFoo = wrapper.find('.foo').filterWhere(n =&gt; typeof n.type() !== 'string');</span></span><br><span class="line"><span class="xml">expect(complexFoo).to.have.lengthOf(4);</span></span><br></pre></td></tr></table></figure><h4 id="find-selector"><a href="#find-selector" class="headerlink" title="find(selector)"></a>find(selector)</h4><p><code>.find(selector) =&gt; ShallowWrapper</code></p><p>查找当前包装器的呈现树中与提供的选择器匹配的每个节点。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foo <span class="keyword">from</span> <span class="string">'../components/Foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('.foo')).to.have.lengthOf(1);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('.bar')).to.have.lengthOf(3);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// compound selector</span></span><br><span class="line"><span class="xml">expect(wrapper.find('div.some-class')).to.have.lengthOf(3);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// CSS id selector</span></span><br><span class="line"><span class="xml">expect(wrapper.find('#foo')).to.have.lengthOf(1);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 组件</span></span><br><span class="line"><span class="xml">expect(wrapper.find(Foo)).to.have.lengthOf(1);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 组件显示名称</span></span><br><span class="line"><span class="xml">expect(wrapper.find('Foo')).to.have.lengthOf(1);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 对象属性选择器</span></span><br><span class="line"><span class="xml">expect(wrapper.find(&#123; prop: 'value' &#125;)).to.have.lengthOf(1);</span></span><br></pre></td></tr></table></figure><h4 id="findWhere-fn"><a href="#findWhere-fn" class="headerlink" title="findWhere(fn)"></a>findWhere(fn)</h4><p><code>.findWhere(fn) =&gt; ShallowWrapper</code></p><p>查找渲染树中为提供的谓词函数返回true的每个节点。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">const complexComponents = wrapper.findWhere(n =&gt; n.type() !== 'string');</span></span><br><span class="line"><span class="xml">expect(complexComponents).to.have.lengthOf(8);</span></span><br></pre></td></tr></table></figure><h4 id="forEach-fn"><a href="#forEach-fn" class="headerlink" title="forEach(fn)"></a>forEach(fn)</h4><p><code>.forEach(fn) =&gt; Self</code></p><p>迭代当前包装器的每个节点，并使用围绕作为第一个参数传入的相应节点的包装器执行提供的函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo bax"</span> /&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo bar"</span> /&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo baz"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">wrapper.find('.foo').forEach((node) =&gt; &#123;</span></span><br><span class="line"><span class="regexp">  expect(node.hasClass('foo')).to.equal(true);</span></span><br><span class="line"><span class="regexp">&#125;);</span></span><br></pre></td></tr></table></figure><h4 id="get-index"><a href="#get-index" class="headerlink" title="get(index)"></a>get(index)</h4><p><code>.get(index) =&gt; ReactElement</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find(Foo).get(0).props.foo).to.equal('bar');</span></span><br></pre></td></tr></table></figure><h4 id="getWrappingComponent"><a href="#getWrappingComponent" class="headerlink" title="getWrappingComponent()"></a>getWrappingComponent()</h4><p><code>.getWrappingComponent() =&gt; ShallowWrapper</code></p><p>如果<code>wrappingComponent</code>传入了a <code>options</code>，则此方法返回<code>ShallowWrapper</code>渲染的周围<code>wrappingComponent</code>。这<code>ShallowWrapper</code>可以用来更新<code>wrappingComponent</code> props，state等。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Router &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./my/app/store'</span>;</span><br><span class="line"><span class="keyword">import</span> mockStore <span class="keyword">from</span> <span class="string">'./my/app/mockStore'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyProvider</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; children, customStore &#125; = props;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;Provider store=&#123;customStore || store&#125;&gt;</span><br><span class="line">      &lt;Router&gt;</span><br><span class="line">        &#123;children&#125;</span><br><span class="line">      &lt;<span class="regexp">/Router&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Provider&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">MyProvider.propTypes = &#123;</span><br><span class="line">  children: PropTypes.node,</span><br><span class="line">  customStore: PropTypes.shape(&#123;&#125;),</span><br><span class="line">&#125;;</span><br><span class="line">MyProvider.defaultProps = &#123;</span><br><span class="line">  children: <span class="literal">null</span>,</span><br><span class="line">  customStore: <span class="literal">null</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>, &#123;</span></span><br><span class="line"><span class="xml">  wrappingComponent: MyProvider,</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line"><span class="xml">const provider = wrapper.getWrappingComponent();</span></span><br><span class="line"><span class="xml">provider.setProps(&#123; customStore: mockStore &#125;);</span></span><br></pre></td></tr></table></figure><h4 id="getElement"><a href="#getElement" class="headerlink" title="getElement()"></a>getElement()</h4><p><code>.getElement() =&gt; ReactElement</code></p><p>返回包装的ReactElement。如果当前包装器正在包装根组件，则返回根组件的最新呈现输出。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;span /&gt;</span><br><span class="line">    &lt;span /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function MyComponent() &#123;</span></span><br><span class="line"><span class="regexp">  return element;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const wrapper = shallow(&lt;MyComponent /</span>&gt;);</span><br><span class="line">expect(wrapper.getElement()).to.equal(element);</span><br></pre></td></tr></table></figure><h4 id="getElements"><a href="#getElements" class="headerlink" title="getElements()"></a>getElements()</h4><p><code>.getElements() =&gt; Array&lt;ReactElement&gt;</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> one = <span class="xml"><span class="tag">&lt;<span class="name">span</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">const two = <span class="tag">&lt;<span class="name">span</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function Test() &#123;</span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;one&#125;</span><br><span class="line">      &#123;two&#125;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  );</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const wrapper = shallow(<span class="tag">&lt;<span class="name">Test</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('span').getElements()).to.deep.equal([one, two]);</span></span><br></pre></td></tr></table></figure><h4 id="hasClass-className"><a href="#hasClass-className" class="headerlink" title="hasClass(className)"></a>hasClass(className)</h4><p><code>.hasClass(className) =&gt; Boolean</code></p><p>返回包装节点是否具有<code>className</code>包含传入的类名称的prop。它必须是单节点包装器。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.find('.my-button').hasClass('disabled')).to.equal(true);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 正则</span></span><br><span class="line"><span class="xml">expect(wrapper.find('.my-button').hasClass(/(ComponentName)-(other)-(\d+)/)).to.equal(true);</span></span><br></pre></td></tr></table></figure><h4 id="hostNodes"><a href="#hostNodes" class="headerlink" title="hostNodes()"></a>hostNodes()</h4><p><code>.hostNodes() =&gt; ShallowWrapper</code></p><p>返回仅包含主机节点的新包装器。当使用<code>react-dom</code>，主机节点是HTML元素，而不是定制反应的组分</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;MyComponent className=<span class="string">"foo"</span> /&gt;</span><br><span class="line">    &lt;span className=<span class="string">"foo"</span> /&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">));</span></span><br><span class="line"><span class="regexp">const twoNodes = wrapper.find('.foo');</span></span><br><span class="line"><span class="regexp">expect(twoNodes.hostNodes()).to.have.lengthOf(1);</span></span><br></pre></td></tr></table></figure><h4 id="html"><a href="#html" class="headerlink" title="html()"></a>html()</h4><p><code>.html() =&gt; String</code></p><p>返回整个当前渲染树（不仅仅是浅渲染部分）的渲染HTML标记的字符串。只能在单个节点的包装器上调用</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"in-foo"</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function Bar() &#123;</span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line">    &lt;div className="in-bar"&gt;</span><br><span class="line">      &lt;Foo /&gt;</span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">  );</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const wrapper = shallow(<span class="tag">&lt;<span class="name">Bar</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.html()).to.equal('<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"in-bar"</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"in-foo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>');</span></span><br><span class="line"><span class="xml">expect(wrapper.find(Foo).html()).to.equal('<span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"in-foo"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>');</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">const wrapper = shallow(<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>important<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.html()).to.equal('<span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>important<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>');</span></span><br></pre></td></tr></table></figure><h4 id="instance"><a href="#instance" class="headerlink" title="instance()"></a>instance()</h4><p><code>.instance() =&gt; ReactComponent</code></p><p>返回单节点包装器节点的底层类实例; <code>this</code>在它的方法。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stateless</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Stateless<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stateful</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Stateful<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(<span class="string">'shallow wrapper instance should be null'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">Stateless</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">  const instance = wrapper.instance();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  expect(instance).to.equal(null);</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">test('shallow wrapper instance should not be null', () =&gt; &#123;</span></span><br><span class="line"><span class="xml">  const wrapper = shallow(<span class="tag">&lt;<span class="name">Stateful</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">  const instance = wrapper.instance();</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">  expect(instance).to.be.instanceOf(Stateful);</span></span><br><span class="line"><span class="xml">&#125;);</span></span><br></pre></td></tr></table></figure><h4 id="is-selector"><a href="#is-selector" class="headerlink" title="is(selector)"></a>is(selector)</h4><p><code>.is(selector) =&gt; Boolean</code></p><p>返回单个包装节点是否与提供的选择器匹配。它必须是单节点包装器。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"some-class other-class"</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.is('.some-class')).to.equal(true);</span></span><br></pre></td></tr></table></figure><h4 id="isEmptyRender"><a href="#isEmptyRender" class="headerlink" title="isEmptyRender()"></a>isEmptyRender()</h4><p><code>.isEmptyRender() =&gt; Boolean</code></p><p>返回包装器是否最终只呈现允许的假值：<code>false</code>或<code>null</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">Foo</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.isEmptyRender()).to.equal(true);</span></span><br></pre></td></tr></table></figure><h4 id="key"><a href="#key" class="headerlink" title="key()"></a>key()</h4><p><code>.key() =&gt; String</code></p><p>返回当前包装器节点的键值。它必须是单节点包装器。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    &#123;[<span class="string">'foo'</span>, <span class="string">'bar'</span>].map(<span class="function"><span class="params">s</span> =&gt;</span> &lt;li key=&#123;s&#125;&gt;&#123;s&#125;&lt;<span class="regexp">/li&gt;)&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/u</span>l&gt;</span><br><span class="line">)).find(<span class="string">'li'</span>);</span><br><span class="line">expect(wrapper.at(<span class="number">0</span>).key()).to.equal(<span class="string">'foo'</span>);</span><br><span class="line">expect(wrapper.at(<span class="number">1</span>).key()).to.equal(<span class="string">'bar'</span>);</span><br></pre></td></tr></table></figure><h4 id="map-fn"><a href="#map-fn" class="headerlink" title="map(fn)"></a>map(fn)</h4><p><code>.map(fn) =&gt; Array&lt;Any&gt;</code></p><p>将当前节点数组映射到另一个数组。每个节点作为a传递<code>ShallowWrapper</code> 给map函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow((</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo"</span>&gt;bax&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;div className="foo"&gt;bar&lt;/</span>div&gt;</span><br><span class="line">    &lt;div className=<span class="string">"foo"</span>&gt;baz&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> texts = wrapper.find(<span class="string">'.foo'</span>).map(<span class="function"><span class="params">node</span> =&gt;</span> node.text());</span><br><span class="line">expect(texts).to.eql([<span class="string">'bax'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>]);</span><br></pre></td></tr></table></figure><h4 id="matchesElement-patternNode"><a href="#matchesElement-patternNode" class="headerlink" title="matchesElement(patternNode)"></a>matchesElement(patternNode)</h4><p><code>.matchesElement(patternNode) =&gt; Boolean</code></p><p>回给定的react元素是否<code>patternNode</code>与包装器的渲染树匹配。它必须是单节点包装器，并且仅检查根节点。</p><p>这些<code>patternNode</code>行为就像一张通配符。为了匹配包装器中的节点：</p><ul><li>标签名称必须匹配</li><li>内容必须匹配：在文本节点中，前导和尾随空格被忽略，但中间空间不被忽略。子元素必须根据这些规则以递归方式匹配。</li><li><code>patternNode</code>props（attributes）必须出现在包装器的节点中，而不是相反。如果它们出现，它们的值必须匹配。</li><li><code>patternNode</code>样式CSS属性必须出现在包装器节点的样式中，而不是相反。如果它们出现，它们的值必须匹配。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button type=<span class="string">"button"</span> onClick=&#123;<span class="keyword">this</span>.handleClick&#125; className=<span class="string">"foo bar"</span>&gt;Hello&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const wrapper = shallow(&lt;MyComponent /</span>&gt;);</span><br><span class="line">expect(wrapper.matchesElement(<span class="xml"><span class="tag">&lt;<span class="name">button</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>)).to.equal(<span class="literal">true</span>);</span><br><span class="line">expect(wrapper.matchesElement(<span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">"foo bar"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>)).to.equal(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="name"><a href="#name" class="headerlink" title="name()"></a>name()</h4><p><code>.name() =&gt; String|null</code></p><p>返回此包装器的当前节点的名称。如果它是复合组件，则这将是最顶层渲染组件的名称。如果它是本机DOM节点，则它将是标记名称的字符串。如果是的话<code>null</code>，那就是<code>null</code>。</p><p>返回名称的优先顺序是：<code>type.displayName</code>- &gt; <code>type.name</code>- &gt; <code>type</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = shallow(<span class="xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.name()).to.equal('div');</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function SomeWrappingComponent() &#123;</span></span><br><span class="line"><span class="xml">  return <span class="tag">&lt;<span class="name">Foo</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">const wrapper = shallow(<span class="tag">&lt;<span class="name">SomeWrappingComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.name()).to.equal('Foo');</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">Foo.displayName = 'A cool custom name';</span></span><br><span class="line"><span class="xml">function SomeWrappingComponent() &#123;</span></span><br><span class="line"><span class="xml">  return <span class="tag">&lt;<span class="name">Foo</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">const wrapper = shallow(<span class="tag">&lt;<span class="name">SomeWrappingComponent</span> /&gt;</span>);</span></span><br><span class="line"><span class="xml">expect(wrapper.name()).to.equal('A cool custom name');</span></span><br></pre></td></tr></table></figure><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li><a href="https://coding.imooc.com/class/372.html">前端要学的测试课 从Jest入门到TDD/BDD双实战</a></li><li><a href="https://jestjs.io/en/">jest 官方文档</a></li><li><a href="https://airbnb.io/enzyme/">enzyme官方文档</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端必备的测试&quot;&gt;&lt;a href=&quot;#前端必备的测试&quot; class=&quot;headerlink&quot; title=&quot;前端必备的测试&quot;&gt;&lt;/a&gt;前端必备的测试&lt;/h1&gt;&lt;p&gt;DellLee 老师的 &lt;a href=&quot;https://coding.imooc.com/clas
      
    
    </summary>
    
      <category term="测试" scheme="http://laibh.top/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试" scheme="http://laibh.top/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>工欲善其事，必先利其器(eslint+prettier)</title>
    <link href="http://laibh.top/2019-08-08-%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B%EF%BC%8C%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8(eslint+prettier).html"/>
    <id>http://laibh.top/2019-08-08-工欲善其事，必先利其器(eslint+prettier).html</id>
    <published>2019-08-08T01:30:54.000Z</published>
    <updated>2019-10-15T09:29:49.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工欲善其事，必先利其器-eslint-prettier"><a href="#工欲善其事，必先利其器-eslint-prettier" class="headerlink" title="工欲善其事，必先利其器(eslint+prettier)"></a>工欲善其事，必先利其器(eslint+prettier)</h2><h3 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h3><p><a href="https://prettier.io/docs/en/index.html">官网</a></p><h4 id="什么叫Prettier？"><a href="#什么叫Prettier？" class="headerlink" title="什么叫Prettier？"></a>什么叫Prettier？</h4><p>Prettier是一个固定的代码格式化程序，支持：</p><ul><li>JavaScript，包括<a href="https://github.com/tc39/proposals/blob/master/finished-proposals.md">ES2017</a></li><li><a href="https://facebook.github.io/jsx/">JSX</a></li><li><a href="https://angular.io/">Angular</a></li><li><a href="https://vuejs.org/">Vue</a></li><li><a href="https://flow.org/">Flow</a></li><li><a href="https://www.typescriptlang.org/">TS</a></li><li>CSS，<a href="http://lesscss.org/">Less</a>和<a href="http://sass-lang.com/">SCSS</a></li><li><a href="https://en.wikipedia.org/wiki/HTML">HTML</a></li><li><a href="http://json.org/">JSON</a></li><li><a href="http://graphql.org/">GraphQL</a></li><li><a href="http://commonmark.org/">Markdown</a>，包括<a href="https://github.github.com/gfm/">GFM</a>和<a href="https://mdxjs.com/">MDX</a></li><li><a href="http://yaml.org/">YAML</a></li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> yarn</span><br><span class="line">yarn add prettier --dev --exact</span><br><span class="line"><span class="meta">#</span> 全局</span><br><span class="line">yarn global add prettier</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> npm</span><br><span class="line">npm install --save-dev --save-exact prettier</span><br><span class="line"><span class="meta">#</span> 全局</span><br><span class="line">npm install --global prettier</span><br></pre></td></tr></table></figure><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // 排版宽度,即每行最大宽度，默认值是80</span><br><span class="line">  "printWidth":100,</span><br><span class="line">  // 制表符宽度，每个层级缩进几个空格，默认值为2</span><br><span class="line">  "tabWidth": 2,</span><br><span class="line">  // 是否使用 tab 替代 space 为单位缩进，默认值为false</span><br><span class="line">  "useTabs": false,</span><br><span class="line">  // 分号，句尾是否自动补全分号，默认为true</span><br><span class="line">  "semi": true,</span><br><span class="line">  // 启用双引号，不启用单引号,默认为true</span><br><span class="line">  "singleQuote": true,</span><br><span class="line">  // 在 JSX 文件中使用单引号替代双引号，默认为 false</span><br><span class="line">  "jsxSingleQuote": true,</span><br><span class="line">  // 为多行数组的非末尾添加逗号（单行数组不需要逗号），数值：none(不添加逗号)、es5(在ES5中生效的逗号，对象数组等)，all(任何可以添加逗号的地方)</span><br><span class="line">  "trailingComma": "es5",</span><br><span class="line">  // 括号空格，在对象字面量和括号之间添加空格，默认为 true</span><br><span class="line">  "bracketSpacing": true,</span><br><span class="line">  // 将多行 JSX 元素的 &gt; 放置于最后一行的末尾，而非换行。默认为 false</span><br><span class="line">  "jsxBracketSameLine": false,</span><br><span class="line">  // 箭头函数圆括号，默认为 avoid(在可以消除的情况下，消除括号)，always(一直保留括号)</span><br><span class="line">  "arrowParens": "avoid",</span><br><span class="line">  "overrides": [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"files"</span>: <span class="string">".prettierrc"</span>,</span><br><span class="line">      <span class="attr">"options"</span>: &#123; <span class="attr">"parser"</span>: <span class="string">"json"</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h3><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><h4 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h4><p>命名必须传递足够的信息。<code>fetchUserInfoAsync</code>比<code>getData</code>更加具体</p><p><strong>命名基础</strong></p><h3 id="半自动构建"><a href="#半自动构建" class="headerlink" title="半自动构建"></a>半自动构建</h3><h4 id="husky"><a href="#husky" class="headerlink" title="husky"></a>husky</h4><p>Husky 可以阻止无效的 <code>git commit</code>、<code>git push</code>以及其他woff行为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install husky --save-dev</span><br></pre></td></tr></table></figure><h4 id="lint-staged"><a href="#lint-staged" class="headerlink" title="lint-staged"></a>lint-staged</h4><p>针对暂存的git文件运行linters并且不要让💩滑入你的代码库！</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install lint-staged --save-dev</span><br></pre></td></tr></table></figure><h4 id="commitlint"><a href="#commitlint" class="headerlink" title="commitlint"></a>commitlint</h4><p>规范 <code>commit message</code>,便于自动生成 <code>CHANGELOG</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install commitlint @commitlint/cli @commitlint/config-conventional --save-dev</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// commitlint.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  extends: [<span class="string">"@commitlint/config-conventional"</span>],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    <span class="string">"type-enum"</span>: [</span><br><span class="line">      <span class="number">2</span>,</span><br><span class="line">      <span class="string">"always"</span>,</span><br><span class="line">      [<span class="string">"feat"</span>, <span class="string">"fix"</span>, <span class="string">"docs"</span>, <span class="string">"style"</span>, <span class="string">"refactor"</span>, <span class="string">"test"</span>, <span class="string">"chore"</span>, <span class="string">"revert"</span>]</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"subject-full-stop"</span>: [<span class="number">0</span>, <span class="string">"never"</span>],</span><br><span class="line">    <span class="string">"subject-case"</span>: [<span class="number">0</span>, <span class="string">"never"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * feat：新功能（feature）</span></span><br><span class="line"><span class="comment"> * fix：修补bug</span></span><br><span class="line"><span class="comment"> * docs：文档（documentation）</span></span><br><span class="line"><span class="comment"> * style： 格式（不影响代码运行的变动）</span></span><br><span class="line"><span class="comment"> * refactor：重构（即不是新增功能，也不是修改bug的代码变动）</span></span><br><span class="line"><span class="comment"> * test：增加测试</span></span><br><span class="line"><span class="comment"> * chore：构建过程或辅助工具的变动</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="conventional-changelog"><a href="#conventional-changelog" class="headerlink" title="conventional-changelog"></a>conventional-changelog</h4><p>自动生成 <code>CHANGELOG</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install conventional-changelog conventional-changelog-cli --save-dev</span><br></pre></td></tr></table></figure><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"start"</span>: <span class="string">"concurrently \"node scripts/start.js\" \"npm run mock\""</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"node scripts/build.js"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"node scripts/test.js"</span>,</span><br><span class="line">    <span class="attr">"eslint"</span>: <span class="string">"eslint --fix **/*.js"</span>,</span><br><span class="line">    <span class="attr">"prettier"</span>: <span class="string">"prettier --write ./src/**/**/**/*"</span>,</span><br><span class="line">    <span class="attr">"mock"</span>: <span class="string">"json-server --watch db.json --port 3004"</span>,</span><br><span class="line">    <span class="attr">"changelog"</span>: <span class="string">"conventional-changelog -p angular -i CHANGELOG.md -s -r 0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"husky"</span>: &#123;</span><br><span class="line">    <span class="attr">"hooks"</span>: &#123;</span><br><span class="line">      <span class="attr">"pre-commit"</span>: <span class="string">"lint-staged"</span>,</span><br><span class="line">      <span class="attr">"commit-msg"</span>: <span class="string">"commitlint -E HUSKY_GIT_PARAMS"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"lint-staged"</span>: &#123;</span><br><span class="line">    <span class="attr">"src/**/*.&#123;jsx,txs,ts,js,json,css,md&#125;"</span>: [</span><br><span class="line">      <span class="string">"prettier --write ./src/**/**/**/*"</span>,</span><br><span class="line">      <span class="string">"eslint --fix **/*.js"</span>,</span><br><span class="line">      <span class="string">"git add"</span></span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"config"</span>: &#123;</span><br><span class="line">    <span class="attr">"commitizen"</span>: &#123;</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"cz-customizable"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="commit-amp-push"><a href="#commit-amp-push" class="headerlink" title="commit&amp;push"></a>commit&amp;push</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 当有新的改变</span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 提交，输入不规范的提交信息，先校验代码， 提示不规范，并且不通过</span><br><span class="line">git commit -m "test"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 输入规范信息，规范自行百度，也可以从 commitlint.config.js中看出。运行钩子自动prettier，接着运行 eslint,没有报错则 git add，并开始校验提交信息是否规范，无误后顺利提交</span><br><span class="line">git commit -m "feat: add semi-automatic construction"</span><br><span class="line">husky &gt; pre-commit (node v10.15.3)</span><br><span class="line">Stashing changes... [started]</span><br><span class="line">Stashing changes... [skipped]</span><br><span class="line">→ No partially staged files found...</span><br><span class="line">Running tasks... [started]</span><br><span class="line">Running tasks for src/**/*.&#123;jsx,txs,ts,js,json,css,md&#125; [started]</span><br><span class="line">prettier --write ./src/**/**/**/* [started]</span><br><span class="line">prettier --write ./src/**/**/**/* [completed]</span><br><span class="line">eslint --fix **/*.js [started]</span><br><span class="line">eslint --fix **/*.js [completed]</span><br><span class="line">git add [started]</span><br><span class="line">git add [completed]</span><br><span class="line">Running tasks for src/**/*.&#123;jsx,txs,ts,js,json,css,md&#125; [completed]</span><br><span class="line">Running tasks... [completed]</span><br><span class="line">husky &gt; commit-msg (node v10.15.3)</span><br><span class="line">[master 9afdd76] test: lint-staged</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span> 推送到 orgin</span><br><span class="line">git push</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> 生成 changelog</span><br><span class="line">npm run changelog</span><br><span class="line"><span class="meta">&gt;</span> conventional-changelog -p angular -i CHANGELOG.md -s -r 0</span><br></pre></td></tr></table></figure><h3 id="CSS样式顺序"><a href="#CSS样式顺序" class="headerlink" title="CSS样式顺序"></a>CSS样式顺序</h3><p>相关属性应该为一组，可以以下面的样式为编写顺序</p><ul><li>Positioning</li><li>Box model</li><li>Typographic</li><li>Visual</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.declaration-order&#123;</span><br><span class="line">    <span class="comment">/* Positioning */</span></span><br><span class="line">    position: absolute;</span><br><span class="line">    top: <span class="number">0</span>;</span><br><span class="line">    right: <span class="number">0</span>;</span><br><span class="line">    bottom: <span class="number">0</span>;</span><br><span class="line">    left: <span class="number">0</span>;</span><br><span class="line">    z-index: <span class="number">100</span>;    </span><br><span class="line">    <span class="comment">/* Box model */</span></span><br><span class="line">    display:block;</span><br><span class="line">    box-sizing: border-box;</span><br><span class="line">    width: <span class="number">100</span>px;</span><br><span class="line">    height: <span class="number">100</span>px;</span><br><span class="line">    padding: <span class="number">10</span>px;</span><br><span class="line">    border: 1px solid #666;</span><br><span class="line">    border-radius: <span class="number">5</span>px;</span><br><span class="line">    margin: <span class="number">10</span>px;</span><br><span class="line">    float: right;</span><br><span class="line">    overflow: hidden;</span><br><span class="line">    <span class="comment">/* Typographic */</span></span><br><span class="line">    font: normal <span class="number">12</span>px <span class="string">'Helvetica Neue'</span>,sans-serif;</span><br><span class="line">    line-height: <span class="number">1.5</span>;</span><br><span class="line">    text-align: center;</span><br><span class="line">    <span class="comment">/* Visual */</span></span><br><span class="line">    background-color: #333;</span><br><span class="line">    color: #fff;</span><br><span class="line">    opacity: <span class="number">0.8</span>;</span><br><span class="line">    <span class="comment">/* Other */</span></span><br><span class="line">    cursor: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ol><li><a href="http://taobaofed.org/blog/2017/01/05/writing-readable-code/">编写「可读」代码的实践</a></li><li><a href="https://imweb.io/topic/5a5cc753a192c3b460fce3fc">前端开发规范之命名规范、html规范、css规范、js规范</a></li><li><a href="https://prettier.io/docs/en/install.html">Prettier</a></li><li><a href="http://eslint.cn/docs/rules/">eslint</a></li><li><a href="https://github.com/airbnb/javascript">airbnb规范</a></li><li><a href="https://github.com/yannickcr/eslint-plugin-react/tree/1aab93d0e3e91f73accdfc3a59afbdaf97c0d08e/docs/rules">eslint-plugin-react</a></li><li><a href="https://github.com/AlloyTeam/eslint-config-alloy">eslint-config-alloy</a></li><li><a href="https://github.com/evcohen/eslint-plugin-jsx-a11y/tree/master/docs/rules">eslint-plugin-jsx-a11y</a></li><li><a href="https://www.npmjs.com/package/husky">husky</a></li><li><a href="https://www.npmjs.com/package/lint-staged">lint-staged</a></li><li><a href="https://commitlint.js.org/#/concepts-commit-conventions">commitlint</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工欲善其事，必先利其器-eslint-prettier&quot;&gt;&lt;a href=&quot;#工欲善其事，必先利其器-eslint-prettier&quot; class=&quot;headerlink&quot; title=&quot;工欲善其事，必先利其器(eslint+prettier)&quot;&gt;&lt;/a&gt;工欲善其
      
    
    </summary>
    
      <category term="规范" scheme="http://laibh.top/categories/%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="规范" scheme="http://laibh.top/tags/%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>从leetCode学习JavaScript数据结构与基础算法</title>
    <link href="http://laibh.top/2019-07-03-%E4%BB%8EleetCode%E5%AD%A6%E4%B9%A0JavaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95.html"/>
    <id>http://laibh.top/2019-07-03-从leetCode学习JavaScript数据结构与基础算法.html</id>
    <published>2019-07-03T01:30:54.000Z</published>
    <updated>2019-10-15T09:29:49.415Z</updated>
    
    <content type="html"><![CDATA[<p>循序渐进，保持空杯</p><h2 id="从leetCode学习JavaScript数据结构与基础算法"><a href="#从leetCode学习JavaScript数据结构与基础算法" class="headerlink" title="从leetCode学习JavaScript数据结构与基础算法"></a>从leetCode学习JavaScript数据结构与基础算法</h2><p>简单算法：</p><p><code>字符串</code>、<code>数组</code>、<code>正则</code>、<code>排序</code>、<code>递归</code></p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p><strong>反转字符串中的单词③</strong></p><p>给定一个字符串，需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序</p><p>实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入："Let's take LeetCode contest"</span><br><span class="line">输出："s'teL ekat edoCteeL tsetnoc"</span><br></pre></td></tr></table></figure><p>注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment">* @return &#123;string&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 1.字符串按空格进行分隔，数组的元素的先后顺序就是单词的顺序</span></span><br><span class="line">    <span class="comment">// 2.遍历数组的元素，也就是每个单词String，通过 split分隔转Array 同时用Array 自带的 reverse方法将每个单词数组分隔后产生的数组反转</span></span><br><span class="line">    <span class="comment">// 3.接着用join('')将单词数组中的每个数组拼凑成字符串</span></span><br><span class="line">    <span class="comment">// 4.最后将字符串单词数组拼凑为最终的字符串</span></span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">' '</span>).map(<span class="function"><span class="params">i</span>=&gt;</span>i.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)).join(<span class="string">' '</span>)</span><br><span class="line">    <span class="comment">// 或者用正则，匹配空格</span></span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="regexp">/\s/g</span>).map(<span class="function"><span class="params">i</span>=&gt;</span>i.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)).join(<span class="string">' '</span>)</span><br><span class="line">    <span class="comment">// 匹配单词(match)</span></span><br><span class="line">    <span class="keyword">return</span> s.match(<span class="regexp">/[\w']+/g</span>).map(<span class="function"><span class="params">i</span>=&gt;</span>i.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)).join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> reverseByWord <span class="keyword">from</span> <span class="string">'../../code/string/lession1'</span></span><br><span class="line"></span><br><span class="line">test(<span class="string">'reverseByWord:Let\'s take LeetCode contest'</span>, () =&gt; &#123;</span><br><span class="line">  expect(reverseByWord(<span class="string">"Let's take LeetCode contest"</span>)).toBe(<span class="string">"s'teL ekat edoCteeL tsetnoc"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>知识点：</p><p><code>String.prototype.split</code>、<code>String.prototype.match</code>、<code>Array.prototype.map</code>、<code>Array.prototype.reverse</code>、<code>Array.prototype.join</code></p><p>扩展：上面讲的是单个空格隔开，那如果不是当个空格呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样可以使用正则的贪婪匹配来解决</span></span><br><span class="line"><span class="keyword">const</span> reverseWords = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 或者用正则，匹配空格</span></span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="regexp">/\s+/g</span>).map(<span class="function"><span class="params">i</span>=&gt;</span>i.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)).join(<span class="string">' '</span>)</span><br><span class="line">    <span class="comment">// 匹配单词(match)</span></span><br><span class="line">    <span class="keyword">return</span> s.match(<span class="regexp">/[\w']+/g</span>).map(<span class="function"><span class="params">i</span>=&gt;</span>i.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)).join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>计数二进制子串</strong></p><p>给定一个字符串 <code>s</code>，计算具有相同数量 0 和 1的非空（连续）子符串的数量，并且这些子字符串中的所有 0 和 1 都是组合在一起的。</p><p>重复出现的子串要计算它们出现的次数。</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入："00110011"</span><br><span class="line">输出：6</span><br><span class="line">解释：有6个子串具有相同数量的连续1和0："0011","01","1100","10","0011"和"01"</span><br><span class="line">请注意，一些重复出现的子串要计算它们出现的次数</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; str</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (str) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 创建数据结构堆栈保存数据</span></span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line">  <span class="keyword">const</span> match = <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> j = str.match(<span class="regexp">/^(0+|1+)/</span>)[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">// j=(n个)0-&gt;o=(n个)1;j=(n个)1-&gt;o=(n个)0;</span></span><br><span class="line">    <span class="keyword">let</span> o = (j[<span class="number">0</span>] ^ <span class="number">1</span>).toString().repeat(j.length)</span><br><span class="line">    <span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">`^(<span class="subst">$&#123;j&#125;</span><span class="subst">$&#123;o&#125;</span>)`</span>)</span><br><span class="line">    <span class="keyword">if</span> (reg.test(str)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">RegExp</span>.$<span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = str.length - <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="comment">// 简单递归</span></span><br><span class="line">    <span class="keyword">let</span> sub = match(str.slice(i))</span><br><span class="line">    <span class="keyword">if</span> (sub) &#123;</span><br><span class="line">      result.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'countBinarySubstring(00110011)'</span>, () =&gt; &#123;</span><br><span class="line">  expect(countBinarySubstring(<span class="string">'00110011'</span>)).toEqual([<span class="string">'0011'</span>, <span class="string">'01'</span>, <span class="string">'1100'</span>, <span class="string">'10'</span>, <span class="string">'0011'</span>, <span class="string">'01'</span>])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'countBinarySubstring(10101)'</span>, () =&gt; &#123;</span><br><span class="line">  expect(countBinarySubstring(<span class="string">'10101'</span>)).toEqual([<span class="string">'10'</span>, <span class="string">'01'</span>, <span class="string">'10'</span>, <span class="string">'01'</span>])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>知识点：</p><p><code>发现规律</code>，<code>RegExp</code></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong>电话号码的组合</strong></p><p>给定一个仅包含 <code>2-9</code>的字符串，返回它能表示的字母组合。给出数字到字母的映射如下（与电话按钮相同）。注意1不对应任何字母</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1[] 2[abc] 3[def]</span><br><span class="line">4[ghi] 5[jkl] 6[mno]</span><br><span class="line">7[pqrs] 8[tuv] 9[wxyz]</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： "23"</span><br><span class="line">输出： ["ad","ae","af","bd","be","bf","cd","ce","cf"]</span><br></pre></td></tr></table></figure><p>说明：上面的答案是按字典排序的，可以任意选择答案输出的顺序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; digits</span></span><br><span class="line"><span class="comment"> * @return &#123;string[]&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (digits) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (digits.length &lt; <span class="number">1</span>) <span class="keyword">return</span> []</span><br><span class="line">  <span class="comment">// 建立电话号码键盘映射</span></span><br><span class="line">  <span class="keyword">const</span> map = [<span class="string">''</span>, <span class="number">1</span>, <span class="string">'abc'</span>, <span class="string">'def'</span>, <span class="string">'ghi'</span>, <span class="string">'jkl'</span>, <span class="string">'mno'</span>, <span class="string">'pqrs'</span>, <span class="string">'tuv'</span>, <span class="string">'wxyz'</span>]</span><br><span class="line">  <span class="keyword">if</span> (digits.length &lt; <span class="number">2</span>) <span class="keyword">return</span> map[digits].split(<span class="string">''</span>)</span><br><span class="line">  <span class="comment">// 将输入的digits 分隔成数组，234=&gt;[2,3,4]</span></span><br><span class="line">  <span class="keyword">const</span> num = digits.split(<span class="string">''</span>)</span><br><span class="line">  <span class="comment">// 保存键盘映射后的字母内容，如 23=&gt;['abc','def']</span></span><br><span class="line">  <span class="keyword">const</span> code = []</span><br><span class="line">  num.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    code.push(map[item])</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">const</span> comb = <span class="function">(<span class="params">arr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 临时变量用来保存两个组合的结果</span></span><br><span class="line">    <span class="keyword">const</span> temp = []</span><br><span class="line">    <span class="comment">// 循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, ilen = arr[<span class="number">0</span>].length; i &lt; ilen; i++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>, jlen = arr[<span class="number">1</span>].length; j &lt; jlen; j++) &#123;</span><br><span class="line">        temp.push(<span class="string">`<span class="subst">$&#123;arr[<span class="number">0</span>][i]&#125;</span><span class="subst">$&#123;arr[<span class="number">1</span>][j]&#125;</span>`</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去掉一开始遍历的前两个，替换为这两个循环后的结果</span></span><br><span class="line">    arr.splice(<span class="number">0</span>, <span class="number">2</span>, temp)</span><br><span class="line">    <span class="comment">// 当数组的长度大于1时递归</span></span><br><span class="line">    <span class="keyword">if</span> (arr.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      comb(arr)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回真正的结果</span></span><br><span class="line">    <span class="keyword">return</span> arr[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 开始递归运算</span></span><br><span class="line">  <span class="keyword">return</span> comb(code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试用例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">'letterCombinations(23)'</span>, () =&gt; &#123;</span><br><span class="line">  expect(letterCombinations(<span class="string">'23'</span>)).toEqual([<span class="string">'ad'</span>, <span class="string">'ae'</span>, <span class="string">'af'</span>, <span class="string">'bd'</span>, <span class="string">'be'</span>, <span class="string">'bf'</span>, <span class="string">'cd'</span>, <span class="string">'ce'</span>, <span class="string">'cf'</span>])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">test(<span class="string">'letterCombinations(234)'</span>, () =&gt; &#123;</span><br><span class="line">  expect(letterCombinations(<span class="string">'234'</span>)).toEqual([</span><br><span class="line">    <span class="string">'adg'</span>, <span class="string">'adh'</span>, <span class="string">'adi'</span>,</span><br><span class="line">    <span class="string">'aeg'</span>, <span class="string">'aeh'</span>, <span class="string">'aei'</span>,</span><br><span class="line">    <span class="string">'afg'</span>, <span class="string">'afh'</span>, <span class="string">'afi'</span>,</span><br><span class="line">    <span class="string">'bdg'</span>, <span class="string">'bdh'</span>, <span class="string">'bdi'</span>,</span><br><span class="line">    <span class="string">'beg'</span>, <span class="string">'beh'</span>, <span class="string">'bei'</span>,</span><br><span class="line">    <span class="string">'bfg'</span>, <span class="string">'bfh'</span>, <span class="string">'bfi'</span>,</span><br><span class="line">    <span class="string">'cdg'</span>, <span class="string">'cdh'</span>, <span class="string">'cdi'</span>,</span><br><span class="line">    <span class="string">'ceg'</span>, <span class="string">'ceh'</span>, <span class="string">'cei'</span>,</span><br><span class="line">    <span class="string">'cfg'</span>, <span class="string">'cfh'</span>, <span class="string">'cfi'</span></span><br><span class="line">  ])</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>知识点：</p><p><code>公式运算</code></p><p><strong>卡牌分组</strong></p><p>给定一副牌，每张牌上都写着一个整数。</p><p>此时，需要选定一个数字 <code>x</code>，使得可以将整部牌按下述规则分成 1 组或者更多：</p><ul><li>每组都有 <code>x</code> 张牌</li><li>组内所有的牌上都写着相同的整数</li></ul><p>仅当可选的 <code>x&gt;=2</code>时返回 <code>true</code></p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,4,4,3,2,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：可行的分组是 [1,1],[2,2],[3,3],[4,4]</span><br></pre></td></tr></table></figure><p>提示：</p><ol><li><code>1 &lt;= deck.length &lt;= 10000</code></li><li><code>0 &lt;= deck[i] &lt; 10000</code></li></ol><p>知识点：</p><p><code>归并运算</code></p><p><strong>种花问题</strong></p><p>知识点：</p><p><code>筛选运算</code></p><p><strong>格雷编码</strong></p><p>知识点：</p><p><code>二进制运算</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;循序渐进，保持空杯&lt;/p&gt;
&lt;h2 id=&quot;从leetCode学习JavaScript数据结构与基础算法&quot;&gt;&lt;a href=&quot;#从leetCode学习JavaScript数据结构与基础算法&quot; class=&quot;headerlink&quot; title=&quot;从leetCode学习Java
      
    
    </summary>
    
      <category term="javaScript相关" scheme="http://laibh.top/categories/javaScript%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="javaScript数据结构与算法" scheme="http://laibh.top/tags/javaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>React源码浅析</title>
    <link href="http://laibh.top/2019-06-29-React%E6%BA%90%E7%A0%81%E6%B5%85%E6%9E%90.html"/>
    <id>http://laibh.top/2019-06-29-React源码浅析.html</id>
    <published>2019-06-29T01:30:54.000Z</published>
    <updated>2019-10-15T09:29:49.415Z</updated>
    
    <content type="html"><![CDATA[<p>知其然知其所以然，框架工的自我尝试进阶</p><h2 id="React源码浅析"><a href="#React源码浅析" class="headerlink" title="React源码浅析"></a>React源码浅析</h2><p>知识点：</p><p><strong>React Api</strong></p><p><code>createElement</code>、<code>createContext</code>、<code>JSX=&gt;JS</code>、<code>ConcurrentMode</code>、<code>Ref</code>、<code>Component</code>、<code>Suspense</code>、<code>Hooks</code></p><p><strong>React 中的更新创建</strong></p><p><code>ReactDOM.render</code>、<code>Fiber</code>、<code>UpdateQueue</code>、<code>FiberRoot</code>、<code>Update</code>、<code>expirationTime</code></p><p><strong>Fiber Scheduler</strong></p><p><code>scheduleWork</code>、<code>batchedUpdates</code>、<code>performWork</code>、<code>performUnitOfWork</code>、<code>requestWork</code>、<code>react scheduler</code>、<code>renderRoot</code></p><p><strong>开始更新</strong></p><p><code>beginWork以及优化</code>、<code>各类组件的更新过程</code>、<code>调节子节点的过程</code></p><p><strong>完成各个节点的更新</strong></p><p><code>completeUnitOfWork</code>、<code>虚拟DOM对比</code>、<code>completeWork</code>、<code>错误捕获处理</code>、<code>unwindwork</code>、<code>完成整棵树更新</code></p><p><strong>提交更新</strong></p><p><code>commitRoot整体流程</code>、<code>开发时的帮助方法</code>、<code>提交快照</code>、<code>提交DOM插入</code>、<code>提交DOM更新</code>、<code>提交DOM删除</code>、<code>提交所有生命周期</code></p><p><strong>各功能的实现功能</strong></p><p><code>context的实现过程</code>、<code>ref的实现过程</code>、<code>hydrate的实现过程</code>、<code>React的事件体系</code></p><p><strong>Suspense</strong></p><p><code>更新优先级的概念</code>、<code>更新挂起的概念</code>、<code>Suspense组件更新</code>、<code>timeout处理</code>、<code>retry重新尝试渲染</code>、<code>lazy组件更新</code></p><p><strong>Hooks</strong></p><p><code>核心原理</code>、<code>useState</code>、<code>useEffect</code>、<code>useContent</code>、<code>其他Hooks API</code></p><h3 id="React-Api-相关"><a href="#React-Api-相关" class="headerlink" title="React Api 相关"></a>React Api 相关</h3><h4 id="React-js"><a href="#React-js" class="headerlink" title="React.js"></a>React.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const React = &#123;</span><br><span class="line">    Children:&#123;</span><br><span class="line">        map,</span><br><span class="line">        forEach,</span><br><span class="line">        count,</span><br><span class="line">        toArray,</span><br><span class="line">        only</span><br><span class="line">    &#125;,</span><br><span class="line">    createRef,</span><br><span class="line">    Component,</span><br><span class="line">    PureComponent,</span><br><span class="line">    createContext,</span><br><span class="line">    forWardRef,</span><br><span class="line">    lazy,</span><br><span class="line">    memo,</span><br><span class="line">    Fragment:REACT_FRAGMENT_TYPE,</span><br><span class="line">    StrictMode:REACT_STRICT_MODE_TYPE,</span><br><span class="line">    SuspenseLREACT_SUSPENSE_TYPE,</span><br><span class="line">    createElement:__DEV__?createElementWithValidation:createElement,</span><br><span class="line">    cloneElement:__DEV__?cloneElementWithValidation:cloneElement,</span><br><span class="line">    isValidElement:isValidElement,</span><br><span class="line">    version:ReactVersion,</span><br><span class="line">    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:ReactSharedInternals,</span><br><span class="line">&#125;</span><br><span class="line">if (enableStableConcurrentModeAPIs) &#123;</span><br><span class="line">  React.ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;</span><br><span class="line">  React.Profiler = REACT_PROFILER_TYPE;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  React.unstable_ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;</span><br><span class="line">  React.unstable_Profiler = REACT_PROFILER_TYPE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default React;</span><br></pre></td></tr></table></figure><h4 id="ReactElement-js"><a href="#ReactElement-js" class="headerlink" title="ReactElement.js"></a>ReactElement.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br></pre></td><td class="code"><pre><span class="line">// hasOwnProperty 方法返回一个布尔值，指示对象自身属性中是否具有指定的属性（也就是知否有指定的键）</span><br><span class="line">const hasOwnProperty = Object.prototype.hasOwnProperty;</span><br><span class="line">// 内建的props</span><br><span class="line">const RESERVED_PROPS = &#123;</span><br><span class="line">  key: true,</span><br><span class="line">  ref: true,</span><br><span class="line">  __self: true,</span><br><span class="line">  __source: true,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let specialPropKeyWarningShown, specialPropRefWarningShown;</span><br><span class="line">// 判断是否是合法的 ref</span><br><span class="line">function hasValidRef(config) &#123;</span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    if (hasOwnProperty.call(config, &apos;ref&apos;)) &#123;</span><br><span class="line">      /**</span><br><span class="line">      * getOwnPropertyDescriptor 返回指定对象上自有属性描述符（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</span><br><span class="line">      * get 方法。获取该属性的访问器函数（getter）。如果没有访问器，该值为 undefined</span><br><span class="line">      */</span><br><span class="line">      const getter = Object.getOwnPropertyDescriptor(config, &apos;ref&apos;).get;</span><br><span class="line">      if (getter &amp;&amp; getter.isReactWarning) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return config.ref !== undefined;</span><br><span class="line">&#125;</span><br><span class="line">// 判断是否是合法的 key</span><br><span class="line">function hasValidKey(config) &#123;</span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    if (hasOwnProperty.call(config, &apos;key&apos;)) &#123;</span><br><span class="line">      const getter = Object.getOwnPropertyDescriptor(config, &apos;key&apos;).get;</span><br><span class="line">      if (getter &amp;&amp; getter.isReactWarning) &#123;</span><br><span class="line">        return false;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return config.key !== undefined;</span><br><span class="line">&#125;</span><br><span class="line">// 定义了 key 不合法抛出的警告</span><br><span class="line">function defineKeyPropWarningGetter(props, displayName) &#123;</span><br><span class="line">  const warnAboutAccessingKey = function() &#123;</span><br><span class="line">    if (!specialPropKeyWarningShown) &#123;</span><br><span class="line">      specialPropKeyWarningShown = true;</span><br><span class="line">      warningWithoutStack(</span><br><span class="line">        false,</span><br><span class="line">        &apos;%s: `key` is not a prop. Trying to access it will result &apos; +</span><br><span class="line">          &apos;in `undefined` being returned. If you need to access the same &apos; +</span><br><span class="line">          &apos;value within the child component, you should pass it as a different &apos; +</span><br><span class="line">          &apos;prop. (https://fb.me/react-special-props)&apos;,</span><br><span class="line">        displayName,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  warnAboutAccessingKey.isReactWarning = true;</span><br><span class="line">  Object.defineProperty(props, &apos;key&apos;, &#123;</span><br><span class="line">    get: warnAboutAccessingKey,</span><br><span class="line">    configurable: true,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">// 定义了 ref 不合法抛出的警告</span><br><span class="line">function defineRefPropWarningGetter(props, displayName) &#123;</span><br><span class="line">  const warnAboutAccessingRef = function() &#123;</span><br><span class="line">    if (!specialPropRefWarningShown) &#123;</span><br><span class="line">      specialPropRefWarningShown = true;</span><br><span class="line">      warningWithoutStack(</span><br><span class="line">        false,</span><br><span class="line">        &apos;%s: `ref` is not a prop. Trying to access it will result &apos; +</span><br><span class="line">          &apos;in `undefined` being returned. If you need to access the same &apos; +</span><br><span class="line">          &apos;value within the child component, you should pass it as a different &apos; +</span><br><span class="line">          &apos;prop. (https://fb.me/react-special-props)&apos;,</span><br><span class="line">        displayName,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  warnAboutAccessingRef.isReactWarning = true;</span><br><span class="line">  Object.defineProperty(props, &apos;ref&apos;, &#123;</span><br><span class="line">    get: warnAboutAccessingRef,</span><br><span class="line">    configurable: true,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Factory method to create a new React element. This no longer adheres to</span><br><span class="line"> * the class pattern, so do not use new to call it. Also, no instanceof check</span><br><span class="line"> * will work. Instead test $$typeof field against Symbol.for(&apos;react.element&apos;) to check</span><br><span class="line"> * if something is a React Element.</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;*&#125; type</span><br><span class="line"> * @param &#123;*&#125; key</span><br><span class="line"> * @param &#123;string|object&#125; ref</span><br><span class="line"> * @param &#123;*&#125; self A *temporary* helper to detect places where `this` is</span><br><span class="line"> * different from the `owner` when React.createElement is called, so that we</span><br><span class="line"> * can warn. We want to get rid of owner and replace string `ref`s with arrow</span><br><span class="line"> * functions, and as long as `this` and owner are the same, there will be no</span><br><span class="line"> * change in behavior.</span><br><span class="line"> * @param &#123;*&#125; source An annotation object (added by a transpiler or otherwise)</span><br><span class="line"> * indicating filename, line number, and/or other information.</span><br><span class="line"> * @param &#123;*&#125; owner</span><br><span class="line"> * @param &#123;*&#125; props</span><br><span class="line"> * @internal</span><br><span class="line"> */</span><br><span class="line">const ReactElement = function(type, key, ref, self, source, owner, props) &#123;</span><br><span class="line">  const element = &#123;</span><br><span class="line">    // This tag allows us to uniquely identify this as a React Element</span><br><span class="line">    $$typeof: REACT_ELEMENT_TYPE,</span><br><span class="line"></span><br><span class="line">    // Built-in properties that belong on the element</span><br><span class="line">    type: type,</span><br><span class="line">    key: key,</span><br><span class="line">    ref: ref,</span><br><span class="line">    props: props,</span><br><span class="line"></span><br><span class="line">    // Record the component responsible for creating this element.</span><br><span class="line">    _owner: owner,</span><br><span class="line">  &#125;;</span><br><span class="line"> // 开发环境的一些内容</span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    // The validation flag is currently mutative. We put it on</span><br><span class="line">    // an external backing store so that we can freeze the whole object.</span><br><span class="line">    // This can be replaced with a WeakMap once they are implemented in</span><br><span class="line">    // commonly used development environments.</span><br><span class="line">    element._store = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    // To make comparing ReactElements easier for testing purposes, we make</span><br><span class="line">    // the validation flag non-enumerable (where possible, which should</span><br><span class="line">    // include every environment we run tests in), so the test framework</span><br><span class="line">    // ignores it.</span><br><span class="line">    Object.defineProperty(element._store, &apos;validated&apos;, &#123;</span><br><span class="line">      configurable: false,</span><br><span class="line">      enumerable: false,</span><br><span class="line">      writable: true,</span><br><span class="line">      value: false,</span><br><span class="line">    &#125;);</span><br><span class="line">    // self and source are DEV only properties.</span><br><span class="line">    Object.defineProperty(element, &apos;_self&apos;, &#123;</span><br><span class="line">      configurable: false,</span><br><span class="line">      enumerable: false,</span><br><span class="line">      writable: false,</span><br><span class="line">      value: self,</span><br><span class="line">    &#125;);</span><br><span class="line">    // Two elements created in two different places should be considered</span><br><span class="line">    // equal for testing purposes and therefore we hide it from enumeration.</span><br><span class="line">    Object.defineProperty(element, &apos;_source&apos;, &#123;</span><br><span class="line">      configurable: false,</span><br><span class="line">      enumerable: false,</span><br><span class="line">      writable: false,</span><br><span class="line">      value: source,</span><br><span class="line">    &#125;);</span><br><span class="line">    if (Object.freeze) &#123;</span><br><span class="line">      Object.freeze(element.props);</span><br><span class="line">      Object.freeze(element);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return element;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 创建并返回给定类型的新ReactElement。</span><br><span class="line"> * See https://reactjs.org/docs/react-api.html#createelement</span><br><span class="line"> */</span><br><span class="line">export function createElement(type, config, children) &#123;</span><br><span class="line">  let propName;</span><br><span class="line"></span><br><span class="line">  // Reserved names are extracted</span><br><span class="line">  const props = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  let key = null;</span><br><span class="line">  let ref = null;</span><br><span class="line">  let self = null;</span><br><span class="line">  let source = null;</span><br><span class="line"></span><br><span class="line">  if (config != null) &#123;</span><br><span class="line">    if (hasValidRef(config)) &#123;</span><br><span class="line">      ref = config.ref;</span><br><span class="line">    &#125;</span><br><span class="line">    if (hasValidKey(config)) &#123;</span><br><span class="line">      key = &apos;&apos; + config.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self = config.__self === undefined ? null : config.__self;</span><br><span class="line">    source = config.__source === undefined ? null : config.__source;</span><br><span class="line">    // 如果不是内建的props以及本身拥有的属性，将剩余的属性传入到新的props对象中</span><br><span class="line">    for (propName in config) &#123;        </span><br><span class="line">      if (</span><br><span class="line">        hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class="line">        !RESERVED_PROPS.hasOwnProperty(propName)</span><br><span class="line">      ) &#123;</span><br><span class="line">        props[propName] = config[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 子对象可以是多个参数，并且这些参数会传输到新分配的props对象上。</span><br><span class="line">  const childrenLength = arguments.length - 2;</span><br><span class="line">  if (childrenLength === 1) &#123;</span><br><span class="line">    props.children = children;</span><br><span class="line">  &#125; else if (childrenLength &gt; 1) &#123;</span><br><span class="line">    const childArray = Array(childrenLength);</span><br><span class="line">    for (let i = 0; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      childArray[i] = arguments[i + 2];</span><br><span class="line">    &#125;</span><br><span class="line">    if (__DEV__) &#123;</span><br><span class="line">      if (Object.freeze) &#123;</span><br><span class="line">        Object.freeze(childArray);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    props.children = childArray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 解析默认属性</span><br><span class="line">  if (type &amp;&amp; type.defaultProps) &#123;</span><br><span class="line">    const defaultProps = type.defaultProps;</span><br><span class="line">    for (propName in defaultProps) &#123;</span><br><span class="line">      if (props[propName] === undefined) &#123;</span><br><span class="line">        props[propName] = defaultProps[propName];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  if (__DEV__) &#123;</span><br><span class="line">    if (key || ref) &#123;</span><br><span class="line">      const displayName =</span><br><span class="line">        typeof type === &apos;function&apos;</span><br><span class="line">          ? type.displayName || type.name || &apos;Unknown&apos;</span><br><span class="line">          : type;</span><br><span class="line">      if (key) &#123;</span><br><span class="line">        defineKeyPropWarningGetter(props, displayName);</span><br><span class="line">      &#125;</span><br><span class="line">      if (ref) &#123;</span><br><span class="line">        defineRefPropWarningGetter(props, displayName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return ReactElement(</span><br><span class="line">    type,</span><br><span class="line">    key,</span><br><span class="line">    ref,</span><br><span class="line">    self,</span><br><span class="line">    source,</span><br><span class="line">    ReactCurrentOwner.current,</span><br><span class="line">    props,</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 返回一个生成给定类型的ReactElements的函数。（已废弃）</span><br><span class="line"> * See https://reactjs.org/docs/react-api.html#createfactory</span><br><span class="line"> */</span><br><span class="line">export function createFactory(type) &#123;</span><br><span class="line">  const factory = createElement.bind(null, type);</span><br><span class="line">  // Expose the type on the factory and the prototype so that it can be</span><br><span class="line">  // easily accessed on elements. E.g. `&lt;Foo /&gt;.type === Foo`.</span><br><span class="line">  // This should not be named `constructor` since this may not be the function</span><br><span class="line">  // that created the element, and it may not even be a constructor.</span><br><span class="line">  // Legacy hook: remove it</span><br><span class="line">  factory.type = type;</span><br><span class="line">  return factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function cloneAndReplaceKey(oldElement, newKey) &#123;</span><br><span class="line">  const newElement = ReactElement(</span><br><span class="line">    oldElement.type,</span><br><span class="line">    newKey,</span><br><span class="line">    oldElement.ref,</span><br><span class="line">    oldElement._self,</span><br><span class="line">    oldElement._source,</span><br><span class="line">    oldElement._owner,</span><br><span class="line">    oldElement.props,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  return newElement;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 以 element 元素为样板克隆并返回新的 React 元素</span><br><span class="line"> * See https://reactjs.org/docs/react-api.html#cloneelement</span><br><span class="line"> */</span><br><span class="line">export function cloneElement(element, config, children) &#123;</span><br><span class="line">  invariant(</span><br><span class="line">    !(element === null || element === undefined),</span><br><span class="line">    &apos;React.cloneElement(...): The argument must be a React element, but you passed %s.&apos;,</span><br><span class="line">    element,</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  let propName;</span><br><span class="line"></span><br><span class="line">  // 复制原来的props</span><br><span class="line">  const props = Object.assign(&#123;&#125;, element.props);</span><br><span class="line"></span><br><span class="line">  // 提取内建props相关的值</span><br><span class="line">  let key = element.key;</span><br><span class="line">  let ref = element.ref;</span><br><span class="line">  // Self is preserved since the owner is preserved.</span><br><span class="line">  const self = element._self;</span><br><span class="line">  // Source is preserved since cloneElement is unlikely to be targeted by a transpiler, and the original source is probably a better indicator of the true owner.</span><br><span class="line">  const source = element._source;</span><br><span class="line"></span><br><span class="line">  // Owner will be preserved, unless ref is overridden</span><br><span class="line">  let owner = element._owner;</span><br><span class="line"></span><br><span class="line">  if (config != null) &#123;</span><br><span class="line">    if (hasValidRef(config)) &#123;</span><br><span class="line">      // Silently steal the ref from the parent.</span><br><span class="line">      ref = config.ref;</span><br><span class="line">      owner = ReactCurrentOwner.current;</span><br><span class="line">    &#125;</span><br><span class="line">    if (hasValidKey(config)) &#123;</span><br><span class="line">      key = &apos;&apos; + config.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Remaining properties override existing props</span><br><span class="line">    let defaultProps;</span><br><span class="line">    if (element.type &amp;&amp; element.type.defaultProps) &#123;</span><br><span class="line">      defaultProps = element.type.defaultProps;</span><br><span class="line">    &#125;</span><br><span class="line">    for (propName in config) &#123;</span><br><span class="line">      if (</span><br><span class="line">        hasOwnProperty.call(config, propName) &amp;&amp;</span><br><span class="line">        !RESERVED_PROPS.hasOwnProperty(propName)</span><br><span class="line">      ) &#123;</span><br><span class="line">        if (config[propName] === undefined &amp;&amp; defaultProps !== undefined) &#123;</span><br><span class="line">          // Resolve default props</span><br><span class="line">          props[propName] = defaultProps[propName];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          props[propName] = config[propName];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Children can be more than one argument, and those are transferred onto</span><br><span class="line">  // the newly allocated props object.</span><br><span class="line">  const childrenLength = arguments.length - 2;</span><br><span class="line">  if (childrenLength === 1) &#123;</span><br><span class="line">    props.children = children;</span><br><span class="line">  &#125; else if (childrenLength &gt; 1) &#123;</span><br><span class="line">    const childArray = Array(childrenLength);</span><br><span class="line">    for (let i = 0; i &lt; childrenLength; i++) &#123;</span><br><span class="line">      childArray[i] = arguments[i + 2];</span><br><span class="line">    &#125;</span><br><span class="line">    props.children = childArray;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return ReactElement(element.type, key, ref, self, source, owner, props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 验证对象是否为ReactElement。</span><br><span class="line"> * See https://reactjs.org/docs/react-api.html#isvalidelement</span><br><span class="line"> * @param &#123;?object&#125; object</span><br><span class="line"> * @return &#123;boolean&#125; True if `object` is a ReactElement.</span><br><span class="line"> * @final</span><br><span class="line"> */</span><br><span class="line">export function isValidElement(object) &#123;</span><br><span class="line">  return (</span><br><span class="line">    typeof object === &apos;object&apos; &amp;&amp;</span><br><span class="line">    object !== null &amp;&amp;</span><br><span class="line">    object.$$typeof === REACT_ELEMENT_TYPE</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ReactElement</code> 通过 <code>createElement</code> 创建的，传入三个参数：</p><ul><li><p>type（指代 <code>ReactElement</code>的类型）</p><ul><li>字符串。<code>&#39;div&#39;</code>等，被称为 <code>HostComponent</code></li><li>Class。继承自 <code>Component</code>或者 <code>PureComponent</code>的组件，称为 <code>ClassComponent</code></li><li>方法。<code>functinal Component</code></li><li>原生。<code>Fragment</code>、<code>AsyncModel</code>、<code>Symbol</code></li></ul></li><li><p>config</p></li><li>children</li></ul><p><code>ReactElement</code>只是一个用来承载信息的容器，里面有几个信息：</p><ul><li><code>type</code>，用来判断如何创建节点</li><li><code>key</code>和 <code>ref</code>这些特殊信息</li><li><code>props</code>新的属性内容</li><li><code>$$type</code>用于确定是否属于 <code>ReactElement</code></li></ul><h4 id="ReactBaseClasses-js"><a href="#ReactBaseClasses-js" class="headerlink" title="ReactBaseClasses.js"></a>ReactBaseClasses.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">import ReactNoopUpdateQueue from &apos;./ReactNoopUpdateQueue&apos;;</span><br><span class="line">/**</span><br><span class="line"> * Base class helpers for the updating state of a component.</span><br><span class="line"> */</span><br><span class="line">const emptyObject = &#123;&#125;;</span><br><span class="line">function Component(props, context, updater) &#123;</span><br><span class="line">  this.props = props;</span><br><span class="line">  this.context = context;</span><br><span class="line">  // If a component has string refs, we will assign a different object later.</span><br><span class="line">  this.refs = emptyObject;</span><br><span class="line">  // We initialize the default updater but the real one gets injected by the renderer.</span><br><span class="line">  this.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Component.prototype.isReactComponent = &#123;&#125;;</span><br><span class="line">// 核心方法</span><br><span class="line">Component.prototype.setState = function(partialState, callback) &#123;</span><br><span class="line">  invariant(</span><br><span class="line">    typeof partialState === &apos;object&apos; ||</span><br><span class="line">      typeof partialState === &apos;function&apos; ||</span><br><span class="line">      partialState == null,</span><br><span class="line">    &apos;setState(...): takes an object of state variables to update or a &apos; +</span><br><span class="line">      &apos;function which returns an object of state variables.&apos;,</span><br><span class="line">  );</span><br><span class="line">  // DOM 实现的</span><br><span class="line">  this.updater.enqueueSetState(this, partialState, callback, &apos;setState&apos;);</span><br><span class="line">&#125;;</span><br><span class="line">// 强制更新</span><br><span class="line">Component.prototype.forceUpdate = function(callback) &#123;</span><br><span class="line">  this.updater.enqueueForceUpdate(this, callback, &apos;forceUpdate&apos;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function ComponentDummy() &#123;&#125;</span><br><span class="line">ComponentDummy.prototype = Component.prototype;</span><br><span class="line"></span><br><span class="line">function PureComponent(props, context, updater) &#123;</span><br><span class="line">  this.props = props;</span><br><span class="line">  this.context = context;</span><br><span class="line">  // If a component has string refs, we will assign a different object later.</span><br><span class="line">  this.refs = emptyObject;</span><br><span class="line">  this.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line">const pureComponentPrototype = (PureComponent.prototype = new ComponentDummy());</span><br><span class="line">pureComponentPrototype.constructor = PureComponent;</span><br><span class="line">// Avoid an extra prototype jump for these methods.</span><br><span class="line">Object.assign(pureComponentPrototype, Component.prototype);</span><br><span class="line">// isPureComponent 属性便于 REACT-DOM 后面辨认是否是纯组件</span><br><span class="line">pureComponentPrototype.isPureReactComponent = true;</span><br><span class="line"></span><br><span class="line">export &#123;Component, PureComponent&#125;;</span><br></pre></td></tr></table></figure><h4 id="ReactCreateRef-js"><a href="#ReactCreateRef-js" class="headerlink" title="ReactCreateRef.js"></a>ReactCreateRef.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export function createRef()&#123;</span><br><span class="line">    const refObject = &#123;</span><br><span class="line">        current:null,</span><br><span class="line">    &#125;</span><br><span class="line">    return refObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Refs 提供了一种方式，允许我们访问 DOM 节点或者在 render 方法中创建的 React 元素。</p><p>使用 Refs 的情况：</p><ul><li>管理焦点，文本选择或者媒体播放</li><li>触发强制动画</li><li>集成第三方 DOM 库</li></ul><p>使用 Refs 的方法：</p><ul><li>string ref</li><li>function</li><li>createRef</li></ul><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">export default class RefDemo extends React.Component &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.objRef = React.createRef();</span><br><span class="line">    // &#123;current:null&#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      this.refs.stringRef.textContent = &apos;string ref got&apos;</span><br><span class="line">      this.methodRef.textContent = &apos;method ref got&apos;</span><br><span class="line">      this.objRef.current.textContent = &apos;obj ref got&apos;</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;&gt;</span><br><span class="line">        &lt;p ref=&quot;stringRef&quot;&gt;span1&lt;/p&gt;</span><br><span class="line">        &lt;p ref=&#123;ele =&gt; (this.methodRef = ele)&#125;&gt;span3&lt;/p&gt;</span><br><span class="line">        &lt;p ref=&#123;this.objRef&#125;&gt;span3&lt;/p&gt;</span><br><span class="line">      &lt;/&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="forwardRef-js"><a href="#forwardRef-js" class="headerlink" title="forwardRef.js"></a>forwardRef.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">export default function forwardRef(render:(props,ref))&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">        $$typeof:REACT_FORWARD_REF_TYPE,</span><br><span class="line">        render,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>React.forwardRef 会创建一个 React 组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。</p><p>主要使用的是：</p><ul><li>转发 refs 到 DOM 组件</li><li>在高阶组件中转发 refs</li></ul><p>React.forwardRef 接受渲染函数作为参数。React 将使用 props 和 refs 作为参数来调用此函数。此函数应该返回 React 节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// PureComponent</span><br><span class="line">const TargetComponent = React.forwardRef((props,ref)=&gt;&#123;</span><br><span class="line">    &lt;input type=&quot;text&quot; ref=&#123;ref&#125; /&gt;</span><br><span class="line">&#125;)</span><br><span class="line">        </span><br><span class="line">export default class Comp extends React.Component&#123;</span><br><span class="line">    constructor()&#123;</span><br><span class="line">        super();</span><br><span class="line">        this.ref = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        this.ref.current.value = &apos;ref get input&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        return &lt;TargetComponent ref=&#123;this.ref&#125;/&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ReactContext.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">export function createContext(defaultValue,calculateChangedBits)&#123;</span><br><span class="line">    if(calculateChangedBits === undefined)&#123;</span><br><span class="line">        calculateChangedBits = null;</span><br><span class="line">    &#125;     </span><br><span class="line">    const context = &#123;</span><br><span class="line">        $$typeof:REACT_CONTEXT_TYPE,</span><br><span class="line">        _calculateChangedBits:calculateChangedBits,</span><br><span class="line">        _currentValue:defaultValue,</span><br><span class="line">        _currentValue2:defaultValue,</span><br><span class="line">        Provider:null,</span><br><span class="line">        Consumer:null</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    context.Provider = &#123;</span><br><span class="line">        $$typeof:REACT_PROVIDER_TYPE,</span><br><span class="line">        _context:context</span><br><span class="line">    &#125;</span><br><span class="line">    if(__DEV__)&#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        context.Consumer = context;</span><br><span class="line">    &#125;    </span><br><span class="line">    return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReactLazy-js"><a href="#ReactLazy-js" class="headerlink" title="ReactLazy.js"></a>ReactLazy.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">lazy</span>(<span class="params">ctor:(</span>)=&gt;<span class="title">Thenable</span>&lt;<span class="title">T</span>,<span class="title">R</span>&gt;)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        $$<span class="keyword">typeof</span>:REACT_LAZY_TYPE,</span><br><span class="line">        <span class="comment">// 类 promise</span></span><br><span class="line">        _ctor:ctor,</span><br><span class="line">        _status:<span class="number">-1</span>,</span><br><span class="line">        <span class="comment">// 加载完返回的结果</span></span><br><span class="line">        _result:<span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Hooks"><a href="#Hooks" class="headerlink" title="Hooks"></a>Hooks</h4><p>简单用法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState,useEffect &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> [name,setName] = useState(<span class="string">'lbh'</span>);</span><br><span class="line">    useEffect(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'component update'</span>)</span><br><span class="line">        <span class="comment">// 解除绑定</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'unbind'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,[])</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">    &lt;&gt;</span><br><span class="line">        &lt;p&gt;My name is:&#123;name&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;input type="text" value=&#123;name&#125; onChange=&#123;e=&gt;setName(e.target.value)&#125;&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReactChildren-js"><a href="#ReactChildren-js" class="headerlink" title="ReactChildren.js"></a>ReactChildren.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line">const SEPARATOP = &apos;.&apos;;</span><br><span class="line">const SUBSEPARATOR = &apos;:&apos;;</span><br><span class="line">function escape(key)&#123;</span><br><span class="line">    const escapeRegex = /[=:]/g;</span><br><span class="line">    const escaperLookup = &#123;</span><br><span class="line">        &apos;=&apos;:&apos;=0&apos;,</span><br><span class="line">        &apos;:&apos;:&apos;=2&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    const escapedString = (&apos;&apos;+key).replace(escapeRegex,function(match)&#123;</span><br><span class="line">        return escapeLookup[match];</span><br><span class="line">    &#125;)</span><br><span class="line">    return &apos;$&apos; + escapedString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let didWarnAboutMaps = false;</span><br><span class="line">const userProviderKeyEscapeRegex = /\/+/g;</span><br><span class="line">function escapeUserProvidedKey(text)&#123;</span><br><span class="line">    return (&apos;&apos;+text).replace(userProviderKeyEscapeRegex,&apos;$&amp;/&apos;);</span><br><span class="line">&#125;</span><br><span class="line">// 对象池</span><br><span class="line">const POOL_SIZE = 10;</span><br><span class="line">const traverseContextPool = [];</span><br><span class="line">function getPooledTraverseContext(mapResult,keyPrefix,mapFunction,mapContext)&#123;</span><br><span class="line">    if(traverseContextPool.length)&#123;</span><br><span class="line">        const traverseContext = traverseContextPool.pop();</span><br><span class="line">        traverseContext.result = mapResult;</span><br><span class="line">        traverseContext.keyPrefix = keyPrefix;</span><br><span class="line">        traverseContext.func = mapFunction;</span><br><span class="line">        traverseContext.context = mapContext;</span><br><span class="line">        traverseContext.count = 0;</span><br><span class="line">        return traverseContext;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return&#123;</span><br><span class="line">            result:mapResult,</span><br><span class="line">            keyPrefix:keyPrefix,</span><br><span class="line">            func:mapFunction,</span><br><span class="line">            context:mapContext,</span><br><span class="line">            count:0</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 释放对象属性，少于指定长度时，将对象push 对象池</span><br><span class="line">function releaseTravserContext(traverseContext)&#123;</span><br><span class="line">    traverseContext.result = null;</span><br><span class="line">    traverseContext.keyPrefix = null;</span><br><span class="line">    traverseContext.func = null;</span><br><span class="line">    traverseContext.context = null;</span><br><span class="line">    traverseContext.count = 0;</span><br><span class="line">    if(traverseContextPool.length &lt; POOL_SIZE)&#123;</span><br><span class="line">        traverseContextPool.push(traverseContext)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 核心</span><br><span class="line">function traverseAllChildrenImpl(</span><br><span class="line">  children,</span><br><span class="line">  nameSoFar,</span><br><span class="line">  callback,</span><br><span class="line">  traverseContext,</span><br><span class="line">) &#123;</span><br><span class="line">  const type = typeof children;</span><br><span class="line"></span><br><span class="line">  if (type === &apos;undefined&apos; || type === &apos;boolean&apos;) &#123;</span><br><span class="line">    children = null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let invokeCallback = false;</span><br><span class="line"></span><br><span class="line">  if (children === null) &#123;</span><br><span class="line">    invokeCallback = true;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    switch (type) &#123;</span><br><span class="line">      case &apos;string&apos;:</span><br><span class="line">      case &apos;number&apos;:</span><br><span class="line">        invokeCallback = true;</span><br><span class="line">        break;</span><br><span class="line">      case &apos;object&apos;:</span><br><span class="line">        switch (children.$$typeof) &#123;</span><br><span class="line">          case REACT_ELEMENT_TYPE:</span><br><span class="line">          case REACT_PORTAL_TYPE:</span><br><span class="line">            invokeCallback = true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (invokeCallback) &#123;</span><br><span class="line">    callback(</span><br><span class="line">      traverseContext,</span><br><span class="line">      children,</span><br><span class="line">      nameSoFar === &apos;&apos; ? SEPARATOR + getComponentKey(children, 0) : nameSoFar,</span><br><span class="line">    );</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let child;</span><br><span class="line">  let nextName;</span><br><span class="line">  let subtreeCount = 0; </span><br><span class="line">  const nextNamePrefix =</span><br><span class="line">    nameSoFar === &apos;&apos; ? SEPARATOR : nameSoFar + SUBSEPARATOR;</span><br><span class="line"></span><br><span class="line">  if (Array.isArray(children)) &#123;</span><br><span class="line">    for (let i = 0; i &lt; children.length; i++) &#123;</span><br><span class="line">      child = children[i];</span><br><span class="line">      nextName = nextNamePrefix + getComponentKey(child, i);</span><br><span class="line">      subtreeCount += traverseAllChildrenImpl(</span><br><span class="line">        child,</span><br><span class="line">        nextName,</span><br><span class="line">        callback,</span><br><span class="line">        traverseContext,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    const iteratorFn = getIteratorFn(children);</span><br><span class="line">    if (typeof iteratorFn === &apos;function&apos;) &#123;</span><br><span class="line">      const iterator = iteratorFn.call(children);</span><br><span class="line">      let step;</span><br><span class="line">      let ii = 0;</span><br><span class="line">      while (!(step = iterator.next()).done) &#123;</span><br><span class="line">        child = step.value;</span><br><span class="line">        nextName = nextNamePrefix + getComponentKey(child, ii++);</span><br><span class="line">        subtreeCount += traverseAllChildrenImpl(</span><br><span class="line">          child,</span><br><span class="line">          nextName,</span><br><span class="line">          callback,</span><br><span class="line">          traverseContext,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (type === &apos;object&apos;) &#123;</span><br><span class="line">      let addendum = &apos;&apos;;</span><br><span class="line">      const childrenString = &apos;&apos; + children;</span><br><span class="line">      invariant(</span><br><span class="line">        false,</span><br><span class="line">        &apos;Objects are not valid as a React child (found: %s).%s&apos;,</span><br><span class="line">        childrenString === &apos;[object Object]&apos;</span><br><span class="line">          ? &apos;object with keys &#123;&apos; + Object.keys(children).join(&apos;, &apos;) + &apos;&#125;&apos;</span><br><span class="line">          : childrenString,</span><br><span class="line">        addendum,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return subtreeCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function traverseAllChildren(children,callback,traverseContext)&#123;</span><br><span class="line">    if(children === null)&#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    return traverseAllChildrenImpl(children,&apos;&apos;,callback,traverseContext)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getComponentKey(component,index)&#123;</span><br><span class="line">    if(</span><br><span class="line">        typeof component === &apos;object&apos; &amp;&amp; </span><br><span class="line">        component !== null &amp;&amp;</span><br><span class="line">        component.key != null</span><br><span class="line">    )&#123;</span><br><span class="line">        return escape(component.key);</span><br><span class="line">    &#125;</span><br><span class="line">    return index.toString(36);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function forEachSingleChild(bookKeeping,child,name)&#123;</span><br><span class="line">    const &#123; func, context &#125; = bookKeeping;</span><br><span class="line">    func.call(context,child,bookKeeping.count++);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function forEachChildren(children, forEachFunc, forEachContext) &#123;</span><br><span class="line">  if (children == null) &#123;</span><br><span class="line">    return children;</span><br><span class="line">  &#125;</span><br><span class="line">  const traverseContext = getPooledTraverseContext(</span><br><span class="line">    null,</span><br><span class="line">    null,</span><br><span class="line">    forEachFunc,</span><br><span class="line">    forEachContext,</span><br><span class="line">  );</span><br><span class="line">  traverseAllChildren(children, forEachSingleChild, traverseContext);</span><br><span class="line">  releaseTraverseContext(traverseContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mapSingleChildIntoContext(bookKeeping, child, childKey) &#123;</span><br><span class="line">  const &#123;result, keyPrefix, func, context&#125; = bookKeeping;</span><br><span class="line"></span><br><span class="line">  let mappedChild = func.call(context, child, bookKeeping.count++);</span><br><span class="line">  if (Array.isArray(mappedChild)) &#123;</span><br><span class="line">    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, c =&gt; c);</span><br><span class="line">  &#125; else if (mappedChild != null) &#123;</span><br><span class="line">    if (isValidElement(mappedChild)) &#123;</span><br><span class="line">      mappedChild = cloneAndReplaceKey(</span><br><span class="line">        mappedChild,</span><br><span class="line">        keyPrefix +</span><br><span class="line">          (mappedChild.key &amp;&amp; (!child || child.key !== mappedChild.key)</span><br><span class="line">            ? escapeUserProvidedKey(mappedChild.key) + &apos;/&apos;</span><br><span class="line">            : &apos;&apos;) +</span><br><span class="line">          childKey,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    result.push(mappedChild);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mapIntoWithKeyPrefixInternal(children,array,prefix,func,context)&#123;</span><br><span class="line">    let escapedPrefix = &apos;&apos;;</span><br><span class="line">    if(prefix != null)&#123;</span><br><span class="line">        escapedPrefix = escapeUserProvidedKey(prefix)+&apos;/&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">    const traverseContext = getPooledTraverseContext(</span><br><span class="line">        array,</span><br><span class="line">        escapedPrefix,</span><br><span class="line">        func,</span><br><span class="line">        context</span><br><span class="line">    )</span><br><span class="line">    traverseAllChildren(children,mapSingleChildIntoContext,traverseContext);</span><br><span class="line">    releaseTraverseContext(traverseContext);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function mapChildren(children,func,context)&#123;</span><br><span class="line">    if(children == null)&#123;</span><br><span class="line">        return children;</span><br><span class="line">    &#125;</span><br><span class="line">    const result = [];</span><br><span class="line">    mapIntoWithKeyPrefixInternal(children,result,null,func,context);</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function countChildren(children)&#123;</span><br><span class="line">    return traverseAllChildren(children,()=&gt;null,null);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function toArray(children)&#123;</span><br><span class="line">    const result = [];</span><br><span class="line">    mapIntoWithKeyPrefixInternal(children,result,null,child =&gt; child)</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function onlyChild(children) &#123;</span><br><span class="line">  invariant(</span><br><span class="line">    isValidElement(children),</span><br><span class="line">    &apos;React.Children.only expected to receive a single React element child.&apos;,</span><br><span class="line">  );</span><br><span class="line">  return children;</span><br><span class="line">&#125;</span><br><span class="line">export &#123;</span><br><span class="line">forEachChild as forEach,</span><br><span class="line">    mapChildren as map,</span><br><span class="line">    countChildren as count,</span><br><span class="line">    onlyChild as only,</span><br><span class="line">    toArray,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要方法流程图：</p><pre class="mermaid">graph TDA(开始)contextPool(contextPool)mapIntoWithKeyPrefixInternal(mapIntoWithKeyPrefixInternal)traverseAllChildren(traverseAllChildren)traverseAllChildrenImpl(traverseAllChildrenImpl)mapSingleChildrenContext(mapSingleChildrenContext)是否多个节点{是否多个节点}isArray{isArray}循环每个节点((循环每个节点))对每个节点调用mapFunc返回map之后的节点(对每个节点调用mapFunc返回map之后的节点)往result中推入clone节点并替换key(往result中推入clone节点并替换key)A --> mapIntoWithKeyPrefixInternalmapIntoWithKeyPrefixInternal -. 开始的时候获取 .-> contextPoolmapIntoWithKeyPrefixInternal -. 结束之后归还 .-> contextPoolmapIntoWithKeyPrefixInternal --> traverseAllChildrentraverseAllChildren --> traverseAllChildrenImpltraverseAllChildrenImpl --> 是否多个节点是否多个节点 --Y--> 循环每个节点是否多个节点 --N--> mapSingleChildrenContext循环每个节点 --> traverseAllChildrenImplmapSingleChildrenContext --> 对每个节点调用mapFunc返回map之后的节点对每个节点调用mapFunc返回map之后的节点 --> isArrayisArray --Y--> mapIntoWithKeyPrefixInternalisArray --N--> 往result中推入clone节点并替换key</pre><h4 id="ReactContext-js"><a href="#ReactContext-js" class="headerlink" title="ReactContext.js"></a>ReactContext.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export function createCOntext(defaultValue,calculateChangedBits)&#123;</span><br><span class="line">    if(calculateChangedBits === undefined)&#123;</span><br><span class="line">        calculateChangedBits = null;</span><br><span class="line">    &#125;</span><br><span class="line">    const context = &#123;</span><br><span class="line">        $$typeof:REACT_CONTEXT_TYPE,</span><br><span class="line">        _calculateChangeBits:calculateChangeBits,</span><br><span class="line">        _currentValue:defaultValue,</span><br><span class="line">        _currentValue2:defaultValue,</span><br><span class="line">        Provider:null,</span><br><span class="line">        Consumer:null</span><br><span class="line">    &#125;</span><br><span class="line">    context.Provider = &#123;</span><br><span class="line">        $$typeof:REACT_PROVIDER_TYPE,</span><br><span class="line">        _context:context,</span><br><span class="line">    &#125;</span><br><span class="line">    context.Consumer = context;</span><br><span class="line">    return context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="memo-js"><a href="#memo-js" class="headerlink" title="memo.js"></a>memo.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">memo</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params"> type: React$ElementType,</span></span></span><br><span class="line"><span class="function"><span class="params"> compare?: (oldProps: Props, newProps: Props</span>) =&gt; <span class="title">boolean</span>,</span></span><br><span class="line"><span class="function">    )</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        $$<span class="keyword">typeof</span>:REACT_MEMO_TYPE,</span><br><span class="line">        type,</span><br><span class="line">        compare:compare === <span class="literal">undefined</span> ? <span class="literal">null</span> : compare,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建更新的方式"><a href="#创建更新的方式" class="headerlink" title="创建更新的方式"></a>创建更新的方式</h3><p>主要是下面的知识点：</p><p><code>ReactDOM.render</code>、<code>ReactDOM.render</code>、<code>setState</code>、<code>forceUpdate</code></p><p>步骤：</p><ul><li>创建 ReactRoot</li><li>创建 FiberRoot 和 RootFiber</li><li>创建更新</li></ul><h4 id="ReactDOM-js"><a href="#ReactDOM-js" class="headerlink" title="ReactDOM.js"></a>ReactDOM.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// ReactDOM</span><br><span class="line">const ReactDOM = &#123;</span><br><span class="line">    createPortal,</span><br><span class="line">    findDOMNode(</span><br><span class="line">    componentOrElement,</span><br><span class="line">    )&#123;</span><br><span class="line">        if (componentOrElement == null) &#123;</span><br><span class="line">          return null;</span><br><span class="line">        &#125;</span><br><span class="line">        if (componentOrElement.nodeType === ELEMENT_NODE) &#123;</span><br><span class="line">          return componentOrElement;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    // REACTElememt,DOM包裹节点，回调方法</span><br><span class="line">    hydrate(element,container,callback)&#123;</span><br><span class="line">        return legacyRenderSubtreeIntoContainer(</span><br><span class="line">        null,</span><br><span class="line">            element,</span><br><span class="line">            container,</span><br><span class="line">            // 协调更新的选项</span><br><span class="line">            true,</span><br><span class="line">            callback</span><br><span class="line">        )</span><br><span class="line">    &#125;,</span><br><span class="line">    render(element,container,callback)&#123;</span><br><span class="line">        return legacyRenderSubtreeIntoContainer(</span><br><span class="line">            null,</span><br><span class="line">            element,</span><br><span class="line">            container,</span><br><span class="line">            false,</span><br><span class="line">            callback</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>render 与 hydrate 方法都可以传入三个参数，包括 ReactElement、DOM包裹节点和渲染结束后执行的回调方法，返回 <code>legacyRenderSubtreeIntoContainer</code> 方法执行的结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">function legacyRenderSubtreeIntoContainer(</span><br><span class="line"> parentComponent,</span><br><span class="line"> children,</span><br><span class="line"> container,</span><br><span class="line"> forceHydrate,</span><br><span class="line"> callback</span><br><span class="line">)&#123;</span><br><span class="line">     let root;</span><br><span class="line">     if(!root)&#123;</span><br><span class="line">         root = container._reactRootContainer = legacyCreateRootFromDOMContainer(</span><br><span class="line">             container,</span><br><span class="line">             forceHydrate,</span><br><span class="line">         )</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">function legacyCreateRootFromDOMContainer(</span><br><span class="line"> container,</span><br><span class="line"> forceHydrate,</span><br><span class="line">)&#123;</span><br><span class="line">     const shouldHydrate = forceHydrate || shouldHydrateDueToLegacyHeuristic(container);</span><br><span class="line">     // 没有ssr的情况</span><br><span class="line">     if(!shouldHydrate)&#123;</span><br><span class="line">         let rootSibling;</span><br><span class="line">         while((rootSibling = container.lastChild))&#123;</span><br><span class="line">             // 删除 container 下面的所有子节点</span><br><span class="line">             container.removeChild(rootSibling)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;     </span><br><span class="line">     const isConcurrent = false;</span><br><span class="line">     return new ReactRoot(container,isConcurrent,shouldHydrate)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function shouldHydrateDueToLegacyHeuristic()&#123;</span><br><span class="line">    const rootElement = getReactRootElementInContainer(container);</span><br><span class="line">    return !!(</span><br><span class="line">        rootElement &amp;&amp; </span><br><span class="line">        // 普通element节点</span><br><span class="line">        rootElement.nodeType === ELEMENT_NODE &amp;&amp; </span><br><span class="line">        // data-reactroot 老版本ssr的节点</span><br><span class="line">        rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getReactRootElementInContainer(container)&#123;</span><br><span class="line">    if(!container)&#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断节点</span><br><span class="line">    if(container.nodeType === DOCUMENT_NODE)&#123;</span><br><span class="line">        return container.documentElement;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return container.firstChild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先判断 root 是否不存在，不存在调用<code>legacyCreateRootFromDOMContainer</code>，传入 <code>container</code>,<code>forceHydrate</code>两个参数。<code>legacyCreateRootFromDOMContainer</code>函数创建了一个 <code>ReactRoot</code>，而 <code>forceHydrate</code>布尔类型参数在 <code>hydrate</code> 传入 <code>true</code>,在 <code>render</code> 里面传入 <code>false</code>。前者是服务器渲染，后者是客户端渲染。服务器渲染当服务器呈现标记的节点，React 会保留它并附加事件处理程序，从而具有高性能的首屏加载，客户端渲染当初始DOM与当前 DOM 存在差异，则可能会更改节点。可以看到 如果是 <code>false</code>会 <code>container.removeChild(rootSibling)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">function ReactRoot(</span><br><span class="line"> container,</span><br><span class="line"> isConcurrent,</span><br><span class="line"> hydrate</span><br><span class="line">)&#123;</span><br><span class="line">     const root = DOMRender.createContainer(container,isConcurrent,hydrate);</span><br><span class="line">     this._internalRoot = root;</span><br><span class="line"> &#125;</span><br><span class="line">// react-reconciler/inline.dom</span><br><span class="line">function createContainer(</span><br><span class="line"> containerInfo,</span><br><span class="line">  isConcurrent,</span><br><span class="line">  hydrate</span><br><span class="line">)&#123;</span><br><span class="line">     // 创建 FiberRoot</span><br><span class="line">     return createFiberRoot(container,isConcurrent,hydrate)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// ReactFiberRoot</span><br><span class="line">export function createFiberRoot(</span><br><span class="line">  containerInfo,</span><br><span class="line">  isConcurrent,</span><br><span class="line">  hydrate,</span><br><span class="line">): FiberRoot &#123;</span><br><span class="line">    // </span><br><span class="line">  const uninitializedFiber = createHostRootFiber(isConcurrent);</span><br><span class="line"></span><br><span class="line">  let root;</span><br><span class="line">  if (enableSchedulerTracing) &#123;</span><br><span class="line">    root = &#123;</span><br><span class="line">      current: uninitializedFiber,</span><br><span class="line">      containerInfo: containerInfo,</span><br><span class="line">      pendingChildren: null,</span><br><span class="line"></span><br><span class="line">      earliestPendingTime: NoWork,</span><br><span class="line">      latestPendingTime: NoWork,</span><br><span class="line">      earliestSuspendedTime: NoWork,</span><br><span class="line">      latestSuspendedTime: NoWork,</span><br><span class="line">      latestPingedTime: NoWork,</span><br><span class="line"></span><br><span class="line">      didError: false,</span><br><span class="line"></span><br><span class="line">      pendingCommitExpirationTime: NoWork,</span><br><span class="line">      finishedWork: null,</span><br><span class="line">      timeoutHandle: noTimeout,</span><br><span class="line">      context: null,</span><br><span class="line">      pendingContext: null,</span><br><span class="line">      hydrate,</span><br><span class="line">      nextExpirationTimeToWorkOn: NoWork,</span><br><span class="line">      expirationTime: NoWork,</span><br><span class="line">      firstBatch: null,</span><br><span class="line">      nextScheduledRoot: null,</span><br><span class="line"></span><br><span class="line">      interactionThreadID: unstable_getThreadID(),</span><br><span class="line">      memoizedInteractions: new Set(),</span><br><span class="line">      pendingInteractionMap: new Map(),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    root = &#123;</span><br><span class="line">      current: uninitializedFiber,</span><br><span class="line">      containerInfo: containerInfo,</span><br><span class="line">      pendingChildren: null,</span><br><span class="line"></span><br><span class="line">      earliestPendingTime: NoWork,</span><br><span class="line">      latestPendingTime: NoWork,</span><br><span class="line">      earliestSuspendedTime: NoWork,</span><br><span class="line">      latestSuspendedTime: NoWork,</span><br><span class="line">      latestPingedTime: NoWork,</span><br><span class="line"></span><br><span class="line">      didError: false,</span><br><span class="line"></span><br><span class="line">      pendingCommitExpirationTime: NoWork,</span><br><span class="line">      finishedWork: null,</span><br><span class="line">      timeoutHandle: noTimeout,</span><br><span class="line">      context: null,</span><br><span class="line">      pendingContext: null,</span><br><span class="line">      hydrate,</span><br><span class="line">      nextExpirationTimeToWorkOn: NoWork,</span><br><span class="line">      expirationTime: NoWork,</span><br><span class="line">      firstBatch: null,</span><br><span class="line">      nextScheduledRoot: null,</span><br><span class="line">    &#125;;</span><br><span class="line">    uninitializedFiber.stateNode = root;</span><br><span class="line">    return root;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;知其然知其所以然，框架工的自我尝试进阶&lt;/p&gt;
&lt;h2 id=&quot;React源码浅析&quot;&gt;&lt;a href=&quot;#React源码浅析&quot; class=&quot;headerlink&quot; title=&quot;React源码浅析&quot;&gt;&lt;/a&gt;React源码浅析&lt;/h2&gt;&lt;p&gt;知识点：&lt;/p&gt;
&lt;p&gt;&lt;st
      
    
    </summary>
    
      <category term="React" scheme="http://laibh.top/categories/React/"/>
    
    
      <category term="源码" scheme="http://laibh.top/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://laibh.top/2019-06-25-regExp.html"/>
    <id>http://laibh.top/2019-06-25-regExp.html</id>
    <published>2019-06-25T01:30:54.000Z</published>
    <updated>2019-10-15T09:29:49.415Z</updated>
    
    <content type="html"><![CDATA[<p>最近这段时间因为赶项目，一直没有更新博客。精通正则这本书一年前翻阅过过一些。用到的地方不多，便很快就忘记了。今忙里抽空复习一下正则，在项目中也会有所用到。主要是跟随<a href="http://deerchao.net/tutorials/regex/regex-1.htm">正则表达式30分钟入门教程</a>，再结合 JS 中的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式</a>进行复习。</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>编写处理字符串的程序或者网页时候，经常会有查找符合复杂规则的字符串的需要。正则表达式就是用于描述这些规。即记录文本规则的代码。</p><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>在一篇英文小说中查找 <code>hi</code>，可以使用正则 <code>hi</code>。它可以精确匹配这样的字符串：由两个字符组成，前一个字符是 <code>h</code>，后一个字符串是 <code>i</code>。通常，处理正则表达式的工具会提供一个忽略大小写的选项，如果选中了这个选项，可以匹配 <code>hi</code>、<code>HI</code>、<code>Hi</code>、<code>hI</code>这四种情况中的任意的一种。</p><p><code>hi</code>这个正则表达式也会匹配 <code>him</code>、<code>history</code>、<code>high</code>等，如果要精确查找到 <code>hi</code>这个单词的话，应该使用正则表达式 <code>\bhi\b</code>。</p><p><code>\b</code>是正则表达式规定一个特殊代码（元字符），代表着单词的开头或者结尾，也就是单词的分界处。英文的单词一般是由空格，标点符号或者换行符来分隔的，但是 <code>\b</code>并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。</p><p>如果要找到是 <code>hi</code>后面不远处跟着一个 <code>Lucy</code>，就要使用正则表达式 <code>\bhi\b.*\bLucy\b</code>。这里的 <code>.</code>是一个元字符，匹配除了换行符外的任意字符。<code>*</code>同样是元字符，不过它代表的不是字符，也不是位置。而是数量，它指定 <code>*</code>前边的内容可以连续重复使用任意次以使整个正则表达式得到匹配。因此 <code>.*</code>连在一起就意味着任意数量的不包括换行的字符。现在 <code>\bhi\b.*\bLucy\b</code>的意思就是：先是一个单词<code>hi</code>，然后是任意个任意字符（但不能是换行），最后是 <code>Lucy</code>整个单词。</p><p>如果使用其他元字符，可以构造更强大的正则表达式，比如下面的例子</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>\d\d-\d\d\d\d\d\d\d\d</span><br><span class="line"><span class="comment"># 以 0 开头，然后是两个数字，然后是一个连字符'-'，最后是8个数字（也就是中国的电话号码，只能匹配区号是3位的情况）</span></span><br><span class="line"><span class="comment"># \d 是一个新的元字符。匹配一个数字。'-'不是元字符，只匹配它本身——连字符（或者减号，或者中横线等）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简化</span></span><br><span class="line"><span class="number">0</span>\d<span class="string">&#123;2&#125;</span>-d<span class="string">&#123;8&#125;</span></span><br><span class="line"><span class="comment"># \d 后面&#123;2&#125; 和 &#123;8&#125;的意思必须连续重复匹配2（8）次</span></span><br></pre></td></tr></table></figure><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><p>常用的元字符</p><table><thead><tr><th>代码</th><th>说明</th><th>相当于</th></tr></thead><tbody><tr><td><code>.</code></td><td>匹配换行符以外的任意字符</td><td></td></tr><tr><td><code>\w</code></td><td>匹配字母或数字或下划线或汉字</td><td></td></tr><tr><td><code>\s</code></td><td>匹配任意的空白符（包括空格、制表符（Tab）、换行符，中文全角空格）</td><td></td></tr><tr><td><code>\d</code></td><td>匹配数字</td><td></td></tr><tr><td><code>\b</code></td><td>匹配单词的开始或者结束</td><td></td></tr><tr><td><code>^</code></td><td>匹配字符串的开始</td><td></td></tr><tr><td><code>$</code></td><td>匹配字符串的结束</td></tr></tbody></table><p>元字符 <code>^</code>和 <code>$</code>都匹配一个位置，这和 <code>\b</code>有点类似。<code>^</code>匹配想要用来查找的字符串的开头，<code>$</code>匹配结尾。</p><p><code>\d+</code>匹配1个或者更多连续的数字。<code>+</code>是和 <code>*</code>类似的元字符，不同的是 <code>*</code>匹配重复任意次（可能是0次），而 <code>+</code>则匹配重复1次或者更多次。</p><p><code>\b\w{6}\b</code>匹配刚好 6个字符的单词</p><p><code>\d{5,12}</code> 表示匹配字符串里面包含 5 到 12 连续位数字，而不是整个字符串是 5 到 12 位数字</p><p><code>^\d{5,12}$</code>则是精确匹配整个字符串就是 5 到 12 位数字</p><h3 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h3><p>如果想要查找元字符本身的话，比如查找<code>.</code>或者 <code>*</code>就需要转义，<code>\</code>可以来取消这些字符的特殊意义</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找 .</span></span><br><span class="line">\.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找 *</span></span><br><span class="line">\*</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 查找 \</span></span><br><span class="line">\\</span><br></pre></td></tr></table></figure><h3 id="重复"><a href="#重复" class="headerlink" title="重复"></a>重复</h3><p>下面是正则表达式中所有限定符（指定数量的代码）</p><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复0次或者更多次</td></tr><tr><td>+</td><td>重复1次或者更多次</td></tr><tr><td>？</td><td>重复0次或者1次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n次到m次</td></tr></tbody></table><p><code>Windows\d+</code> 匹配 <code>Windows</code>后面跟1个或者跟多数字</p><p><code>^\w+</code>匹配一行的第一个单词（或者整个字符串的第一个单词）</p><h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><p>要想查找数字、字母或者数字，空白是很简单的，因为已经有对应的这些字符集合的元字符，但是想匹配没有预定字符的字符集合（比如元音字母 <code>a</code>/<code>e</code>/<code>i</code>/<code>o</code>/<code>u</code>）。</p><p>只需要在方括号中列出它们就可以了,<code>[aeiou]</code>就匹配任何一个英文元音字母，<code>[.?!]</code>匹配标点符号（<code>.</code>或<code>?</code>或<code>!</code>）</p><p>也可以轻松指定一个字符范围，<code>[0-9]</code>的含义和  <code>\d</code>是完全一致的：一个数字。</p><p><code>[a-z0-9A-Z]</code>也完全等同于 <code>\w</code>（如果值考虑英文的话）</p><p>思考：</p><p><code>\(?0\d{2}[) -]?\d{8}</code></p><p>上面的表达式，可以匹配几种格式的电话号码，像（010）88888888，或者010-88888888。它首先是一个转义字符，它能出现0次或者1次（？）,然后是一个0，后面跟着两个数字（d{2}），然后是<code>）</code>或者<code>-</code>或者空格中的一个，它出现1次或者不出现，最后是8个数字。</p><h3 id="分枝条件"><a href="#分枝条件" class="headerlink" title="分枝条件"></a>分枝条件</h3><p>上面思考题，其实也可以匹配 010)8888888或者 （010-88888888 这样不正确的格式。要解决这个问题，需要用到分枝条件。正则表达式里面的分枝条件是有几种规则的。如果满足其中任意一个规则应该都当成匹配，具体的方法是用 <code>|</code>把不同的规则都分隔开。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>\d<span class="string">&#123;2&#125;</span>-\d<span class="string">&#123;8&#125;</span>|<span class="number">0</span>\d<span class="string">&#123;3&#125;</span>-d<span class="string">&#123;7&#125;</span></span><br><span class="line"><span class="comment"># 这个表达式可以匹配两种连字符分隔的电话号码：一种是三位区号的，8位本地号。另一种是4位区号的，7个本地号的</span></span><br><span class="line">\(<span class="number">0</span>\d<span class="string">&#123;2&#125;</span>\)[- ]?\d<span class="string">&#123;8&#125;</span>|<span class="number">0</span>\d<span class="string">&#123;2&#125;</span>[- ]?\d<span class="string">&#123;8&#125;</span></span><br><span class="line"><span class="comment"># 这个表达式匹配3位区号的电话号码，其中区号可以用小括号括起来，也可以不用，区号与本地号间可以用连字号或空格间隔，也可以没有间隔。可以试试用分支条件把这个表达式扩展成支持4位区号的</span></span><br><span class="line">\d<span class="string">&#123;5&#125;</span>-\d<span class="string">&#123;4&#125;</span>|\d<span class="string">&#123;5&#125;</span></span><br><span class="line"><span class="comment"># 这个表达式用于匹配美国的邮政编码。它的规则是5位数字，或者用连字号间隔的9位数字。</span></span><br><span class="line"><span class="comment"># 这要需要注意，不能改成 \d&#123;5&#125;|\d&#123;5&#125;-d&#123;4&#125;，这样就只会匹配5位邮编（以及9位邮编的前5位）。原因是匹配分支条件时，会从左到右测试每个条件，如果满足了某个分支的话，就不会去管其他条件了。</span></span><br></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>重复单个字符，直接在字符后面加上限定符就好了。如果想要重复多个字符的话，可以用小括号来指定子表达式（分组），然后就可以指定这个子表达式的重复次数了，或者是其他的操作。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（\d&#123;<span class="number">1</span>,<span class="number">3</span>&#125;\.)<span class="string">&#123;3&#125;</span>\d&#123;<span class="number">1</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># 上面是一个简答的 ip地址匹配。\d&#123;1,3&#125;匹配1到3位数字</span></span><br><span class="line"><span class="comment"># (\d&#123;1,3&#125;\.)&#123;3&#125;匹配三位数字加上一个英文句号，这个整体也是这个分组重复了3次，最后再加上一个1到3位的数字 \d&#123;1,3&#125;</span></span><br><span class="line"><span class="comment"># 缺漏的地方在于它也会匹配 256.300.899.999 这种不存在的ip 地址。</span></span><br><span class="line"><span class="comment"># 正确的地址(ip地址中每个数字都不能大于255，可以有前导0)</span></span><br><span class="line">((<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>]\d|<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|[<span class="number">01</span>]?\d\d?)\.)<span class="string">&#123;3&#125;</span>(<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>]\d|<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|[<span class="number">01</span>]?\d\d?)</span><br></pre></td></tr></table></figure><h3 id="反义"><a href="#反义" class="headerlink" title="反义"></a>反义</h3><p>有时候需要查找的不是某个能简单定义的字符类的字符。比如想查找除了数字以外的，其他任意字符都行的情况，这时候就需要反义。</p><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td><code>\W</code></td><td>匹配任意不是字母、数字、下划线或者汉字的字符</td></tr><tr><td><code>\S</code></td><td>匹配任意不是空白符的字符</td></tr><tr><td><code>\D</code></td><td>匹配任意不是数字的字符</td></tr><tr><td><code>\B</code></td><td>匹配不是单词开头或者结束的位置</td></tr><tr><td><code>[^X]</code></td><td>匹配除了 X 以外的任意的字符</td></tr><tr><td><code>[^aeiou]</code></td><td>匹配除了 aeiou 这个字母与以外的任意字符</td></tr></tbody></table><p>例子：</p><p><code>\S+</code>匹配不包括空白符的字符串</p><p><code>&lt;a[^&gt;]+&gt;</code>匹配用尖括号括起来的以 <code>a</code>开头的字符串</p><h3 id="后向引用"><a href="#后向引用" class="headerlink" title="后向引用"></a>后向引用</h3><p>使用小括号指定一个子表达式后，匹配这个子表达式的文本（也就是此分组捕获的内容）可以在表达式或者其他程序中作进一步的处理。默认情况下，每个分组都会自动拥有一个组号，规则就是：从左到右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，依次类推。</p><p>分组0代表整个正则表达式，实际上组号分配过程是要从左向右扫描两遍的，第一遍只给未命名组分配，第二遍只给命名组分配，因为所有命名组的组号都大于未命名的组号。</p><p>可以使用 <code>(?:exp)这样的语法来剥夺一个分组对组号分配的参与权</code></p><p>后向引用，用于重复搜索前面的某个分组匹配的文本。例如，<code>\1</code>代表分组1匹配的文本。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\b(\w+)\b\<span class="keyword">s</span>+\<span class="number">1</span>\b</span><br><span class="line"><span class="comment"># 匹配重复的单词，这个表达式首先是一个单词，也就是单词开始处和单词结束处之间多于一个的字母或者数字（\b(\w+)\b），这个单词会被捕获到编码为1的分组中，然后是1个或者几个空白符(\s+)，最后分组1中捕获的内容（也就是前面匹配的那个单词）（\1）</span></span><br></pre></td></tr></table></figure><p>也可以自己指定子表达式的组名，要指定一个子表达式的组名，使用这样的语法:</p><p><code>(?&lt;Word&gt;\w+)</code>或者<code>(?&#39;Word&#39;\w+)</code>这样就把 <code>\w</code>的组名指定为 Word。要反向引用这个分组捕获的内容，可以使用<code>\k&lt;Word&gt;</code>，上面的例子也可以写成这样：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\b(?&lt;Word&gt;\w+)\b\<span class="keyword">s</span>+\k&lt;Word&gt;\b</span><br></pre></td></tr></table></figure><p>下表是常用分组语法：</p><table><thead><tr><th>分类</th><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>捕获</td><td>(exp)</td><td>匹配 exp,并捕获文本到自动命名的组里</td></tr><tr><td></td><td>(?\<name>exp)</td><td>匹配 exp，并捕获文本到名称为 name 的组里，也可以写成 <code>(?&#39;name&#39;exp)</code></td></tr><tr><td></td><td>(?:exp)</td><td>匹配 exp，不捕获匹配的文本，也不给此分组的分配组号</td></tr><tr><td>零宽断言</td><td>(?= exp)</td><td>匹配 exp 前面的位置</td></tr><tr><td></td><td>(?&lt;= exp)</td><td>匹配 exp 后面的位置</td></tr><tr><td></td><td>(?!exp)</td><td>匹配后面跟的不是 exp 的位置</td></tr><tr><td></td><td>(?&lt;!exp)</td><td>匹配前面不是 exp 的位置</td></tr><tr><td>注释</td><td>(?#comment)</td><td>这种类型的分组不对正则表达式的处理产生任何影响，用于注释让人阅读</td></tr></tbody></table><h3 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h3><p>断言用来声明一个应该为真的事实，正则表达式中只有当断言为真的时候才会继续进行匹配。</p><p>用于查找在某些内容前或者之后的东西，像 <code>\b</code>、<code>^</code>、<code>$</code>那样用于指定一个位置，这个位置应该满足一定的条件（断言），因此它们被称为零宽断言。</p><p><code>(?=exp)</code>也叫零宽度正预测先行断言（Zero-width positive lookahead），它断言自身出现的位置的后面能匹配表达式 exp。比如，<code>\b\w+(?=ing\b)</code>，匹配以 <code>ing</code>为结尾的单词的前面部分（除了 ing 以外的部分），如查找 <code>I&#39;m singing while you&#39;re dancing.</code>时，它会匹配 <code>sing</code>和 <code>danc</code></p><p><code>(?&lt;=exp)</code>也叫零宽度正回顾后发断言(Zero-width positive lookbehind)，它断言自身出现的为位置的前面能匹配表示达 exp，比如 <code>(?&lt;=\bre)\w+\b</code>会匹配以 <code>re</code>开头的单词的后半部分（除了re 以外的部分）。例如在查找 <code>reading a book</code>时，它匹配 <code>ading</code>。</p><p>假如想要给一个很长的数字中每三位加一个逗号，从右边加。可以这样查找前面和里面添加逗号的部分：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">((?&lt;=\d)\d<span class="string">&#123;3&#125;</span>)+\b</span><br><span class="line"><span class="comment"># 查找 1234567890 =&gt; 234567890</span></span><br><span class="line"></span><br><span class="line">（?&lt;=\<span class="keyword">s</span>）\d+(?=\<span class="keyword">s</span>)</span><br><span class="line"><span class="comment"># 匹配以空白符间隔的数字，不包括这些空白符</span></span><br><span class="line"><span class="comment"># 查找 1234 56 7890 =&gt; 56</span></span><br></pre></td></tr></table></figure><h3 id="负向零宽断言"><a href="#负向零宽断言" class="headerlink" title="负向零宽断言"></a>负向零宽断言</h3><p>前面提到怎么查找不是某个字符或者不在某个字符类里面的字符的方法（反义）。但是如果我们只是想确保某个字符没有出现，但不想去匹配它时，例如查找这样的单词——它里面的出现了字母q,但是q后面跟着的不是字母 u，我们可以尝试：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\b\w*<span class="string">q[^u]</span>\w*\b</span><br><span class="line"><span class="comment"># 匹配包含后面不是字母u 的字母q的单词。但是你可以发现 [^u]总要匹配一个字符，所以如果q是单词的最后一个字符的话，后面的[^u]总要匹配一个字符，或者是句号或者是其他的什么。后面的 \w*\b 将会匹配下一个单词，于是 上面的表达式就可以匹配整个  Iraq fighting。</span></span><br><span class="line"><span class="comment"># 负向零宽断言能解决这样的问题，因为它只匹配一个位置，并不消费任何字符。</span></span><br><span class="line">\b\w*<span class="string">q(?!u)</span>\w*\b</span><br></pre></td></tr></table></figure><p>零宽度负预测先行断言(?!exp)(Zero-width negative lookahead)，断言此位置后面不能匹配表达式exp。</p><p>例如：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\d<span class="string">&#123;3&#125;</span>(?!\d)</span><br><span class="line"><span class="comment"># 匹配三位数字，而且这三位数字的后面不能是数字</span></span><br><span class="line">\b((?!abc)\w)+\b</span><br><span class="line"><span class="comment"># 匹配不包括连续字符串 abc 的单词</span></span><br></pre></td></tr></table></figure><p>同理可以用零宽度负回顾后发断言(?&lt;!exp)(Zero-width negative lookbehind)，来断言此位置的前面不能匹配表达式 <code>(?&lt;![a-z])\d{7}</code>,即前面不是小写字母的七位数字</p><p>一个更加复杂的例子：</p><p><code>(?&lt;=&lt;(\w+)&gt;).*(?=&lt;\/\1&gt;)</code></p><p>匹配不包含属性的简单 html 标签内的内容。<code>(?&lt;=&lt;(\w+)&gt;)</code>指定了这样的前缀：被尖括号括起来的单词，然后是 <code>.*</code>(任意的字符串)，最后一个是后缀<code>(?=&lt;\/\1&gt;)</code>。<code>\/</code>转义了，<code>\1</code>反向引用，整个内容就是闭合标签之间的内容，不包括两个标签本身。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>小括号的另一种用途是通过语法<code>(?#comment)</code>来包含注释。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)</span><br></pre></td></tr></table></figure><p>要包含注释的话，最好是启用“忽略模式里面的空白符”选项。这样在编写表达式时能任意的添加空格/TAB/换行，而实际使用时这些都被忽略。启用这个选项后，在 <code>#</code>后面到这一行结束的所有文本都被当做注释忽略掉。例如，我们可以前面的一个表达式写成这样：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(?&lt;=<span class="comment"># 断言要匹配的文本的前缀</span></span><br><span class="line">&lt;(\w+)&gt; <span class="comment"># 查找尖括号括起来的字母或者数字（即HTML/XML标签）</span></span><br><span class="line">)       <span class="comment"># 前缀结束</span></span><br><span class="line">.*      <span class="comment"># 匹配任意文本</span></span><br><span class="line">(?=     <span class="comment"># 断言要匹配的文本的后缀</span></span><br><span class="line">&lt;\/\<span class="number">1</span>&gt;  <span class="comment"># 查找尖括号括起来的内容：前面是一个 '/'，后面是先前捕获的标签</span></span><br><span class="line">)       <span class="comment"># 后缀结束</span></span><br></pre></td></tr></table></figure><h3 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h3><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例子：a.*b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索 <code>aabab</code>的话，它就会匹配整个 <code>aabab</code>，这被称为贪婪匹配。</p><p>有时候，我们需要懒惰匹配，也就是尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号 <code>?</code>。这样，<code>.?</code>这意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。</p><p><code>a.*?b</code>匹配最短的，以a开始，以b结束的字符串。如果把它应用于 <code>aabab</code>的话，它会匹配 <code>aab</code>和 <code>ab</code></p><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td><code>*?</code></td><td>重复任意次，但尽可能少重复</td></tr><tr><td><code>+?</code></td><td>重复 1次或者更多次，但尽可能少重复</td></tr><tr><td><code>??</code></td><td>重复 0 次或者 1 次，但尽可能少重复</td></tr><tr><td><code>{n,m}？</code></td><td>重复 n 到 m 次，但尽可能少重复</td></tr><tr><td><code>{n,}?</code></td><td>重复  n 次以上，但尽可能少重复</td></tr></tbody></table><h2 id="JS-中的正则表达式"><a href="#JS-中的正则表达式" class="headerlink" title="JS 中的正则表达式"></a>JS 中的正则表达式</h2><p>正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是对象，这些模式被用于 <code>RegExp</code>的<code>test</code>和 <code>exec</code>，以及 <code>String</code>的 <code>match</code>、<code>replace</code>、<code>search</code>和 <code>split</code>方法。</p><h3 id="创建一个正则表达式"><a href="#创建一个正则表达式" class="headerlink" title="创建一个正则表达式"></a>创建一个正则表达式</h3><p>1.使用一个正则表达式字面量，其由包含斜杠之间的模式组成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/ab+c/</span>;</span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^[a-zA-Z]+[0-9]*\W?_$/gi</span></span><br></pre></td></tr></table></figure><p>2.调用<code>RegExp</code>对象的构造函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ab+c'</span>);</span><br><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/^[a-zA-Z]+[0-9]*\W?_$/</span>,<span class="string">'gi'</span>)</span><br><span class="line"><span class="keyword">let</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"^[a-zA-Z]+[0-9]*\\W?_$"</span>,<span class="string">"gi"</span>)</span><br></pre></td></tr></table></figure><h3 id="编写一个正则表达式的模式"><a href="#编写一个正则表达式的模式" class="headerlink" title="编写一个正则表达式的模式"></a>编写一个正则表达式的模式</h3><p>一个正则表达式的模式由简单的字符所构成，比如 <code>/abc/</code>，或是简单和特殊字符的组合，比如 <code>/ab*c/</code>或者 <code>/Chapter(\d+)\.\d*/</code>。后者用到了括号，它在正则表达中可以被当作是一个记忆设备。这一部分正则所匹配的字符会被记住，在后面可以利用。</p><p><strong>使用简单的模式</strong></p><p>简单的模式由找到的直接匹配所构成的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/abc/</span><br><span class="line"><span class="comment">// 匹配 Hi, do you know your abc's? </span></span><br><span class="line"><span class="comment">// 匹配 The latest airplane designs evolved from slabcraft.? </span></span><br><span class="line"><span class="comment">// 不匹配 Grab crab</span></span><br></pre></td></tr></table></figure><p><strong>使用特殊字符</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/ab*c/</span><br><span class="line"><span class="comment">// 匹配 cbbabbbbcdebc =&gt; abbbbc</span></span><br></pre></td></tr></table></figure><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td><code>\</code></td><td>在非特殊字符之前的反斜杆表示下一个字符是特殊的。<br>反斜杆也可以将其后的特殊字符，转义为字面量。<br>使用 <code>new RegExp(&#39;pattern&#39;)</code>的时候要将 <code>\</code>转义，因为 <code>\</code>在字符串里面也是一个转义字符</td></tr><tr><td><code>^</code></td><td>匹配输入的开始。如果多行标志被设置为 true，那么也匹配换行符后紧跟的位置。</td></tr><tr><td><code>$</code></td><td>匹配输入的结束。如果多行标识符被设置为 true，那么也会匹配换行符之前的位置。0</td></tr><tr><td><code>*</code></td><td>匹配前一个表示0 次或者多次。等价于<code>{0,}</code></td></tr><tr><td><code>+</code></td><td>匹配前面一个表达式1次或者更多次，等价于 <code>{1,}</code></td></tr><tr><td><code>?</code></td><td>匹配前面一个表达式0次或者1次。等价于<code>{0,1}</code><br>如果紧跟在任何量词 <code>*</code>、<code>+</code>、<code>?</code>、<code>{}</code>后面，将会使得量词变成非贪婪（匹配尽量少的字符），和缺省使用的贪婪模式（匹配尽可能多的字符）正好相反</td></tr><tr><td><code>.</code></td><td>（小数点）匹配除换行符之外面的任何单个字符</td></tr><tr><td><code>(x)</code></td><td>匹配 ‘x’并记住匹配项。括号被称为捕获括号。<br>模式<code>/(foo)(bar)\1\2/</code><br>在正式表达式的替换环节，使用 <code>$1</code>的语法，例如 <code>&#39;bar.foo&#39;.replace(/(..)(..)/,&#39;$2$1&#39;)</code></td></tr><tr><td><code>(?:x)</code></td><td>匹配‘x’但不记住匹配项。这种叫做非捕获括号，使得你能够定义与正则表达式运算符一起使用的子表达式。<br></td></tr><tr><td><code>x(?=y)</code></td><td>匹配‘x’仅仅当’x’后面跟着‘y’。这种叫先行断言。<br><code>/Jack(?=Spart)/</code>会匹配到 ‘Jack’仅当它后面跟着’Spart’。但是‘Spart’都不是匹配结果中的一部分</td></tr><tr><td><code>(?&lt;=y)x</code></td><td>匹配‘x’仅仅当’x’前面是‘y’,这种叫做后行断言。<br><code>/(?&lt;=Jack)Spart/</code>会匹配到 ‘Spart’仅仅当它前面是‘Jack’。<br>`/(?&lt;=Jack</td><td>Tom)Spart/`会匹配到 ’Spart‘仅仅当它前面是 ’Jack‘或者是 ‘Tom’。但是’Tom‘和’Jack‘都不是匹配结果的一部分</td></tr><tr><td><code>x(?！y)</code></td><td>匹配’x‘仅仅当’x‘后面不跟着’y‘,这个叫做正向否定查找。<br><code>/\d+(?!\.)/</code>匹配一个数字仅仅当这个数字后面没有跟小数点的时候。</td></tr><tr><td>`x</td><td>y`</td><td>匹配’x‘或者’y‘。</td></tr><tr><td><code>{n}</code></td><td>n是一个正整数，匹配了前面一个字符刚好发生了 n 次</td></tr><tr><td><code>{n,m}</code></td><td>n 和 m 都是整数。匹配前面的字符至少 n 次，最多 m 次。如果 n 或者 m 的值是0，这个值会被忽略。</td></tr><tr><td><code>[xyz]</code></td><td>一个字符的集合。匹配方括号中的任意字符，包括转义序列。可以用破折号（-）来指定一个字符范围。对于点（.）和星号（*）这样的特殊符号在一个字符集中没有特殊意义。</td></tr><tr><td><code>[^xyz]</code></td><td>一个反向字符集。匹配任何没有包含在方括号中的字符。同样可以使用破折号来指定一个字符范围。</td></tr><tr><td><code>[\b]</code></td><td>匹配一个退格(U+0008)</td></tr><tr><td><code>\b</code></td><td>匹配一个词的边界。一个词的边界就是一个词不被另外一个字字符跟随的位置或者没有其他“字”字符在其前面的位置。</td></tr><tr><td><code>\B</code></td><td>匹配一个非单词边界。匹配一个前后字符都是相同类型的位置。都是’字‘字符或者都不是’字‘字符。一个字符串的开始和结尾都被认为不是‘字’字符，或者是字符串。</td></tr><tr><td><code>\cX</code></td><td>当 X 是处于A 到 Z 之间的字符的时候，匹配字符串中的一个控制符</td></tr><tr><td><code>\d</code></td><td>匹配一个数字</td></tr><tr><td><code>\D</code></td><td>匹配一个非数字字符</td></tr><tr><td><code>\f</code></td><td>匹配一个换页符（U+000C）</td></tr><tr><td><code>\n</code></td><td>匹配一个换行符（U+000A）</td></tr><tr><td><code>\r</code></td><td>匹配一个回车符（U+000D）</td></tr><tr><td><code>\s</code></td><td>匹配一个空白符号，包括空格、制表符、换页符和换行符。<br>等价于<code>[\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]</code></td></tr><tr><td><code>\S</code></td><td>匹配一个非空白字符。<br>等价于<code>[^</code>\f\n\r\t\v\u00a0\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff<code>]</code>。</td></tr><tr><td><code>\t</code></td><td>匹配一个水平制表符（U+0009）</td></tr><tr><td><code>\v</code></td><td>匹配一个垂直制表符（U+000B）</td></tr><tr><td><code>\w</code></td><td>匹配一个单字字符（字母、数字或者下划线）<br>等价于  <code>[A-Za-z0-9_]</code></td></tr><tr><td><code>\W</code></td><td>匹配一个单字字符<br>等价于 <code>[^A-Za-z0-9_]</code></td></tr><tr><td><code>\n</code></td><td>在正则表达式中，它返回最后的第 n 个子捕获匹配的子字符串（捕获的数目以左括号计数）</td></tr><tr><td><code>\0</code></td><td>匹配 NULL(U+0000)字符，不要在这后面跟着其他小数，因为 <code>\0&lt;digits&gt;</code>是一个八进制转义序列</td></tr><tr><td><code>\xhh</code></td><td>与代码 hh 匹配字符（两个十六进制数字）</td></tr><tr><td><code>\uhhhh</code></td><td>与代码 <code>hhhh</code>匹配字符（四个十六进制数字）</td></tr></tbody></table><h3 id="使用正则表达式"><a href="#使用正则表达式" class="headerlink" title="使用正则表达式"></a>使用正则表达式</h3><p>正则表达式被用于 RegExp 的 exec 和 test 方法，还有 String  的 match、replace、search和 split 方法。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>exec</code></td><td>一个在字符串中执行查找匹配的 RegExp 方法，它返回一个数组(未匹配返回 null)</td></tr><tr><td><code>test</code></td><td>一个在字符串中测试是否匹配的 RegExp 方法，它返回 true 或者 false</td></tr><tr><td><code>match</code></td><td>一个在字符串中执行查找匹配的 String 方法，它返回一个数组或者在未匹配时返回 null</td></tr><tr><td><code>search</code></td><td>一个在字符串中测试匹配的 String  方法，它返回匹配到的位置索引，或者在失败时返回 -1</td></tr><tr><td><code>replace</code></td><td>一个在字符串中执行查找匹配的 String 方法，并且使用替换字符串替换掉后面的子字符串</td></tr><tr><td><code>split</code></td><td>一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的字符串存储到数组中的 String 方法</td></tr></tbody></table><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 脚本使用 exec 方法在一个字符串中查找一个匹配</span></span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/d(b+)d/g</span>;</span><br><span class="line"><span class="comment">/**reg参数</span></span><br><span class="line"><span class="comment">* 5 lastIndex 下一个匹配的索引值</span></span><br><span class="line"><span class="comment">* "d(b+)d" source 模式文本。在正则表达式创建时更新，不执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">let</span> myArray = reg.exec(<span class="string">"cdbbdbsbz"</span>)</span><br><span class="line">myArray; <span class="comment">// ["dbbd", "bb", index: 1, input: "cdbbdbsbz", groups: undefined]</span></span><br><span class="line"><span class="comment">/** myArray参数</span></span><br><span class="line"><span class="comment">* ["dbbd,bb"] 匹配到的字符和所有被记住的子字符串</span></span><br><span class="line"><span class="comment">* 1 1input 初始字符串</span></span><br><span class="line"><span class="comment">* input:cdbbdbsbz  初始字符串</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 不需要访问正则表达式的属性，通过另一个方法来创建</span></span><br><span class="line">myArray = <span class="regexp">/d(b+)d/g</span>.exec(<span class="string">"cdbbdbsbz"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过一个字符串构建正则表达式，还有另一种方式</span></span><br><span class="line">reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"d(b+)d"</span>,<span class="string">"g"</span>);</span><br><span class="line">myArray = reg.exec(<span class="string">"cdbbdbsbz"</span>)</span><br></pre></td></tr></table></figure><h4 id="使用括号的子字符串匹配"><a href="#使用括号的子字符串匹配" class="headerlink" title="使用括号的子字符串匹配"></a>使用括号的子字符串匹配</h4><p>一个正则表达式模式使用括号，将导致相应的子匹配被记住。使用括号匹配的子字符串的数量是无限的。返回的数组中保存所有被发现的子匹配。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/(\w+)\s(\w+)/</span>;</span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'John Smith'</span>;</span><br><span class="line"><span class="keyword">let</span> newStr = str.replace(reg,<span class="string">"$2,$1"</span>)</span><br><span class="line">newStr; <span class="comment">// "Smith,John"</span></span><br></pre></td></tr></table></figure><h4 id="通过标志进行高级搜索"><a href="#通过标志进行高级搜索" class="headerlink" title="通过标志进行高级搜索"></a>通过标志进行高级搜索</h4><p>正则表达式有四个可选参数进行全局和不区分大小写搜索，这些参数可以单独使用也可以一起使用在任何顺序和包含正则表达式的部分中。</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td><code>g</code></td><td>全局搜索</td></tr><tr><td><code>i</code></td><td>不区分大小写搜索</td></tr><tr><td><code>m</code></td><td>多行搜索(使用该标志，<code>^</code>和 <code>$</code>匹配的开始或者结束输入字符串的)</td></tr><tr><td><code>y</code></td><td>执行“粘性”搜索，匹配从目标字符串的当前位置开始，可以使用 <code>y</code>标志</td></tr></tbody></table><p>格式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/pattern/</span>flags;</span><br><span class="line"><span class="keyword">let</span> reg = <span class="regexp">/\w+\s/g</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"pattern"</span>,<span class="string">"flags"</span>)</span><br><span class="line">reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"\\w+\\s"</span>,<span class="string">"g"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近这段时间因为赶项目，一直没有更新博客。精通正则这本书一年前翻阅过过一些。用到的地方不多，便很快就忘记了。今忙里抽空复习一下正则，在项目中也会有所用到。主要是跟随&lt;a href=&quot;http://deerchao.net/tutorials/regex/regex-1.ht
      
    
    </summary>
    
      <category term="正则表达式" scheme="http://laibh.top/categories/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    
      <category term="正则表达式" scheme="http://laibh.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面试官问我HTML5是什么（下）</title>
    <link href="http://laibh.top/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91HTML5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%8B%EF%BC%89.html"/>
    <id>http://laibh.top/面试官问我HTML5是什么（下）.html</id>
    <published>2019-05-30T01:30:54.000Z</published>
    <updated>2019-10-15T09:29:49.419Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><p>发展历史</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CSS1 -&gt; CSS2 -&gt; CSS2.1 -&gt;CSS3</span><br></pre></td></tr></table></figure><p><strong>模块与模块化结构</strong></p><p>CSS3采用了分工协作的模块化结构</p><p>其中最重要的 CSS3 模块包括：</p><ul><li>选择器</li><li>框模型</li><li>背景和边框</li><li>文本效果</li><li>2D/3D 转换</li><li>动画</li><li>多列布局</li><li>用户界面</li></ul><h3 id="CSS3-新增的选择器"><a href="#CSS3-新增的选择器" class="headerlink" title="CSS3 新增的选择器"></a>CSS3 新增的选择器</h3><p><strong>属性选择器</strong></p><table><thead><tr><th>选择器</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td><em>E[att^=”val”]</em></td><td>属性 <code>att</code>的值以 <code>val</code>开头的元素</td><td><code>div[id^=&#39;haha&#39;]</code></td></tr><tr><td><em>E[att$=”val”]</em></td><td>属性 <code>att</code>的值以 <code>val</code>结尾的元素</td><td><code>div[id^=&#39;haha&#39;]</code></td></tr><tr><td><em>E[att</em>=”val”]</td><td>属性 <code>att</code>的值包含 <code>val</code>字符串的元素</td><td><code>div[id^=&#39;haha&#39;]</code></td></tr></tbody></table><p><strong>结构性伪类选择器</strong></p><table><thead><tr><th>选择器</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td><em>E:root</em></td><td>匹配文档的根元素，对于 HTML 文档就是 HTML元素</td><td></td></tr><tr><td><em>E:not(s)</em></td><td>匹配不符合当前选择器的任何元素</td><td><code>div:not([class=&quot;demo&quot;])</code>:除了<code>class</code>为<code>demo</code>的div以外</td></tr><tr><td><em>E:empty</em></td><td>匹配一个不包含任何子元素的元素（文本节点也被看成子元素，空格也是一个元素）</td><td></td></tr><tr><td><em>E:target</em></td><td>匹配被 <code>location.hash</code>选中的元素（即锚点元素），选择器可以用来选取当前活动的目标元素</td><td></td></tr><tr><td><em>E:first-child</em></td><td>匹配<code>E</code>父元素的第一个子元素,如果当前位置元素不是前面所修饰的元素，那么无效</td><td><code>li:first-child</code>:匹配页面中所有第一个<code>li</code></td></tr><tr><td><em>E:last-child</em></td><td>匹配<code>E</code>父元素的最后一个子元素，等同于 <code>E:nth-last-child(1)</code>,如果当前位置元素不是前面所修饰的元素，那么无效</td><td></td></tr><tr><td><em>E:nth-child(n)</em></td><td>匹配<code>E</code>父元素的第<code>n</code>个元素，第一个编号为1,如果当前位置元素不是前面所修饰的元素，那么无效</td><td></td></tr><tr><td><em>E:nth–last-child(n)</em></td><td>匹配<code>E</code>父元素的倒数第n个子元素，第一个编号为1,如果当前位置元素不是前面所修饰的元素，那么无效</td><td></td></tr><tr><td><em>E:nth-of-type(n)</em></td><td>与<code>E:nth-child()</code>类似，但是仅匹配使用同种标签的元素</td><td><code>p:nth-of-type(2)</code>:匹配父元素的第2个子元素p</td></tr><tr><td><em>E:first-of-type(n)</em></td><td>匹配父元素使用同种标签的第一个子元素，等同于 <code>E:nth-of-type(1)</code></td><td></td></tr><tr><td><em>E:last-of-type(n)</em></td><td>匹配父元素使用同种标签的最后一个子元素，等同于 <code>E:nth-last-of-type(1)</code></td><td></td></tr><tr><td><em>E:nth-last-of-type(n)</em></td><td>与 <code>E:nth-last-child(n)</code>类似，但是仅匹配使用相同标签的元素</td><td></td></tr><tr><td><em>E:only-child</em></td><td>匹配父元素下仅有的一个子元素，等同于 <code>E:first-child:last-child</code>或者 <code>E:nth-child(1):nth-last-child(1)</code></td><td></td></tr><tr><td><em>E：only-of-type</em></td><td>匹配父元素下使用同种标签的唯一一个子元素，等同于 <code>E:first-of-type:last-of-type</code>或者 <code>E:nth-of-type(1):nth-last-of-type(1)</code></td><td></td></tr><tr><td>备注：</td><td><code>n</code>里面可以是 odd(奇数)、even(偶数)</td><td>循环使用样式：<code>li:nth-child(2n+1)</code></td></tr></tbody></table><p><strong>UI状态伪类选择器</strong></p><table><thead><tr><th>选择器</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td><em>E:enabled</em></td><td>匹配表单中激活的元素</td><td></td></tr><tr><td><em>E:disabled</em></td><td>匹配表单中禁用的元素</td><td></td></tr><tr><td><em>E:checked</em></td><td>匹配表单中被选中的单选框或者复选框</td><td></td></tr><tr><td><em>E::selection</em></td><td>匹配用户用鼠标当前选中的元素</td><td><code>user-select: none;</code>取消鼠标选中的默认样式</td></tr><tr><td><em>E:read-only</em></td><td>匹配选中只读的元素</td><td><code>&lt;input type=&quot;text&quot; readonly=&quot;readonly&quot; value=&quot;hahha&quot;/&gt;</code></td></tr><tr><td><em>E:read-write</em></td><td>匹配选中非只读的元素</td><td><code>&lt;input type=&quot;text&quot; value=&quot;hahha&quot;/&gt;</code></td></tr></tbody></table><p><strong>级元素通用选择器</strong></p><table><thead><tr><th>选择器</th><th>含义</th><th>实例</th></tr></thead><tbody><tr><td><code>E~F</code></td><td>匹配任何在 <code>E</code>元素之后的同级元素 <code>F</code></td><td>p~ul{background:#ff9;}</td></tr></tbody></table><ol><li>E：hover</li><li>E：active</li><li>E：focus</li><li>E：enabled</li><li>E：disabled</li><li>E：read-only</li><li>E：read-write</li><li>E：checked</li><li>E：default</li><li>E：indeterminate</li><li>E：selection</li></ol><h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><ol><li>简单属性选择</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*把包含某个attribute的所有边元素变成红色*/</span></span><br><span class="line">*<span class="selector-attr">[attribute]</span>&#123;<span class="attribute">color</span>:red&#125;</span><br><span class="line"><span class="comment">/*只对有attribute属性的div元素应用样式*/</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[attribute]</span>&#123;<span class="attribute">color</span>:red&#125;</span><br><span class="line"><span class="comment">/*根据多个属性，同时拥有attribute1和attribute2的元div应用样式*/</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-attr">[attribute1]</span><span class="selector-attr">[attribute2]</span>&#123;<span class="attribute">color</span>:red&#125;</span><br><span class="line"><span class="comment">/*对有alt属性的图像*/</span></span><br><span class="line"><span class="selector-tag">img</span><span class="selector-attr">[alt]</span>&#123;<span class="attribute">border</span>:<span class="number">5px</span> solid red&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>根据具体属性选择</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*某个具体的a标签*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href="http://laibh.top"]</span>&#123;<span class="attribute">color</span>:red&#125;;</span><br><span class="line"><span class="comment">/*加多一个限制*/</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href="http://laibh.top"]</span><span class="selector-attr">[title="赖同学"]</span>&#123;<span class="attribute">color</span>:red&#125;;</span><br><span class="line"><span class="comment">/*不要忽略空格*/</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[class="red small"]</span>&#123;<span class="attribute">color</span>:red&#125;;</span><br></pre></td></tr></table></figure><ol start="3"><li>根据部分属性值选择</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*选择 class属性中包含 important元素的 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[class~="important"]</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">[abc^=”def”]</td><td style="text-align:left">选择 abc 属性值以 “def” 开头的所有元素</td></tr><tr><td style="text-align:left">[abc$=”def”]</td><td style="text-align:left">选择 abc 属性值以 “def” 结尾的所有元素</td></tr><tr><td style="text-align:left">[abc*=”def”]</td><td style="text-align:left">选择 abc 属性值中包含子串 “def” 的所有元素</td></tr></tbody></table><ol start="4"><li>特定属性选择类型</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*这个规则会选择 lang 属性等于 en 或以 en- 开头的所有元素*/</span></span><br><span class="line">*<span class="selector-attr">[lang|="en"]</span>&#123;<span class="attribute">color</span>:red&#125;</span><br></pre></td></tr></table></figure><p><strong>css属性选择器表</strong></p><table><thead><tr><th style="text-align:left">选择器</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">[<em>attribute</em>]</td><td style="text-align:left">用于选取带有指定属性的元素。</td></tr><tr><td style="text-align:left">[<em>attribute</em>=<em>value</em>]</td><td style="text-align:left">用于选取带有指定属性和值的元素。</td></tr><tr><td style="text-align:left">[<em>attribute</em>~=<em>value</em>]</td><td style="text-align:left">用于选取属性值中包含指定词汇的元素。</td></tr><tr><td style="text-align:left">[<em>attribute</em>\</td><td style="text-align:left">=<em>value</em>]</td><td>用于选取带有以指定值开头的属性值的元素，该值必须是<strong>整个单词</strong>。</td></tr><tr><td style="text-align:left">[<em>attribute</em>^=<em>value</em>]</td><td style="text-align:left">匹配属性值以指定值开头的每个元素。（CSS3新增）</td></tr><tr><td style="text-align:left">[<em>attribute</em>$=<em>value</em>]</td><td style="text-align:left">匹配属性值以指定值结尾的每个元素。（CSS3新增）</td></tr><tr><td style="text-align:left">[<em>attribute**=</em>value*]</td><td style="text-align:left">匹配属性值中包含指定值的每个元素。（CSS3新增）</td></tr></tbody></table><h3 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a>伪类与伪元素</h3><h4 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h4><p>CSS2定义：用于向某些选择器添加特殊的效果。</p><p>CSS3定义：</p><ol><li>伪类的存在是为了通过选择器找到那些不存于DOM树中的信息以及不能被常规 CSS选择器获取到的信息（:target）</li><li>伪类由<strong>一个</strong>冒号<code>:</code>开头，冒号后面是伪类的名称和包含在圆括号中的可选参数</li><li>任何常规选择器都可以在任何位置使用伪类。伪类语法不区分大小写。一些伪类的作用会互斥，另外一些伪类可以同时被同一个元素使用。并且，为了满足用户在操作  DOM时产生的 DOM 结构变化，伪类也可以是动态的</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">selector</span> : <span class="selector-tag">pseudo-class</span>&#123; <span class="attribute">property</span>:value &#125;</span><br><span class="line"><span class="selector-tag">selector</span><span class="selector-class">.class</span> : <span class="selector-tag">pseudo-class</span>&#123; <span class="attribute">property</span>:value &#125;</span><br></pre></td></tr></table></figure><p><strong>锚伪类</strong>（不存在于 DOM树的信息）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span>&#123;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>&#123;&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;&#125;</span><br><span class="line"><span class="selector-tag">a</span>;<span class="selector-tag">active</span>&#123;&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-class">.tab_content</span> &#123;</span></span><br><span class="line"><span class="undefined">  height: 800px;</span></span><br><span class="line"><span class="undefined">  background: red;</span></span><br><span class="line"><span class="undefined">  margin-bottom: 100px;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#tab1</span><span class="selector-pseudo">:target</span>, <span class="selector-id">#tab2</span><span class="selector-pseudo">:target</span>, <span class="selector-id">#tab3</span><span class="selector-pseudo">:target</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line"><span class="undefined">&#125;    </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tab1"</span> <span class="attr">class</span>=<span class="string">"tab_content"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--tabed content--&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tab2"</span> <span class="attr">class</span>=<span class="string">"tab_content"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--tabed content--&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"tab3"</span> <span class="attr">class</span>=<span class="string">"tab_content"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--tabed content--&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--:target通过CSS实现了常规CSS无法实现的逻辑--&gt;</span></span><br></pre></td></tr></table></figure><p><strong>伪类表</strong></p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th><th style="text-align:left">CSS</th></tr></thead><tbody><tr><td style="text-align:left">:active</td><td style="text-align:left">向被激活的元素添加样式。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:focus</td><td style="text-align:left">向拥有键盘输入焦点的元素添加样式。</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:hover</td><td style="text-align:left">当鼠标悬浮在元素上方时，向元素添加样式。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:link</td><td style="text-align:left">向未被访问的链接添加样式。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:visited</td><td style="text-align:left">向已被访问的链接添加样式。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:first-child</td><td style="text-align:left">向元素的第一个子元素添加样式。</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:lang</td><td style="text-align:left">向带有指定 lang 属性的元素添加样式。</td><td style="text-align:left">2</td></tr></tbody></table><h4 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h4><p>CSS2定义：用于向某些选择器设置特殊效果</p><p>CSS3定义：</p><ol><li>伪元素在DOM树中创建了一些抽象元素，这些抽象元素是不存在文档语言里面的（html源码）。如：document接口不提供访问元素内容的第一个字或者第一行的机制，而伪元素可以使得开发者提取到这些信息。并且，一些伪元素可以使开发者获取到不存在与源文档中的内容（<code>:before</code>/<code>:after</code>）</li><li>伪元素由<strong>两个</strong>冒号<code>:：</code>开头，然后是伪元素的名称</li><li>使用<code>::</code>是为了区分伪类和伪元素（CSS2中没有区别）。考虑兼容性的话，CSS2中的已存伪元素可以使用 <code>:</code>，但是 CSS3的就要使用 <code>::</code></li><li>一个选择器只能使用一个伪元素，并且伪元素必须处于选择器语句的最后</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">selector</span><span class="selector-pseudo">:pseudo-element</span>&#123;<span class="attribute">property</span>:value&#125;</span><br><span class="line"><span class="selector-tag">selector</span><span class="selector-class">.class</span><span class="selector-pseudo">:pseudo-element</span>&#123;<span class="attribute">property</span>:value&#125;</span><br></pre></td></tr></table></figure><p><code>:first-line</code></p><p>用于向文本的首行设置特殊样式(只能用于块级元素)</p><p>下面属性可以应用这个伪元素</p><ul><li>font</li><li>color</li><li>background</li><li>word-spacing</li><li>letter-spacing</li><li>text-decoration</li><li>vertical-align</li><li>text-transform</li><li>line-height</li><li>clear</li></ul><p><code>:first-letter</code></p><p>用于向文本的首字母设置特殊样式</p><p>下面的属性可以应用这个伪元素</p><ul><li>font</li><li>color</li><li>background</li><li>margin</li><li>padding</li><li>border</li><li>text-decoration</li><li>vertical-align(当 float为none)</li><li>text-transform</li><li>line-height</li><li>float</li><li>clear</li></ul><p><code>:before</code></p><p>在元素内容前面插入新内容</p><p><code>:after</code></p><p>在元素内容之后插入新内容</p><p><strong>伪元素表</strong></p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th><th style="text-align:left">CSS</th></tr></thead><tbody><tr><td style="text-align:left">:first-letter</td><td style="text-align:left">向文本的第一个字母添加特殊样式。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:first-line</td><td style="text-align:left">向文本的首行添加特殊样式。</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:before</td><td style="text-align:left">在元素之前添加内容。</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:after</td><td style="text-align:left">在元素之后添加内容。</td><td style="text-align:left">2</td></tr></tbody></table><h4 id="伪类与伪元素特性与区别"><a href="#伪类与伪元素特性与区别" class="headerlink" title="伪类与伪元素特性与区别"></a>伪类与伪元素特性与区别</h4><ol><li>伪类本质上是为了弥补常规 CSS 选择器的不足，以便获取更多的信息（不存在 DOM树的信息，不能被常规CSS选择器获取的信息）</li><li>伪元素本质上是创建了一个有内容的虚拟容器,这个容器不包含任何DOM元素，但是可以包含内容</li><li>CSS3 中的伪类和伪元素的语法不同（<code>:</code>与<code>::</code>）</li><li>可以同时使用多个伪类，而只能同时使用一个伪元素</li></ol><h3 id="完整表格"><a href="#完整表格" class="headerlink" title="完整表格"></a>完整表格</h3><table><thead><tr><th style="text-align:left">选择器</th><th style="text-align:left">示例</th><th style="text-align:left">示例说明</th><th style="text-align:left">CSS</th></tr></thead><tbody><tr><td style="text-align:left">.<em>class</em></td><td style="text-align:left">.intro</td><td style="text-align:left">选择所有class=”intro”的元素</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">#<em>id</em></td><td style="text-align:left">#firstname</td><td style="text-align:left">选择所有id=”firstname”的元素</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">*</td><td style="text-align:left">选择所有元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>element</em></td><td style="text-align:left">p</td><td style="text-align:left">选择所有<p>元素</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"><em>element,element</em></td><td style="text-align:left">div,p</td><td style="text-align:left">选择所有<div>元素和<p>元素</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"><em>element</em> <em>element</em></td><td style="text-align:left">div p</td><td style="text-align:left">选择<div>元素内的所有<p>元素</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"><em>element</em>&gt;<em>element</em></td><td style="text-align:left">div&gt;p</td><td style="text-align:left">选择所有父级是 <div> 元素的 <p> 元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>element</em>+<em>element</em></td><td style="text-align:left">div+p</td><td style="text-align:left">选择所有紧接着<div>元素之后的<p>元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>attribute</em></td><td style="text-align:left">[target]</td><td style="text-align:left">选择所有带有target属性元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>attribute</em>=<em>value</em></td><td style="text-align:left">[target=-blank]</td><td style="text-align:left">选择所有使用target=”-blank”的元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>attribute</em>~=<em>value</em></td><td style="text-align:left">[title~=flower]</td><td style="text-align:left">选择标题属性包含单词”flower”的所有元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>attribute</em></td><td style="text-align:left">=<em>language</em>[lang\</td><td style="text-align:left">=en]</td><td style="text-align:left">选择 lang 属性以 en 为开头的所有元素</td><td>2</td></tr><tr><td style="text-align:left">:link</td><td style="text-align:left">a:link</td><td style="text-align:left">选择所有未访问链接</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:visited</td><td style="text-align:left">a:visited</td><td style="text-align:left">选择所有访问过的链接</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:active</td><td style="text-align:left">a:active</td><td style="text-align:left">选择活动链接</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:hover</td><td style="text-align:left">a:hover</td><td style="text-align:left">选择鼠标在链接上面时</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:focus</td><td style="text-align:left">input:focus</td><td style="text-align:left">选择具有焦点的输入元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:first-letter</td><td style="text-align:left">p:first-letter</td><td style="text-align:left">选择每一个<P>元素的第一个字母</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:first-line</td><td style="text-align:left">p:first-line</td><td style="text-align:left">选择每一个<P>元素的第一行</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">:first-child</td><td style="text-align:left">p:first-child</td><td style="text-align:left">指定只有当<p>元素是其父级的第一个子级的样式。</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:before</td><td style="text-align:left">p:before</td><td style="text-align:left">在每个<p>元素之前插入内容</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:after</td><td style="text-align:left">p:after</td><td style="text-align:left">在每个<p>元素之后插入内容</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">:lang(<em>language</em>)</td><td style="text-align:left">p:lang(it)</td><td style="text-align:left">选择一个lang属性的起始值=”it”的所有<p>元素</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"><em>element1</em>~<em>element2</em></td><td style="text-align:left">p~ul</td><td style="text-align:left">选择p元素之后的每一个ul元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left"><em>attribute</em>^=<em>value</em></td><td style="text-align:left">a[src^=”https”]</td><td style="text-align:left">选择每一个src属性的值以”https”开头的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left"><em>attribute</em>$=<em>value</em></td><td style="text-align:left">a[src$=”.pdf”]</td><td style="text-align:left">选择每一个src属性的值以”.pdf”结尾的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left"><em>attribute</em>=<em>value</em></td><td style="text-align:left">a[src*=”runoob”]</td><td style="text-align:left">选择每一个src属性的值包含子字符串”runoob”的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:first-of-type</td><td style="text-align:left">p:first-of-type</td><td style="text-align:left">选择每个p元素是其父级的第一个p元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:last-of-type</td><td style="text-align:left">p:last-of-type</td><td style="text-align:left">选择每个p元素是其父级的最后一个p元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:only-of-type</td><td style="text-align:left">p:only-of-type</td><td style="text-align:left">选择每个p元素是其父级的唯一p元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:only-child</td><td style="text-align:left">p:only-child</td><td style="text-align:left">选择每个p元素是其父级的唯一子元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:nth-child(<em>n</em>)</td><td style="text-align:left">p:nth-child(2)</td><td style="text-align:left">选择每个p元素是其父级的第二个子元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:nth-last-child(<em>n</em>)</td><td style="text-align:left">p:nth-last-child(2)</td><td style="text-align:left">选择每个p元素的是其父级的第二个子元素，从最后一个子项计数</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:nth-of-type(<em>n</em>)</td><td style="text-align:left">p:nth-of-type(2)</td><td style="text-align:left">选择每个p元素是其父级的第二个p元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:nth-last-of-type(<em>n</em>)</td><td style="text-align:left">p:nth-last-of-type(2)</td><td style="text-align:left">选择每个p元素的是其父级的第二个p元素，从最后一个子项计数</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:last-child</td><td style="text-align:left">p:last-child</td><td style="text-align:left">选择每个p元素是其父级的最后一个子级。</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:root</td><td style="text-align:left">:root</td><td style="text-align:left">选择文档的根元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:empty</td><td style="text-align:left">p:empty</td><td style="text-align:left">选择每个没有任何子级的p元素（包括文本节点）</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:target</td><td style="text-align:left">#news:target</td><td style="text-align:left">选择当前活动的#news元素（包含该锚名称的点击的URL）</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:enabled</td><td style="text-align:left">input:enabled</td><td style="text-align:left">选择每一个已启用的输入元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:disabled</td><td style="text-align:left">input:disabled</td><td style="text-align:left">选择每一个禁用的输入元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:checked</td><td style="text-align:left">input:checked</td><td style="text-align:left">选择每个选中的输入元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:not(<em>selector</em>)</td><td style="text-align:left">:not(p)</td><td style="text-align:left">选择每个并非p元素的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">::selection</td><td style="text-align:left">::selection</td><td style="text-align:left">匹配元素中被用户选中或处于高亮状态的部分</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:out-of-range</td><td style="text-align:left">:out-of-range</td><td style="text-align:left">匹配值在指定区间之外的input元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:in-range</td><td style="text-align:left">:in-range</td><td style="text-align:left">匹配值在指定区间之内的input元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:read-write</td><td style="text-align:left">:read-write</td><td style="text-align:left">用于匹配可读及可写的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:read-only</td><td style="text-align:left">:read-only</td><td style="text-align:left">用于匹配设置 “readonly”（只读） 属性的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:optional</td><td style="text-align:left">:optional</td><td style="text-align:left">用于匹配可选的输入元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:required</td><td style="text-align:left">:required</td><td style="text-align:left">用于匹配设置了 “required” 属性的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:valid</td><td style="text-align:left">:valid</td><td style="text-align:left">用于匹配输入值为合法的元素</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">:invalid</td><td style="text-align:left">:invalid</td><td style="text-align:left">用于匹配输入值为非法的元素</td><td style="text-align:left">3</td></tr></tbody></table><h3 id="在页面插入内容"><a href="#在页面插入内容" class="headerlink" title="在页面插入内容"></a>在页面插入内容</h3><p><code>:before</code>或者 <code>:after</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 插入文字 */</span></span><br><span class="line"><span class="comment">/* 在h2前 */</span></span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">'哈哈哈'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在h2后 */</span></span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="string">'内容'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 指定个别元素不进行插入 */</span></span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-class">.sample</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 插入图像 */</span></span><br><span class="line"><span class="comment">/* 在h2前 */</span></span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:bofore</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="built_in">url</span>(mark.png);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 在h2后 */</span></span><br><span class="line"><span class="selector-tag">h2</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="built_in">url</span>(mark.png);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 将元素属性作为content的值来显示 */</span></span><br><span class="line"><span class="selector-tag">img</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">context</span>:<span class="built_in">attr</span>(alt);</span><br><span class="line">    <span class="attribute">display</span>:block;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">    <span class="attribute">margin-top</span>:<span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>content</code>插入项目编号</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>大标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>实例文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>大标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>实例文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*多个标题加上连续编号*/</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="built_in">counter</span>(mycounter)</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line"><span class="attribute">counter-increment</span>:mycounter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*追加文字*/</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">'第'</span><span class="built_in">counter</span>(mycounter)<span class="string">'章'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line"><span class="attribute">counter-increment</span>:mycounter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 指定样式 */</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">'第'</span><span class="built_in">counter</span>(mycounter)<span class="string">'章'</span>;</span><br><span class="line"><span class="attribute">color</span>:blue;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">42px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span>&#123;</span><br><span class="line"><span class="attribute">counter-increment</span>:mycounter;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 指定编号种类 list-style-type的值*/</span></span><br><span class="line"><span class="comment">/* content(计数器名，编号种类)*/</span></span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">:before</span>&#123;</span><br><span class="line"><span class="attribute">content</span>:<span class="string">'第'</span><span class="built_in">counter</span>(mycounter,lower-roman)<span class="string">'章'</span>;</span><br><span class="line"><span class="attribute">color</span>:blue;</span><br><span class="line"><span class="attribute">font-size</span>:<span class="number">42px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 编号嵌套 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">:bofore</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>:<span class="built_in">counter</span>(mycounter2,lower-roman);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">counter-increment</span>:mycounter2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list-style-type 的值</p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">none</td><td style="text-align:left">无标记。</td></tr><tr><td style="text-align:left">disc</td><td style="text-align:left">默认。标记是实心圆。</td></tr><tr><td style="text-align:left">circle</td><td style="text-align:left">标记是空心圆。</td></tr><tr><td style="text-align:left">square</td><td style="text-align:left">标记是实心方块。</td></tr><tr><td style="text-align:left">decimal</td><td style="text-align:left">标记是数字。</td></tr><tr><td style="text-align:left">decimal-leading-zero</td><td style="text-align:left">0开头的数字标记。(01, 02, 03, 等。)</td></tr><tr><td style="text-align:left">lower-roman</td><td style="text-align:left">小写罗马数字(i, ii, iii, iv, v, 等。)</td></tr><tr><td style="text-align:left">upper-roman</td><td style="text-align:left">大写罗马数字(I, II, III, IV, V, 等。)</td></tr><tr><td style="text-align:left">lower-alpha</td><td style="text-align:left">小写英文字母The marker is lower-alpha (a, b, c, d, e, 等。)</td></tr><tr><td style="text-align:left">upper-alpha</td><td style="text-align:left">大写英文字母The marker is upper-alpha (A, B, C, D, E, 等。)</td></tr><tr><td style="text-align:left">lower-greek</td><td style="text-align:left">小写希腊字母(alpha, beta, gamma, 等。)</td></tr><tr><td style="text-align:left">lower-latin</td><td style="text-align:left">小写拉丁字母(a, b, c, d, e, 等。)</td></tr><tr><td style="text-align:left">upper-latin</td><td style="text-align:left">大写拉丁字母(A, B, C, D, E, 等。)</td></tr><tr><td style="text-align:left">hebrew</td><td style="text-align:left">传统的希伯来编号方式</td></tr><tr><td style="text-align:left">armenian</td><td style="text-align:left">传统的亚美尼亚编号方式</td></tr><tr><td style="text-align:left">georgian</td><td style="text-align:left">传统的乔治亚编号方式(an, ban, gan, 等。)</td></tr><tr><td style="text-align:left">cjk-ideographic</td><td style="text-align:left">简单的表意数字</td></tr><tr><td style="text-align:left">hiragana</td><td style="text-align:left">标记是：a, i, u, e, o, ka, ki, 等。（日文片假名）</td></tr><tr><td style="text-align:left">katakana</td><td style="text-align:left">标记是：A, I, U, E, O, KA, KI, 等。（日文片假名）</td></tr><tr><td style="text-align:left">hiragana-iroha</td><td style="text-align:left">标记是：i, ro, ha, ni, ho, he, to, 等。（日文片假名）</td></tr><tr><td style="text-align:left">katakana-iroha</td><td style="text-align:left">标记是：I, RO, HA, NI, HO, HE, TO, 等。（日文片假名）</td></tr></tbody></table><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://www.cnblogs.com/ihardcoder/p/5294927.html">CSS3伪类和伪元素的特性和区别</a></li><li><a href="https://read.douban.com/ebook/15160963/">HTML 5与CSS 3权威指南</a></li><li><a href="https://www.w3cschool.cn/html/">W3cScholl</a></li><li><a href="https://www.cnblogs.com/dreamingbaobei/p/5062998.html">CSS3新增的选择器和属性</a></li><li><a href="https://www.cnblogs.com/wangzhenling/p/8824093.html">神奇的css3（1）新增属性、选择器</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CSS3&quot;&gt;&lt;a href=&quot;#CSS3&quot; class=&quot;headerlink&quot; title=&quot;CSS3&quot;&gt;&lt;/a&gt;CSS3&lt;/h2&gt;&lt;p&gt;发展历史&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=
      
    
    </summary>
    
      <category term="前端面试" scheme="http://laibh.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="HTML5" scheme="http://laibh.top/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>面试官问我HTML5是什么（中）</title>
    <link href="http://laibh.top/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91HTML5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%AD%EF%BC%89.html"/>
    <id>http://laibh.top/面试官问我HTML5是什么（中）.html</id>
    <published>2019-05-25T01:30:54.000Z</published>
    <updated>2019-10-15T09:29:49.423Z</updated>
    
    <content type="html"><![CDATA[<p>学习链接：<br><a href="https://read.douban.com/ebook/15160963/">HTML 5与CSS 3权威指南</a></p><p><a href="https://www.w3cschool.cn/html/">W3cScholl</a></p><h2 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h2><p>HTML5 中的一个新增元素，可以在页面绘制出各种漂亮的图形与图像。</p><h3 id="绘制图形"><a href="#绘制图形" class="headerlink" title="绘制图形"></a>绘制图形</h3><p>canvas 元素就是 HTML5 中新增的一个用来绘制图形。在页面上放置一个 <code>canvas</code>元素，相当于在页面上放置一块画布，可以在其中进行图形绘制。</p><h3 id="在页面中放置-canvas元素"><a href="#在页面中放置-canvas元素" class="headerlink" title="在页面中放置 canvas元素"></a>在页面中放置 canvas元素</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Canvas<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"draw('canvas')"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"canvas"</span> <span class="attr">width</span>=<span class="string">"400"</span> <span class="attr">height</span>=<span class="string">"300"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"canvas.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--script--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">id</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span></span><br><span class="line"><span class="javascript">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span></span><br><span class="line"><span class="undefined">  context.fillRect(0, 0, 400, 300);</span></span><br><span class="line"><span class="javascript">  context.fillStyle = <span class="string">'red'</span>;</span></span><br><span class="line"><span class="javascript">  context.strokeStyle = <span class="string">'blue'</span>;</span></span><br><span class="line"><span class="undefined">  context.lineWidth = 1;</span></span><br><span class="line"><span class="undefined">  context.fillRect(50,50,100,100);</span></span><br><span class="line"><span class="undefined">  context.strokeRect(50,50,100,100);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>首先，要指定 ID,width,height 这三个属性。</p><h4 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h4><ol><li>取得 canvas 元素，用 DOM 方法取得要绘制的目标元素</li><li>取得上下文（context）。进行绘制的时候需要用到图形上下文（graphics context），图形上下文是一个封装了很多绘图功能的对象。使用 canvas 对象的 <code>getContext</code>方法来获得图形上下文。</li><li>填充与绘制边框。绘制图形的时候有两种方式：填充（fill）与绘制边框（stroke）。填充是指填充图形内部，绘制边框是指不填充图形内部，值绘制图形的外框。</li><li>设定绘图样式（style）。在进行图形绘制的时候，要设定好绘图的样式，然后调用相关的方法进行图形绘制。相关的属性有 fillStyle(填充图形的样式)，strokeStyle(图形边框的样式)</li><li>指定线宽。使用图形上下文对象的 lineWidth 属性设置图形边框的宽度。</li><li>指定颜色值。颜色名，或者十六进制的颜色值</li><li>分别使用 fillRect 与 strokeRect 方法来填充矩形和绘制矩形边框。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.fillRect(x,y,width,height);</span><br><span class="line">context.strokeRect(x,y,width,height);</span><br></pre></td></tr></table></figure><p>还有一个 clearRect 方法，擦除指定矩形区域中的图形，使得矩形中的颜色全部变成透明。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.clearRect(x,y,width,height);</span><br></pre></td></tr></table></figure><h3 id="使用路径"><a href="#使用路径" class="headerlink" title="使用路径"></a>使用路径</h3><h4 id="绘制圆形"><a href="#绘制圆形" class="headerlink" title="绘制圆形"></a>绘制圆形</h4><p>使用路径绘制图形的过程：</p><ol><li>开始创建路径</li><li>创建图形的路径</li><li>路径创建完成后，关闭路径</li><li>设定绘制样式，调用绘制方法，绘制路径</li></ol><p>大概的意思就是，先用路径勾勒图形轮廓，然后设置颜色，进行绘制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawCircle</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.arc(i * <span class="number">25</span>, i * <span class="number">25</span>, i * <span class="number">10</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>)</span><br><span class="line">    context.closePath();</span><br><span class="line">    context.fillStyle = <span class="string">'rgba(255,0,0,0.25)'</span>;</span><br><span class="line">    context.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>context.arc(x,y,radius,startAngle,endAngle,anticlockwise)</code></p><p>这个方法使用了六个参数，<code>x</code>为绘制圆形的横坐标，<code>y</code>为纵坐标，<code>radius</code>为圆形半径，<code>startAngle</code>为开始的角度，<code>endAngle</code>为结束角度，<code>anticlockwise</code>为是否按顺时针方向进行绘制。</p><p>关于角度与弧度的计算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> radius = degress * <span class="built_in">Math</span>.PI / <span class="number">180</span>;</span><br></pre></td></tr></table></figure><p><code>arc</code>方法不仅可以用阿里绘制圆形，也可以用来绘制圆弧。因此，使用时必须要指定开始角度与结束角度。因为这两个角度决定了弧度。<code>anticlockwise</code>为一个布尔值的参数，参数为 true 时，按顺时针绘制，参数为 false时，按逆时针绘制。</p><p>绘制完图形后，使用 <code>context.closePath()</code>将路径关闭，接着就可以使用 <code>fill</code>方法（<code>stroke</code>）填充图形与绘制图形边框了。</p><h4 id="不关闭路径"><a href="#不关闭路径" class="headerlink" title="不关闭路径"></a>不关闭路径</h4><p>如果不关闭路径，已经创建的路径会被永远保留，使用 fill 或者 stroke 绘制的时候会重复绘制已存在的路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawCircle</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    context.arc(i * <span class="number">25</span>, i * <span class="number">25</span>, i * <span class="number">10</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>)</span><br><span class="line">    context.fillStyle = <span class="string">'rgba(255,0,0,0.25)'</span>;</span><br><span class="line">    context.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="绘制线"><a href="#绘制线" class="headerlink" title="绘制线"></a>绘制线</h4><p><strong>moveTo 与 lineTo</strong></p><p>moveTo 方法的作用是将光标移动到指定坐标，绘制直线的时候以这个坐标点为起点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moveTo(x,y)</span><br></pre></td></tr></table></figure><p>lineTo方法，也是用两个参数，x ，y表示直线终点的横纵坐标。使用该方法绘制直线后，光标会自动移动到 lineTo 方法参数所指定的直线终点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawLine</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">let</span> dx = <span class="number">150</span>;</span><br><span class="line">  <span class="keyword">let</span> dy = <span class="number">150</span>;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="number">100</span>;</span><br><span class="line">  context.beginPath();</span><br><span class="line">  context.fillStyle = <span class="string">'rgb(100,255,100)'</span>;</span><br><span class="line">  context.strokeStyle = <span class="string">'rgb(0,0,100)'</span>;</span><br><span class="line">  <span class="keyword">let</span> dig = <span class="built_in">Math</span>.PI / <span class="number">15</span> * <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">Math</span>.sin(i * dig);</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Math</span>.cos(i * dig);</span><br><span class="line">    context.lineTo(dx + x * s, dy + y * s);</span><br><span class="line">  &#125;</span><br><span class="line">  context.closePath()</span><br><span class="line">  context.fill();</span><br><span class="line">  context.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用-bezierCurveTo-绘制贝塞尔曲线"><a href="#使用-bezierCurveTo-绘制贝塞尔曲线" class="headerlink" title="使用 bezierCurveTo 绘制贝塞尔曲线"></a>使用 bezierCurveTo 绘制贝塞尔曲线</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.bezierCurveTo(cp1x,cp1y,cp2x,cpy2y,x,y);</span><br></pre></td></tr></table></figure><p>绘制曲线，需要两个控制点以及一点终点。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawBezierLine</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">let</span> dx = <span class="number">150</span>;</span><br><span class="line">  <span class="keyword">let</span> dy = <span class="number">150</span>;</span><br><span class="line">  <span class="keyword">let</span> s = <span class="number">100</span>;</span><br><span class="line">  context.beginPath();</span><br><span class="line">  context.fillStyle = <span class="string">'rgb(100,255,100)'</span>;</span><br><span class="line">  context.strokeStyle = <span class="string">'rgb(0,0,100)'</span>;</span><br><span class="line">  <span class="keyword">let</span> dig = <span class="built_in">Math</span>.PI / <span class="number">15</span> * <span class="number">11</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">Math</span>.sin(i * dig);</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Math</span>.cos(i * dig);</span><br><span class="line">    context.bezierCurveTo(dx + x * s, dy + y * s - <span class="number">100</span>, dx + x * s + <span class="number">100</span>, dy + y * s, dx + x * s, dy + y * s);</span><br><span class="line">  &#125;</span><br><span class="line">  context.closePath()</span><br><span class="line">  context.fill();</span><br><span class="line">  context.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>quadraticCurveTo</code>方法绘制二次贝塞尔曲线</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.quadraticCurveTo(cpx,cpy,x,y)</span><br></pre></td></tr></table></figure><h3 id="绘制渐变图形"><a href="#绘制渐变图形" class="headerlink" title="绘制渐变图形"></a>绘制渐变图形</h3><h4 id="绘制线性渐变"><a href="#绘制线性渐变" class="headerlink" title="绘制线性渐变"></a>绘制线性渐变</h4><p>绘制线性渐变需要用到 <code>lineargradient</code>对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.createLinearGradient(xStart,yStart,xEnd,yEnd);</span><br></pre></td></tr></table></figure><p>接着使用 addColorStop 方法设定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.addColorStop(offset,color);</span><br></pre></td></tr></table></figure><p>offset 为所设定的颜色离开渐变起始点的偏移量。参数的值是0到1之间的浮点值，渐变起始点的偏移量是0，渐变结束点的偏移量是1.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawLineGradient</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  <span class="keyword">const</span> gl = context.createLinearGradient(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>);</span><br><span class="line">  gl.addColorStop(<span class="number">0</span>, <span class="string">'rgb(255,255,0)'</span>);</span><br><span class="line">  gl.addColorStop(<span class="number">1</span>, <span class="string">'rgb(0,255,255)'</span>);</span><br><span class="line">  context.fillStyle = gl;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">const</span> g2 = context.createLinearGradient(<span class="number">0</span>, <span class="number">0</span>, <span class="number">300</span>, <span class="number">0</span>);</span><br><span class="line">  g2.addColorStop(<span class="number">0</span>, <span class="string">'rgba(0,0,255,0.5)'</span>);</span><br><span class="line">  g2.addColorStop(<span class="number">0</span>, <span class="string">'rgba(255,0,0,0.5)'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.fillStyle = g2;</span><br><span class="line">    context.arc(i * <span class="number">25</span>, i * <span class="number">25</span>, i * <span class="number">10</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">    context.closePath();</span><br><span class="line">    context.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="绘制径向渐变"><a href="#绘制径向渐变" class="headerlink" title="绘制径向渐变"></a>绘制径向渐变</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.createRadialGradient(xStart,yStart,radiusStart,xEnd,yEnd,radiusEnd);</span><br></pre></td></tr></table></figure><p>分别指定两个圆的大小和位置。从第一个圆的圆心处向外进行扩散渐变，一直扩散到第二个圆的外轮廓处。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawRadialGradient</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  <span class="keyword">const</span> g1 = context.createRadialGradient(<span class="number">400</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">0</span>, <span class="number">400</span>);</span><br><span class="line">  g1.addColorStop(<span class="number">0.1</span>, <span class="string">'rgb(255,255,0)'</span>);</span><br><span class="line">  g1.addColorStop(<span class="number">0.3</span>, <span class="string">'rgb(255,0,255)'</span>);</span><br><span class="line">  g1.addColorStop(<span class="number">1</span>, <span class="string">'rgb(0,255,255)'</span>);</span><br><span class="line">  context.fillStyle = g1;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">const</span> g2 = context.createRadialGradient(<span class="number">250</span>, <span class="number">250</span>, <span class="number">0</span>, <span class="number">250</span>, <span class="number">250</span>, <span class="number">300</span>);</span><br><span class="line">  g2.addColorStop(<span class="number">0.1</span>, <span class="string">'rgb(255,0,0,0.5)'</span>);</span><br><span class="line">  g2.addColorStop(<span class="number">0.7</span>, <span class="string">'rgb(255,255,0,0.5)'</span>);</span><br><span class="line">  g2.addColorStop(<span class="number">1</span>, <span class="string">'rgb(0,0,255,0.5)'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.fillStyle = g2;</span><br><span class="line">    context.arc(i * <span class="number">25</span>, i * <span class="number">25</span>, i * <span class="number">10</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>, <span class="literal">true</span>);</span><br><span class="line">    context.closePath();</span><br><span class="line">    context.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制变形图形"><a href="#绘制变形图形" class="headerlink" title="绘制变形图形"></a>绘制变形图形</h3><h4 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h4><p>主要有三种形式：</p><ul><li>平移，使用图形上下文的 <code>translate</code>方法来移动图形坐标轴原点。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.translate(x,y);</span><br></pre></td></tr></table></figure><ul><li>扩大，使用对象的 <code>scale</code>方法将图形放大</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.scale(x,y)</span><br></pre></td></tr></table></figure><ul><li>旋转，使用 <code>rotate</code>方法将图形进行旋转</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.rotate(angle);</span><br></pre></td></tr></table></figure><p>旋转中西是坐标轴的原点，顺时针方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawDeformationGraphics</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">   <span class="comment">// 改变圆心位置</span></span><br><span class="line">  context.translate(<span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'rgba(255,0,0,0.25)'</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    context.translate(<span class="number">25</span>, <span class="number">25</span>);</span><br><span class="line">    context.scale(<span class="number">0.95</span>, <span class="number">0.95</span>);</span><br><span class="line">    context.rotate(<span class="built_in">Math</span>.PI / <span class="number">10</span>);</span><br><span class="line">    context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">50</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码使用坐标变换的方法。首先绘制了一个长方形，然后在一个循环中反复使用平移坐标轴，图形缩小，图形旋转三种技巧绘制出来变形图形。</p><h4 id="与路径结合使用"><a href="#与路径结合使用" class="headerlink" title="与路径结合使用"></a>与路径结合使用</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawDeformationGraphicsWithFivePointedStar</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  context.translate(<span class="number">200</span>, <span class="number">50</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'rgba(255,0,0,0.25)'</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">    context.translate(<span class="number">25</span>, <span class="number">25</span>);</span><br><span class="line">    context.scale(<span class="number">0.95</span>, <span class="number">0.95</span>);</span><br><span class="line">    context.rotate(<span class="built_in">Math</span>.PI / <span class="number">10</span>);</span><br><span class="line">    createFivePointedStar(context);</span><br><span class="line">    context.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFivePointedStar</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.beginPath();</span><br><span class="line">  context.fillStyle = <span class="string">'rgba(255,0,0,0.5)'</span>;</span><br><span class="line">  <span class="keyword">const</span> dx = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">const</span> dy = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> s = <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">let</span> dig = <span class="built_in">Math</span>.PI / <span class="number">5</span> * <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">Math</span>.sin(i * dig);</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Math</span>.cos(i * dig);</span><br><span class="line">    context.lineTo(dx + x * s, dy + y * s);</span><br><span class="line">  &#125;</span><br><span class="line">  context.closePath();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="矩阵变换"><a href="#矩阵变换" class="headerlink" title="矩阵变换"></a>矩阵变换</h4><p>当图形上下文被创建完毕时，事实上也创建了一个默认的变换矩阵，如果不对这个变换矩阵进行修改，绘制的图形将以画布的最左上角为坐标原点绘制图形，绘制出来的图形也不经过缩放、变形的处理。我们可以对这个变换矩形进行修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.transform(a , b , c , d , e , f )</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><em>a</em></td><td style="text-align:left">水平缩放绘图</td></tr><tr><td style="text-align:left"><em>b</em></td><td style="text-align:left">水平倾斜绘图</td></tr><tr><td style="text-align:left"><em>c</em></td><td style="text-align:left">垂直倾斜绘图</td></tr><tr><td style="text-align:left"><em>d</em></td><td style="text-align:left">垂直缩放绘图</td></tr><tr><td style="text-align:left"><em>e</em></td><td style="text-align:left">水平移动绘图</td></tr><tr><td style="text-align:left"><em>f</em></td><td style="text-align:left">垂直移动绘图</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawTransform</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  <span class="keyword">const</span> colors = [<span class="string">'red'</span>, <span class="string">'orange'</span>, <span class="string">'yellow'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'navy'</span>, <span class="string">'purple'</span>];</span><br><span class="line">  context.lineWidth = <span class="number">10</span>;</span><br><span class="line">  context.transform(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; colors.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 定义每次向下移动 10个像素的变换矩阵</span></span><br><span class="line">    context.transform(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    context.strokeStyle = colors[i];</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.arc(<span class="number">50</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI, <span class="literal">true</span>);</span><br><span class="line">    context.stroke();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>setTransform 会将变换矩阵重置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setTransform(m11,m12,m21,m22,dx,dy)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawSetTransform</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.strokeStyle = <span class="string">'red'</span>;</span><br><span class="line">  context.strokeRect(<span class="number">30</span>, <span class="number">10</span>, <span class="number">60</span>, <span class="number">20</span>);</span><br><span class="line">  <span class="keyword">let</span> rad = <span class="number">45</span> * <span class="built_in">Math</span>.PI / <span class="number">180</span>;</span><br><span class="line"></span><br><span class="line">  context.setTransform(<span class="built_in">Math</span>.cos(rad), <span class="built_in">Math</span>.sin(rad), -<span class="built_in">Math</span>.sin(rad), <span class="built_in">Math</span>.cos(rad), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  context.strokeStyle = <span class="string">'blue'</span>;</span><br><span class="line">  context.strokeRect(<span class="number">30</span>, <span class="number">10</span>, <span class="number">60</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  context.setTransform(<span class="number">2.5</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">2.5</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  context.strokeStyle = <span class="string">'green'</span>;</span><br><span class="line">  context.strokeRect(<span class="number">30</span>, <span class="number">10</span>, <span class="number">60</span>, <span class="number">20</span>);</span><br><span class="line">  </span><br><span class="line">  context.setTransform(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">40</span>, <span class="number">80</span>);</span><br><span class="line">  context.strokeStyle = <span class="string">'gray'</span>;</span><br><span class="line">  context.strokeRect(<span class="number">30</span>, <span class="number">10</span>, <span class="number">60</span>, <span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图形组合"><a href="#图形组合" class="headerlink" title="图形组合"></a>图形组合</h3><p>设定图形上下文对象的 <code>globalCompositeOperation</code>属性能自己决定图形的组合方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.globalCompositeOperation = type</span><br></pre></td></tr></table></figure><p>type 的值必须是下面几种字符串之一：</p><ul><li><p>source-over(默认值)</p><p>表示新图形覆盖杂原有图形上</p></li><li><p>destination-over</p><p>表示在原有图形之下绘制新图形</p></li><li><p>source-in</p><p>新图形与原有图形作 in 运算，只显示新图形中与原有图像相互重叠的部分，新图形与原有图形的其他部分均变成透明</p></li><li><p>destination-in</p><p>原有图形与新图形作 in 运算，只显示原有图形中与新图形相重叠的部分，新图形与原有图形的其他部分均变成透明</p></li><li><p>source-out</p><p>新图形与原有图形 out 运算。只显示新图形中与原有图形不重叠的部分，新图形与原有图形的其他部分变成透明</p></li><li><p>destination-out</p><p>新图形与原有图形 out 运算。只显示原有图形中与新图形不重叠的部分，原有图形与新图形的其他部分变成透明</p></li><li><p>source-atop</p><p>只绘制新图形中与原有图形重叠的部分与未被重叠覆盖的原有图形，新图形的其他部分变成透明</p></li><li><p>destination-atop</p><p>只绘制原有图形中被新图形重叠覆盖的部分与新图形的其他部分，原有图形中的其他部分变成透明，不绘制新图形中与原有图形相重叠的部分</p></li><li><p>lighter</p><p>原有图形与新图形均绘制，重叠部分做加色处理</p></li><li><p>xor</p><p>只绘制新图形中与原有图形不重叠的部分，重叠部分变成透明</p></li><li><p>copy</p><p>只绘制新图形，原有图形中未与新图形重叠的部分变成透明</p></li></ul><h3 id="给图形绘制阴影"><a href="#给图形绘制阴影" class="headerlink" title="给图形绘制阴影"></a>给图形绘制阴影</h3><ul><li>shadowOffsetX——阴影的横线位移量</li><li>shadowOffsetY——阴影的纵向位移量</li><li>shadowColor——阴影的颜色</li><li>shadowBlur——阴影的模糊范围</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawShadowFifthStar</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  context.shadowOffsetX = <span class="number">10</span>;</span><br><span class="line">  context.shadowOffsetY = <span class="number">10</span>;</span><br><span class="line">  context.shadowColor = <span class="string">'rgba(100,100,100,0.5)'</span>;</span><br><span class="line">  context.shadowBlur = <span class="number">7.5</span>;</span><br><span class="line">  context.translate(<span class="number">0</span>, <span class="number">50</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    context.translate(<span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    createFivePointedStar(context);</span><br><span class="line">    context.fill();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用图像"><a href="#使用图像" class="headerlink" title="使用图像"></a>使用图像</h3><h4 id="绘制图像"><a href="#绘制图像" class="headerlink" title="绘制图像"></a>绘制图像</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宽高 为原图像宽高</span></span><br><span class="line">context.drawImage(image,x,y);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 增加宽高的自定义</span></span><br><span class="line">context.drawImage(image,x,y,w,h)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将画布中绘制好的图像的全部或者部分复制到画布的另一个位置上</span></span><br><span class="line">context.drawImage(image,sx,sy,sw,sh,dx,dy,dw,dh)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawCanvasImage</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>)</span><br><span class="line">  image = <span class="keyword">new</span> Image();</span><br><span class="line">  image.src = <span class="string">'../Desktop/微信图片_20190311090059.jpg'</span></span><br><span class="line">  image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    drawBigImage(context, image)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawImage</span>(<span class="params">context, image</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">    context.drawImage(image, <span class="number">0</span> + i * <span class="number">50</span>, <span class="number">0</span> + i * <span class="number">25</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawBigImage</span>(<span class="params">context, image</span>) </span>&#123;</span><br><span class="line">  context.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">  context.drawImage(image, <span class="number">23</span>, <span class="number">5</span>, <span class="number">57</span>, <span class="number">80</span>, <span class="number">110</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="图像平铺"><a href="#图像平铺" class="headerlink" title="图像平铺"></a>图像平铺</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawTileImage</span>(<span class="params">canvas, context, image</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(canvas);</span><br><span class="line">  <span class="keyword">const</span> scale = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">let</span> n1 = image.width / scale;</span><br><span class="line">  <span class="keyword">let</span> n2 = image.height / scale;</span><br><span class="line">  <span class="keyword">let</span> n3 = canvas.width / n1;</span><br><span class="line">  <span class="keyword">let</span> n4 = canvas.height / n2;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; n3; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; n4; j++) &#123;</span><br><span class="line">      context.drawImage(image, i * n1, j * n2, n1, n2);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面使用变量和循环来实现图像平铺。还可以用更简便的图形上下文的 <code>createPattern</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.createPattern(image,type)</span><br></pre></td></tr></table></figure><p>image 参数为要平铺的图像，type 参数：</p><ul><li>no-repeat：不平铺</li><li>repeat-x：横方向平铺</li><li>repeat-y：纵方向平铺</li><li>repeat：全方向平铺</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawCanvasImage</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'#EEEEFF'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>)</span><br><span class="line">  image = <span class="keyword">new</span> Image();</span><br><span class="line">  image.src = <span class="string">'../Desktop/微信图片_20190311090059.jpg'</span>;</span><br><span class="line">  image.width = <span class="number">10</span>;</span><br><span class="line">  image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> canvasTemp = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">    <span class="keyword">const</span> contextTemp = canvasTemp.getContext(<span class="string">'2d'</span>);</span><br><span class="line">    canvasTemp.width = <span class="number">100</span>;</span><br><span class="line">    canvasTemp.height = <span class="number">100</span>;</span><br><span class="line">    contextTemp.drawImage(<span class="keyword">this</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">let</span> ptrn = context.createPattern(canvasTemp,<span class="string">'repeat'</span>);</span><br><span class="line">    <span class="comment">// context.drawImage(image, 23, 5, 57, 80);</span></span><br><span class="line">    context.fillStyle = ptrn;</span><br><span class="line">    context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当图像太大的时候，可以通过把图像绘制在一个临时的 canvas 里面，然后再用主canvas 重复这个临时 canvas </p><h4 id="图像裁剪"><a href="#图像裁剪" class="headerlink" title="图像裁剪"></a>图像裁剪</h4><p>使用 clip 方法设置裁剪区域</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cutImage</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  <span class="keyword">const</span> gr = context.createLinearGradient(<span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>, <span class="number">0</span>);</span><br><span class="line">  gr.addColorStop(<span class="number">0</span>, <span class="string">'rgb(255,255,0)'</span>);</span><br><span class="line">  gr.addColorStop(<span class="number">1</span>, <span class="string">'rgb(0,255,255)'</span>);</span><br><span class="line">  context.fillStyle = gr;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  image = <span class="keyword">new</span> Image();</span><br><span class="line">  image.src = <span class="string">'../Desktop/微信图片_20190311090059.jpg'</span>;</span><br><span class="line">  image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    createFivePointedStar(context);</span><br><span class="line">    context.drawImage(image, <span class="number">-50</span>, <span class="number">-150</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFivePointedStar</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">  context.beginPath();</span><br><span class="line">  context.translate(<span class="number">100</span>,<span class="number">150</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'rgba(255,0,0,0.5)'</span>;  </span><br><span class="line">  <span class="keyword">const</span> dx = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">const</span> dy = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> s = <span class="number">50</span>;</span><br><span class="line">  <span class="keyword">let</span> dig = <span class="built_in">Math</span>.PI / <span class="number">5</span> * <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="built_in">Math</span>.sin(i * dig);</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Math</span>.cos(i * dig);</span><br><span class="line">    context.lineTo(dx + x * s, dy + y * s);</span><br><span class="line">  &#125;</span><br><span class="line">  context.closePath();</span><br><span class="line">  context.clip();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="像素处理"><a href="#像素处理" class="headerlink" title="像素处理"></a>像素处理</h4><p>使用 getImageData 方法可以获取图像中的像素,获得像素组依次 rgba 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imageData = context.getImageData(x,y,width,height);</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><em>x</em></td><td style="text-align:left">开始复制的左上角位置的 x 坐标。</td></tr><tr><td style="text-align:left"><em>y</em></td><td style="text-align:left">开始复制的左上角位置的 y 坐标。</td></tr><tr><td style="text-align:left"><em>width</em></td><td style="text-align:left">将要复制的矩形区域的宽度。</td></tr><tr><td style="text-align:left"><em>height</em></td><td style="text-align:left">将要复制的矩形区域的高度。</td></tr></tbody></table><p>对于 ImageData 对象中的每个像素，都存在着四方面的信息，即 RGBA 值：</p><ul><li>R - 红色 (0-255)</li><li>G - 绿色 (0-255)</li><li>B - 蓝色 (0-255)</li><li>A - alpha 通道 (0-255; 0 是透明的，255 是完全可见的)</li></ul><p>利用 putImageData 将图像数据放回画布,期间做一些颜色处理，可以模拟滤镜。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">image.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// createFivePointedStar(context);</span></span><br><span class="line">  context.drawImage(image, <span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">  <span class="keyword">let</span> imagedata = context.getImageData(<span class="number">0</span>, <span class="number">0</span>, image.width, image.height)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, n = imagedata.data.length; i &lt; n; i += <span class="number">4</span>) &#123;</span><br><span class="line">    imagedata.data[i + <span class="number">0</span>] = <span class="number">255</span> - imagedata.data[i + <span class="number">0</span>];</span><br><span class="line">    imagedata.data[i + <span class="number">1</span>] = <span class="number">255</span> - imagedata.data[i + <span class="number">2</span>];</span><br><span class="line">    imagedata.data[i + <span class="number">2</span>] = <span class="number">255</span> - imagedata.data[i + <span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  context.putImageData(imagedata, <span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">300</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.putImageData(imgData,x,y,dirtyX,dirtyY,dirtyWidth,dirtyHeight);</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><em>imgData</em></td><td style="text-align:left">规定要放回画布的 ImageData 对象。</td></tr><tr><td style="text-align:left"><em>x</em></td><td style="text-align:left">ImageData 对象左上角的 x 坐标，以像素计。</td></tr><tr><td style="text-align:left"><em>y</em></td><td style="text-align:left">ImageData 对象左上角的 y 坐标，以像素计。</td></tr><tr><td style="text-align:left"><em>dirtyX</em></td><td style="text-align:left">可选。水平值（x），以像素计，在画布上放置图像的位置。</td></tr><tr><td style="text-align:left"><em>dirtyY</em></td><td style="text-align:left">可选。水平值（y），以像素计，在画布上放置图像的位置。</td></tr><tr><td style="text-align:left"><em>dirtyWidth</em></td><td style="text-align:left">可选。在画布上绘制图像所使用的宽度。</td></tr><tr><td style="text-align:left"><em>dirtyHeight</em></td><td style="text-align:left">可选。在画布上绘制图像所使用的高度。</td></tr></tbody></table><h3 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h3><p>fillText 填充方式绘制字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.fillText(text,x,y,maxWidth);</span><br></pre></td></tr></table></figure><p>maxWidth，允许最大的宽度，像素单位</p><p>strokeText 用轮廓方式绘制字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.strokeText(text,x,y,maxWidth);</span><br></pre></td></tr></table></figure><p>一些关于文字绘制的属性：</p><ul><li>font：字体</li><li>textAlign：水平对齐方式，start(默认)、end、left、right、center</li><li>textBaseline：垂直对齐方式，top、hanging、middle、alphabetic(默认)、ideographic、bottom</li></ul><p>获得文字的宽度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.measureText(text)</span><br></pre></td></tr></table></figure><p>接受一个参数 text，该参数为需要绘制的文字，返回一个 TextMetrics 对象，TextMetrics对象的 width 属性表示使用当前指定的文字后  text 参数中指定的文字的总文字宽度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawText</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.font = <span class="string">'italic 20px sans-serif'</span>;</span><br><span class="line">  <span class="keyword">let</span> txt = <span class="string">'字符串的宽度为：'</span>;</span><br><span class="line">  <span class="keyword">let</span> tml = context.measureText(txt);</span><br><span class="line">  context.fillText(txt, <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">  context.fillText(tml.width, tml.width + <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">  context.font = <span class="string">'bold 30px sans-serif'</span>;</span><br><span class="line">  <span class="keyword">let</span> tm2 = context.measureText(txt);</span><br><span class="line">  context.fillText(txt, <span class="number">10</span>, <span class="number">70</span>);</span><br><span class="line">  context.fillText(tm2.width, tm2.width + <span class="number">10</span>, <span class="number">70</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="保存与恢复状态"><a href="#保存与恢复状态" class="headerlink" title="保存与恢复状态"></a>保存与恢复状态</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将当前状态保存到 栈中</span></span><br><span class="line">context.save();</span><br><span class="line"><span class="comment">// 从栈中取出之前保存的图形上下文的状态进行恢复 </span></span><br><span class="line">context.restore();</span><br></pre></td></tr></table></figure><p>绘画状态包括坐标的原点、变形时的变换矩阵，图形上下文对象的当前属性值。</p><p>可以应用在下面但不仅仅下面的场景：</p><ul><li>图像或图形变形</li><li>图像裁剪</li><li>改变图形上下文的以下属性的时候：fillStyle、font、globalAlpha、globalComposite、Operation、lineCap、lineJoin、lineWidth、miterLimit、shadowBlur、shadowColor、shadowOffsetX、shadowOffsetY、strokeStyle、textAlign、textBaseline</li></ul><h4 id="保存文件"><a href="#保存文件" class="headerlink" title="保存文件"></a>保存文件</h4><p> 原理实际上是把当前的绘画状态输出到一个 data URL 地址所指向的数据中的过程。data URL指的是目前大部分浏览器能够识别的一种 base64编码的 URL，主要用于小型的、可以在网页中直接嵌入的，而不需要从外部文件嵌入的数据，例如 img 元素中的图像文件等。</p><p>toDataURL 方法把绘画状态输出到一个 data URL中，然后重新装载，客户可以直接把装载后的文件进行保存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">canvas.toDataURL(type);</span><br><span class="line"><span class="comment">// type 表示输出输出类型的 MIME 类型</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawDataURL</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">const</span> context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  context.fillStyle = <span class="string">'rgb(0,0,255)'</span>;</span><br><span class="line">  context.fillRect(<span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">  context.fillStyle = <span class="string">'rgb(255,255,0)'</span>;</span><br><span class="line">  context.fillRect(<span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(canvas.toDataURL(<span class="string">"image/jepg"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="简单动画的制作"><a href="#简单动画的制作" class="headerlink" title="简单动画的制作"></a>简单动画的制作</h4><p>canvas 画布中制作的动画实际上就是一个不断擦除（clearRect）、重绘的过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">animationOnCanvas</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">  <span class="keyword">if</span> (!canvas) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  context = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  width = canvas.width;</span><br><span class="line">  height = canvas.height;</span><br><span class="line">  i = <span class="number">0</span>;</span><br><span class="line">  setInterval(rotate, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rotate</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  context.clearRect(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">  context.fillStyle = <span class="string">'red'</span>;</span><br><span class="line">  context.fillRect(i, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">  i += <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多媒体播放"><a href="#多媒体播放" class="headerlink" title="多媒体播放"></a>多媒体播放</h2><h3 id="关于-video-与-audio元素"><a href="#关于-video-与-audio元素" class="headerlink" title="关于 video 与 audio元素"></a>关于 video 与 audio元素</h3><p>HTML4页面中播放视频或者音频数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">classid</span>=<span class="string">"clsid:F08DF954-8592-11D1-B16A-00C0F0283628"</span> <span class="attr">id</span>=<span class="string">"Slider1"</span> <span class="attr">width</span>=<span class="string">"100"</span> <span class="attr">height</span>=<span class="string">"50"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"BorderStyle"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"MousePointer"</span> <span class="attr">value</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Enabled"</span> <span class="attr">value</span>=<span class="string">"1"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Min"</span> <span class="attr">value</span>=<span class="string">"0"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"Max"</span> <span class="attr">value</span>=<span class="string">"10"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"allowFullScreen"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"allowscriptaccess"</span> <span class="attr">value</span>=<span class="string">"always"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">embed</span> <span class="attr">type</span>=<span class="string">"application/x-shockwave-flash"</span> <span class="attr">width</span>=<span class="string">"425"</span> <span class="attr">height</span>=<span class="string">"344"</span> <span class="attr">src</span>=<span class="string">"p.swf"</span> <span class="attr">allowscriptaccess</span>=<span class="string">"always"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">allowfullscreen</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出上面代码的一些缺点：冗长，需要使用 Flash 插件，用户没有安装的话，则视频看不了。需要结合多个元素，并且需要添加很多属性。</p><p>HTML5 中的则是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">'xxx.mp3'</span>&gt;</span></span><br><span class="line">    您的浏览器器不支持 audio 元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">"640"</span> <span class="attr">height</span>=<span class="string">"360"</span> <span class="attr">src</span>=<span class="string">'xxx.mp4'</span>&gt;</span></span><br><span class="line">    您的浏览器器不支持 video 元素</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--结合 source元素为同一个媒体数据指定多个播放格式与编码方式，浏览器会从中找到一种自己支持的播放格式来播放 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"sample.ogv"</span> <span class="attr">type</span>=<span class="string">"video/ogg"</span>;<span class="attr">codecs</span>=<span class="string">"theora,vorbis"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"sample.mov"</span> <span class="attr">type</span>=<span class="string">"video/quicktime"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--type指播放媒体的MIME类型，codes表示媒体的编码格式--&gt;</span></span><br></pre></td></tr></table></figure><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li><p>src</p><p>指定媒体数据的 URL 地址</p></li><li><p>autoplay</p><p>指定媒体是否在页面加载后自动播放</p></li><li><p>preload</p><p>指定数据是否预加载。预加载浏览器会预先将视频或者音频数据缓冲，加快播放速度，因为播放时数据已经缓冲完毕。该属性有 none（不进行预加载）、metadata（只预加载媒体的元数据：媒体字节数、第一帧、播放列表、持续时间等）、auto(默认，表示预加载全部视频或者音频)。</p></li><li><p>poster(video独有)</p><p>当视频不可用的时候，可以使用该元素向用户展示一副替代用的图片。用户体验良好</p></li><li><p>loop</p><p>循环播放</p></li><li><p>controls</p><p>添加浏览器自带的播放用的控制条，具有播放、暂停等按钮。</p></li><li><p>width 与 height（video独有）</p><p>该属性中指定视频的宽度和高度（像素）</p></li><li><p>error</p><p>读取使用媒体数据的过程中出错的话，返回一个 MediaError对象，该对象的code返回对应的错误状态，有4个值</p><p>MEDIA_ERR_ABORTED(数字值为1)：媒体数据的下载过程由于用户操作的原因而被中止</p><p>MEDIA_ERR_NETWORK(数字值为2)：确认媒体资源可用，但是在下载时出现网络错误，媒体数据的下载过程被中止</p><p>MEDIA_ERR_DECODE(数字值为3)：确认媒体资源可用，但是解码时发生错误。</p><p>MEDIA_ERR_SRC_NOT_SUPPORTED(数字值为4)：媒体资源不可用媒体格式不被支持，error属性为只读属性</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> video = <span class="built_in">document</span>.getElementById(<span class="string">'video element'</span>);</span><br><span class="line">video.addEventListener(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; error &#125; = video;</span><br><span class="line">  <span class="keyword">switch</span> (error.code) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'视频的下载过程被中止'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'网络发生故障，视频的下载过程被中止'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'解码失败'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'不支持的播放格式'</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'无'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><ul><li>networkState,4个可能值<ul><li>NETWORK_EMPTY(数字值为0)：音频/视频尚未初始化</li><li>NETWORK_IDLE(1)：音频/视频是活动的且已选取资源，但并未使用网络</li><li>NETWORK_LOADING(2)：浏览器正在下载数据</li><li>NETWORK_NO_SOURCE(3)：未找到音频/视频来源</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">video.addEventListener(<span class="string">'progress'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; networkState &#125; = video;</span><br><span class="line">  <span class="keyword">if</span> (networkState === <span class="number">2</span>) &#123;</span><br><span class="line">    x.innerHTML = <span class="string">`加载中...[<span class="subst">$&#123;e.loaded&#125;</span>/<span class="subst">$&#123;e.total&#125;</span> byte]`</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (networkState === <span class="number">3</span>) &#123;</span><br><span class="line">    x.innerHTML = <span class="string">'记载失败'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><ul><li><p>currentSrc</p><p>读取播放中的媒体数据的 URL地址，为只读属性</p></li><li><p>buffered（只读）</p><p>buffered 属性返回 TimeRanges 对象。该对象表示用户的音视频缓冲范围，缓冲范围指的是已缓冲音视频的时间范围。如果用户在音频中跳跃播放，会得到多个缓冲范围。</p></li></ul><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">audio|video.buffered</span><br></pre></td></tr></table></figure><p>返回值</p><table><thead><tr><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">TimeRanges 对象</td><td style="text-align:left">表示音视频的已缓冲部分。TimeRanges 对象属性：length - 获得音视频中已缓冲范围的数量<br>start(index) - 获得某个已缓冲范围的开始位置<br/>end(index) - 获得某个已缓冲范围的结束位置<br/><strong>注释：</strong>首个缓冲范围的下表是 0。</td></tr></tbody></table><ul><li><p>readyState（只读）</p><p>返回媒体当前的播放位置的就绪状态值：</p><p>HAVE_NOTHING(0)：没有获取到媒体的任何信息，当前的播放位置没有可播放数据</p><p>HAVE_METADATA(1)：已经获取到足够的媒体数据，但是当前播放位置没有有效的媒体数据（获取到的媒体数据无效）</p><p>HAVE_CURRENT_DATA(2)：当前播放位置已经有数据可以播放，但没有获取到可以让播放器前进的数据。当媒体为视频，即当前帧的数据已经获得，也获得了下一帧大数据，或者当前帧已经是最后一帧</p><p>HAVE_FUTURE_DATA(3)：当前播放位置已经有数据可以播放，而且也获得到了可以让播放器前进的数据。当媒体为视频时，即当前帧的数据已经获得，而且也获得了下一帧的数据，当前帧是播放的最后一帧时，readyState 属性不可能为 HAVE_FUTURE_DATA</p><p>HAVE_ENOUGH_DATA(4)：当前播放位置已经有数据可以播放，同时也获得了可以让播放器前进的数据，而且浏览器确认媒体数据以某一种速度可以加载，可以保证有足够的后续数据进行播放。</p></li><li><p>seeking属性与seekable（只读）</p><p>seeking属性返回一个布尔值，表示浏览器是否正在请求某一特定播放为孩子的数据，true表示浏览器正在请求数据，false表示浏览器正在停止请求。</p><p>seekable返回一个 TimeRanges对象，该对象表示请求到的数据的时间范围。当媒体为视频时，开始时间为请求到视频数据第一帧的时间结束为请求到视频数据最后一帧的时间。</p></li><li><p>currentTime（可读写）/startTime（只读）/duration（只读）</p><p>currentTime获取当前播放位置，也可以通过修改currentTime来修改当前播放位置。如果修改的位置上没有可用的媒体数据时，将抛出 INVALID_STATE_ERR 异常。如果修改的位置超出了浏览器在一次请求中可以请求的数据范围，将抛出 INDEX_SIZE_ERR  异常。</p><p>startTime 来读取媒体播放的开始时间，通常为0</p><p>duration 读取媒体文件总的播放时间</p><p>三者单位均为秒</p></li><li><p>played/paused/ended（均为只读）</p><p>played 返回一个 TimeRanges 对象，从该对象中可以去读媒体文件的以播放部分的时间段。开始时间为已播放部分的开始时间，结束时间为已播放部分的结束时间。</p><p>paused 返回一个布尔值，表示是否处于暂停播放中，true 表示媒体暂停播放，false 表示媒体正在播放</p><p>end 返回一个布尔值，表示是否播放完毕，true表示播放完毕，false表示还没有播放完毕</p></li><li><p>defaultPlaybackRate/playbackRate</p><p>前者读取或者修改默认的播放速率，后者可以读取修改当前的播放速率</p></li><li><p>volume与 muted</p><p>Volume 读取或者修改媒体的播放音量，范围为0到1。0为静音，1为最大音量</p><p>muted读取或者修改媒体的静音状态，布尔值。true表示静音状态，false表示非静音状态</p></li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>video与 audio都有以下四种方法：</p><ul><li>play。播放媒体，将 paused变为 false</li><li>pause。暂停媒体，将 paused 变为 true</li><li>load。重新载入媒体进行播放，将 playbackRate变为 defaultPlaybackRate，error变为 null</li><li>canPlayType。来测试浏览器是否支持指定的媒体类型。<code>support = videoElement.canPlayType(type)</code>。该方法使用一个参数type，该参数的指定方法与 source元素的type参数的指定方法相同，都用播放文件的 MIME 类型来指定，可以在指定的字符串中加上表示媒体编码格式的 codes参数。该方法返回3个可能值：<ul><li>空字符串：表示浏览器不支持此种媒体类型</li><li>maybe：表示浏览器可能支持此种媒体类型</li><li>probably：表示浏览器确定支持此种媒体类型</li></ul></li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件处理方式分为两种：</p><ul><li>addEventListener</li><li>获取事件句柄的方式</li></ul><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>loadstart</td><td>浏览器开始在网上寻找媒体数据</td></tr><tr><td>progress</td><td>浏览器正在获取媒体数据</td></tr><tr><td>suspend</td><td>浏览器暂停获取媒体数据，但是下载过程并没有正常结束</td></tr><tr><td>abort</td><td>浏览器在下载完全部媒体数据之前中止获取媒体数据，但是并不是由错误引起的</td></tr><tr><td>error</td><td>获取媒体数据过程中出错</td></tr><tr><td>emptied</td><td>video元素或者 audio元素所在网络突然变为未初始状态。可能引起的原因有两个：载入媒体过程中突然发生一个致命错误和在浏览器正在选择支持的播放格式时，又调用了 load 方法重新载入媒体</td></tr><tr><td>stalled</td><td>浏览器尝试获取媒体数据失败</td></tr><tr><td>play</td><td>即使开始播放，当执行了 play 方法时触发，或者数据下载完之后元素被谁 autoplay</td></tr><tr><td>pause</td><td>播放暂停，当执行了 pause 方法时触发</td></tr><tr><td>loadedmetadata</td><td>浏览器获取完毕媒体的时长好字节数</td></tr><tr><td>loadeddata</td><td>浏览器已经加载完毕当前播放位置的媒体数据，准备播放</td></tr><tr><td>waiting</td><td>播放过程由于得不到下一帧而暂停播放（例如下一帧尚未加载完毕），但很快就能够播放下一帧</td></tr><tr><td>playing</td><td>正在播放</td></tr><tr><td>canplay</td><td>浏览器能够播放媒体，但估计以前播放速率不能直接将媒体播放完毕，播放需要缓冲</td></tr><tr><td>canplaythrough</td><td>浏览器能够播放媒体，而且以当前播放速率能够将媒体播放完毕，不再需要进行缓冲</td></tr><tr><td>seeking</td><td>seeking属性变为 true，浏览器正在请求数据</td></tr><tr><td>seeked</td><td>seeking属性变成false，浏览器停止请求数据</td></tr><tr><td>timeupdate</td><td>当前播放位置被改变，可能是播放过程中的自然改变，也可能是人为地改变，或由于播放不能连续而发生的跳变</td></tr><tr><td>ended</td><td>播放结束后停止播放</td></tr><tr><td>ratechange</td><td>defaultplaybackRate属性（默认播放速率）或 playbackRate属性（当前播放速率）被改变</td></tr><tr><td>durationchange</td><td>播放时长被改变</td></tr><tr><td>volumechange</td><td>volume（音量）被改变或者 muted（静音状态） 被改变</td></tr></tbody></table><h3 id="事件捕捉示例"><a href="#事件捕捉示例" class="headerlink" title="事件捕捉示例"></a>事件捕捉示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">video.addEventListener(<span class="string">'timeupdate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> timer = <span class="built_in">document</span>.getElementById(<span class="string">'time'</span>);</span><br><span class="line">  timer.innerHTML = <span class="built_in">Math</span>.floor(video.currentTime) + <span class="string">'/'</span> + <span class="built_in">Math</span>.floor(video.duration) + <span class="string">'(秒)'</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><h3 id="Web-Storage"><a href="#Web-Storage" class="headerlink" title="Web Storage"></a>Web Storage</h3><p>我们可以使用 cookies 在客户端保存注入用户等简单的用户信息，但它有一些限制：</p><ul><li>大小：cookies大小被限制在 4KB</li><li>带宽：cookies 随 HTTP 事务一起被发送，会浪费一部分发送 cookies使用的带宽</li><li>复杂度</li></ul><p>在 HTML5中重新提供了一种在客户端本地保存数据的功能，就是 Web Storage 功能。它分为两种</p><ul><li><p>sessionStorage</p><p>将数据保存在 seesion对象中。所谓的 session，是指用户在浏览某个网站的时候，从进入网站到浏览器关闭所经过这段时间，也就是用户浏览器这个网站所花费的时间，session 对象可以用来保存这时间所要求保存的任何数据、</p></li><li><p>localStorage</p><p>将数据保存在客户端本地的硬件设备（通常值硬盘，但也可以是其他硬件设备）中，即使浏览器被关闭了，该数据仍然存在，下次打开浏览器访问网站仍然可以使用。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sessionStorage</span></span><br><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">sessionStorage.setItem(key,value);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取数据</span></span><br><span class="line">变量 = seesionStorage.getItem(key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// localStorage</span></span><br><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">localStorage.setItem(key,value);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">变量 = localStorage.getItem(key)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保存时不允许重复键名。保存后可以修改键值，但是不允许修改键名（只能重新取键名，然后保存键值）</span></span><br></pre></td></tr></table></figure><h3 id="示例：简单-web-留言本"><a href="#示例：简单-web-留言本" class="headerlink" title="示例：简单 web 留言本"></a>示例：简单 web 留言本</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>简单 Web 留言本<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"memo"</span> <span class="attr">id</span>=<span class="string">"memo"</span> <span class="attr">cols</span>=<span class="string">"60"</span> <span class="attr">rows</span>=<span class="string">"10"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"追加"</span> <span class="attr">onclick</span>=<span class="string">"saveStorage('memo')"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"初始化"</span> <span class="attr">onclick</span>=<span class="string">"clearStorage('msg')"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">saveStorage</span>(<span class="params">id</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> data = <span class="built_in">document</span>.getElementById(id).value;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span></span><br><span class="line"><span class="undefined">    localStorage.setItem(time, data);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'数据已经保存了'</span>);</span></span><br><span class="line"><span class="javascript">    loadStorage(<span class="string">'msg'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">loadStorage</span>(<span class="params">id</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> result = <span class="string">`&lt;table border="1"&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; localStorage.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> key = localStorage.key(i);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> value = localStorage.getItem(key);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="undefined">      date.setTime(key);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> datestr = date.toGMTString();</span></span><br><span class="line"><span class="xml">      result += `<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;value&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;datestr&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span>`</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    result += <span class="string">`&lt;/table&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> target = <span class="built_in">document</span>.getElementById(id);</span></span><br><span class="line"><span class="undefined">    target.innerHTML = result;</span></span><br><span class="line"><span class="undefined">  &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">clearStorage</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    localStorage.clear();</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'全部数据被清除'</span>);</span></span><br><span class="line"><span class="javascript">    loadStorage(<span class="string">'msg'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="示例：简易数据库"><a href="#示例：简易数据库" class="headerlink" title="示例：简易数据库"></a>示例：简易数据库</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>简易数据库<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>EMAIL:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"email"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>电话号码:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"tel"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>备注:<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"memo"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"saveStorage()"</span> <span class="attr">value</span>=<span class="string">"保存"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>检索：</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"find"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"检索"</span> <span class="attr">onclick</span>=<span class="string">"findStorage('msg')"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">saveStorage</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> data = <span class="keyword">new</span> <span class="built_in">Object</span>;</span></span><br><span class="line"><span class="javascript">    data.name = <span class="built_in">document</span>.getElementById(<span class="string">'name'</span>).value;</span></span><br><span class="line"><span class="javascript">    data.email = <span class="built_in">document</span>.getElementById(<span class="string">'email'</span>).value;</span></span><br><span class="line"><span class="javascript">    data.tel = <span class="built_in">document</span>.getElementById(<span class="string">'name'</span>).value;</span></span><br><span class="line"><span class="javascript">    data.memo = <span class="built_in">document</span>.getElementById(<span class="string">'memo'</span>).value;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(data);</span></span><br><span class="line"><span class="undefined">    localStorage.setItem(data.name, str);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'数据已经保存了'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">findStorage</span>(<span class="params">id</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> find = <span class="built_in">document</span>.getElementById(<span class="string">'find'</span>).value;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> str = localStorage.getItem(find);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> data = <span class="built_in">JSON</span>.parse(str);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> result = <span class="string">`姓名： <span class="subst">$&#123;data.name&#125;</span>&lt;br&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    result += <span class="string">`EMAIL： <span class="subst">$&#123;data.email&#125;</span>&lt;br&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    result += <span class="string">`电话号码： <span class="subst">$&#123;data.tel&#125;</span>&lt;br&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    result += <span class="string">`备注： <span class="subst">$&#123;data.memo&#125;</span>&lt;br&gt;`</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> target = <span class="built_in">document</span>.getElementById(id);</span></span><br><span class="line"><span class="undefined">    target.innerHTML = result;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="本地数据库-新的推荐IndexedDB实现"><a href="#本地数据库-新的推荐IndexedDB实现" class="headerlink" title="本地数据库(新的推荐IndexedDB实现)"></a>本地数据库(新的推荐IndexedDB实现)</h2><p>HTML5中内置了一个可以通过 SQL 语言来访问的数据库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> db = openDatabase(<span class="string">'mydb'</span>,<span class="string">'1.0'</span>,<span class="string">'Test DB'</span>,<span class="number">2</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br></pre></td></tr></table></figure><p>openDatabase接收五个参数：</p><ol><li>数据库名字</li><li>数据库版本号</li><li>显示名字</li><li>数据库保存数据的大小（以字节为单位 )</li><li>回调函数（非必须)</li></ol><p>transaction 方法来执行事务处理，防止在对数据库进行访问以及有关操作的时候收到外界的干扰。当一条语法执行失败的时候，整个事务会回滚</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.transaction(<span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    context.executeSql(<span class="string">'CREATE TABLE IF NOT EXISTS tesTable (id unique,name)'</span>);</span><br><span class="line">    context.executeSql(<span class="string">'INSERT INTO testTable(id,name) VALUES (0,"haha")'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>executeSql 方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transaction.executeSql(sqlquery,[],dataHandler,errorHandler);</span><br></pre></td></tr></table></figure><p>executeSql 接收四个参数：</p><ol><li>查询字符串</li><li>用以替换查询字符串中问号的参数</li><li>执行成功回调函数（可选）</li><li>执行失败回调函数（可选）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transaction.executeSql(<span class="string">"UPDATE people set age=?where name=?;"</span>,[age,name],(transaction,result)=&gt;&#123;&#125;,(transaction,errmsg)=&gt;&#123;&#125;)</span><br></pre></td></tr></table></figure><h3 id="实例：留言本"><a href="#实例：留言本" class="headerlink" title="实例：留言本"></a>实例：留言本</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"init()"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>使用数据库实现的 Web 留言本<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>姓名：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>留言：<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"memo"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"保存"</span> <span class="attr">onclick</span>=<span class="string">"saveData()"</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">"datatable"</span> <span class="attr">border</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> datatable = <span class="literal">null</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> db = openDatabase(<span class="string">'MyData'</span>, <span class="string">''</span>, <span class="string">'My Database'</span>, <span class="number">102400</span>);</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(datatable.childNodes);</span></span><br><span class="line"><span class="javascript">    datatable = <span class="built_in">document</span>.getElementById(<span class="string">'datatable'</span>);</span></span><br><span class="line"><span class="undefined">    showAllData();</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">removeAllData</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = datatable.childNodes.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span></span><br><span class="line"><span class="undefined">      datatable.removeChild(datatable.childNodes[i]);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> tr = <span class="built_in">document</span>.createElement(<span class="string">'tr'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> th1 = <span class="built_in">document</span>.createElement(<span class="string">'th'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> th2 = <span class="built_in">document</span>.createElement(<span class="string">'th'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> th3 = <span class="built_in">document</span>.createElement(<span class="string">'th'</span>);</span></span><br><span class="line"><span class="javascript">    th1.innerHTML = <span class="string">'姓名'</span>;</span></span><br><span class="line"><span class="javascript">    th2.innerHTML = <span class="string">'留言'</span>;</span></span><br><span class="line"><span class="javascript">    th3.innerHTML = <span class="string">'时间'</span>;</span></span><br><span class="line"><span class="undefined">    tr.appendChild(th1);</span></span><br><span class="line"><span class="undefined">    tr.appendChild(th2);</span></span><br><span class="line"><span class="undefined">    tr.appendChild(th3);</span></span><br><span class="line"><span class="undefined">    datatable.appendChild(tr);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">showData</span>(<span class="params">row</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> tr = <span class="built_in">document</span>.createElement(<span class="string">'tr'</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> td1 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span></span><br><span class="line"><span class="undefined">    td1.innerHTML = row.name;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> td2 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span></span><br><span class="line"><span class="undefined">    td2.innerHTML = row.message;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> td3 = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> t = <span class="keyword">new</span> <span class="built_in">Date</span>();</span></span><br><span class="line"><span class="undefined">    t.setTime(row.time);</span></span><br><span class="line"><span class="javascript">    td3.innerHTML = t.toLocaleDateString() + <span class="string">" "</span> + t.toLocaleTimeString();</span></span><br><span class="line"><span class="undefined">    tr.appendChild(td1);</span></span><br><span class="line"><span class="undefined">    tr.appendChild(td2);</span></span><br><span class="line"><span class="undefined">    tr.appendChild(td3);</span></span><br><span class="line"><span class="undefined">    datatable.appendChild(tr);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">showAllData</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    db.transaction(<span class="function"><span class="keyword">function</span> (<span class="params">tx</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      tx.executeSql(<span class="string">'CREATE TABLE IF NOT EXISTS MsgData(name TEXT,message TEXT,time INTEGER)'</span>, []);</span></span><br><span class="line"><span class="javascript">      tx.executeSql(<span class="string">'SELECT * FROM MsgData'</span>, [], <span class="function"><span class="keyword">function</span> (<span class="params">tx, rs</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">        removeAllData();</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; rs.rows.length; i++) &#123;</span></span><br><span class="line"><span class="undefined">          showData(rs.rows.item(i));</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">addData</span>(<span class="params">name, message, time</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    db.transaction(<span class="function"><span class="keyword">function</span> (<span class="params">tx</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      tx.executeSql(<span class="string">'INSERT INTO MsgData VALUES(?,?,?)'</span>, [name, message, time], <span class="function"><span class="keyword">function</span> (<span class="params">tx, rs</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'成功保存数据'</span>);</span></span><br><span class="line"><span class="javascript">      &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">tx, error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;error.source&#125;</span>:<span class="subst">$&#123;error.message&#125;</span>`</span>);</span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">saveData</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> name = <span class="built_in">document</span>.getElementById(<span class="string">'name'</span>).value;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> memo = <span class="built_in">document</span>.getElementById(<span class="string">'memo'</span>).value;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> time = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span></span><br><span class="line"><span class="undefined">    addData(name, memo, time);</span></span><br><span class="line"><span class="undefined">    showAllData();</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不过，Web SQL Database规范已经被废弃。因为每个浏览器都有自己的实现，浏览器的兼容性就不重要了。</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/IndexedDB_API">关于 IndexedDB</a></p><h2 id="离线应用程序（已废弃）"><a href="#离线应用程序（已废弃）" class="headerlink" title="离线应用程序（已废弃）"></a>离线应用程序（<strong>已废弃</strong>）</h2><p>HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。</p><p>应用程序缓存为应用带来三个优势：</p><ul><li>离线浏览 - 用户可在应用离线时使用它们</li><li>速度 - 已缓存资源加载得更快</li><li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。</li></ul><p><strong>本地缓存与浏览器网页缓存的区别</strong></p><p>本地缓存为整个 Web 程序服务的，浏览器的网页缓存只服务于单个网页。任何网页都有网页缓存，而本地缓存值缓存指定的网页。本地缓存可以控制缓存更新，利用缓存对象的各种属性、状态和事件来开发出离线应用程序</p><h3 id="manifest文件"><a href="#manifest文件" class="headerlink" title="manifest文件"></a>manifest文件</h3><p>首先在 index.html 中引入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">！DOCTYPE</span> <span class="attr">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">mainfest</span> =<span class="string">'index.appcache'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>每个指定了 manifest 的页面在用户对其访问时都会被缓存。如果未指定 manifest 属性，则页面不会被缓存（除非在 manifest 文件中直接指定了该页面）。</p><p>manifest 文件的建议的文件扩展名是：”.appcache”。</p><p>请注意，manifest 文件需要配置<em>正确的 MIME-type</em>，即 “text/cache-manifest”。必须在 web 服务器上进行配置。</p><p>Web 应用程序的本地缓存是通过每个页面的 <code>manifest</code>文件来管理的。是一个简单的文件文本，清单列举了需要被缓存或者不需要被缓存的资源文件的文件名以及访问路径。</p><p>manifest 文件可分为三个部分：</p><ul><li><em>CACHE MANIFEST</em> - 在此标题下列出的文件将在首次下载后进行缓存</li><li><em>NETWORK</em> - 在此标题下列出的文件需要与服务器的连接，且不会被缓存</li><li><em>FALLBACK</em> - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CACHE MANIFEST</span><br><span class="line"># 文件开头必须要书写 CACHE MANIFEST</span><br><span class="line"># 以下是需要缓存的文件</span><br><span class="line"></span><br><span class="line">other.html</span><br><span class="line">images/1.jpg</span><br><span class="line">js/jquery.js</span><br><span class="line">css/bootstrap.css</span><br><span class="line"></span><br><span class="line">NETWORK：</span><br><span class="line">login.asp</span><br><span class="line"></span><br><span class="line">FALLBACK:</span><br><span class="line">online.js locale.js</span><br><span class="line"># 如果无法建立因特网连接，用 404页面替换/html/目录所有的文件，第一个是 URI资源，第二个是替补</span><br><span class="line">/html5/ /404.html</span><br></pre></td></tr></table></figure><p><strong>更新缓存</strong></p><p>一旦应用被缓存，它就会保持缓存知道下列的情况发生：</p><ul><li>用户清空浏览器缓存</li><li>manifest 文件被修改</li><li>由程序来更新应用缓存</li></ul><h3 id="浏览器与服务器的交互过程"><a href="#浏览器与服务器的交互过程" class="headerlink" title="浏览器与服务器的交互过程"></a>浏览器与服务器的交互过程</h3><p>场景：访问 网站A,以 index.html 为主页，使用 manifest 缓存了 index.html、1.js、1.css、1.jpg几个资源文件。</p><p>第一次访问：</p><ol><li>浏览器请求访问网站 A</li><li>服务器访问 index.html</li><li>浏览器解析 index.html，请求页面上的所有资源，包括 HTML/图像文件/CSS/JS/manifest文件等</li><li>服务器返回所有资源</li><li>浏览器处理 manifest文件，请求 manifest指定的本地缓存的文件，即使3中已经请求过了。如果要求缓存所有文件也是一个比较大的重复过程。</li><li>服务器返回所有要求缓存的文件</li><li>浏览器对本地缓存文件进行缓存，触发一个事件，通知本地缓存被更新</li></ol><p>manifest文件没有被修改，第二次访问：</p><ol><li>浏览器再次请求网站A</li><li>浏览器发现这个页面被本地缓存，于是使用本地缓存中的 index.html页面</li><li>浏览器解析 index.html，使用所有本地缓存中的资源文件</li><li>浏览器向服务器请求 manifest 文件</li><li>服务器返回一个 304，通知浏览器 manifest没有发生变化</li></ol><p>manifest文件被修改了，第三次访问：</p><ol><li>浏览器再次请求网站A</li><li>浏览器发送这个页面被本地缓存了，于是使用本地缓存中的 index.html页面</li><li>浏览器解析 index.html 文件，使用所有本地缓存中的资源文件</li><li>浏览器向服务器请求 manifest文件</li><li>服务器返回更新过的 manifest文件</li><li>浏览器处理 manifest文件，发送文件已经更新了，于是请求所有要求进行本地缓存的资源文件，包括 index.html 本身</li><li>浏览器返回要求进行本地缓存的资源文件</li><li>浏览器对本地缓存进行更新，存入所有新的资源文件，并且触发一个事件，通知本地缓存被更新了</li></ol><p>浏览器缓存过程中会触发一系列事件，该事件处理程序注册在ApplicationCache对象上，此对象是window的applicationCache属性的值。</p><p>下面详细描述了加载文档与更新应用缓存的流程：</p><ol><li>当浏览器访问一个包含 <code>manifest</code> 特性的文档时，如果应用缓存不存在，浏览器会加载文档，然后获取所有在清单文件中列出的文件，生成应用缓存的第一个版本。</li><li>对该文档的后续访问会使浏览器直接从应用缓存(而不是服务器)中加载文档与其他在清单文件中列出的资源。此外，浏览器还会向 <code>window.applicationCache 对象发送一个</code> <code>checking</code> 事件，在遵循合适的 HTTP 缓存规则前提下，获取清单文件。</li><li>如果当前缓存的清单副本是最新的，浏览器将向 <code>applicationCache 对象发送一个</code> <code>noupdate</code> 事件，到此，更新过程结束。注意，如果你在服务器修改了任何缓存资源，同时也应该修改清单文件，这样浏览器才能知道它需要重新获取资源。</li><li>如果清单文件<em>已经</em>改变，文件中列出的所有文件—也包括通过调用 <code>applicationCache.add() 方法添加到缓存中的那些文件</code>—会被获取并放到一个临时缓存中，遵循适当的 HTTP 缓存规则。对于每个加入到临时缓存中的文件，浏览器会向 <code>applicationCache 对象发送一个</code> <code>progress</code> 事件。如果出现任何错误，浏览器会发送一个 <code>error</code> 事件，并暂停更新。</li><li>一旦所有文件都获取成功，它们会自动移送到真正的离线缓存中，并向  <code>applicationCache</code>对象发送一个 <code>cached</code> 事件。鉴于文档早已经被从缓存加载到浏览器中，所以更新后的文档不会重新渲染，直到页面重新加载(可以手动或通过程序).</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//载入的时候，检查该清单文件。</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onchecking = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"san"</span>).innerHTML = <span class="string">"checking for a new version"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果清单文件没有动，同时应用程序也已经缓存了，该事件执行。</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onnoupdate = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"san"</span>).innerHTML = <span class="string">"This version is up-to-date"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果还未缓存应用程序，或者清单有改动</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.ondownloading = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"san"</span>).innerHTML = <span class="string">"Downloading new version"</span>;</span><br><span class="line">    <span class="built_in">window</span>.progresscount = <span class="number">0</span>; <span class="comment">//在下面的事件中用到</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下载过程不断调用progress事件，通常在每个文件下载完的时候。</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> progress = <span class="string">""</span>; </span><br><span class="line">    <span class="keyword">if</span>(e &amp;&amp; e.lengthComputable)&#123;</span><br><span class="line">        progress = <span class="string">""</span> + <span class="built_in">Math</span>.round(<span class="number">100</span>*e.loaded / e.total) + <span class="string">"%"</span>; <span class="comment">//计算下载完成比例</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        progress = <span class="string">"("</span> + ++progresscount + <span class="string">")"</span>;  <span class="comment">//输出调用次数。</span></span><br><span class="line">    &#125;</span><br><span class="line">    $(<span class="string">"san"</span>).innerHTML = <span class="string">"Downloading new version"</span> + progress;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当下载完成并且首次将应用程序下载到缓存中时</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.oncached = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">"san"</span>).innerHTML = <span class="string">"This application is now cached locally"</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下载完成并且首次将应用程序下载到缓存中。</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.oncached = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">"This application is now cached locally"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//下载完成并缓存的程序更新后触发，注意触发此事件时，用户任然看到老版本，只有当用户再次载入时才会访问最新版。</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onupdateready = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">"A new version has been downloaded.  Reload to run it"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//处于离线时，检查清单失败触发。</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">window</span>.applicationCache.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">"Couldn't load manifest or cache application"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//程序引用一个不存在的清单文件触发，同时将应用从缓存中删除。</span></span><br><span class="line"><span class="built_in">window</span>.applicationCache.onobsolete = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status(<span class="string">"This application is no longer cached. "</span> + </span><br><span class="line">           <span class="string">"Reload to get the latest version from the network."</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="通信-API"><a href="#通信-API" class="headerlink" title="通信 API"></a>通信 API</h2><h3 id="跨文档消息传输"><a href="#跨文档消息传输" class="headerlink" title="跨文档消息传输"></a>跨文档消息传输</h3><p>可以在不同网页文档、不同端口、不同域之间进行消息传递。</p><p>HTML5 提供了在网页文档之间互相接受与发送消息的功能，只要获取到网页所在窗口对象的实例，不仅同源（域+端口号）的 Web 之间可以互相通信，甚至可以实现跨域通信。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.postMessage();</span><br><span class="line"><span class="comment">// 这个方法可以安全实现跨域通信。提供了一个受控禁止来规避同源策略的限制。这个方法被调用时，会在所有页面脚本执行完毕之后向目标窗口派发一个 MessageEvent 消息。这个消息有四个属性：message属性表示 message类型，data属性为 window.postMessage的第一个参数；origin属性表示调用 window.postMessage方法调用页面的当前状态；source属性记录调用 window.postMessage方法的窗口消息</span></span><br><span class="line"></span><br><span class="line">otherWindow.postMessage(message,targetOrigin,[transfer]);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* otherWindow 其他窗口的一个引用，比如 iframe的contentWindow属性，执行 window.open返回的窗口对象，或者是命名过或数值索引的 window.frames</span></span><br><span class="line"><span class="comment">* message 将要发送到其他 window的数据，会被结构化克隆算法序列化。意味着不受什么限制将数据对象安全传送给目标窗口不用自己序列化</span></span><br><span class="line"><span class="comment">* targetOrigin 通过窗口的 origin 属性来指定哪些窗口能接受到消息时间。可以是“*”或者一个URI.如果目标窗口的协议、主机地址或端口这三者的任意一项不匹配targetOrigin提供的值，那么消息就不会被发送；只有三者完全匹配，消息才会被发送。这个机制用来控制消息可以发送到哪些窗口；</span></span><br><span class="line"><span class="comment">* transfer 可选 是一串和 message同时传递的 Transferable 对象，这些对象的所有权将被转移给消息的接收方，而发送一方不再保有所有权。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>派发事件</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,receiveMessage,<span class="literal">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; origin,data,source&#125; = event;</span><br><span class="line">    <span class="keyword">if</span>(origin !== <span class="string">'http://example.com:8080'</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(source+<span class="string">':'</span>+data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* message的属性;</span></span><br><span class="line"><span class="comment">* data 从其他 window 传递来的对象</span></span><br><span class="line"><span class="comment">* origin 调用 postMessage 时消息发送方窗口的 origin，不能保证是该窗口当前的 或者 未来的origin，因为 postMessage被调用后可能被导航到不同的位置</span></span><br><span class="line"><span class="comment">* source 对发送消息窗口的引用，可以使用这个在具有不同 origin 的两个窗口建立双向通信</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A窗口域名是 http://example.com:8080 下面是 A 窗口 script 里面代码</span></span><br><span class="line"><span class="keyword">let</span> popup = <span class="built_in">window</span>.open(...popup details...);</span><br><span class="line"><span class="comment">// 如果弹出框没有被阻止且加载完成</span></span><br><span class="line"><span class="comment">// 这行语句没有发送信息出去，即使假设当前页面没有改变location（因为targetOrigin设置不对）</span></span><br><span class="line">popup.postMessage(<span class="string">"The user is 'bob' and the password is 'secret'"</span>,<span class="string">"https://secure.example.net"</span>);</span><br><span class="line"><span class="comment">// 假设当前页面没有改变location，这条语句会成功添加message到发送队列中去（targetOrigin设置对了）</span></span><br><span class="line">popup.postMessage(<span class="string">"hello there!"</span>,<span class="string">"http://example.com"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event.origin !== <span class="string">'http://example.org'</span>) <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>,receiveMessage,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 弹出页 popup域名是 http://example.org 下面是 script 里面代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//当A页面postMessage被调用后，这个function被addEventListenner调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receiveMessage</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event.origin !== <span class="string">'http://example.com:8080'</span>) <span class="keyword">return</span></span><br><span class="line">     <span class="comment">// event.data 是 "hello there!"</span></span><br><span class="line">    <span class="comment">// event.source 就当前弹出页的来源页面</span></span><br><span class="line">    event.source.postMessage(<span class="string">"hi there yourself!  the secret response "</span> +<span class="string">"is: rheeeeet!"</span>,event.origin);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"message"</span>, receiveMessage, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h3 id="Web-Sockets-通信"><a href="#Web-Sockets-通信" class="headerlink" title="Web Sockets 通信"></a>Web Sockets 通信</h3><p>使用 Web Sockets API 可以在服务器与客户端之间建立一个非 HTTP 的双向连接。这个连接是实时的，也是要永久的，除非某一方显示关闭。</p><p><strong>常量</strong></p><table><thead><tr><th><strong>Constant</strong></th><th><strong>Value</strong></th></tr></thead><tbody><tr><td><code>WebSocket.CONNECTING</code></td><td><code>0</code></td></tr><tr><td><code>WebSocket.OPEN</code></td><td><code>1</code></td></tr><tr><td><code>WebSocket.CLOSING</code></td><td><code>2</code></td></tr><tr><td><code>WebSocket.CLOSED</code></td><td><code>3</code></td></tr></tbody></table><p>以上是WebSocket 构造函数的原型中存在的一些常量，可通过 <code>WebSocket.readyState</code> 对照上述常量判断 WebSocket 连接 当前所处的状态</p><p><strong>用法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// URL字符串以 ws 或者 wss（加密通信时）文字开头</span></span><br><span class="line"><span class="keyword">const</span> socket = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:8080'</span>);</span><br><span class="line"></span><br><span class="line">socket.addEventListener(<span class="string">'open'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// send方法对服务器发送数据，只能发送文本数据，可以使用 JSON对象把任何 js对象转换为文本数据后发送</span></span><br><span class="line">    socket.send(<span class="string">'Hello Server!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">socket.addEventListerner(<span class="string">'message'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Message from server'</span>,event.data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//事件句柄</span></span><br><span class="line"><span class="comment">// 接受服务器传过来的数据</span></span><br><span class="line">socket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; data &#125; = event</span><br><span class="line">&#125;</span><br><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 开始通信</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 监听 socket 关闭事件</span></span><br><span class="line">socket.onclose = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 通信结束时的处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭 socket，切断通信连接0000</span></span><br><span class="line">socket.close()</span><br></pre></td></tr></table></figure><h2 id="使用-Web-Workers-处理线程"><a href="#使用-Web-Workers-处理线程" class="headerlink" title="使用 Web Workers 处理线程"></a>使用 Web Workers 处理线程</h2><p>web worker 是运行在后台的 javaScript，不会影响页面的性能。</p><p>创建后台线程的步骤很简单。将需要在后台线程中指定的脚本文件的 URL 地址作为参数，然后创建 Worker对象就可以了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">'worker.js'</span>);</span><br><span class="line"><span class="comment">// 后台线程是不能访问到页面或者窗口对象的，所以如果使用到 window对象或者 document对象会以前你错误的发生</span></span><br></pre></td></tr></table></figure><p>可以通过发送和接收消息来与后台线程互相传递数据。通过 Worker 对象的 onmessage 事件句柄活期户后台线程之间的消息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 处理收到的消息</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// message 文本数据</span></span><br><span class="line">worker.postMessage(message);</span><br></pre></td></tr></table></figure><h3 id="示例：求和计算"><a href="#示例：求和计算" class="headerlink" title="示例：求和计算"></a>示例：求和计算</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>从1到给定数值求和<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  输入数值：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"num"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">"calculate()"</span>&gt;</span>计算<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">'SumCalculate.js'</span>);</span></span><br><span class="line"><span class="javascript">    worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(event.data);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">calculate</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> num = <span class="built_in">parseInt</span>(<span class="built_in">document</span>.getElementById(<span class="string">'num'</span>).value,<span class="number">10</span>);</span></span><br><span class="line"><span class="undefined">      worker.postMessage(num);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SumCalculate.js</span></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> num = event.data;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= num; i++) &#123;</span><br><span class="line">    result += i;</span><br><span class="line">  &#125;</span><br><span class="line">  postMessage(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="示例：与线程进行数据的交互"><a href="#示例：与线程进行数据的交互" class="headerlink" title="示例：与线程进行数据的交互"></a>示例：与线程进行数据的交互</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>从随机生成的数字中抽取3的倍数并显示<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">"table"</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 随机数组</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> intArray = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">100</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> intStr = <span class="string">''</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 生成100个随机数</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">      intArray[i] = <span class="built_in">parseInt</span>(<span class="built_in">Math</span>.random() * <span class="number">100</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">        intStr += <span class="string">';'</span>;       </span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">      intStr += intArray[i]</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">'script.js'</span>);</span></span><br><span class="line"><span class="undefined">    worker.postMessage(intStr);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    worker.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (event.data != <span class="string">''</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> j;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> k;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> tr;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> td;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> intArray = event.data.split(<span class="string">';'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> table = <span class="built_in">document</span>.getElementById(<span class="string">'table'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; intArray.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">          j = <span class="built_in">parseInt</span>(i / <span class="number">10</span>, <span class="number">0</span>);</span></span><br><span class="line"><span class="undefined">          k = i % 10;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 该行不存在</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="comment">// 添加行</span></span></span><br><span class="line"><span class="javascript">            tr = <span class="built_in">document</span>.createElement(<span class="string">'tr'</span>);</span></span><br><span class="line"><span class="javascript">            tr.id = <span class="string">'tr'</span> + j;</span></span><br><span class="line"><span class="undefined">            table.appendChild(tr);</span></span><br><span class="line"><span class="javascript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            tr = <span class="built_in">document</span>.getElementById(<span class="string">'tr'</span> + j);</span></span><br><span class="line"><span class="undefined">          &#125;</span></span><br><span class="line"><span class="javascript">          td = <span class="built_in">document</span>.createElement(<span class="string">'td'</span>);</span></span><br><span class="line"><span class="undefined">          tr.appendChild(td);</span></span><br><span class="line"><span class="undefined">          td.innerHTML = intArray[j * 10 + k];</span></span><br><span class="line"><span class="javascript">          td.style.backgroundColor = <span class="string">'blue'</span>;</span></span><br><span class="line"><span class="javascript">          td.style.color = <span class="string">'white'</span>;</span></span><br><span class="line"><span class="undefined">          td.width = 30;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script.js</span></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; data &#125; = event;</span><br><span class="line">  <span class="keyword">let</span> returnStr=<span class="string">""</span>;</span><br><span class="line">  <span class="keyword">let</span> intArray = data.split(<span class="string">';'</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; intArray.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">parseInt</span>(intArray[i]) % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (returnStr != <span class="string">''</span>) &#123;</span><br><span class="line">        returnStr += <span class="string">';'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      returnStr += intArray[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  postMessage(returnStr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程嵌套"><a href="#线程嵌套" class="headerlink" title="线程嵌套"></a>线程嵌套</h3><p><strong>单层嵌套</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// html script</span></span><br><span class="line"><span class="keyword">let</span> worket = <span class="keyword">new</span> Worker(<span class="string">'script.js'</span>)</span><br><span class="line">worket.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.data)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// script.js</span></span><br><span class="line"></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; data &#125; = event;</span><br><span class="line">    <span class="keyword">let</span> worker = <span class="keyword">new</span> Worker(<span class="string">'script2.js'</span>)</span><br><span class="line">    <span class="comment">// 把数据提交给子线程处理</span></span><br><span class="line">    worker.postMessage(<span class="built_in">JSON</span>.stringfy(data))</span><br><span class="line">    worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 把结果返回主页面</span></span><br><span class="line">        postMessage(event.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// script2.js</span></span><br><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; data &#125; = event;</span><br><span class="line">    result = someMethod(data);</span><br><span class="line">    <span class="comment">// 将处理好的处理返回</span></span><br><span class="line">    postMessage(result)</span><br><span class="line">    <span class="comment">// 如果不再使用则关闭子线程</span></span><br><span class="line">    close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多个线程中进行数据的交互</strong></p><p>实现子线程与子线程之间数据交互的，大致需要下面步骤：</p><ol><li>先创建发送数据的子线程</li><li>执行子线程中的任务，然后把要传递的数据发送给主线程</li><li>在主线程接受到子线程传回来的消息时，创建接受数据的子线程，然后把发送数据的子线程中返回的消息传递给接受数据的子线程</li><li>执行接受数据子线程中的代码</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> worker;</span><br><span class="line">    worker = <span class="keyword">new</span> Worker(<span class="string">'worker1.js'</span>);</span><br><span class="line">    worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 接受子线程中的数据</span></span><br><span class="line">        <span class="keyword">let</span> &#123; data &#125; = event;</span><br><span class="line">        worker = <span class="keyword">new</span> Worker(<span class="string">'worker2.js'</span>);</span><br><span class="line">        <span class="comment">// 把从发送数据的子线程中发回的消息传递给接受数据的子线程</span></span><br><span class="line">        worker.postMessage(data);</span><br><span class="line">        worker.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">            <span class="comment">// 获取接受数据的子线程中传回的数据</span></span><br><span class="line">            <span class="keyword">let</span> &#123;data&#125; = event;</span><br><span class="line">            <span class="comment">// 把结果发送到主页面</span></span><br><span class="line">            postMessage(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker1.js 发送数据的子线程</span></span><br><span class="line">onmessga = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> &#123;someData&#125; = event;</span><br><span class="line">    result = someMethod(someData);</span><br><span class="line">    postMassage(result);</span><br><span class="line">    <span class="comment">// 关闭子线程</span></span><br><span class="line">    close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程中可用的变量、函数与类"><a href="#线程中可用的变量、函数与类" class="headerlink" title="线程中可用的变量、函数与类"></a>线程中可用的变量、函数与类</h3><ul><li><p>self</p><p>表示本线程范围内的作用域</p></li><li><p>postMessage(message)</p><p>向创建线程的源窗口发送信息</p></li><li><p>onmessage</p><p>获取接受消息的事件句柄</p></li><li><p>importScripts(urls)</p><p>导入其他脚本文件，参数为文件的 URL地址，可以导入多个</p></li><li><p>navigator</p><p>与 window.navigator对象类似，具有 appName、platform、userAgent、appVersion这些属性</p></li><li><p>sessionStorage/localStorage</p><p>可以在线程中使用 Web Storage</p></li><li><p>XMLHttpRequest</p><p>在线程中处理 Ajax请求</p></li><li><p>setTimeout/setInterval</p><p>在线程中实现定时处理</p></li><li><p>close</p><p>结束本线程</p></li><li><p>eval/isNaN/escape</p><p>使用 javascipt 的核心函数</p></li><li><p>object</p><p>可以创建对象</p></li><li><p>WebSockets</p><p>使用 WebSockets API 来想服务器发送和接收信息</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习链接：&lt;br&gt;&lt;a href=&quot;https://read.douban.com/ebook/15160963/&quot;&gt;HTML 5与CSS 3权威指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.w3cschool.cn/html/&quot;&gt;W3cScholl
      
    
    </summary>
    
      <category term="前端面试" scheme="http://laibh.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="HTML5" scheme="http://laibh.top/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>面试官问我HTML5是什么（上）</title>
    <link href="http://laibh.top/%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E6%88%91HTML5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%E4%B8%8A%EF%BC%89.html"/>
    <id>http://laibh.top/面试官问我HTML5是什么（上）.html</id>
    <published>2019-05-23T01:30:54.000Z</published>
    <updated>2019-10-15T09:29:49.419Z</updated>
    
    <content type="html"><![CDATA[<p>学习链接：<br><a href="https://read.douban.com/ebook/15160963/">HTML 5与CSS 3权威指南</a></p><p><a href="https://www.w3cschool.cn/html/">W3cScholl</a></p><h2 id="HTML5-与-HTML4-的区别"><a href="#HTML5-与-HTML4-的区别" class="headerlink" title="HTML5 与 HTML4 的区别"></a>HTML5 与 HTML4 的区别</h2><p>常见代码区别：</p><p>新增的一些属性：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"search"</span> <span class="attr">id</span>=<span class="string">"search"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(<span class="string">'search'</span>).focus();</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"search"</span> <span class="attr">autofocus</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结构上：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"nav"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"article"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"section"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"side-bar"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HTML-5-要解决的三个问题"><a href="#HTML-5-要解决的三个问题" class="headerlink" title="HTML 5 要解决的三个问题"></a>HTML 5 要解决的三个问题</h3><ul><li>Web 浏览器之间的兼容性很低</li><li>文档结构不明确</li><li>Web应用程序的功能受到了限制</li></ul><h3 id="语法的改变"><a href="#语法的改变" class="headerlink" title="语法的改变"></a>语法的改变</h3><p>HTML 语法是在 SGML(Standard Generalized Markup Language)语言的基础上建立起来的。对于 HTML 的执行在各个浏览器之间没有统一的一个标准。</p><p>HTML5 就是围绕这个Web标准，重新定义了一套在现有的 HTML 的基础上修改而来的语法，使它运行在各浏览器时它们都能符合这个通用标准。</p><h4 id="HTML5-的标记方法"><a href="#HTML5-的标记方法" class="headerlink" title="HTML5 的标记方法"></a>HTML5 的标记方法</h4><p>1.内容类型（ContentType）</p><p>扩展符仍为 ‘.html’或者 ‘.htm’。内容类型仍然为 ‘text/html’</p><p>2.DOCTYPE 声明</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html PUBLIC "-//W3C/DTD 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/Xhtml1-transitional.dtd"&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure><p>3.指定字符编码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equive</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="确保与之前的HTML-版本兼容"><a href="#确保与之前的HTML-版本兼容" class="headerlink" title="确保与之前的HTML 版本兼容"></a>确保与之前的HTML 版本兼容</h4><p>1.可以省略标记的元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">不允许写结束标记的元素有：area/base/br/col/command/embed/hr/img/input/keygen/link/meta/param/source/track/wbr</span><br><span class="line">可以省略结束标记的元素：</span><br><span class="line">li/dt/dd/p/rt/rp/optgroup/option/colgroup/thead/tbody/tfoot/tr/td/th</span><br><span class="line">可以省略全部标记的元素(隐式存在，在文档结构仍然存在)：</span><br><span class="line">html/head/body/colgroup/tbody</span><br></pre></td></tr></table></figure><p>2.具有 boolean 值的属性</p><p>例如 disable/readonly/checked 等，只写属性不写属性值或者属性值为空字符表示属性值为 true。</p><p>3.省略引号</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">'text'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">text</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="新增的元素和废除的元素"><a href="#新增的元素和废除的元素" class="headerlink" title="新增的元素和废除的元素"></a>新增的元素和废除的元素</h3><h3 id="新增-html5-html4"><a href="#新增-html5-html4" class="headerlink" title="新增-html5(html4)"></a>新增-<code>html5(html4)</code></h3><h4 id="结构元素"><a href="#结构元素" class="headerlink" title="结构元素"></a>结构元素</h4><p><code>section(div)</code></p><p>表示页面中的一个内容区块，用于章节、页眉、页脚或者页面中的其他部分。与 h1-h6元素结合使用，表示文档结构</p><p><code>article(div)</code></p><p>表示页面中的一块与上下文不相关的独立内容，例如博客中的一篇文章或者报纸中的一篇文章</p><p><code>aside(div)</code></p><p>aside 元素表示 article 元素的内容之外的，与 article 元素内容相关的辅助信息</p><p><code>header(div)</code></p><p>表示页面一个内容区块或者整个页面的标题</p><p><code>hgroup(div)</code></p><p>用于整个页面或者页面中的一个内容块的标题进行组合</p><p><code>footer(div)</code></p><p>整个页面或者页面中的一个内容区块的脚注。一般来说，会包括作者的姓名、创作日期以及作者的联系信息。</p><p><code>nav(ul)</code></p><p>页面中导航链接部分</p><p><code>figure(dl)</code></p><p>一段独立的流内容，一般表示文档主体流内容中的一个独立单元，使用 <code>figcaption</code> 元素 为 <code>figure</code> 元素组添标题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hahahahaha<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>hahahahaha<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="多媒体元素"><a href="#多媒体元素" class="headerlink" title="多媒体元素"></a>多媒体元素</h4><p><code>video(object)</code></p><p>定义视频，比如电影片段或者其他视频流</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">'movie.ogg'</span> <span class="attr">controls</span>=<span class="string">'controls'</span>&gt;</span>video元素<span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">type</span>=<span class="string">'video/ogg'</span> <span class="attr">data</span>=<span class="string">'movie.ogv'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parma</span> <span class="attr">name</span>=<span class="string">'src'</span> <span class="attr">value</span>=<span class="string">"movie.ogv"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>audio(object)</code></p><p>定义音频，比如音乐或者其他音频流</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">'music.wav'</span>&gt;</span>audio元素<span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">type</span>=<span class="string">'application/ogg'</span> <span class="attr">data</span>=<span class="string">'someaudio.wav'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parma</span> <span class="attr">name</span>=<span class="string">'src'</span> <span class="attr">value</span>=<span class="string">"someaudio.wav"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>embed(object)</code></p><p>用来插入各种多媒体，格式可以是 Midi/Wav/AIFF/AU/MP3</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">'music.swf'</span>&gt;</span>embed元素<span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">type</span>=<span class="string">'application/x-shockwave-flash'</span> <span class="attr">data</span>=<span class="string">'music.swf'</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>source</code></p><p>为媒介元素定义媒介资源</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"horse.ogg"</span> <span class="attr">type</span>=<span class="string">"audio/ogg"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"horse.mp3"</span> <span class="attr">type</span>=<span class="string">"audio/mpeg"</span>&gt;</span></span><br><span class="line"> Your browser does not support the audio element.</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">type</span>=<span class="string">'application/ogg'</span> <span class="attr">data</span>=<span class="string">'someaudio.wav'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parma</span> <span class="attr">name</span>=<span class="string">'src'</span> <span class="attr">value</span>=<span class="string">"someaudio.wav"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="语义元素"><a href="#语义元素" class="headerlink" title="语义元素"></a>语义元素</h4><p><code>mark(span)</code>元素</p><p>用来在视觉上向用户呈现那些需要突出显示或者高亮显示的文字。mark 元素的一个比较经典的应用就是在搜索结果中向用户高亮显示搜索关键词</p><p><code>progress(无)</code></p><p>表示进程运行中的进程，可以用 progress 来显示 javascript 中耗费时间的函数的进程</p><p><code>meter(无)</code></p><p>表示度量衡。仅用于已知最大值和最小值的度量。必须定义度量的范围，既可以在元素的文本中，也可以在 min/max 属性中定义。</p><p><code>time(span)</code></p><p>表示日期或者时间，也可以同时表示两者</p><p><code>ruby(无)</code></p><p>表示 ruby 注释（中文注音或者字符）</p><p>在东亚使用，显示的是东亚字符的发音。</p><p>与 <code>&lt;ruby&gt;</code> 以及 <code>&lt;rt&gt;</code> 标签一同使用：</p><p>ruby 元素由一个或多个字符（需要一个解释/发音）和一个提供该信息的 rt 元素组成，还包括可选的 rp 元素，定义当浏览器不支持 “ruby” 元素时显示的内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;ruby&gt;</span><br><span class="line"> 漢 <span class="tag">&lt;<span class="name">rt</span>&gt;</span> ㄏㄢˋ <span class="tag">&lt;/<span class="name">rt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ruby</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>rt(无)</code></p><p>表示元素字符的解释或者发音</p><p><code>rp（无）</code></p><p>在 ruby 注释中使用，以定义不支持 ruby 元素的浏览器所显示的内容</p><p><code>wbr</code></p><p>表示软换行，wbr 与 br 区别在于后者表示此处必须换行，前者是浏览器窗口或者父级元素的宽度足够宽的时候不进行换行，而当宽度不够时，主动在此处进行换行。wbr 元素好像对字符型的语言作用挺大，但是对中文没有多大用处。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>学习 AJAX ,您必须熟悉 <span class="tag">&lt;<span class="name">wbr</span>&gt;</span>Http<span class="tag">&lt;<span class="name">wbr</span>&gt;</span>Request 对象。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>canvas</code></p><p>canvas 表示图形，比如图表和其他图像。元素本身没有行为，仅提供一块画布，但它把一个绘图 API 展示给 客户端的 javascript 以使得脚本能够把想绘制的东西绘制到这块画布上面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--html5--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">'myCanvas'</span> <span class="attr">width</span>=<span class="string">'200'</span> <span class="attr">height</span>=<span class="string">'200'</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--html4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">type</span>=<span class="string">'image/svg+xml'</span> <span class="attr">data</span>=<span class="string">'inc/hdr.svg'</span> <span class="attr">width</span>=<span class="string">'200'</span> <span class="attr">height</span>=<span class="string">'200'</span>&gt;</span><span class="tag">&lt;/<span class="name">object</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>details</code></p><p>details 元素表示用户要求得到并且可以得到的细节信息，可以与 <code>summary</code>元素配合使用。<code>summary</code>提供标题或者图例。标题是可见的，用户点击标题时，会显示出细节信息。<code>summary</code>元素应该是 <code>details</code>元素的第一个子元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">summary</span>&gt;</span>H5<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">    hahahahha</span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>datalist</code></p><p>表示可选数据的列表，与 input 元素配合使用，可以制作出 输入值的下拉列表。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">list</span>=<span class="string">"cars"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"cars"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"BMW"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Ford"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Volvo"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>datagrid</code></p><p>表示可选数据的列表，以树形列表的形式来显示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">datagrid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span> (datagrid row 0) <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span> (datagrid row 1)</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">style</span>=<span class="string">"list-style-type:lower-alpha;"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span> (datagrid row 1,0) <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span> (datagrid row 1,1) <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span> (datagrid row 2) <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">datagrid</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>output(span)</code></p><p>表示不同类型的输出，比如脚本输出</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">form</span> <span class="attr">oninput</span>=<span class="string">"x.value=parseInt(a.value)+parseInt(b.value)"</span>&gt;</span></span><br><span class="line">0</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">id</span>=<span class="string">'a'</span> <span class="attr">value</span>=<span class="string">"50"</span>&gt;</span>100+</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">id</span>=<span class="string">"b"</span> <span class="attr">value</span>=<span class="string">"50"</span>&gt;</span>=</span><br><span class="line"><span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">"x"</span> <span class="attr">for</span>=<span class="string">"a b"</span>&gt;</span><span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>menu</code></p><p>表示菜单列表，当希望列出表单控件的时候使用该标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">type</span>=<span class="string">"toolbar"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">menu</span> <span class="attr">label</span>=<span class="string">"File"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"file_new()"</span>&gt;</span>新建<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"file_open()"</span>&gt;</span>打开<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"file_save()"</span>&gt;</span>保存<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">menu</span> <span class="attr">label</span>=<span class="string">"Edit"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"edit_cut()"</span>&gt;</span>剪切<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"edit_copy()"</span>&gt;</span>复制<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"edit_paste()"</span>&gt;</span>粘贴<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是目前主流所有浏览器都不支持这个标签</p><h4 id="input元素类型"><a href="#input元素类型" class="headerlink" title="input元素类型"></a>input元素类型</h4><p><code>email</code></p><p>表示必须输入 E-mail </p><p><code>url</code></p><p>输入 URL 地址</p><p><code>number</code></p><p>输入数值</p><p><code>range</code></p><p>输入一定范围内数字值</p><p><code>Date Pickers</code></p><p>拥有多个选择日期和时间的新型输入文本框</p><p>data-日、月、年</p><p>month-月、年</p><p>week-周、年</p><p>time-小时、分钟</p><p>datetime-日、月、年（UTC）</p><p>datetime-local-日、月、年（本地时间）</p><h3 id="废除（替代元素）"><a href="#废除（替代元素）" class="headerlink" title="废除（替代元素）"></a>废除（替代元素）</h3><p>1.能用css替代的元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">basefont/big/center/font/s/strike(del)/tt/u</span><br></pre></td></tr></table></figure><p>2.不再使用 frame 框架</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frameset/frame/noframes，现只支持 iframe框架。</span><br></pre></td></tr></table></figure><p>3.只有部分浏览器支持的元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applet(embed/obejct)/bgsound(audio)/blink/marquee</span><br></pre></td></tr></table></figure><p>4.其他被废除的元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rb(ruby)/acronym(abbr)/dir(ul)/isindex(form+input)/listing(pre)/xmp(code)/nextid(GUIDS)/plaintext('text/plain' MIME 类型)</span><br></pre></td></tr></table></figure><h3 id="新增的属性和废除的属性"><a href="#新增的属性和废除的属性" class="headerlink" title="新增的属性和废除的属性"></a>新增的属性和废除的属性</h3><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><h4 id="表单相关的属性"><a href="#表单相关的属性" class="headerlink" title="表单相关的属性"></a>表单相关的属性</h4><ul><li><code>input[type=text]</code>、<code>select</code>与 <code>button</code> 指定 <code>autofucus</code>属性，以指定的方式让元素在画面打开的时候自动获得焦点</li><li><code>input[type=text]</code>与 <code>textarea</code>指定 <code>placeholder</code>属性，会对用户的输入进行提示，提示用户输入的内容</li><li><code>input</code>、<code>output</code>、<code>select</code>、<code>textarea</code>、<code>button</code>与 <code>fieldset</code>指定 <code>form</code>属性，声明它们属性哪个表单，然后将其放置任何位置，而不是在表单之内</li><li><code>input[type=text]</code>与 <code>textarea</code>指定 <code>required</code>。表示用户提交的时候进行检查，检查该元素内一定要有输入内容</li><li><code>input</code>其他新增的属性：<code>autocomplete</code>、<code>min</code>、<code>max</code>、<code>multiple</code>、<code>pattern</code>、<code>step</code>。同时还有一个 新的 <code>list</code>元素可以与 <code>datalist</code>配合使用。<code>datalist</code>与 <code>autocomplete</code>属性配合使用。<code>multiple</code>属性允许在上传文件的时候一次上传多个文件。</li><li><code>input</code>、<code>button</code>增加了新的属性 <code>formaction</code>、<code>formenctype</code>、<code>formmethod</code>、<code>formnovalidate</code>与 <code>formtarget</code>，它们可以重载 <code>form</code>元素的 <code>action</code>、<code>enctype</code>、<code>method</code>、<code>novalidate</code>与 <code>target</code>属性。为  <code>fileset</code>增加了 <code>disabled</code>，可以把它的子元素设为 <code>disabled(无效)</code>状态</li><li><code>input</code>、<code>button</code>、<code>form</code>增加了 <code>novalidate</code>属性，该属性可以取消提交时进行的有关检查，表单可以被无条件提交。</li></ul><h4 id="链接相关属性"><a href="#链接相关属性" class="headerlink" title="链接相关属性"></a>链接相关属性</h4><ul><li><code>a</code>与 <code>area</code>增加 <code>media</code>属性，该属性规定目标 URL是什么类型的媒介/设备进行优化，只能在 <code>href</code>属性存在时使用</li><li>为 <code>area</code>元素增加了 <code>hreflang</code>属性与 <code>rel</code>属性，以保持与 <code>a</code>元素、<code>link</code>元素的一致。</li><li><code>link</code>元素增加了新的属性 <code>sizes</code>。该属性可以与 <code>icon</code>属性元素结合使用(通过 <code>rel</code>属性)，该属性指定关联图标（<code>icon</code>元素）的大小。</li><li>为 <code>base</code>元素增加了<code>target</code>属性，主要目的是保持与 <code>a</code>元素的一致性。</li></ul><h4 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h4><p>除了上面介绍的与表单和链接相关的属性外，HTML5 还增加了下面的属性：</p><ul><li><code>ol</code>元素增加 <code>reversed</code>,它指定了列表倒序显示</li><li><code>meta</code>增加 <code>charset</code>属性。因为这个属性被广泛支持了，而且为文档的字符编码的执行提供了一种良好的方式</li><li>为 <code>style</code>属性增加<code>scoped</code>属性，用来规定样式的作用范围，例如只对页面某个树起作用。</li><li><code>script</code>增加 <code>async</code>属性，定义脚本是否异步执行</li><li><code>html</code>增加 <code>mainfest</code>，开发离线Web 应用程序时它与 API 结合使用，定义一个 URL,在这个 URL 上描述文档的缓存信息。</li><li><code>iframe</code>元素增加了三个属性 <code>sandbox</code>、<code>seamless</code>与 <code>srcdoc</code>，用来提高页面安全性，防止不信任的 Web 页面执行某些操作。</li></ul><h3 id="废除"><a href="#废除" class="headerlink" title="废除"></a>废除</h3><table><thead><tr><th><strong>在HTML 4中使用的属性</strong></th><th><strong>使用该属性的元素</strong></th><th><strong>在HTML 5中的替代方案</strong></th></tr></thead><tbody><tr><td><strong>rev</strong></td><td>link、a</td><td>rel</td></tr><tr><td><strong>charset</strong></td><td>link、a</td><td>在被链接的资源的中使用HTTP Content-type头元素</td></tr><tr><td><strong>shape</strong>、coords</td><td>a</td><td>使用area元素代替a元素</td></tr><tr><td><strong>longdesc</strong></td><td>img、iframe</td><td>使用a元素链接到校长描述</td></tr><tr><td><strong>target</strong></td><td>link</td><td>多余属性，被省略</td></tr><tr><td><strong>nohref</strong></td><td>area</td><td>多余属性，被省略</td></tr><tr><td><strong>profile</strong></td><td>head</td><td>多余属性，被省略</td></tr><tr><td><strong>version</strong></td><td>html</td><td>多余属性，被省略</td></tr><tr><td><strong>name</strong></td><td>img</td><td>id</td></tr><tr><td><strong>scheme</strong></td><td>meta</td><td>只为某个表单域使用scheme</td></tr><tr><td><strong>archive**</strong>、chlassid、codebose、codetype、declare、standby**</td><td>object</td><td>使用data与typc属性类调用插件。需要使用这些属性来设置参数时，使用param属性</td></tr><tr><td><strong>valuetype</strong>、type</td><td>param</td><td>使用name与value属性，不声明之的MIME类型</td></tr><tr><td><strong>axis</strong>、abbr</td><td>td、th</td><td>使用以明确简洁的文字开头、后跟详述文字的形式。可以对更详细内容使用title属性，来使单元格的内容变得简短</td></tr><tr><td><strong>scope</strong></td><td>td</td><td>在被链接的资源的中使用HTTP Content-type头元素</td></tr><tr><td><strong>align</strong></td><td>caption、input、legend、div、h1、h2、h3、h4、h5、h6、p</td><td>使用CSS样式表替代</td></tr><tr><td><strong>alink</strong>、link、text、vlink、background、bgcolor</td><td>body</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、bgcolor、border、cellpadding、cellspacing、frame、rules、width</td><td>table</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、char、charoff、height、nowrap、valign</td><td>tbody、thead、tfoot</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、bgcolor、char、charoff、height、nowrap、valign、width</td><td>td、th</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、bgcolor、char、charoff、valign</td><td>tr</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、char、charoff、valign、width</td><td>col、colgroup</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、border、hspace、vspace</td><td>object</td><td>使用CSS样式表替代</td></tr><tr><td><strong>clear</strong></td><td>br</td><td>使用CSS样式表替代</td></tr><tr><td><strong>compace</strong>、type</td><td>ol、ul、li</td><td>使用CSS样式表替代</td></tr><tr><td><strong>compace</strong></td><td>dl</td><td>使用CSS样式表替代</td></tr><tr><td><strong>compace</strong></td><td>menu</td><td>使用CSS样式表替代</td></tr><tr><td><strong>width</strong></td><td>pre</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、hspace、vspace</td><td>img</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、noshade、size、width</td><td>hr</td><td>使用CSS样式表替代</td></tr><tr><td><strong>align</strong>、frameborder、scrolling、marginheight、marginwidth</td><td>iframe</td><td>使用CSS样式表替代</td></tr><tr><td><strong>autosubmit</strong></td><td>menu</td></tr></tbody></table><h3 id="全局属性"><a href="#全局属性" class="headerlink" title="全局属性"></a>全局属性</h3><h4 id="contentEditable"><a href="#contentEditable" class="headerlink" title="contentEditable"></a>contentEditable</h4><p>允许用户编辑元素中的内容，该元素必须是可以获得用户鼠标焦点的元素，在点击鼠标后要向用户提供一个插入符号，提示用户该元素中的内容允许被编辑。<code>contentEditable</code>属性是一个布尔值属性，可以被指定 <code>true</code>或者 <code>false</code></p><p>除此之外，还有一个隐藏的 <code>inherit</code>状态，属性为  <code>true</code>，元素被指定为允许编辑，属性为 <code>false</code>时，元素被指定为不允许编辑。未指定 <code>true</code>或者 <code>false</code>时，则由 <code>inherit</code>状态来决定，如果元素的父元素是可以编辑的，则该元素就是可编辑的。</p><p>元素还具有一个叫做 <code>isContentEditable</code>属性，当元素可编辑时，该属性为 true，当元素不可编辑时，该属性 为 false。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">contentEditable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>元素列表1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>元素列表2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>元素列表3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="designMode"><a href="#designMode" class="headerlink" title="designMode"></a>designMode</h4><p><code>designMode</code> 属性用来指定整个页面是否可编辑，当页面可编辑时，页面中任何支持上文所述的 <code>contentEditable</code> 属性的元素都变成了可编辑状态。<code>designMode</code>只能在 javascript 脚本里被编辑修改。该属性有两个值——“on” 和 “off”。属性被指定为 <code>on</code>时，页面可编辑，被指定为 <code>off</code>时，页面不可编辑。使用 javascript 来指定 designMode 属性的方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.designMode = <span class="string">'on'</span></span><br></pre></td></tr></table></figure><p>针对 <code>designMode</code> 属性，各个浏览器的支持情况也不一样：</p><ul><li>IE8：安全考虑，不允许使用 <code>designMode</code>属性让页面进行编辑状态</li><li>IE9：允许使用 <code>designMode</code>属性让页面进入编辑状态</li><li>Chrome3 和 Safari：使用内嵌 <code>frame</code>方式，该内嵌 <code>frame</code>是可编辑的</li><li>Firefox 和 Opera：允许使用 <code>designMode</code>属性让页面进入编辑状态</li></ul><h4 id="hidden"><a href="#hidden" class="headerlink" title="hidden"></a>hidden</h4><p>在 HTML5 中，所有的元素都允许有一个 <code>hidden</code>属性，该属性类似于 <code>input</code> 中的 <code>hidden</code>元素，功能是通知浏览器不渲染该元素，使该元素处于不可见状态。但是元素中的内容还是浏览器创建的，也就是说页面装载后允许使用 javascript 脚本将该属性取消，取消后该元素变为可见状态，同时元素中的内容页即时显示出来。<code>hidden</code>属性是一个布尔值的属性，为设为 <code>true</code>后，元素处于不可见状态，当设为 <code>false</code>后，元素属于可见状态。</p><h4 id="spellcheck"><a href="#spellcheck" class="headerlink" title="spellcheck"></a>spellcheck</h4><p><code>spellcheck</code> 是针对 <code>input</code>与 <code>textarea</code>这两个文本输入框提供的一个新属性，它的功能为对用户输入的文本内容进行拼写和语法检查。是一个布尔值属性，具有 true 和 false 两种值。必须明确书写属性值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">contentEditable</span> <span class="attr">spellcheck</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">spellcheck</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">contenteditable</span>=<span class="string">"true"</span> <span class="attr">spellcheck</span>=<span class="string">"true"</span>&gt;</span>这是可编辑的段落。请试着编辑文本。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是如果元素的 <code>readonly</code>或者  <code>disabled</code>设为 <code>true</code>，则不执行拼写检查。</p><h4 id="tabindex"><a href="#tabindex" class="headerlink" title="tabindex"></a>tabindex</h4><p>当不断敲击 Tab 键让窗口或者页面中的控件获得焦点，对窗口或者页面的所有控件进行遍历的时候，每一个控件的 <code>tabindex</code>表示该控件是第几个页面访问到的。</p><p>过去的这个属性在编辑网页的时候非常有用，但如今控件的遍历顺序是由元素在页面上所处的位置决定的，所以不再需要了。</p><p>但是 <code>tabindex</code>还有另外一个作用，在默认属性下，只有链接元素与表单可以通过按键获得焦点。如果对其他元素使用 <code>tabindex</code>属性后，也能让该元素获得焦点，那么当脚本中执行 <code>focus()</code>语句的时候，就可以让该元素获得焦点了。但这样做会有一个副作用：钙元素也可以通过按 Tab 键获得焦点，而这时有可能也不是开发者想要的结果。</p><p>把元素的 <code>tabindex</code>设为为负数（通常为-1）后就可以解决这个问题。<code>tabindex</code>的值为负数后，仍然可以通过编程的方式让元素获得焦点，但按下 Tab 键时该元素就不能获得焦点了。这在复杂的页面中或复杂的 Web 应用程序中是非常有用的。在 HTML4 中，-1 是一个无用的属性值，但到了 HTML5 中，通过巧妙运用让该属性得到了极大的应用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://laibh.top"</span> <span class="attr">tabindex</span>=<span class="string">"2"</span>&gt;</span>赖同学<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.com/"</span> <span class="attr">tabindex</span>=<span class="string">"1"</span>&gt;</span>Google<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.microsoft.com/"</span> <span class="attr">tabindex</span>=<span class="string">"3"</span>&gt;</span>Microsoft<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="data"><a href="#data" class="headerlink" title="data-*"></a>data-*</h4><p>使用 data-* 属性来嵌入自定义数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"target"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"e1"</span> <span class="attr">data-animal-type</span>=<span class="string">"鸟类"</span>&gt;</span>喜鹊<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"e2"</span> <span class="attr">data-animal-type</span>=<span class="string">"鱼类"</span>&gt;</span>金枪鱼<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"e3"</span> <span class="attr">data-animal-type</span>=<span class="string">"蜘蛛"</span>&gt;</span>蝇虎<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">showDetails</span>(<span class="params">animal</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> animalType = animal.getAttribute(<span class="string">"data-animal-type"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(animal.innerHTML + <span class="string">'是一种'</span> + animalType);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> ul = <span class="built_in">document</span>.getElementById(<span class="string">'target'</span>);</span></span><br><span class="line"><span class="javascript">    ul.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> ev = e || <span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> target = ev.target || ev.srcElement;</span></span><br><span class="line"><span class="undefined">        showDetails(target);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="draggable"><a href="#draggable" class="headerlink" title="draggable"></a>draggable</h4><p>规定元素是否可以拖动，链接和图像默认是可以拖动的。</p><p>语法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">element</span> <span class="attr">draggable</span>=<span class="string">"true|false|auto"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-id">#dropbox</span>&#123;</span></span><br><span class="line"><span class="undefined">width: 400px;</span></span><br><span class="line"><span class="undefined">height: 400px;</span></span><br><span class="line"><span class="css"><span class="selector-tag">border</span><span class="selector-pseudo">:1px</span> <span class="selector-tag">solid</span> <span class="selector-id">#aaaaaa</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"dropbox"</span> <span class="attr">ondrop</span>=<span class="string">"drop(event)"</span> <span class="attr">ondragover</span>=<span class="string">"allowDrop(event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"drag"</span> <span class="attr">draggable</span>=<span class="string">"true"</span> <span class="attr">ondragstart</span>=<span class="string">"drag(event)"</span>&gt;</span>这是一段可移动的段落，请把该段落拖入上面的矩形<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">allowDrop</span>(<span class="params">ev</span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">        ev.preventDefault();</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">drag</span>(<span class="params">ev</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        ev.dataTransfer.setData(<span class="string">'Text'</span>,ev.target.id)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">drop</span>(<span class="params">ev</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> data = ev.dataTransfer.getData(<span class="string">'Text'</span>);</span></span><br><span class="line"><span class="javascript">        ev.target.appendChild(<span class="built_in">document</span>.getElementById(data));</span></span><br><span class="line"><span class="undefined">        ev.preventDefault()</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="新结构元素使用样式"><a href="#新结构元素使用样式" class="headerlink" title="新结构元素使用样式"></a>新结构元素使用样式</h3><p>兼容旧版本浏览器的 hack</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">    article,aside,dialog,figure,footer,header,legend,nav,section&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">display</span><span class="selector-pseudo">:block</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    nav&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:20</span>%;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    article&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">float</span><span class="selector-pseudo">:right</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:79</span>%;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--IE8之前的浏览器不支持使用 CSS方法来使用这些尚未支持的结构元素，需要使用脚本定义--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.createElement(<span class="string">'header'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.createElement(<span class="string">'nav'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.createElement(<span class="string">'article'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.createElement(<span class="string">'footer'</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--或者引入一个 js来hack--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>HTML5 HACK<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--[if lt IE9]&gt;</span></span><br><span class="line"><span class="comment">&lt;script src="http://apps.bdimg.com/libs/html5shiv/3.7/html5shiv.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">    &lt;![end if]--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="表单与文件"><a href="#表单与文件" class="headerlink" title="表单与文件"></a>表单与文件</h2><p><strong>新的 form 属性</strong>：</p><ul><li>autocomplete</li><li>novalidate</li></ul><p><strong>新的 input 属性</strong>：</p><ul><li>autocomplete</li><li>autofocus</li><li>form</li><li>form overrides (formaction, formenctype, formmethod, formnovalidate, formtarget)</li><li>height 和 width</li><li>list</li><li>min, max 和 step</li><li>multiple</li><li>pattern (regexp)</li><li>placeholder</li><li>required</li></ul><p><strong>浏览器支持</strong></p><table><thead><tr><th style="text-align:left">Input type</th><th style="text-align:left">IE</th><th style="text-align:left">Firefox</th><th style="text-align:left">Opera</th><th style="text-align:left">Chrome</th><th style="text-align:left">Safari</th></tr></thead><tbody><tr><td style="text-align:left">autocomplete</td><td style="text-align:left">8.0</td><td style="text-align:left">3.5</td><td style="text-align:left">9.5</td><td style="text-align:left">3.0</td><td style="text-align:left">4.0</td></tr><tr><td style="text-align:left">autofocus</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">10.0</td><td style="text-align:left">3.0</td><td style="text-align:left">4.0</td></tr><tr><td style="text-align:left">form</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">9.5</td><td style="text-align:left">No</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">form overrides</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">10.5</td><td style="text-align:left">No</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">height and width</td><td style="text-align:left">8.0</td><td style="text-align:left">3.5</td><td style="text-align:left">9.5</td><td style="text-align:left">3.0</td><td style="text-align:left">4.0</td></tr><tr><td style="text-align:left">list</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">9.5</td><td style="text-align:left">No</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">min, max and step</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">9.5</td><td style="text-align:left">3.0</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">multiple</td><td style="text-align:left">No</td><td style="text-align:left">3.5</td><td style="text-align:left">No</td><td style="text-align:left">3.0</td><td style="text-align:left">4.0</td></tr><tr><td style="text-align:left">novalidate</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">pattern</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">9.5</td><td style="text-align:left">3.0</td><td style="text-align:left">No</td></tr><tr><td style="text-align:left">placeholder</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">3.0</td><td style="text-align:left">3.0</td></tr><tr><td style="text-align:left">required</td><td style="text-align:left">No</td><td style="text-align:left">No</td><td style="text-align:left">9.5</td><td style="text-align:left">3.0</td><td style="text-align:left">No</td></tr></tbody></table><h3 id="新增属性"><a href="#新增属性" class="headerlink" title="新增属性"></a>新增属性</h3><p><code>form</code></p><p>在 HTML4 中表单内的从属元素必须写在表单内容，但是 HTML5 中，可以把它书写在页面的任何地方，然后给该元素指定一个 <code>form</code>属性。属性值为该表单的 id，这样就可以声明该元素从属于指定表单了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"testform"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">form</span>=<span class="string">"testform"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目前只有 Opera 支持这个属性</p><p><code>formaction</code></p><p>HTML4中，一个表单内的所有元素都只能通过表单的 <code>action</code>属性统一提交到另一个页面，而在 HTML5 可以给所有的提交按钮，<code>&lt;input type=&quot;submit&quot;&gt;</code>、<code>&lt;input type=&quot;image&quot;&gt;</code>、<code>&lt;button type=&quot;submit&quot;&gt;</code>都增加 <code>formaction</code>属性，使得点击不同的按钮，可以将表单提交到不同的页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"testform"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s1"</span> <span class="attr">value</span>=<span class="string">"v1"</span> <span class="attr">formaction</span>=<span class="string">"s1.jsp"</span>&gt;</span>提交到 s1</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s2"</span> <span class="attr">value</span>=<span class="string">"v2"</span> <span class="attr">formaction</span>=<span class="string">"s2.jsp"</span>&gt;</span>提交到 s2</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s3"</span> <span class="attr">value</span>=<span class="string">"v3"</span> <span class="attr">formaction</span>=<span class="string">"s3.jsp"</span>&gt;</span>提交到 s3</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目前没有浏览器支持这一属性</p><p><code>formmethod</code></p><p>在 HTML4 中只有一个表单内有 <code>action</code>属性来对表单内所有元素统一指定提交页面，所以每个表单内只有一个 <code>method</code>属性来指统一指定提交方法。在 HTML5 中，可以使用 <code>formaction</code>属性来对每个表单元素分别指定不同的提交页面，也可以用 <code>formmethod</code>对每个表单元素分别指定不同的提交方式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"testform"</span> <span class="attr">action</span>=<span class="string">"serve.jsp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s1"</span> <span class="attr">value</span>=<span class="string">"v1"</span> <span class="attr">formaction</span>=<span class="string">"s1.jsp"</span> <span class="attr">formmethod</span>=<span class="string">"get"</span>&gt;</span>提交到 s1</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"s2"</span> <span class="attr">value</span>=<span class="string">"v2"</span> <span class="attr">formaction</span>=<span class="string">"s2.jsp"</span> <span class="attr">formmethod</span>=<span class="string">"post"</span>&gt;</span>提交到 s2</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目前没有浏览器支持这一属性</p><p><code>placeholder</code></p><p>是指文本框为输入状态时，文本框里面显示的输入提示。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"input me"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>autofocus</code></p><p>给文本框、选择框或者按钮控件加上该属性，当画面打开的时候，该控件自动获得光标焦点。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">autofocus</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个页面只能有一个控件具有该属性。不要滥用，建议只有当一个页面是以使用某个控件为主要目的的时候才使用。例如搜索页面中的搜索文本框。</p><p><code>list</code></p><p>为单行文本框添加一个 <code>list</code>属性，它的值为某个 <code>datalist</code>元素的 id。类似于 <code>select</code>，不同的是它除了可以选择之外，还可以自己输入。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">list</span>=<span class="string">"cars"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"cars"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"BMW"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Ford"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Volvo"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>autocomplete</code></p><p>辅助输入所用的自动完成功能，是一个节省输入时间，同时也非常方便的功能。可以指定 <code>on</code>、<code>off</code>、<code>&quot;&quot;</code>三个值。不指定时用浏览器的默认值。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"greeting"</span> <span class="attr">autocomplete</span>=<span class="string">"on"</span> <span class="attr">list</span>=<span class="string">"greetings"</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="表单元素种类"><a href="#表单元素种类" class="headerlink" title="表单元素种类"></a>表单元素种类</h3><p><code>url</code>、<code>email</code>、<code>date</code>、<code>time</code>、<code>datetime</code>、<code>datetime-local</code>、<code>month</code>、<code>week</code>、<code>number</code>、<code>range</code>、<code>search</code>、<code>tel</code>、<code>color</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"http://laibh.top"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">value</span>=<span class="string">"544289495@qq.com"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"date"</span> <span class="attr">value</span>=<span class="string">"2019-05-22"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"time"</span> <span class="attr">value</span>=<span class="string">"11:27"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"datetime"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"datetime-local"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"month"</span> <span class="attr">value</span>=<span class="string">"2019-05"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"week"</span> <span class="attr">value</span>=<span class="string">"2019-W21"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"number"</span> <span class="attr">value</span>=<span class="string">"25"</span> <span class="attr">min</span>=<span class="string">"10"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">step</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">value</span>=<span class="string">"25"</span> <span class="attr">min</span>=<span class="string">"10"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">step</span>=<span class="string">"2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"search"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"tel"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"color"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>output</code></p><p>定义了不同类型的输出，比如计算结果或者脚本的输出。output 元素必须从属某个表单，必须将它书写在表单内部，或者对它添加 form 属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"testform1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">name</span>=<span class="string">"range1"</span> <span class="attr">step</span>=<span class="string">"5"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">output</span> <span class="attr">onforminput</span>=<span class="string">"value=range1.value"</span>&gt;</span>50<span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--或者浏览器兼容更好的下面这种方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"testform1"</span> <span class="attr">oninput</span>=<span class="string">"x.value=range1.value"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"range"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">name</span>=<span class="string">"range1"</span> <span class="attr">step</span>=<span class="string">"5"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">output</span> <span class="attr">name</span>=<span class="string">"x"</span> <span class="attr">for</span>=<span class="string">"range1"</span>&gt;</span>50<span class="tag">&lt;/<span class="name">output</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><a href="http://www.w3school.com.cn/tags/att_output_for.asp">for</a></td><td style="text-align:left"><em>element_id</em></td><td style="text-align:left">定义输出域相关的一个或多个元素。</td></tr><tr><td style="text-align:left"><a href="http://www.w3school.com.cn/tags/att_output_form.asp">form</a></td><td style="text-align:left"><em>form_id</em></td><td style="text-align:left">定义输入字段所属的一个或多个表单。</td></tr><tr><td style="text-align:left"><a href="http://www.w3school.com.cn/tags/att_output_name.asp">name</a></td><td style="text-align:left"><em>name</em></td><td style="text-align:left">定义对象的唯一名称。（表单提交时使用）</td></tr></tbody></table><h3 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h3><p><strong>自动验证</strong></p><p><code>require</code></p><p>可以应用在大部分输入元素（除了隐藏元素，图片按钮上）。在提交时，如果元素中内容为空白，则不允许提交，同时在浏览器中显示信息提示文字。</p><p><code>pattern</code></p><p>要求输入内容格式的，对 <code>input</code>使用 <code>pattern</code>属性，设为某个正则表达式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">pattern</span>=<span class="string">"[0-9][A-Z]&#123;3&#125;"</span> <span class="attr">name</span>=<span class="string">"part"</span> <span class="attr">placeholder</span>=<span class="string">"输入内容；一个数字与三个大写字母"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>min</code> 与 <code>max</code></p><p>数值类型与日期类型元素专用属性。限制了 <code>input</code>元素输入的数值与日期范围。</p><p><code>step</code></p><p>控制 <code>input</code>元素中的值增加或者减少的步幅。</p><p><strong>显式验证</strong></p><p>HTML5 中，<code>form</code> 与 <code>input</code>(除了 <code>select</code> 与 <code>textarea</code>)都具有一个 <code>checkValidity</code>。使用这个方法，可以显示对表单内所有元素内容或者单个元素内容进行有效性验证。返回 boolen值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"textform4"</span> <span class="attr">onsubmit</span>=<span class="string">"return check()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"http://laibh.top"</span> <span class="attr">id</span>=<span class="string">"url"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> url = <span class="built_in">document</span>.getElementById(<span class="string">'url'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (!url.value) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'地址不能为空'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (!url.checkValidity()) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'请输入正确的url地址'</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(url.value)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但其实一般提交按钮的时候，会自动检验格式</p><h3 id="取消校验"><a href="#取消校验" class="headerlink" title="取消校验"></a>取消校验</h3><p>有两种方法取消校验，第一种用 <code>form</code>的 <code>novalidate</code>属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"textform4"</span> <span class="attr">onsubmit</span>=<span class="string">"return check()"</span> <span class="attr">novalidate</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"http://laibh.top"</span> <span class="attr">id</span>=<span class="string">"url"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>但是上述的方法里面的 <code>checkValidity()</code>仍会生效</p><p>第二种是利用 <code>input</code>  或者 <code>submit</code>元素的 <code>formnovalidate</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"textform4"</span> <span class="attr">onsubmit</span>=<span class="string">"return check()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"http://laibh.top"</span> <span class="attr">id</span>=<span class="string">"url"</span> <span class="attr">formnovalidate</span>=<span class="string">"formnovalidate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--或者--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"textform4"</span> <span class="attr">onsubmit</span>=<span class="string">"return check()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"http://laibh.top"</span> <span class="attr">id</span>=<span class="string">"url"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">formnovalidate</span>=<span class="string">"formnovalidate"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前者是单单让一个 <code>input</code>取消验证，后者是取消验证整个 <code>form</code>表单</p><h3 id="自定义错误信息"><a href="#自定义错误信息" class="headerlink" title="自定义错误信息"></a>自定义错误信息</h3><p>HTML5 中可以利用 javascript 调用各个 input 元素的 <code>setCustomValidity</code>方法来自定义错误信息。需要注意的是一旦设置了 <code>setCustomValidity</code>，检验通过的条件变成了 <code>setCustomValidity(&#39;&#39;) &amp;&amp; !valueMissing &amp;&amp; !patternMismatch</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"code"</span> <span class="attr">required</span> <span class="attr">pattern</span>=<span class="string">"^\d&#123;4&#125;$"</span> <span class="attr">placeholder</span>=<span class="string">"请输入代码"</span> <span class="attr">oninput</span>=<span class="string">"check(this)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">check</span>(<span class="params">i</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> &#123; valueMissing,patternMismatch &#125; = i.validity;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(valueMissing,patternMismatch)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(valueMissing)&#123;</span></span><br><span class="line"><span class="javascript">            i.setCustomValidity(<span class="string">'该字段不能为空，请按要求填入代码'</span>)</span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span>(patternMismatch)&#123;</span></span><br><span class="line"><span class="javascript">                i.setCustomValidity(<span class="string">'请输入4位数字的代码'</span>)</span></span><br><span class="line"><span class="javascript">            &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">                i.setCustomValidity(<span class="string">''</span>)</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;    </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="增强的页面元素"><a href="#增强的页面元素" class="headerlink" title="增强的页面元素"></a>增强的页面元素</h3><p><code>figure</code>和 <code>figcaption</code></p><p><code>figure</code>是一种元素的组合，带有可选标题。figure 元素用来表示网页上一块独立内容，将其从网页上移除后不会对网页上的其他内容产生任何影响。<code>figure</code>元素所表示的内容可以是图片、统计图或者代码示例。</p><p><code>figcaption</code>表示 <code>figure</code>元素的标题，从属于 <code>figure</code>。一个 <code>figure</code>最多只允许防止一个 <code>figcaption</code>元素，但是运行放置多个其他元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">figure</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">figcaption</span>&gt;</span>黄浦江上的的卢浦大桥<span class="tag">&lt;/<span class="name">figcaption</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>拍摄者：W3School 项目组，拍摄时间：2010 年 10 月<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.w3school.com.cn/i/shanghai_lupu_bridge.jpg"</span> <span class="attr">width</span>=<span class="string">"350"</span> <span class="attr">height</span>=<span class="string">"234"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">figure</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>figure</code>所表示的内容通常是图片、统计图或者代码示例，也可以是音频插件、视频插件或者统计表格。</p><p><code>details</code></p><p>提供了一种替代 javascript 的将画面上的局部区域进行展开或者收缩的方法，目前只有 Chrome 和 Safari 6 支持 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">summary</span>&gt;</span>Copyright 2011.<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>All pages and graphics on this web site are the property of W3School.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>mark</code></p><p>表示页面需要高亮或者突出显示的。只好是对网页全文检索某个关键词时显示的检索结果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Do not forget to buy <span class="tag">&lt;<span class="name">mark</span>&gt;</span>milk<span class="tag">&lt;/<span class="name">mark</span>&gt;</span> today.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了某种特殊目的把原文作者没有特别重点标示的内容给标示出来。</p><p>与 <code>em</code> 、<code>strong</code>元素的区别在于前者是作者自己标出来的重点要注意的，而<code>mark</code>跟作者本身没有太多关系，是在后来引用的时候添加上去的。</p><p><code>progress</code></p><p>表示一个任务的完成进度。</p><p>该元素有两个参数来表示当前任务完成情况。<code>value</code>表示完成了多少工作量，<code>max</code>表示总共多少工作量。</p><p>在属性设定的时候，这两个属性只能设定为有效的浮点数，<code>value</code>的值必须大于0，小于等于 <code>max</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>progress 使用示例<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>完成百分比：<span class="tag">&lt;<span class="name">progress</span> <span class="attr">id</span>=<span class="string">"progress"</span> <span class="attr">max</span>=<span class="string">"100"</span> <span class="attr">value</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>0<span class="tag">&lt;/<span class="name">span</span>&gt;</span>%<span class="tag">&lt;/<span class="name">progress</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">'add()'</span> <span class="attr">value</span>=<span class="string">"请点击"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> progressBar = <span class="built_in">document</span>.getElementById(<span class="string">'progress'</span>);</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        progressBar.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>].textContent = <span class="string">'0'</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">            setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">                progressBar.value = i;</span></span><br><span class="line"><span class="javascript">                progressBar.getElementsByTagName(<span class="string">'span'</span>)[<span class="number">0</span>].textContent = i</span></span><br><span class="line"><span class="undefined">            &#125;, 1000 * i)</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>meter</code></p><p>表示规定范围内的数量值。例如磁盘使用量，对于某个候选者的投票人数占总投票人数的比例等。</p><p>meter 元素有六个属性：</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">high</td><td style="text-align:left"><em>number</em></td><td style="text-align:left">定义度量的值位于哪个点，被界定为高的值。</td></tr><tr><td style="text-align:left">low</td><td style="text-align:left"><em>number</em></td><td style="text-align:left">定义度量的值位于哪个点，被界定为低的值。</td></tr><tr><td style="text-align:left">max</td><td style="text-align:left"><em>number</em></td><td style="text-align:left">定义最大值。默认值是 1。</td></tr><tr><td style="text-align:left">min</td><td style="text-align:left"><em>number</em></td><td style="text-align:left">定义最小值。默认值是 0。</td></tr><tr><td style="text-align:left">optimum</td><td style="text-align:left"><em>number</em></td><td style="text-align:left">定义什么样的度量值是最佳的值。如果该值高于 “high” 属性，则意味着值越高越好。如果该值低于 “low” 属性的值，则意味着值越低越好。</td></tr><tr><td style="text-align:left">value</td><td style="text-align:left"><em>number</em></td><td style="text-align:left">定义度量的值。</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">value</span>=<span class="string">"5"</span> <span class="attr">min</span>=<span class="string">"0"</span> <span class="attr">max</span>=<span class="string">"10"</span> <span class="attr">high</span>=<span class="string">"8"</span> <span class="attr">low</span>=<span class="string">"2"</span> <span class="attr">optimum</span>=<span class="string">"5"</span>&gt;</span>3/10<span class="tag">&lt;/<span class="name">meter</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meter</span> <span class="attr">value</span>=<span class="string">"0.6"</span>&gt;</span>60%<span class="tag">&lt;/<span class="name">meter</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>注释：<span class="tag">&lt;/<span class="name">b</span>&gt;</span>Internet Explorer 不支持 meter 标签。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>menu</code>与 <code>command</code></p><p>用于菜单工具条与弹出菜单。两个元素的浏览器支持不是很好，不做介绍。</p><p><code>ol</code></p><p>增加了 <code>start</code>与 <code>reversed</code>属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">reversed</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>咖啡<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>牛奶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>茶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span> <span class="attr">start</span>=<span class="string">"50"</span> <span class="attr">reversed</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>咖啡<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>牛奶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>茶<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>dl</code></p><p>重新定义后的 <code>dl</code>列表包含多个带名字的列表项。每一项包含一条或者多条带名字的 <code>dt</code>元素，用来表示术语，<code>dt</code>元素后面紧跟一个或者多个 <code>dd</code>元素，用来表示定义。在一个元素内，不允许带有相同的 <code>dt</code>元素，不允许有重复的术语。<code>dl</code>可以用来定义文章或者网页上的术语解释</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>Black hot drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>White cold drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>cite</code></p><p>标签定义作品（比如书籍、歌曲、电影、电视节目、绘画、雕塑等等）的标题。不能是人名</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"/i/ct_fcsz.jpg"</span> <span class="attr">alt</span>=<span class="string">"富春山居图"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cite</span>&gt;</span>《富春山居图》<span class="tag">&lt;/<span class="name">cite</span>&gt;</span>由黄公望始画于至正七年(1347)，于至正十年完成。</span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>small</code></p><p>由原来的通用展示性元素变成更具体的、专门用来标识所谓的”小字印刷体”的元素。通常用于免责声明、注意事项、法律法规、与版权相关等的法律性声明文字中，同时不允许被应用在页面主内容中，只允许被当做辅助信息用 <code>inline</code>方式内嵌在页面上使用。同时 <code>small</code>元素也不意味着元素中内容字体会变小，如果需要将字体变小，需要配合  CSS 样式来用。</p><h3 id="文件-API"><a href="#文件-API" class="headerlink" title="文件 API"></a>文件 API</h3><p>HTML5 中提供了一个关于文件操作的文件 API.</p><h4 id="FileList-对象与-file-对象"><a href="#FileList-对象与-file-对象" class="headerlink" title="FileList 对象与 file 对象"></a>FileList 对象与 file 对象</h4><p><code>FileList</code> 对象表示用户选择的文件列表。在 HTML4 中，<code>file</code> 控件只允许放置一个文件，到了 HTML5 中。通过添加 <code>multiple</code>属性，<code>file</code>控件允许一次放置多个文件。控件内的每一个用户选择的文件都是一个 <code>file</code>对象，而 <code>FileList</code>对象则为这些 <code>file</code>对象的列表，代表用户选择的所有文件。 <code>file</code>对象有两个属性，<code>name</code>属性表示文件名，不包括路径，<code>lastModifiedDate</code>属性表示文件的最后修改日期。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span> <span class="attr">multiple</span> <span class="attr">size</span>=<span class="string">"80"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"showFileName()"</span> <span class="attr">value</span>=<span class="string">"文件上传"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">showFileName</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> file;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> files = <span class="built_in">document</span>.getElementById(<span class="string">'file'</span>).files;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> len = files.length;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="undefined">            file = files[i]</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(file.name);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Blob对象"><a href="#Blob对象" class="headerlink" title="Blob对象"></a>Blob对象</h4><p>Blob 表示二进制原始数据，它提供一个 <code>slice</code>方法，可以通过该方法访问到字节内部数据块。事实上，上面的 <code>file</code>对象也继承了这个 Blob 对象。</p><p>Blob 对象有两个属性，<code>size</code>属性表示一个 Blob 对象的字节长度，<code>type</code> 属性表示 Blob 的 MIME 类型，如果是未知类型的话，返回一个空字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showFileName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> file;</span><br><span class="line">    <span class="keyword">const</span> files = <span class="built_in">document</span>.getElementById(<span class="string">'file'</span>).files;</span><br><span class="line">    <span class="keyword">const</span> len = files.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        file = files[i]</span><br><span class="line">       <span class="built_in">console</span>.log(file.name + <span class="string">'==='</span> + file.size + <span class="string">'==='</span> + file.type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对 <code>file.size</code>或者 <code>file.type</code>判断可以进行文件大小与文件类型的限制。另外 HTML5 已经对 <code>file</code>控件添加了 <code>accept</code>属性，企图让 <code>file</code>控件只能接受某种类型的文件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span> <span class="attr">multiple</span> <span class="attr">size</span>=<span class="string">"80"</span> <span class="attr">accept</span>=<span class="string">"image/gif"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样打开文件的时候就会显示 gif结尾的文件，当然如果你强行传其他类型的也是没有报错的。所以如果要做限制上传文件类型的话要结合 <code>file.type</code>来实现。</p><h4 id="FileReader接口"><a href="#FileReader接口" class="headerlink" title="FileReader接口"></a>FileReader接口</h4><p>主要用来把文件读入内存，并且读取文件中的数据。FileReader 接口有了一个异步 API,使用该 API可以在浏览器主线程中异步访问文件系统，读取文件中的数据。</p><p>检查是否可以使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="keyword">typeof</span> FileReader)&#123;</span><br><span class="line">    <span class="comment">// 浏览器为实现 FileReader 接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口方法</strong></p><p>这个接口拥有4个方法，其中三个用来读取文件，另一个用来读取过程中断</p><table><thead><tr><th>方法名</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>readAsBinaryString</td><td>file</td><td>将文件读取为二进制码</td></tr><tr><td>readAsText</td><td>file,[encoding]</td><td>将文件读取为文本</td></tr><tr><td>readAsDataURL</td><td>file</td><td>将文件读取为 DataURL</td></tr><tr><td>abort</td><td>（none）</td><td>中断读取操作</td></tr></tbody></table><ul><li>readAsBinaryString,这个方法将文件读取为二进制字符串，通常我们把它传送到后端，后端可以通过这段字符串存储文件。</li><li>readAsText,有两个参数，第二个参数是文本的编码方式，默认值为 <code>UTF-8</code>。将文件以文本方式读取，读取的结果是这个文本文件中的内容。</li><li>readAsDateURL,该方法将文件读取为一串 Data URL字符串，该方法事实上是将小文件以一种特殊格式的URL 地址形式直接读入页面。这里的小文件通常是图像与 html 格式的文件。</li></ul><p><strong>接口的事件</strong></p><p>除了上面打方法，FileReader 接口还包含了一套完整的事件模型，用于捕获读取文件时的状态。</p><table><thead><tr><th>事件</th><th>描述</th></tr></thead><tbody><tr><td>onabort</td><td>数据读取中断时触发</td></tr><tr><td>onerror</td><td>数据读取出错时触发</td></tr><tr><td>onloadstart</td><td>数据取数开始时触发</td></tr><tr><td>onprogress</td><td>数据读取中</td></tr><tr><td>onload</td><td>数据读取成功完成时触发</td></tr><tr><td>onloadend</td><td>数据读取完成时触发，无论成功或者失败</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"file"</span>&gt;</span>请选择一个文件<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"readAsDataURL()"</span> <span class="attr">value</span>=<span class="string">"读取图像"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"readAsBinaryString()"</span> <span class="attr">value</span>=<span class="string">"读取二进制数据"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">onclick</span>=<span class="string">"readAsText()"</span> <span class="attr">value</span>=<span class="string">"读取文本数据"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">name</span>=<span class="string">"result"</span> <span class="attr">id</span>=<span class="string">"result"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> result = <span class="built_in">document</span>.getElementById(<span class="string">'result'</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> file = <span class="built_in">document</span>.getElementById(<span class="string">'file'</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (!<span class="keyword">typeof</span> FileReader) &#123;</span></span><br><span class="line"><span class="javascript">  alert(<span class="string">'浏览器不支持 FileReader 接口'</span>)</span></span><br><span class="line"><span class="javascript">  file.setAttribute(<span class="string">'disabled'</span>, <span class="string">'disabled'</span>);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">readAsDataURL</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 检查文件是否为图像</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> &#123; files &#125; = file;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> len = files.length;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!<span class="regexp">/image\/\w+/</span>.test(files[i].type)) &#123;</span></span><br><span class="line"><span class="javascript">      alert(<span class="string">'请确保文件都为图像类型'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将文件以 Data URL 形式读入页面</span></span></span><br><span class="line"><span class="undefined">    reader.readAsDataURL(files[i])</span></span><br><span class="line"><span class="javascript">    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span></span><br><span class="line"><span class="javascript">      img.src = <span class="keyword">this</span>.result</span></span><br><span class="line"><span class="undefined">      result.appendChild(img)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 将文件以二进制的形式读入页面</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">readAsBinaryString</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 检查文件是否为图像</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> &#123; files &#125; = file;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> len = files.length;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!<span class="regexp">/image\/\w+/</span>.test(files[i].type)) &#123;</span></span><br><span class="line"><span class="javascript">      alert(<span class="string">'请确保文件都为图像类型'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将文件以 二进制形式读入页面</span></span></span><br><span class="line"><span class="undefined">    reader.readAsBinaryString(files[i])</span></span><br><span class="line"><span class="javascript">    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>)</span></span><br><span class="line"><span class="javascript">      p.innerHTML += <span class="keyword">this</span>.result</span></span><br><span class="line"><span class="undefined">      result.appendChild(p)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 将文件以文本形式读入页面</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">readAsText</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 检查文件是否为图像</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> &#123; files &#125; = file;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> len = files.length;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!<span class="regexp">/image\/\w+/</span>.test(files[i].type)) &#123;</span></span><br><span class="line"><span class="javascript">      alert(<span class="string">'请确保文件都为图像类型'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 将文件以 二进制形式读入页面</span></span></span><br><span class="line"><span class="undefined">    reader.readAsText(files[i])</span></span><br><span class="line"><span class="javascript">    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>)</span></span><br><span class="line"><span class="javascript">      p.innerHTML += <span class="keyword">this</span>.result</span></span><br><span class="line"><span class="undefined">      result.appendChild(p)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于读取状态的先后顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readAsDataURL</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 检查文件是否为图像</span></span><br><span class="line">  <span class="keyword">const</span> &#123; files &#125; = file;</span><br><span class="line">  <span class="keyword">const</span> len = files.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="regexp">/image\/\w+/</span>.test(files[i].type)) &#123;</span><br><span class="line">      alert(<span class="string">'请确保文件都为图像类型'</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> reader = <span class="keyword">new</span> FileReader();</span><br><span class="line">    <span class="comment">// 将文件以 Data URL 形式读入页面</span></span><br><span class="line">    reader.readAsDataURL(files[i])</span><br><span class="line">    reader.onload = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>)</span><br><span class="line">      img.src = <span class="keyword">this</span>.result</span><br><span class="line">      result.appendChild(img)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'load'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    reader.onprogress = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'progress'</span>);&#125;</span><br><span class="line">    reader.onabort = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'abort'</span>);&#125;</span><br><span class="line">    reader.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'error'</span>);&#125;</span><br><span class="line">    reader.onloadstart = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'loadstart'</span>);&#125;</span><br><span class="line">    reader.onloadend = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;<span class="built_in">console</span>.log(<span class="string">'loadend'</span>);&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// loadstart</span></span><br><span class="line"><span class="comment">// progress</span></span><br><span class="line"><span class="comment">// load</span></span><br><span class="line"><span class="comment">// loadend</span></span><br></pre></td></tr></table></figure><p>在 <code>onprogress</code>里面可以用 <code>progress</code>来显示文件读取的百分比。</p><h4 id="拖放-API"><a href="#拖放-API" class="headerlink" title="拖放 API"></a>拖放 API</h4><p>虽然在 HTML5 之前已经可以使用 <code>mousedown</code>、<code>mousemove</code>、<code>mouseup</code>来实现拖放操作，但是这只是在浏览器内容的拖放。在 HTML5 中，支持在浏览器与其他应用程序之间的数据互相拖动，同时也大大简化了拖放方面的代码。</p><h5 id="实现拖放的步骤"><a href="#实现拖放的步骤" class="headerlink" title="实现拖放的步骤"></a>实现拖放的步骤</h5><ol><li>将想要拖放的对象元素的 <code>draggable</code>属性设为 <code>true</code>，这样才能将该元素进行拖放。另外，img元素与 a 元素默认运行拖放。</li><li>编写与拖放有关的代码。</li></ol><h5 id="拖放的相关事件"><a href="#拖放的相关事件" class="headerlink" title="拖放的相关事件"></a>拖放的相关事件</h5><table><thead><tr><th>事件</th><th>产生事件的元素</th><th>描述</th></tr></thead><tbody><tr><td>drastart</td><td>被拖放的元素</td><td>开始施放操作</td></tr><tr><td>drag</td><td>被拖放的元素</td><td>拖放过程中</td></tr><tr><td>dragenter</td><td>拖放过程中鼠标经过的元素</td><td>被拖放的元素开始进入本元素的范围</td></tr><tr><td>dragover</td><td>拖放过程中鼠标经过的元素</td><td>被拖放的元素正在本元素范围内移动</td></tr><tr><td>dragleave</td><td>拖放过程中鼠标经过的元素</td><td>被拖放的元素离开本元素的范围</td></tr><tr><td>drop</td><td>拖放的目标元素</td><td>有其他元素被拖放到了本元素中</td></tr><tr><td>dragend</td><td>拖放的对象元素</td><td>拖放操作结束</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"init()"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>简单拖放示例<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"dragme"</span> <span class="attr">draggable</span>=<span class="string">"true"</span> <span class="attr">style</span>=<span class="string">"width:200px;border:1px solid gray"</span>&gt;</span></span><br><span class="line">    请拖放</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"text"</span> <span class="attr">style</span>=<span class="string">"width:200px;height:200px;border:1px solid gray"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> source = <span class="built_in">document</span>.getElementById(<span class="string">'dragme'</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> dest = <span class="built_in">document</span>.getElementById(<span class="string">'text'</span>);</span></span><br><span class="line"><span class="javascript">      source.addEventListener(<span class="string">'dragstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> dt = ev.dataTransfer;</span></span><br><span class="line"><span class="javascript">        dt.effectAllowed = <span class="string">'all'</span>;</span></span><br><span class="line"><span class="javascript">        dt.setData(<span class="string">'text/plain'</span>, <span class="string">'你好'</span>)</span></span><br><span class="line"><span class="javascript">      &#125;, <span class="literal">false</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">      dest.addEventListener(<span class="string">'dragend'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 不执行默认处理（拒绝被拖放）</span></span></span><br><span class="line"><span class="undefined">        ev.preventDefault();</span></span><br><span class="line"><span class="undefined">      &#125;);</span></span><br><span class="line"><span class="javascript">      dest.addEventListener(<span class="string">'drop'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> dt = ev.dataTransfer;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> text = dt.getData(<span class="string">'text/plain'</span>);</span></span><br><span class="line"><span class="undefined">        dest.textContent += text;</span></span><br><span class="line"><span class="undefined">        ev.preventDefault();</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 禁止事件传播</span></span></span><br><span class="line"><span class="undefined">        ev.stopPropagation();</span></span><br><span class="line"><span class="javascript">      &#125;, <span class="literal">false</span>)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 页面设置属性，不执行默认处理(拒绝被拖放)</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.ondragover = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; e.preventDefault() &#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.ondrop = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; e.preventDefault() &#125;</span></span><br><span class="line"><span class="undefined">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>开始拖动（<code>dragstart</code>事件发生）时，将要拖动的数据存入 <code>DataTransfer</code>对象（<code>setData()方法</code>）。<code>DataTransfer</code>对象专门用来存放拖放时要携带的数据，它可以被设置为拖动事件对象的 <code>dataTransfer</code>属性。<code>setData</code>方法中的第一个参数为携带数据的数据种类的字符串，第二个参数为要修改的数据。第一个参数中表示数据种类的字符串里只能填入类似 <code>text/plain</code>或者<code>text/html</code>的表示 MIME 类型的文字，不能填入其他文字。</li><li>如果把<code>dt.setData(&quot;text/plain&quot;,&quot;你好&quot;)</code>改成 <code>dt.setData(&quot;text/plain&quot;,this.id)</code>。因为把被拖动元素的 id 当成了参数，所以携带的数据就是被拖动元素中的数据了，因为浏览器在使用 <code>getData()</code>方法读取数据时会自动读取该元素中的数据。</li><li>针对拖放的目标元素，必须在 <code>dragend</code>或者 <code>dragover</code>事件内调用事件对象的 <code>preventDefault()</code>方法。因为默认情况下，被拖放的目标元素不允许接受元素的，为了把元素拖放到其中，必须把默认处理给关闭掉。</li><li>目标元素接受到被拖放的元素后，执行 <code>getData</code>方法从 <code>DataTransfer</code>获得数据。<code>getData</code>方法的参数为 <code>setData</code>方法中指定的数据种类</li><li>要实现拖放过程，还必须在目标元素的 <code>drop</code>事件中关闭默认处理（拒绝被拖放），否则目标元素不能接受被拖放的元素</li><li>实现拖放过程，还必须设定整个页面为不执行默认处理（拒绝被拖放），否则拖放处理也不能被实现。因为页面是先于其他元素接受拖放的，如果页面上拒绝拖放，那么页面上其他元素就都不能接受拖放</li><li>要使元素可以被拖放，首先必须把该元素的 <code>draggable</code>属性设为 <code>true</code>，另外，为了让这个示例在所有支持拖放 API 的浏览器中都能正常运行，需要指定 <code>-webkit-user-drag:element</code>这种 Webkit 特有的 CSS 属性</li></ul><p>现在支持拖放处理的 MIME 类型主要有一下几种：</p><ul><li>text/plain:文本文字</li><li>text/html：HTML文字</li><li>text/xml：xml 文字</li><li>text/uri-list：URL 列表，每个 URL 为一行</li></ul><h5 id="DataTransfer-对象的属性与方法"><a href="#DataTransfer-对象的属性与方法" class="headerlink" title="DataTransfer 对象的属性与方法"></a>DataTransfer 对象的属性与方法</h5><table><thead><tr><th>属性/方法</th><th>描述</th></tr></thead><tbody><tr><td>dropEffect属性</td><td>表示拖放操作的视觉效果，运行对其进行值的设定。该效果必须用 <code>effectAllowed</code>属性置顶的允许的效果范围内。允许指定的值为 none、copy、move、link</td></tr><tr><td>effectAllowed属性</td><td>用来指定当元素被拖放时所运行的视觉效果，可以指定的值为none、copy、copyLink、copyMove、link、linkMove、move、all、unintialize</td></tr><tr><td>types属性</td><td>存入数据的种类，字符串的伪数组</td></tr><tr><td>void clearData(DOMString format)方法</td><td>清除 DataTransfer 对象中存放的数据，如果省略参数 format,则清除全部数据</td></tr><tr><td>void setData(DOMString format、DOMString data)</td><td>向 DataTransfer 对象内存入数据</td></tr><tr><td>DOMString getData(DOMString format)</td><td>从 DataTransfer 对象中读数据</td></tr><tr><td>void setDragImage(Element image,long x,long y)</td><td>用 img 元素来设置拖放图标（部分浏览器可以用 canvas 等其他元素来设置）</td></tr></tbody></table><h5 id="设定拖放时的视觉效果"><a href="#设定拖放时的视觉效果" class="headerlink" title="设定拖放时的视觉效果"></a>设定拖放时的视觉效果</h5><p><code>dropEffect</code>与 <code>effectAllowed</code>属性结合起来可以设定拖放时的视觉效果。<code>effectAllowed</code>属性表示当一个元素被拖动时所运行的视觉效果，一般在 <code>ondragstart</code>事件中设定，运行使用的值为 none、copy、copyLink、copyMove、link、move、all、unintialize。</p><p><code>dropEffect</code>属性表示实际拖放时的视觉效果，一般在 <code>ondragover</code>事件中指定，运行设定的值为 none、copy、link、move。<code>dropEffect</code>属性所表示的实际视觉效果必须在 <code>effectAllowed</code>属性所表示的允许的视觉效果范围内。规则如下：</p><ol><li>如果 <code>effectAllowed</code>属性被设为 <code>none</code>，则不允许拖放元素。</li><li>如果 <code>dropEffect</code>属性设定为 <code>none</code>，则不允许被拖放到目标元素中</li><li><code>effectAllowed</code>属性设定为 <code>all</code>或者不设定，则 <code>dropEffect</code>属性允许被设定为任何值，并按照指定的视觉效果进行显示</li><li>如果 <code>effectAllowed</code>属性设定为具体效果（不为 none或者 all），<code>dropEffect</code>属性也设定了具体视觉效果，则两个具体效果值必须完全相等，否则不允许被拖放元素拖放到目标元素中。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">source.addEventListener(<span class="string">'dragstart'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dt = ev.dataTransfer;</span><br><span class="line">    dt.effectAllowed = <span class="string">'copy'</span>;</span><br><span class="line">    dt.setData(<span class="string">"text/plain"</span>,<span class="string">"你好"</span>)</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">dest.addEventListener(<span class="string">'dragover'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> dt = ev.dataTransfer;</span><br><span class="line">    dt.dropEffect = <span class="string">'copy'</span>;</span><br><span class="line">    ev.preventDefault();</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h5 id="自定义拖放图标"><a href="#自定义拖放图标" class="headerlink" title="自定义拖放图标"></a>自定义拖放图标</h5><p>除了上面所说的使用 <code>effectAllowed</code>属性与<code>dropEffect</code>属性外，HTML5 还允许自定义拖放图标——指的是在用鼠标拖动元素的过程中，位于鼠标指针下部的小图标。</p><p><code>setDragImage</code>方法有三个惨呼，第一个参数 image 设定为拖放图标的图标元素，第二个参数 x 为拖放图标离鼠标指针x轴方向的位移量，第三个参数 y 为拖放图标距离鼠标指针的 y 轴方向的位移量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dragIcon.src = <span class="string">'http://laibh.top/images/favicon-32x32-next.png?v=5.1.4'</span>;</span><br><span class="line">source.addEventListener(<span class="string">'dragstart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">ev</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> dt = ev.dataTransfer;</span><br><span class="line"><span class="built_in">console</span>.log(ev)</span><br><span class="line"><span class="built_in">console</span>.log(dt)</span><br><span class="line">dt.effectAllowed = <span class="string">'all'</span>;</span><br><span class="line">dt.setDragImage(dragIcon, <span class="number">-10</span>, <span class="number">-10</span>)</span><br><span class="line">dt.setData(<span class="string">'text/plain'</span>, <span class="string">'你好'</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习链接：&lt;br&gt;&lt;a href=&quot;https://read.douban.com/ebook/15160963/&quot;&gt;HTML 5与CSS 3权威指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.w3cschool.cn/html/&quot;&gt;W3cScholl
      
    
    </summary>
    
      <category term="前端面试" scheme="http://laibh.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="HTML5" scheme="http://laibh.top/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题目汇总摘录（React 基础篇）</title>
    <link href="http://laibh.top/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E6%91%98%E5%BD%95-React%20%E5%9F%BA%E7%A1%80%E7%AF%87.html"/>
    <id>http://laibh.top/前端面试题目汇总摘录-React 基础篇.html</id>
    <published>2019-05-13T02:30:54.000Z</published>
    <updated>2019-10-15T09:29:49.419Z</updated>
    
    <content type="html"><![CDATA[<p>温故而知新，保持空杯心态</p><h2 id="React-基础"><a href="#React-基础" class="headerlink" title="React  基础"></a>React  基础</h2><h3 id="什么是-React"><a href="#什么是-React" class="headerlink" title="什么是 React?"></a>什么是 React?</h3><p>是一个用于构建用户界面的 javaScript 库，主要用于构建 UI,很多人认为是 MVC 中的 View 层</p><p>特点：</p><ul><li>声明式设计 – 采用声明范式，可以轻松描述应用</li><li>高效 – 通过对 DOM 的模拟，最大限度地减少与 DOM 的交互</li><li>灵活 –  React 可以与很多库或者框架很好地配合</li><li>JSX – JSX 是 javascript 语法的扩展</li><li>组件 – 通过 React 构建的组件，使得代码更加容易得到，很好的应用在大项目的开发中</li><li>单向响应的数据流 – 减少了重复代码</li></ul><h3 id="React的渲染机制"><a href="#React的渲染机制" class="headerlink" title="React的渲染机制"></a>React的渲染机制</h3><h4 id="React-渲染过程"><a href="#React-渲染过程" class="headerlink" title="React 渲染过程"></a>React 渲染过程</h4><p>页面打开的时候，React 会调用 render 函数来构建一颗 DOM 树，在 <code>state/props</code>改变的时候， render 函数会再次调用渲染出来另外一颗树，接着， React 会对两棵树进行对比，找出需要更新的地方进行批量改动</p><h4 id="Diff-算法"><a href="#Diff-算法" class="headerlink" title="Diff 算法"></a>Diff 算法</h4><p><strong>作用</strong></p><p>计算出 Virtual DOM 中真正变化的部分，并只针对该部分进行原生 DOM 操作，而非重新渲染整个页面。</p><p><strong>传统 diff 算法的劣处</strong></p><p>通过循环递归节点进行依次对比，算法复杂度达到 <code>O(n^3)</code>，n 是树的节点数。假设展示1000个节点，得执行上亿次比较。CPU 无法进行在很短的时间内计算出差异</p><p><strong>React 的 diff 算法</strong></p><p>将 Virtual DOM 树转换成为 Actual DOM 树的最少操作过程被称为调和。React  的 diff 算法就是调和的具体实现。</p><p><strong>React 的diff 策略</strong></p><p>React 用三大策略将 <code>O(n^3)</code>复杂都转换为 <code>O(n)</code>复杂度</p><p>策略1（tree diff）:</p><p>Web UI 中 DOM 节点跨层级的移动操作特别少，可以忽略不计</p><p>策略2（component diff）:</p><p>拥有相同类的两个组件生成相似的树形结构</p><p>拥有不同类的两个组件生成不同的树形结构</p><p>策略三（element diff）:</p><p>对于同一层级的一组子节点，通过唯一的 id 区分</p><p><strong>diff 策略详解</strong></p><p><em>Tree diff</em></p><ol><li>React 通过 updateDepth 对 Virtual DOM 树进行层级控制</li><li>对树分层比较，两棵树只对同一层次节点进行比较，如果该节点不存在时，则该节点以及其节点会被完全删除，不会再进行进一步比较</li><li>只要遍历一次，就能完成整颗 DOM 的比较</li><li>如果 DOM 出现了跨层操作，diff 只会简单考虑同层级的节点位置变化，如果是跨层的话，只有创建和删除节点的操作。因此也不建议进行跨 DOM 操作，可以通过 CSS 隐藏、显示节点，而不是真正地移除，添加 DOM 节点</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">updateChildren:<span class="function"><span class="keyword">function</span>(<span class="params">nextNestedChildrenElements,transaction,context</span>)</span>&#123;</span><br><span class="line">    updateDepth++;</span><br><span class="line">    <span class="keyword">var</span> errorThrow = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._updateChildren(nextNestedChildrenElements,transaction,context)</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        updateDepth--;</span><br><span class="line">        <span class="keyword">if</span>(updateDepth)&#123;</span><br><span class="line">            <span class="keyword">if</span>(errorThrow)&#123;</span><br><span class="line">            clearQueue();   </span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                processQueue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Component diff</em></p><ol><li>同一类型的两个组件，按原策略（层级比较）继续比较 Virtual DOM 树即可</li><li>同一类型的两个组件，组件 A 变化为 组件 B时，可能 Virtual DOM 没有任何改变，如果知道这一点，可节省大量计算时间。用户可以通过 <code>shouldComponentUpdate()</code> 来判断是否需要判断计算</li><li>不同类型的组件，将一个（将被改变的）组件判断为 <code>dirty component(脏组件)</code>，从而替换整个组件的所有节点。</li></ol><p>注意：如果组件 A 和 组件 B 的结构相似，但是 React 判断是不同类型的组件，则不会比较其结构，而是删除 组件 A 以及其子节点，创建组件 B 以其子节点。</p><p><em>Element diff</em></p><p>当节点处于同一层级时，diff 提供三个节点操作：删除、插入、移动</p><p>插入：组件 C 不在集合 （AB）中,需要插入</p><p>删除：组件 D 在集合 （ABD）中，但是集合变成（AB）,D就需要被删除</p><p>移动：组件 D 已经在集合（ABCD）中，且集合更新时，D 没有发生更新，只是位置的改变，如新的集合（ADBC）。D 在第二个，无须像传统的 diff,让旧集合的第二个 B 和新集合的比较，并且删除第二个位置的 B，再在第二个位置插入 D 。需要做的是（对同一层级的同组子节点）添加唯一的 key 进行区分，移动即可。</p><p><strong>移动逻辑详解</strong></p><p>情形一：新旧集合中存在相同节点但是位置不同时，如何移动节点</p><p><img src="/images/前端面试题目汇总摘录-React 基础篇-react-diff移动1.png" alt="react-diff移动1"></p><p><code>lastIndex</code>有点像浮标，或者一个 map 的索引，默认值是 0，会与 map 中的元素进行比较后改变自己的值（取 <code>index</code>和 <code>lastIndex</code>中的较大值）</p><ol><li>B，React 在新中取得 ,判断旧中是否存在相同的节点B,发现节点B后判断是否需要移动B。<ol><li>B 在旧中 <code>index = 1</code>,它 的 <code>lastIndex = 0</code></li><li>不满足 <code>lastIndex &gt; index</code>，无需移动操作。</li><li><code>lastindex = Math.max(lastindex,index) = 1</code> </li></ol></li><li>A，A在旧的 <code>index=0</code>,此时 <code>lastIndex=1</code>。满足 <code>lastIndex &gt; index</code>，对 A 进行移动到 <code>lastIndex=1</code>。接着操作 <code>lastIndex=Math.max(lastIndex,index)</code>还是等于1</li><li>D，同 1，不移动，由于旧的D <code>index=3</code>,<code>lastIndex=1</code>，改 <code>lastIndex=Math.max(lastIndex,index)=3</code></li><li>C,同 2，移动。C在旧的 <code>index=2</code>,满足<code>lastIndex(3)&gt;index</code>，移动</li><li>由于 C 已经是最后一个节点了，所以 diff 操作结束</li></ol><p>情形二：新集合中有新加入的节点，旧集合中有删除的节点</p><p><img src="/images/前端面试题目汇总摘录-React 基础篇-react-diff移动2.png" alt="react-diff移动2"></p><ol><li>B,同上理，不移动，更新 <code>lastIndex=1</code></li><li>E,旧集合中没有，在 <code>lastIndex=1</code>上创建E，更新 <code>lastIndex=1</code></li><li>C，C在旧集合中 <code>index=2</code>,不满足<code>lastIndex&gt;index</code>，不移动，更新 <code>lastIndex=Math.max(lastIndex,index)=2</code></li><li>A，旧集合中 <code>index=0</code>，符合 <code>lastIndex&gt;index</code>，移动，<code>lastIndex还是等于 2</code></li><li>新旧集合对比后，再对旧集合遍历。判断新集合中没有，但是旧集合有的元素D，删除 D，diff 操作结束</li></ol><p><strong>diff 的不足之处与待优化的地方</strong></p><p>情形三：将最后一个元素移动到最前面</p><p><img src="/images/前端面试题目汇总摘录-React 基础篇-react-diff移动3.png" alt="react-diff移动3"></p><p>D,此时D 不移动，但是因为它的 index 最大的，导致 <code>lastIndex=3</code>，从而使得其他元素的 <code>index &lt; lastIndex</code>，导致都要去移动。</p><p>理想的情况是值移动D,不移动 ABC.因此在开发中，应该尽量减少将最后一个节点移动到列表的首部，当节点数量过大或者操作更新过于频繁的时候，会影响到 React 的渲染性能。</p><h3 id="React-JSX"><a href="#React-JSX" class="headerlink" title="React JSX"></a>React JSX</h3><p>React 使用 JSX 来替代常规的 javascript,有几个优点：</p><ul><li>执行更快，在编译为 javascript 代码后进行了优化</li><li>类型安全，在编译过程中就能发现错误</li><li>使用 JSX 编写模板简单快速</li></ul><p>在 React 应用中，元素是构成 React 的最小单位，JSX 就是用来声明 React 当中的元素。</p><p>与浏览器的 DOM 元素不同，React 当中的元素是普通的对象，ReactDOM 可以确保浏览器的数据内容与 React 元素一致。通过 <code>ReactDOM.render</code>将元素渲染到 DOM 节点上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> App = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"foo "</span> /&gt;</span></span></span><br><span class="line">ReactDOM.render(&lt;App&gt;,document.getElementById('root'))</span><br></pre></td></tr></table></figure><p><strong>原理</strong></p><p>如何用 JavaScript 元素来表示一个 DOM 元素的结构:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"content"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span></span><br><span class="line">        Hello</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>Click<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个 DOM 元素包含的信息其实只有三个：标签、属性，子元素，所以上面的内容可以表示为</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tag:'div',</span><br><span class="line">    attrs:&#123;className:'box',id:'content'&#125;,</span><br><span class="line">    children:[&#123;</span><br><span class="line">        tag:'div',</span><br><span class="line">        attrs&#123;className:'title'&#125;,</span><br><span class="line">        children:['Hello']</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        tag:'button',</span><br><span class="line">        attrs:null,</span><br><span class="line">        children:['Click']</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用 javaScript 有个缺点就是内容太长，结构不够清晰，用 HTML 的方式会方便很多。而 React 把 javascript 扩展了一下，让 javascript 能够支持直接在 javascript 代码中编写类似 HTML 标签结构的语法。编译的过程中会把类似 HTML 的 JSX 结构转换成为 javascript 的对象结构。例如下面的代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'/index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1 className=<span class="string">'title'</span>&gt;React JSX&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;MyComponent /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElememtById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>经过编译后：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">'/index.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            React.createElement(</span><br><span class="line">                <span class="string">'div'</span>,</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                React.createElement(</span><br><span class="line">                <span class="string">'h1'</span>,</span><br><span class="line">                &#123;<span class="attr">className</span>:<span class="string">'title'</span>&#125;,</span><br><span class="line">                <span class="string">"React JSX"</span></span><br><span class="line">                )</span><br><span class="line">            )</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    React.createElement(MyComponent,<span class="literal">null</span>)</span><br><span class="line">    <span class="built_in">document</span>.getElememtById(<span class="string">'root'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>React.createElement</code> 会构建一个 JavaScript 对象来描述 HTML 结构的信息，包括标签名，属性，还有子元素等等。</p><p><strong>所谓的JSX 其实就是 JavaScript 对象</strong></p><p><code>React.render</code>功能就是把组件渲染并且构造 DOM 树，然后插入到页面上特定的元素上。</p><p>总结过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Babel 编译 +   </span><br><span class="line">React.js 构造           ReactDOM.render</span><br><span class="line">JSX -----&gt; JavaScript 对象结构 -----&gt; DOM 元素 -----&gt; 插入页面</span><br></pre></td></tr></table></figure><h3 id="React-生命周期函数"><a href="#React-生命周期函数" class="headerlink" title="React 生命周期函数"></a>React 生命周期函数</h3><h4 id="React-v16-0-前的生命周期"><a href="#React-v16-0-前的生命周期" class="headerlink" title="React v16.0 前的生命周期"></a>React v16.0 前的生命周期</h4><p>分成四个阶段 Initialization、Mounting、Updation、Unmounting</p><h4 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a><strong>Initialization</strong></h4><p>setup props and states</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React,&#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test 类继承 react 的基本类，拥有了 render ，生命周期等等方法可以使用。</p><p><code>super(props)</code>，用来调用基类的构造方法（constructor()），将父组件中的props 注入给子组件，供其读取。</p><p>使用ES6 classes构建组件的时候<strong>static defaultProps={}</strong>其实就是调用内部的<strong>getDefaultProps</strong>方法。</p><p><code>constructor</code>可以做一些组件初始化的功能，例如初始化 <code>state</code>,就是调用内部的 <code>getIntialState</code>方法</p><h4 id="Mounting"><a href="#Mounting" class="headerlink" title="Mounting"></a><strong>Mounting</strong></h4><p>getDefaultProps =&gt; getInitialState =&gt; componentWillMount =&gt; render =&gt; componentDidMount</p><ul><li>componentWillMount</li></ul><p>在组件挂载到 DOM 之前调用且只会被调用一次，这里调用 <code>setState</code>不会引起组件重新渲染，也可以把这边的内容写在 <code>constructor</code>中。另外 在 React SSR 中，这个生命周期函数很重要。React-Helmet等等插件都是根据这个函数来实现在 Server 插入内容</p><ul><li>render</li></ul><p>根据组件的 <code>props</code>和 <code>state</code>，返回一个 React 元素，不负责组件的实际渲染工作，之后 React 根据元素去渲染 页面的 DOM 工作。render 是纯函数，不能在里面执行 <code>this.setState</code>，会有改变组件状态的副作用</p><ul><li>componentDidMount</li></ul><p>组件挂载到 DOM 后调用，且只会被调用一次</p><h4 id="Updation"><a href="#Updation" class="headerlink" title="Updation"></a><strong>Updation</strong></h4><p>props:</p><p>componentWillReciveProps =&gt; shouldComponentUpdate =&gt; ComponentWillUpdate =&gt; render =&gt; componentDidUpdate</p><p>states:</p><p>shouldComponentUpdate =&gt; componentWillUpdate =&gt; render =&gt; componentDidUpdate</p><p><strong>造成组件更新的情况有两类（三种）情况</strong></p><p>1.父组件重新 render</p><p>父组件重新 render 引起子组件重新 render 的情况有两种</p><p>a) 直接使用，每当父组件重新 render 导致 重传 <code>props</code>,子组件将跟着重新渲染，无论 <code>props</code> 知否有变化，可通过 <code>shouldComponentUpdate</code>方法优化</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    shouldComponentUpdate(nextProps)&#123; <span class="comment">// 使用这个方法，可以避免无论 props 是否有更新都会导致组件跟着渲染</span></span><br><span class="line">        <span class="keyword">if</span>(nextProps.somethings === <span class="keyword">this</span>.props.somethings)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        render()&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.sometings&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>b) 在 <code>componentWillReceiveProps</code>方法中，将 <code>props</code> 换成自己的 <code>state</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            sometings:props.somethings</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillReceiveProps(nextProps)&#123;</span><br><span class="line">        <span class="comment">// 父组件重传 props 时会调用这个方法</span></span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">something</span>:nextProps.somethings&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.sometings&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官网的描述，在 <code>componentWillReceiveProps</code>中调用 <code>this.setState()</code>不会引起第二次渲染</p><p>是因为 <code>componentWillReceiveProps</code>中判断 <code>props</code>是否变化了，如果变化了， <code>this.setState</code>将引起 <code>state</code>的变化，从而引起 <code>render</code>，此时就没有必要再做第二次重传 <code>props</code>引起的 <code>render</code>,避免重复做一样的渲染。</p><p>2.组件本身调用 <code>setState</code>，无论 <code>state</code> 是否有变化，可通过 <code>shouldComponentUpdate</code>方法优化</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.state = &#123;</span><br><span class="line">            something:<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    shouldComponentUpdate(nextState)&#123;</span><br><span class="line">        <span class="comment">// 使用这个方法，可以避免相同 state引起 render</span></span><br><span class="line">        <span class="keyword">if</span>(nextState.something === <span class="keyword">this</span>.state.something)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleClick = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> preSomething = <span class="keyword">this</span>.state.something</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;<span class="attr">something</span>:preSomething&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleChild&#125;</span>&gt;</span>&#123;this.state.something&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>componentWillReceviceProps(nextProps)</li></ul><p>这个方法只会调用于<code>props</code> 引起的组件更新过程中，参数 <code>nextProps</code>是父组件传给当前组件的新 <code>props</code>。但是父组件 <code>render</code>方法的调用不能保证重传给当前组件的 <code>props</code> 是否有变化，所以在此方法根据 <code>nextProps</code>和 <code>this.props</code>来查明重传的 <code>props</code>是否有变化，以及如果改变了要执行什么，例如根据新的 <code>props</code>调用 <code>this.setState()</code>触发当前组件重新 <code>render</code></p><ul><li>shouldComponentUpdate(nextProps,nextState)</li></ul><p>通过比较 <code>nextProps</code>，<code>nextState</code>以及 <code>this.state</code>,<code>this.props</code>返回 true 时当前组件将继续执行更新过程，返回 false 当前组件停止更新，从而来减少组件的不必要的渲染，优化组件性能。</p><ul><li>componentWillUpdate(nextProps,nextState)</li></ul><p>在 调用 render 之前调用，在这里可以执行一些组件更新前的工作，一般比较少用</p><ul><li>componentDidUpdate(prevProps,prevState)</li></ul><p>这个方法组件更新后调用，可以操作组件更新的 DOM,<code>prevProps</code>，<code>prevState</code>这两个参数是指组件更新前的 <code>props</code> 和 <code>state</code></p><h4 id="Unmounting"><a href="#Unmounting" class="headerlink" title="Unmounting"></a><strong>Unmounting</strong></h4><p>componentWillUnMount</p><ul><li>componentWillUnMount</li></ul><p>这个方法在组件被卸载前调用，可以在这里执行一些清理工作。例如组件中使用的定时器，componentDidMount 中手动创建的 DOM 元素等等，可以避免内存泄露</p><p>具体实现可以看看这篇文章，<a href="https://segmentfault.com/a/1190000018499749">一次性搞懂 React 生命周期</a></p><h4 id="React-v-16-4-的生命周期"><a href="#React-v-16-4-的生命周期" class="headerlink" title="React v.16.4 的生命周期"></a>React v.16.4 的生命周期</h4><p><a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">图</a></p><p><img src="/images/前端面试题目汇总摘录-React 基础篇-react-v16.4-生命周期函数图.png" alt="v.16.4"></p><h4 id="变更缘故"><a href="#变更缘故" class="headerlink" title="变更缘故"></a>变更缘故</h4><p>生命周期在React v16 推出 Fiber 后就不合适了，如果开启 <code>async rendering</code>，在 <code>render</code>函数之前的所有函数，都有可能被执行多次。</p><p>v.16 前的生命周期中,<code>componentWillMount</code>,<code>componentReceiveProps</code>,  <code>shouldComponentUpdate</code>,<code>componentWillUpdate</code>是在 <code>render</code>之前执行的。</p><p>开发者如果开启了 <code>async rendering</code>，而且在上述的生命周期方法做 ajax 请求的话，那就将会被无谓多次调用。明显不是我们期望的结果。在 <code>componentWillMount</code>请求 ajax ,不管多快的结果都跟不上首次 <code>render</code>，而且 <code>componentWillMount</code>在服务器渲染也会被调用到，这样的 IO 操作放在 <code>componentDidMount</code>里面更加适合。</p><p>禁止不能用比劝导开发者不要这样用更好，所以除了 <code>shouldComponentUpdate</code>，其他在 <code>render</code>函数之前的所有函数 <code>componentWillMount</code>、<code>componentWillReceiveProps</code>，<code>componentWillUpdate</code>都被 <code>getDerivedStateFromProps</code>替代。</p><p>就是用一个静态函数 <code>getDerivedStateFromProps</code>来取代被 <code>deprecate</code>的几个生命周期函数，强制开发者在 <code>render</code>之前只做无副作用的操作，而且能做的操作局限在根据 <code>props</code>和 <code>state</code>决定新的 <code>state</code></p><p><a href="https://react.docschina.org/docs/react-component.html?no-cache=1#static-getderivedstatefromprops">官网API-getDerivedStateFromProps()</a></p><p><a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html">关于更多</a></p><p>v16.0 刚推出的时候，增加了一个 <code>componentDidCatch</code> 生命周期函数，新引入的两个生命周期函数:<code>getDerivedStateFromProps</code>和 <code>getSnapshotBeforeUpdate</code></p><ul><li>getDerivedStateFromProps</li></ul><p><code>getDerivedStateFromProps</code>在v.16.3 中只是创建和更新（由父组件引发的）。如果不由父组件引发，这个方法是不会调用的，如自身的 <code>setState</code> 和 <code>forceUpate</code>引发的。</p><p>在 v.16.4  中改正了这一点，让 <code>getDerivedStateFromProps</code> 无论是 <code>Mounting</code> 还是 <code>Updating</code>,也无论是因为什么引起的 <code>Updating</code>全部都会被调用。</p><p><em>static getDerivedStateFromProps(props,state)</em>在组件创建时和更新时的 <code>render</code>方法之前调用，它应该返回一个对象来更新状态，或者返回 null 来不更新任何内容</p><ul><li>getSnapshotBeforeUpadate</li></ul><p><code>getSnapshotBeforeUpdate</code>被调用于 <code>render</code> 之后，可以读取但是无法使用 DOM 的时候。它使得组件可以在可能更改之前从 DOM 中捕获一些信息（例如滚动位置）。这个生命周期返回的任何值都将作为参数传递给 <code>componentDidUpdate</code></p><p>官网的例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ScrollingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(props)&#123;</span><br><span class="line">        <span class="keyword">super</span>(props);</span><br><span class="line">        <span class="keyword">this</span>.listRef = React.createRef();</span><br><span class="line">    &#125;</span><br><span class="line">    getSnapshotBeforeUpdate(nextProps,prevState)&#123;</span><br><span class="line">        <span class="comment">// 我们是否要添加新的 items 到列表中，捕获滚动位置以便我们可以稍后整理滚动</span></span><br><span class="line">        <span class="keyword">if</span>(prevProps.list.length &lt; <span class="keyword">this</span>.props.list.length)&#123;</span><br><span class="line">            <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">            <span class="keyword">return</span> list.scrollHeight - list.scrollTop</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidUpdate(prevProps,prevState,snapshot)&#123;</span><br><span class="line">        <span class="comment">// 如果我们有 snapshot 值，我们已经添加新的 items，调整滚动以至于这些新的 items，不会将就的 items 推出视图。</span></span><br><span class="line">        <span class="keyword">if</span>(snapshot)&#123;</span><br><span class="line">            <span class="keyword">const</span> list = <span class="keyword">this</span>.listRef.current;</span><br><span class="line">            list.scrollTop = list.scrollHeight - snapshot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="keyword">return</span>(</span><br><span class="line">            &lt;div ref=&#123;<span class="keyword">this</span>.listRef&#125;&gt;&#123;<span class="comment">/* ...contents */</span>&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        )</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>另外可以看看这篇文章，<a href="https://www.imooc.com/article/39395">你可能不需要派生状态</a></p><h3 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h3><p>官方的解释:</p><p><strong>React Fiber 是对核心算法的一次重新实现</strong></p><h4 id="同步更新过程的局限"><a href="#同步更新过程的局限" class="headerlink" title="同步更新过程的局限"></a><strong>同步更新过程的局限</strong></h4><p>v16 之前，更新过程是同步的，这可能会导致性能问题。</p><p>React 决定要加载或者更新组件树的时候，会做很多事情，比如调用各个组件的生命周期函数，计算和对比 Virtual DOM ,最后更新 DOM 树，这整个过程是同步进行的，也就是说只要一个加载或者更新过程开始，那么 React 就会一直更新下去，中途不会停歇。</p><p>表面看，这样的设计也是合理的，更新过程中不会有 I/O 操作，完全是 CPU 计算，所以不需异步操作。但是当组件书比较庞大的时候，问题就来了。</p><p>例如更新一个组件需要1毫秒，如果有200个组件需要更新，那就有200毫秒。用户在 input 按钮输入一个子，要等待200毫秒才会有反应，造成界面卡顿，带来不好的用户体验。</p><p>另外一个生动的比较就是潜水员的比喻，潜水员进行潜水任务，在潜到底的过程中，如果岸上有更加优先的任务他是不知道的，只有当他重新浮出水面才能去执行优先级更高的任务。</p><p>因为 javascript 单线程的特点，每个同步任务的耗时不能太长，不然就会让程序不会对其他输入做出反应，React 的更新就是犯了这个禁止，而 React Fiber 是要改变现状。</p><h4 id="React-Fiber-1"><a href="#React-Fiber-1" class="headerlink" title="React Fiber"></a>React Fiber</h4><p>分片是破解 Javascript 同步操作时间过长的方法。</p><p>把一个耗时长的任务分成很多小片，每一个小片的运行时间都很短，虽然总时间依然很长，但是在每个小片执行之后，都给其他任务一个执行的机会，这样唯一的线程就不会被独占，其他任务依然有运行的时间。</p><p>React Fiber 把更新过程碎片化，每执行一段更新过程，就把控制权交还给 React 负责任务协调的模块，看看有没有其他紧急任务要做，如果没有就继续去更新，如果有紧急任务，那就去做紧急任务。</p><p>维护每一个分片的数据结构，就是 Fiber</p><h4 id="为什么叫-Fiber"><a href="#为什么叫-Fiber" class="headerlink" title="为什么叫 Fiber"></a>为什么叫 Fiber</h4><p>在计算机科学中，Fiber 的含义是 “纤维”，意指比 Thread(线程) 更细的线，也就是比线程控制更精密的并发处理机制。</p><h4 id="React-Fiber-对现有代码的影响"><a href="#React-Fiber-对现有代码的影响" class="headerlink" title="React Fiber 对现有代码的影响"></a>React Fiber 对现有代码的影响</h4><p>在 React Fiber 中，一次更新过程会分成多个分片完成，所以完全可能一个更新任务还没有完成，会被另一个更高优先级的更新过程打断，这时候，<strong>优先级的更新任务会优先处理完，而低优先级更新任务所做的工作则会完全作废，然后等待机会重头再来。</strong></p><p>因为一个更新过程可能会被打断，所以 React Fiber 更新过程会被分成两个阶段（Phase）：第一个阶段 Reconciliation 和 第二个阶段 Commit Phase.</p><p>在第一个阶段中，React Fiber 会找出需要更新哪些 DOM,这个阶段可以被打断，但是到了第二个阶段，那就是一鼓作气把 DOM 更新完成，不会被打断。</p><p>这两个阶段大部分工作是结合 React Fiber 和 生命周期函数。</p><p>以 <code>render</code> 为界，第一个阶段可能会调用下面这些生命周期函数：</p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li></ul><p>下面这些生命周期函数则会在第二个阶段调用</p><ul><li>componentDidMount</li><li>componentDidUpdate</li><li>componentWillUnmount</li></ul><p>因为第一个阶段会被打断，重新再来，会造成意想不到的情况。</p><p>比如说，一个低优先级的任务 A 正在执行，已经调用了某个组件的 <code>componentWillUpdate</code>函数，接下来发现自己的时间分片已经用完了，于是冒出水面，看看有没有紧急任务，发现有个紧急任务B，接下来 React Fiber 就去执行这个紧急任务B。任务A 虽然执行了一半，但是没有办法，只能完全放弃，等到任务B 完成后，任务 A 重头来一遍，也就是说 <code>componentWillUpdate</code>函数会被再重新调用一次。</p><p>在现有的 React 中，每个生命周期函数在一个加载或者更新过程中决定只会被调用一次，在 React Fiber 中，不再是这样了，第一阶段的声生命周期函数在一次加载和更新过程中可能会被多次调用。</p><p>使用 React Fiber 之后，一定要检查一下第一阶段相关的这些生命周期函数，看看有没有逻辑是假设在一个更新过程中只调用一次的，有的话就要改了。</p><p>看看可能会重复调用的函数</p><p><code>componentWillReceiveProps</code>即使当前组件不更新，只要父组件更新也会引起和这个函数被调用多次，调用多次无妨</p><p><code>shouldComponentUpdate</code>这个函数的作用是返回一个 true 或者 false，不应该有任何副作用，调用多次无妨</p><p><code>render</code> 是纯函数，调用多次无妨</p><p>剩下 <code>componentWillMount</code> 和 <code>componentWillUpdate</code>这两个函数往往包含副作用，所以当使用 React Fiber 的时候一定要重点看这两个函数的实现。</p><h3 id="this-setState-异步原因以及更新机制"><a href="#this-setState-异步原因以及更新机制" class="headerlink" title="this.setState 异步原因以及更新机制"></a>this.setState 异步原因以及更新机制</h3><h4 id="现象"><a href="#现象" class="headerlink" title="现象"></a><strong>现象</strong></h4><p>在 React 中，如果是由 React 引发的事件处理（比如通过 onClick 引发的合成事件处理）和组件生命周期函数内（比如 <code>componentDidMount</code>），调用 <code>this.setState</code> 不会同步更新 <code>this.state</code>，除此之外的 <code>setState</code> 调用会同步执行 <code>this.state</code>。除此之外指的是绕过 React 通过 <code>addEventListener</code> 直接添加的事件处理函数，还有通过 <code>setTimeout</code>/<code>setInterval</code> 产生的异步调用。另外在合成事件和生命周期函数中的异步调用 <code>setState</code>（比如 <code>ajax</code> 和 <code>setTimeout</code>） 也是会同步更新 <code>this.setState</code></p><h4 id="保证内部（数据）的统一"><a href="#保证内部（数据）的统一" class="headerlink" title="保证内部（数据）的统一"></a>保证内部（数据）的统一</h4><p>假设 setState 是同步的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value); <span class="comment">//0</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>:<span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value); <span class="comment">//1</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>:<span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.state.value); <span class="comment">//2</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>:<span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>这种只用到了 state 的情况下，同步 setState 是可以的。</p><p>然而这时需要将状态提升到父组件，以供多个兄弟组件共享：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.props.value) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">this</span>.props.onIncrement();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.props.value) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">this</span>.props.onIncrement();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.props.value) <span class="comment">// 0</span></span><br><span class="line"><span class="keyword">this</span>.props.onIncrement();</span><br></pre></td></tr></table></figure><p>在同步模型中，虽然 this.state 会立即更新，但是 this.props 并不会。而且在没有重渲染父组件的情况下，我们不能立即更新 this.props。如果要立即更新 this.props(立即重新渲染父组件)，必须放弃批处理（根据不同的情况，性能可能有显著下降）</p><p>所以为了解决这样的问题，在 React 中，this.state 和 this.props 都是异步更新的，在上面的例子中重构前后都会打印出0，这让状态提升更加安全。</p><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>我们通常认为状态更新会按照既定顺序被应用，无论 state 是同步更新还是异步更新，然而事实并不一定如此。</p><p>React 会依据不同的调用源，给不同的 setState 调用分配不同的优先级。调用源包括事件处理、网络请求、动画等。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用法1</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;&#125;,()=&gt;&#123;&#125;)</span><br><span class="line"><span class="comment">// 用法2</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">()</span>=(<span class="params">&#123;&#125;</span>),<span class="params">()</span>=&gt;</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数1：对象，key是 this.state 中key值，val 是修改后的值</span></span><br><span class="line"><span class="comment">// 参数2：函数，可查看数据是否更新完成，获取到数据更新后的最新 dom 结构</span></span><br></pre></td></tr></table></figure><p><strong>不要直接修改 state</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.state.comment = <span class="string">'Hello'</span> (X)</span><br></pre></td></tr></table></figure><p><strong>state  更新可能会异步</strong></p><p>从上面也知道了，React 为了性能优化，有可能会将多个 setState 调用合并为一次更新，因为 this.props 与 this.state  可能是异步更新的，你不可能依赖他们的值进行下一个 state 的计算</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">counter</span>:<span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment&#125;) (X)</span><br></pre></td></tr></table></figure><p>为了弥补这个问题，使用了另一种 setState 形式，接受一个函数。这个函数接收前一个状态作为第一个参数，应用更新时的 props 作为第二个参数，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState,props</span>)=&gt;</span>&#123;</span><br><span class="line">    counter:prevState.counter + props.increment</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>多次setState函数调用产生的效果会合并</strong></p><p>当调用 setState ,React 会合并你提供的对象到当前的状态。所以当 state 是一个多键值的结构，可以单独更新其中一个，此时会 差分 更新，不会影响到其他的属性值</p><p>总结起来就是：</p><ol><li>setState 不会立刻改变 React 组件中的 state</li><li>setState 通过触发一次组件的更新来引发重绘</li><li>多次 setState 函数嗲用产生的效果会合并</li></ol><p>重绘指的更新的生命周期函数：</p><ul><li><code>shouldComponentUpdate</code>:被调用时 this.state 没有更新，如果返回 false，生命周期被中断，虽然不调用之后的函数，但是 state 仍然会被更新</li><li><code>componentWillUpdate</code>：被调用时 this.state 没有更新</li><li><code>render</code>：被调用时 this.state 得到更新</li><li><code>componentDidUpdate</code></li></ul><p>React会将setState的效果放在队列中，积攒着一次引发更新过程。为的就是把Virtual DOM和DOM树操作降到最小，用于提高性能。</p><p><strong>执行setState 后拿到最新的 state</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">updateData = <span class="function">(<span class="params">newData</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(</span><br><span class="line">        &#123;<span class="attr">data</span>:newData&#125;,</span><br><span class="line">        () =&gt;&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.data)</span><br><span class="line">        &#125; </span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="setState-更新机制"><a href="#setState-更新机制" class="headerlink" title="setState 更新机制"></a>setState 更新机制</h4><p><strong>循环调用风险</strong></p><p>不要在 <code>shouldComponentUpdate</code>和 <code>componentWillUpdate</code>中调用 <code>setState</code>，不然会出现死循环</p><p>在调用 <code>setState</code>时候实际上会执行 <code>enqueueSetState</code>方法，并对 <code>partialState</code>、<code>pendingStateQueue</code>更新队列进行合并操作，最终通过 <code>enqueueUpdate</code>执行 state 更新。</p><p>而 <code>performUpdateIfNecessary</code>方法会获取 <code>pendingElement</code>、<code>pendingStateQueue</code>、<code>pendingForceUpdate</code>并调用 <code>receiveComponent</code>和 <code>updateComponent</code>方法进行组件更新</p><p>如果在 <code>componentWillUpdate</code> 和 <code>shouldComponentUpdate</code> 中调用 <code>setState</code>，此时 <code>pendingStateQueue !== null</code>则 <code>performUpdateIfNessary</code> 会调用 <code>updateComponent</code> 进行组件更新，而 <code>updateComponent</code>又会调用 <code>shouldComponentUpdate</code> 和 <code>componentWillUpdate</code>这样就导致了循环调用</p><p>setState 源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React 组件继承自 React.Component，而 SetState 是 React.Component 的方法，对于组件来说，setState 属于其原型方法</span></span><br><span class="line"><span class="comment">// 在 React 中每个组件都拥有一个 this.updater，是用来驱动 state 更新的工具对象。当我们在构造函数中调用 super 的时实质调用的就是函数 ReactComponent</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactComponent</span>(<span class="params">props,context,updater</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">    <span class="keyword">this</span>.context = context;</span><br><span class="line">    <span class="keyword">this</span>.refs = emptyObject;</span><br><span class="line">    <span class="comment">// ReactNoopUpdateQueue 实际是没有什么意义的，只相当于是一个初始化的过程。而 ReactNoopUpdateQueue.enqueueSetState 主要起到一个在非生产版本中警告的作用。真正的 updater 是在 renderer 中注入（inject）。因此如果在 constructor 尝试调用 this.helper.isMount会返回 false，表示并没有安装（mount），如果你调用 setState，也会给出响应的警告</span></span><br><span class="line">    <span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue;</span><br><span class="line">&#125;</span><br><span class="line">ReactComponent.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">partialState,callback</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 调用 enqueueSetState 将 setState 事务放进队列中</span></span><br><span class="line">    <span class="comment">// partialState 可以传 Object,也可以传 function,会产生新的 state 以一种 Object.assign() 的方式跟旧的 state 进行合并</span></span><br><span class="line">    <span class="comment">// 参数 this 是组件的实例</span></span><br><span class="line">    <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>,partialState);</span><br><span class="line">    <span class="keyword">if</span>(callback)&#123;</span><br><span class="line">        <span class="keyword">this</span>.updater.enqueueCallback(<span class="keyword">this</span>,callback,<span class="string">'setState'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ReactUpdateQueue = &#123;</span><br><span class="line">    <span class="comment">// 实际通过 enqueueSetState 执行</span></span><br><span class="line">    <span class="comment">// 1.将新的 state 放进数组</span></span><br><span class="line">    <span class="comment">// 2.用 enqueueUpdate 来处理将要更新的实例对象</span></span><br><span class="line">    enqueueSetState：<span class="function"><span class="keyword">function</span>(<span class="params">publicInstance,partialState</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 获取当前组件的 instance，里面有很多属性，主要关注 pendingState(待更新队列)，pendingCallbacks(更新回调队列)</span></span><br><span class="line">        <span class="keyword">const</span> internalInstance = getInernalInstanceReadyForUpdate(</span><br><span class="line">            publickInstance,</span><br><span class="line">            <span class="string">'setState'</span></span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span>(!inernalInstance) <span class="keyword">return</span></span><br><span class="line">        <span class="comment">// 更新队列合并操作</span></span><br><span class="line">        <span class="keyword">const</span> queue = internalInstance._pendingStateQueue || （internalInstance._pendingStateQueue = []）</span><br><span class="line">        <span class="comment">// partialState 可以理解为之前的 state</span></span><br><span class="line">        queue.push(partialState)</span><br><span class="line">        <span class="comment">// 最终通过 enqueueUpdate 更新，将新的 component instance 放入一个队列</span></span><br><span class="line">        enqueueUpdate(internalInstance)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果存在 _pendingElement、_pendingStateQueue 和 _pendingForceUpdate 则更新组件</span></span><br><span class="line">    performUpdateIfNessary:<span class="function"><span class="keyword">function</span>(<span class="params">transaction</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>._pendingElement != <span class="literal">null</span>)&#123;        ReactReconciler.receiveComponent(<span class="keyword">this</span>,<span class="keyword">this</span>._pendingElement,transaction,<span class="keyword">this</span>._context)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>._pendingStateQueue !== <span class="literal">null</span> || <span class="keyword">this</span>._pendingForceUpdate)&#123;        <span class="keyword">this</span>.updateComponent(transaction,<span class="keyword">this</span>._currentElement,<span class="keyword">this</span>._currentElement,<span class="keyword">this</span>._context)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>setState 调用栈</strong></p><pre class="mermaid">graph TDA[this.setState]B[newState存入pending队列]C{是否处于 batch update}D(保存组件在 dirtyComponent中)E(遍历所有的dirtyComponents 调用updateComponent 更新 pending state or props)F[调用enqueueUpdate]A --> BB --> FF --> CC == Y ==> DC == N ==> E</pre><p>React的setState函数实现中，会根据一个变量 <code>isBatchingUpdates</code> 判断是 直接更新 this.state还是 放到队列 中。</p><p><code>isBatchingUpdates</code>默认<code>false</code>，表示setState会同步更新this.state，但是函数<code>batchedUpdates</code>函数会把<code>isBatchingUpdates</code>修改为<code>true</code>。当React在调用事件处理函数之前就会调用<code>batchedUpdates</code>，造成的后果，就是由React控制的事件处理过程setState不会同步更新this.state。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">internalInstance</span>)</span>&#123;</span><br><span class="line">    ReactUpdates.enqueueUpdate(internalInstance)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> ReactUpdates = &#123;</span><br><span class="line">    enqueueUpdate:<span class="function"><span class="keyword">function</span> <span class="title">enqueueUpdate</span>(<span class="params">component</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 保证 ReactUpdates.ReactReconcileTransaction 与 batchingStrategy 是存在的，否则给出对应的警告</span></span><br><span class="line">        ensureInjected();</span><br><span class="line">        <span class="comment">// 如果不处于批量更新模式</span></span><br><span class="line">        <span class="keyword">if</span>(!batchingStrategy.isBatchingUpdates)&#123;</span><br><span class="line">            <span class="comment">// 调用事务</span></span><br><span class="line">            batchingStrategy.batchedUpdates(enqueueUpdate,component)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果处于批量更新模式,将组件放入脏组件队列，也就是待更新组件队列</span></span><br><span class="line">        dirtyComponents.psuh(component);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// batchingStrategy。实质上是一种批量更新策略</span></span><br><span class="line"><span class="keyword">const</span> ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">    isBatchingupdates:<span class="literal">false</span>,</span><br><span class="line">    batchedUpdates:<span class="function"><span class="keyword">function</span>(<span class="params">callback,a,b,c,d,e</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates</span><br><span class="line">        ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span>(callback)&#123;</span><br><span class="line">            callback(a,b,c,d,e)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            transaction.perform(callback,<span class="literal">null</span>,a,b,c,d,e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Transaction</strong></p><p>关于 React 中的事务 Transaction,源码中有这样的 ASCII图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * &lt;pre&gt;</span><br><span class="line"> *                       wrappers (injected at creation time)</span><br><span class="line"> *                                      +        +</span><br><span class="line"> *                                      |        |</span><br><span class="line"> *                    +-----------------|--------|--------------+</span><br><span class="line"> *                    |                 v        |              |</span><br><span class="line"> *                    |      +---------------+   |              |</span><br><span class="line"> *                    |   +--|    wrapper1   |---|----+         |</span><br><span class="line"> *                    |   |  +---------------+   v    |         |</span><br><span class="line"> *                    |   |          +-------------+  |         |</span><br><span class="line"> *                    |   |     +----|   wrapper2  |--------+   |</span><br><span class="line"> *                    |   |     |    +-------------+  |     |   |</span><br><span class="line"> *                    |   |     |                     |     |   |</span><br><span class="line"> *                    |   v     v                     v     v   | wrapper</span><br><span class="line"> *                    | +---+ +---+   +---------+   +---+ +---+ | invariants</span><br><span class="line"> * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained</span><br><span class="line"> * +-----------------&gt;|-|---|-|---|--&gt;|anyMethod|---|---|-|---|-|--------&gt;</span><br><span class="line"> *                    | |   | |   |   |         |   |   | |   | |</span><br><span class="line"> *                    | |   | |   |   |         |   |   | |   | |</span><br><span class="line"> *                    | |   | |   |   |         |   |   | |   | |</span><br><span class="line"> *                    | +---+ +---+   +---------+   +---+ +---+ |</span><br><span class="line"> *                    |  initialize                    close    |</span><br><span class="line"> *                    +-----------------------------------------+</span><br><span class="line"> * &lt;/pre&gt;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p>React 中的事务 Transaction，会给方法包装一个个 wrapper，其中每个 wrapper 都有两个方法：initialize 与 close。当执行方法时，需要执行事务的 perform 方法。这个方法会首先一次执行 wrapper 的 initialize,然后执行函数本身，最后执行 wrapper 的 close 方法</p><p>定义 Transaction 需要给构造函数混入 Transaction.Mixin，并需要提供一个原型方法 getTransactionWrappers 用于返回 wrapper 数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> RESET_BATCHED_UPDATES = &#123;</span><br><span class="line">    initialize:emptyFuntion,</span><br><span class="line">    colse:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 重置为 false</span></span><br><span class="line">        ReactDefaultBatchingStrategy.isBatchingUpdates = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> FLUSH_BATCHED_UPPDATES = &#123;</span><br><span class="line">    initialize:emptyFunction,</span><br><span class="line">    close:ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES,RESET_BATCHED_UPDATES]；</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReactDefaultBatchingStrategyTransaction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.reinitializeTransaction();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Object</span>.assign(</span><br><span class="line">    ReactDefaultBatchingStrategyTransaction.prototype,</span><br><span class="line">    Transaction.Mixin,&#123;</span><br><span class="line">        getTransactionWrappers:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> TRANSACTION_WRAPPERS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> transaction = <span class="keyword">new</span> ReactDefaultBatchingStrategyTransaction();</span><br></pre></td></tr></table></figure><p>重新回顾一下更新的过程，如果处于批量更新的过程中（<code>isBatchingUpdates</code>为 true）的时候，则直接将组件传入 <code>dirtyComponents</code>。如果不是的话，就开启批量更新，用事务 <code>transaction.perform</code>执行 <code>enqueueUpdate</code>，这时候 <code>isBatchingUpdates</code>经过上次执行已经是 true，将直接传入 <code>dirtyComponents</code>。那么更新的组件传入 <code>dirtyComponent</code>会发生什么？</p><p><code>batchUpdates</code>是处于一个事务中的，该事务在 close 阶段做了两件事，首先是将 <code>ReactDefaultBatchingStrategy.isBatchingUpdates</code>设置为 false，即关闭批量更新的标志位，第二个就是调用方法 <code>ReactUpdates.flushBatchedUpdates</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码有省略</span></span><br><span class="line"><span class="keyword">var</span> flushBatchedUpdates = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(dirtyComponents.length)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dirtyComponents.length)&#123;</span><br><span class="line">            <span class="keyword">var</span> transaction = ReactUpdatesFlushTransaction.getPooled();</span><br><span class="line">            <span class="comment">// 以事务的方式执行了 runBatchedUpdates             </span></span><br><span class="line">            transaction.perform(runBatchedUpdates,<span class="literal">null</span>,transaction);</span><br><span class="line">            ReactUpdatesFlushTransaction.release(transaction)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runBatchedUpdates</span>(<span class="params">transaction</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> len = transactiono.dirtyComponentsLength;</span><br><span class="line">    <span class="comment">// 将组件中的 mountOrder 进行了递增排序，目的就是保证更新顺序，父组件保证其子组件之前更新。</span></span><br><span class="line">    dirtyComponents.sort(mountOrderComparator);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="comment">// 在组件中获得 setState 完成之后的回调函数</span></span><br><span class="line">        <span class="keyword">var</span> component = dirtyComponents[i];</span><br><span class="line">        <span class="keyword">var</span> callbacks = component._pendingCallbacks;</span><br><span class="line">        component._pendingCallbacks = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        ReactReconciler.performUpdateIfNessary(component,transaction.reconcileTransaction)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span>(callbacks)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>;j&lt;callbacks.length;j++)&#123;</span><br><span class="line">                transaction.callbackQueue.enqueue(</span><br><span class="line">                callbacks[j],</span><br><span class="line">                component.getPublickInstance()</span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// performUpdateIfNessary 执行组件实例的原型方法performUpdateIfNecessary</span></span><br><span class="line">performUpdateIfNessary:<span class="function"><span class="keyword">function</span>(<span class="params">internalInstance,transaction</span>)</span>&#123;</span><br><span class="line">    interbalInstance.performUpdateIfNecessary(transaction)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略版本</span></span><br><span class="line"><span class="keyword">var</span> ReactCompositeComponentMixin = &#123;</span><br><span class="line">    performUpdateIfNecessary:<span class="function"><span class="keyword">function</span>(<span class="params">transaction</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>._pendingStateQueue !==<span class="literal">null</span> || <span class="keyword">this</span>._pendingForceUpdate)&#123;</span><br><span class="line">            <span class="keyword">this</span>.updateComponent(</span><br><span class="line">                transaction,</span><br><span class="line">                <span class="keyword">this</span>._currentElement,</span><br><span class="line">                <span class="keyword">this</span>._currentElement,</span><br><span class="line">                <span class="keyword">this</span>._context,</span><br><span class="line">                <span class="keyword">this</span>._context</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">updateComponent: <span class="function"><span class="keyword">function</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">    prevParentElement,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextParentElement,</span></span></span><br><span class="line"><span class="function"><span class="params">    prevUnmaskedContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextUnmaskedContext</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance;</span><br><span class="line">    <span class="keyword">var</span> willReceive = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> nextContext;</span><br><span class="line">    <span class="keyword">var</span> nextProps;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证组件context是否改变</span></span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证是否是props更新还是组件state更新</span></span><br><span class="line">    <span class="keyword">if</span> (prevParentElement === nextParentElement) &#123;</span><br><span class="line">      nextProps = nextParentElement.props;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//存在props的更新  </span></span><br><span class="line">      nextProps = <span class="keyword">this</span>._processProps(nextParentElement.props);</span><br><span class="line">      willReceive = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据条件判断是否调用钩子函数componentWillReceiveProps</span></span><br><span class="line">    <span class="keyword">if</span> (willReceive &amp;&amp; inst.componentWillReceiveProps) &#123;</span><br><span class="line">      inst.componentWillReceiveProps(nextProps, nextContext);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算新的state</span></span><br><span class="line">    <span class="keyword">var</span> nextState = <span class="keyword">this</span>._processPendingState(nextProps, nextContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> shouldUpdate =</span><br><span class="line">      <span class="keyword">this</span>._pendingForceUpdate ||</span><br><span class="line">      !inst.shouldComponentUpdate ||</span><br><span class="line">      inst.shouldComponentUpdate(nextProps, nextState, nextContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldUpdate) &#123;</span><br><span class="line">      <span class="keyword">this</span>._pendingForceUpdate = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">this</span>._performComponentUpdate(</span><br><span class="line">        nextParentElement,</span><br><span class="line">        nextProps,</span><br><span class="line">        nextState,</span><br><span class="line">        nextContext,</span><br><span class="line">        transaction,</span><br><span class="line">        nextUnmaskedContext</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._currentElement = nextParentElement;</span><br><span class="line">      <span class="keyword">this</span>._context = nextUnmaskedContext;</span><br><span class="line">      inst.props = nextProps;</span><br><span class="line">      inst.state = nextState;</span><br><span class="line">      inst.context = nextContext;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 计算新的 state 里面调用了 _processPending</span></span><br><span class="line">&#123;</span><br><span class="line">  _processPendingState: <span class="function"><span class="keyword">function</span>(<span class="params">props, context</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance;</span><br><span class="line">    <span class="keyword">var</span> queue = <span class="keyword">this</span>._pendingStateQueue;</span><br><span class="line">    <span class="keyword">var</span> replace = <span class="keyword">this</span>._pendingReplaceState;</span><br><span class="line">    <span class="keyword">this</span>._pendingReplaceState = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">this</span>._pendingStateQueue = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!queue) &#123;</span><br><span class="line">      <span class="keyword">return</span> inst.state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (replace &amp;&amp; queue.length === <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> queue[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> nextState = <span class="built_in">Object</span>.assign(&#123;&#125;, replace ? queue[<span class="number">0</span>] : inst.state);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = replace ? <span class="number">1</span> : <span class="number">0</span>; i &lt; queue.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> partial = queue[i];</span><br><span class="line">      <span class="built_in">Object</span>.assign(</span><br><span class="line">        nextState,</span><br><span class="line">        <span class="keyword">typeof</span> partial === <span class="string">'function'</span> ?</span><br><span class="line">          partial.call(inst, nextState, props, context) :</span><br><span class="line">          partial</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> nextState;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一部分代码相对来说不算是很难，<code>replace</code>是存在是由于之前被废弃的API<code>this.replaceState</code>，我们现在不需要关心这一部分，现在我们可以知道为什么给 <code>setState</code> 传入的参数是函数时，就可以解决 <code>setState</code> 的潜在问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>:<span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="attr">value</span>:<span class="keyword">this</span>.state.value + <span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p>调用 <code>setState</code>是批量更新，那么在第一次调用之后，this.state.value的值并没有发生拜年话。两次更新的指都是一样的。如果传递的是会调用函数形式，那么 <code>partial.call(inst,nextState,props,context)</code>接受的 state 都是上一轮更新之后的新值，因此可以达到我们想要的结果。</p><p><code>_processPendingState</code> 在计算完新的 state 之后会执行 <code>_performComponentUpdate</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_performComponentUpdate</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    nextElement,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextProps,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextState,</span></span></span><br><span class="line"><span class="function"><span class="params">    nextContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    transaction,</span></span></span><br><span class="line"><span class="function"><span class="params">    unmaskedContext</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> inst = <span class="keyword">this</span>._instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> hasComponentDidUpdate = <span class="built_in">Boolean</span>(inst.componentDidUpdate);</span><br><span class="line">    <span class="keyword">var</span> prevProps;</span><br><span class="line">    <span class="keyword">var</span> prevState;</span><br><span class="line">    <span class="keyword">var</span> prevContext;</span><br><span class="line">    <span class="keyword">if</span> (hasComponentDidUpdate) &#123;</span><br><span class="line">      prevProps = inst.props;</span><br><span class="line">      prevState = inst.state;</span><br><span class="line">      prevContext = inst.context;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//  在更新之前，调用钩子函数 componentWillUpdate，然后更新了属性（props,state,context）</span></span><br><span class="line">    <span class="keyword">if</span> (inst.componentWillUpdate) &#123;</span><br><span class="line">      inst.componentWillUpdate(nextProps, nextState, nextContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>._currentElement = nextElement;</span><br><span class="line">    <span class="keyword">this</span>._context = unmaskedContext;</span><br><span class="line">    inst.props = nextProps;</span><br><span class="line">    inst.state = nextState;</span><br><span class="line">    inst.context = nextContext;</span><br><span class="line"><span class="comment">// 执行函数_updateRenderedComponent，涉及到 render 调用和相应的 DOM 更新</span></span><br><span class="line">    <span class="keyword">this</span>._updateRenderedComponent(transaction, unmaskedContext);</span><br><span class="line"><span class="comment">// 最后执行 componentDidUpdate</span></span><br><span class="line">    <span class="keyword">if</span> (hasComponentDidUpdate) &#123;</span><br><span class="line">      transaction.getReactMountReady().enqueue(</span><br><span class="line">        inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext),</span><br><span class="line">        inst</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到目前为止，我们已经基本介绍完了setState的更新过程，只剩一个部分没有介绍，那就是setState执行结束之后的回调函数。我们知道，setState函数中如果存在callback，则会有:　　</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (callback) &#123;</span><br><span class="line">  <span class="keyword">this</span>.updater.enqueueCallback(<span class="keyword">this</span>, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　call函数会被传递给<code>this.updater</code>的函数<code>enqueueCallback</code>，然后非常类似于setState，<code>callback</code>会存储在组件内部实例中的<code>_pendingCallbacks</code>属性之中。我们知道，回调函数必须要setState真正完成之后才会调用，那么在代码中是怎么实现的。大家还记得在函数<code>flushBatchedUpdates</code>中有一个事务<code>ReactUpdatesFlushTransaction</code>:　　</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码有省略</span></span><br><span class="line"><span class="keyword">var</span> flushBatchedUpdates = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (dirtyComponents.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (dirtyComponents.length) &#123;</span><br><span class="line">      <span class="comment">//从事务pool中获得事务实例</span></span><br><span class="line">      <span class="keyword">var</span> transaction = ReactUpdatesFlushTransaction.getPooled();</span><br><span class="line">      transaction.perform(runBatchedUpdates, <span class="literal">null</span>, transaction);</span><br><span class="line">      <span class="comment">//释放实例</span></span><br><span class="line">      ReactUpdatesFlushTransaction.release(transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　我们现在看看<code>ReactUpdatesFlushTransaction</code>的wrapper是怎么定义的:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> UPDATE_QUEUEING = &#123;</span><br><span class="line">  initialize: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackQueue.reset();</span><br><span class="line">  &#125;,</span><br><span class="line">  close: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbackQueue.notifyAll();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>　　我们看到在事务的<code>close</code>阶段定义了<code>this.callbackQueue.notifyAll()</code>,即执行了回调函数，通过这种方法就能保证回调函数一定是在setState真正完成之后才执行的。</p><p>现在可以回答，为什么下面这两种改代码会产生不同的情况：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//未按预期执行</span></span><br><span class="line">_addValue() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        value: <span class="keyword">this</span>.state.value + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        value: <span class="keyword">this</span>.state.value + <span class="number">1</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按预期执行</span></span><br><span class="line">_addValue() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            value: <span class="keyword">this</span>.state.value + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            value: <span class="keyword">this</span>.state.value + <span class="number">1</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一种情况下，如果打断点追踪你会发现，在第一次执行<code>setState</code>前，已经触发了一个 <code>batchedUpdates</code>，等到执行setState时已经处于一个较大的事务，因此两个setState都是会被批量更新的(相当于异步更新的过程，this.state.value值并没有立即改变)，执行setState只不过是将两者的<code>partialState</code>传入<code>dirtyComponents</code>，最后再通过事务的<code>close</code>阶段的<code>flushBatchedUpdates</code>方法去执行重新渲染。但是通过<code>setTimeout</code>函数的包装，两次setState都会在click触发的批量更新<code>batchedUpdates</code>结束之后执行，这两次setState会触发<strong>两次</strong>批量更新batchedUpdates，当然也会执行两个事务以及函数<code>flushBatchedUpdates</code>,这就相当于一个同步更新的过程，自然可以达到我们的目的，这也就解释了为什么React文档中既没有说setState是同步更新或者是异步更新，只是模糊地说到，setState并不保证同步更新。</p><h4 id="DOM事件和生命周期"><a href="#DOM事件和生命周期" class="headerlink" title="DOM事件和生命周期"></a>DOM事件和生命周期</h4><pre class="mermaid">graph TDA(DOM)B(生命周期)C[dispatchEvent-ReactEventListener.js]D[_renderNewRootComponent-ReactMount.js]E[ReactUpdates.batchedUpdates-ReactUpdates.js]F[isBatchingUpdates=true]G[transaction.perform 执行事件回调和生命周期进入事务]H[close isBatchingUpdates=false ReactUpdates.flushBatchedUpdates]I[检查 dirtyComponents 完成更新]A == type:'click' ==> CB == componentDidMount ==> DC --> ED --> EE --> FF --> GG --> HH --> I</pre><h3 id="React合成事件"><a href="#React合成事件" class="headerlink" title="React合成事件"></a>React合成事件</h3><h3 id="HOC-的应用"><a href="#HOC-的应用" class="headerlink" title="HOC 的应用"></a>HOC 的应用</h3><p>### </p><h3 id="中间件应用"><a href="#中间件应用" class="headerlink" title="中间件应用"></a>中间件应用</h3><h3 id="Redux-的应用和原理"><a href="#Redux-的应用和原理" class="headerlink" title="Redux 的应用和原理"></a>Redux 的应用和原理</h3><h3 id="Mobx-的应用和原理"><a href="#Mobx-的应用和原理" class="headerlink" title="Mobx 的应用和原理"></a>Mobx 的应用和原理</h3><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><ol><li><a href="https://segmentfault.com/a/1190000010522782">React 渲染机制解析</a></li><li><a href="https://www.jianshu.com/p/3ba0822018cf">React之diff算法</a></li><li><a href="https://www.runoob.com/react/react-jsx.html">React JSX</a></li><li><a href="http://huziketang.mangojuice.top/books/react/lesson6">使用 JSX 描述 UI 信息</a></li><li><a href="https://zhuanlan.zhihu.com/p/26027085">React Fiber 是什么？</a></li><li><a href="https://www.jianshu.com/p/cc12e9a8052c">为什么setState是异步的</a></li><li><a href="https://www.imooc.com/article/23912?block_id=tuijian_wz">React 中 setState() 为什么是异步的？</a></li><li><a href="https://www.cnblogs.com/t-sun-j/p/10300825.html">this.setState使用时的一些坑</a></li><li><a href="https://segmentfault.com/a/1190000015463599">React setState 简单整理总结</a></li><li><a href="https://segmentfault.com/a/1190000018615027">日常抄书之一次性弄懂setState</a></li><li><a href="https://segmentfault.com/a/1190000018499749">一次性搞懂解React生命周期</a></li><li><a href="https://segmentfault.com/a/1190000010785692">React技术内幕:setState的秘密</a></li><li><a href="https://segmentfault.com/a/1190000015821018">浅入深出setState（下篇）</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;温故而知新，保持空杯心态&lt;/p&gt;
&lt;h2 id=&quot;React-基础&quot;&gt;&lt;a href=&quot;#React-基础&quot; class=&quot;headerlink&quot; title=&quot;React  基础&quot;&gt;&lt;/a&gt;React  基础&lt;/h2&gt;&lt;h3 id=&quot;什么是-React&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="前端面试" scheme="http://laibh.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端面试题" scheme="http://laibh.top/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>React-SSR浅析</title>
    <link href="http://laibh.top/2019-05-11-React-SSR%E6%B5%85%E6%9E%90.html"/>
    <id>http://laibh.top/2019-05-11-React-SSR浅析.html</id>
    <published>2019-05-11T08:30:00.000Z</published>
    <updated>2019-10-15T09:29:49.415Z</updated>
    
    <content type="html"><![CDATA[<h2 id="React-SSR-同构浅析"><a href="#React-SSR-同构浅析" class="headerlink" title="React SSR 同构浅析"></a>React SSR 同构浅析</h2><h2 id="客户端渲染（CSR）"><a href="#客户端渲染（CSR）" class="headerlink" title="客户端渲染（CSR）"></a>客户端渲染（CSR）</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>传统 react项目,在浏览器打开项目，查看源代码，可以看到 index.js 页面里面只有一个基本的 DOM 节点，下面引入了一个 js 文件。而项目的所有内容就是通过这个 js 来渲染，通过禁止浏览器的 javascript 功能可以看到浏览器提示要 开启 javascript 功能的提示，没有项目的内容生成。</p><p>CSR 过程:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览器发送请求 =&gt; 服务器返回HTML =&gt; 浏览器发送 bundle.js 请求 =&gt; 服务器返回 bundle.js =&gt; 浏览器运行 React 代码 =&gt; 页面准备就绪</span><br></pre></td></tr></table></figure><h3 id="优势与劣势"><a href="#优势与劣势" class="headerlink" title="优势与劣势"></a>优势与劣势</h3><p>优势：前后端分离，前端 ajax 请求数据，后端内部处理好逻辑返回 JSON 给前端处理。代码在客户端运行，性能良好</p><p>劣势：首屏加载速度慢。SEO 差（百度爬虫不能识别 js 文件）</p><h2 id="服务器渲染（SSR）"><a href="#服务器渲染（SSR）" class="headerlink" title="服务器渲染（SSR）"></a>服务器渲染（SSR）</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>SSR 过程：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">浏览器发送请求 =&gt; 服务器运行 React 代码生成页面 =&gt; 服务器返回页面</span><br></pre></td></tr></table></figure><h3 id="优势与劣势-1"><a href="#优势与劣势-1" class="headerlink" title="优势与劣势"></a>优势与劣势</h3><p>优势：首屏速度快</p><p>劣势：服务器性能需求大</p><h3 id="renderToString"><a href="#renderToString" class="headerlink" title="renderToString"></a>renderToString</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;renderToString&#125; <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</span><br><span class="line"><span class="keyword">const</span> content = renderToString((</span><br><span class="line">    <span class="comment">// 组件</span></span><br><span class="line">))</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>,(req,res,next)=&gt;&#123;</span><br><span class="line">    res.send(</span><br><span class="line">        <span class="string">`&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;div&gt;<span class="subst">$&#123;content&#125;</span>&lt;/div&gt;</span></span><br><span class="line"><span class="string"> &lt;/html&gt;`</span></span><br><span class="line">    )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="路由-React-router-config"><a href="#路由-React-router-config" class="headerlink" title="路由 React-router-config"></a>路由 React-router-config</h2><p>可识别嵌套路由，内置 ssr 方案</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>服务器上呈现的路由都是无状态的，所以我们将应用程序包装在无状态的 <code>&lt;StaticRouter&gt;</code> e而不是<code>&lt;BrowserRouter&gt;</code>。从服务器传入请求的路由，以便路由可以匹配。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client</span></span><br><span class="line">&lt;BroswerRouter&gt;</span><br><span class="line">    &lt;App /&gt;</span><br><span class="line">&lt;<span class="regexp">/BroswerRouter&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ server </span></span><br><span class="line"><span class="regexp">&lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt;</span></span><br><span class="line"><span class="regexp">    &lt;App /</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/StaticRouter&gt;</span></span><br></pre></td></tr></table></figure><p>在 <code>&lt;Redirect&gt;</code>客户端呈现 a 标签的时候，浏览器历史记录会更改状态，我们获得新的屏幕。在静态服务器 换机中，我们无法更改应用程序的状态。我们可以使用 context 来找出需要渲染的结果。我们找到了 context.url 就知道应用是否被重定向了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> context = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> markup = ReactDOMServer.renderToString(</span><br><span class="line">    &lt;StaticRouter location=&#123;req.path&#125; context=&#123;context&#125;&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp">if(context.url)&#123;</span></span><br><span class="line"><span class="regexp">    redirect(301,context.url)</span></span><br><span class="line"><span class="regexp">&#125;else&#123;</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="添加应用特定上下文信息"><a href="#添加应用特定上下文信息" class="headerlink" title="添加应用特定上下文信息"></a>添加应用特定上下文信息</h3><p>路由器只会添加 context.url,如果希望重定向 301或者 302 可以在希望呈现的 UI 的某个特定分支发送 404 响应，或者如果未授权则发送 401。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">RedirectWithStats</span>(<span class="params">&#123;from,to,status&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;Route render=&#123;(&#123;staticContext&#125;)=&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(staticContext) staticContext.status = status;</span><br><span class="line">                <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">from</span>=<span class="string">&#123;from&#125;</span> <span class="attr">to</span>=<span class="string">&#123;to&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">            &#125;&#125; </span></span><br><span class="line"><span class="xml">            /&gt;</span></span><br><span class="line"><span class="xml">    )</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// somewhere in app</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">function App()&#123;</span></span><br><span class="line"><span class="xml">return(</span></span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &lt;RedirectWithStatus status=&#123;301&#125; from='/users' to='/profiles' /&gt;</span><br><span class="line">            &lt;RedirectWithStatus status=&#123;302&#125; from='/courses' to='/dashboard' /&gt;</span><br><span class="line">        &lt;/Switch&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// server</span><br><span class="line">const context = &#123;&#125;;</span><br><span class="line">const markup = ReactDOMServer.renderToString(</span><br><span class="line">    &lt;StaticRouter context=&#123;context&#125;&gt;</span><br><span class="line">        &lt;App /&gt;</span><br><span class="line">    &lt;/StaticRouter&gt;</span><br><span class="line">)</span><br><span class="line">if(context.url)&#123;</span><br><span class="line">    redirect(context.status,context.url)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="404-401-或者任何其他状态"><a href="#404-401-或者任何其他状态" class="headerlink" title="404,401 或者任何其他状态"></a>404,401 或者任何其他状态</h3><p>跟上面的操作差不多，可以创建一个组件，添加一些上下文并在应用程序中的任何位置呈现它以获取不同的状态码</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Status</span>(<span class="params">&#123;code,children&#125;</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;Route </span><br><span class="line">            render=&#123;(&#123;staticContext&#125;)=&gt;&#123;</span><br><span class="line">                <span class="keyword">if</span>(staticContext) staticContext.status = code</span><br><span class="line">                <span class="keyword">return</span> children;</span><br><span class="line">            &#125;&#125;</span><br><span class="line">            /&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">NotFound</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;Status code=&#123;<span class="number">404</span>&#125;&gt;</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &lt;h1&gt;Sorry,can<span class="string">'t find that.&lt;/h1&gt;</span></span><br><span class="line"><span class="string">            &lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;/Status&gt;</span></span><br><span class="line"><span class="string">    )</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">// somewhere else</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;Switch&gt;</span></span><br><span class="line"><span class="string">    &lt;Route path='</span>/about<span class="string">' component=&#123;About&#125; /&gt;</span></span><br><span class="line"><span class="string">    &lt;Route path='</span>/dashboard<span class="string">' component=&#123;Dashboard&#125; /&gt;</span></span><br><span class="line"><span class="string">    &lt;Route component=&#123;NotFound&#125;&gt;</span></span><br><span class="line"><span class="string">&lt;/Switch&gt;</span></span><br></pre></td></tr></table></figure><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>这不是一个真正的应用程序，但是它显示了将所有这些组合在一起所需要的所有常规部分</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server</span></span><br><span class="line"><span class="keyword">import</span> &#123;createServer&#125; <span class="keyword">from</span> <span class="string">'http'</span>;</span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOMServer <span class="keyword">from</span> <span class="string">'react-dom/server'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;StaticRouter&#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"></span><br><span class="line">createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> context = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> html = ReactDOMServer.renderToString(</span><br><span class="line">        &lt;StaticRouter location=&#123;req.url&#125; context=&#123;context&#125;&gt;</span><br><span class="line">            &lt;App /&gt;</span><br><span class="line">        &lt;<span class="regexp">/StaticRouter&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">    if(context.url)&#123;</span></span><br><span class="line"><span class="regexp">        res.writeHead(301,&#123;</span></span><br><span class="line"><span class="regexp">            Location:context.url</span></span><br><span class="line"><span class="regexp">        &#125;)</span></span><br><span class="line"><span class="regexp">        res.send()</span></span><br><span class="line"><span class="regexp">    &#125;else&#123;</span></span><br><span class="line"><span class="regexp">        res.write(`&lt;!doctype html&gt;&lt;div id="app"&gt;$&#123;html&#125;&lt;/</span>div&gt;<span class="string">`)</span></span><br><span class="line"><span class="string">        res.send();</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;).listen(3000)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// client</span></span><br><span class="line"><span class="string">import ReactDOM from 'react-dom';</span></span><br><span class="line"><span class="string">import &#123;BrowserRouter&#125; from 'react-router-dom';</span></span><br><span class="line"><span class="string">import App from './App';</span></span><br><span class="line"><span class="string">ReactDOM.render(</span></span><br><span class="line"><span class="string">    &lt;BrowserRouter&gt;</span></span><br><span class="line"><span class="string">        &lt;App /&gt;</span></span><br><span class="line"><span class="string">    &lt;/BrowserRouter&gt;</span></span><br><span class="line"><span class="string">)</span></span><br></pre></td></tr></table></figure><h3 id="★数据的加载"><a href="#★数据的加载" class="headerlink" title="★数据的加载"></a>★数据的加载</h3><p>在页面呈现之前加载数据，React Router 导出 matchPath 它在内部使用的静态函数，以匹配路由的位置。可以在服务器上使用此功能来帮助确定在呈现之前数据的依赖项。</p><p>这种方法的要求是依赖于静态路由的配置，用于在呈现之前根据路由匹配来加载对应的数据</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// routes.js</span></span><br><span class="line"><span class="keyword">const</span> routes = &#123;</span><br><span class="line">    &#123;</span><br><span class="line">    path:<span class="string">'/'</span>,</span><br><span class="line">    component:Root,</span><br><span class="line">    loadData:<span class="function"><span class="params">()</span>=&gt;</span> getSomeData()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;router&#125; <span class="keyword">from</span> <span class="string">'./routes'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(</span><br><span class="line">        &lt;Switch&gt;</span><br><span class="line">            &#123;routes.map(<span class="function"><span class="params">route</span>=&gt;</span>(</span><br><span class="line">                &lt;Route &#123;...route&#125;/&gt;</span><br><span class="line">            ))&#125;</span><br><span class="line">        &lt;<span class="regexp">/Switch&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ server </span></span><br><span class="line"><span class="regexp">import &#123;matchPath&#125; from 'react-router-dom';</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">const promises = [];</span></span><br><span class="line"><span class="regexp">routers.some(route=&gt;&#123;</span></span><br><span class="line"><span class="regexp">    const match = matchPath(req.path,route);</span></span><br><span class="line"><span class="regexp">    if(match) promises.push(route.loadData(match))</span></span><br><span class="line"><span class="regexp">    return match</span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">Promise.all(promises).then(data=&gt;&#123;</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><h2 id="Webpack-配置"><a href="#Webpack-配置" class="headerlink" title="Webpack 配置"></a>Webpack 配置</h2><h3 id="公共部分"><a href="#公共部分" class="headerlink" title="公共部分"></a>公共部分</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.js?$/</span>,</span><br><span class="line">      loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">      exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">      options: &#123;</span><br><span class="line">        presets: [<span class="string">'react'</span>, <span class="string">'stage-0'</span>, [<span class="string">'env'</span>, &#123;</span><br><span class="line">          <span class="comment">// 版本兼容大部分浏览器最后2个</span></span><br><span class="line">          targets: &#123;</span><br><span class="line">            browsers: [<span class="string">'last 2 versions'</span>]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 不打包 node modules</span></span><br><span class="line"><span class="keyword">const</span> nodeExternals = <span class="built_in">require</span>(<span class="string">'webpack-node-externals'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.base.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> serverConfig = &#123;</span><br><span class="line">  <span class="comment">// 指明服务器</span></span><br><span class="line">  target: <span class="string">'node'</span>,</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/server/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'build'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  externals: [nodeExternals()],</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.css?$/</span>,</span><br><span class="line">      <span class="comment">// 在高阶组件中通过注水跟脱水 css 来获取 css 代码，这个loader 提供了 ._getCss() 函数</span></span><br><span class="line">      use: [<span class="string">'isomorphic-style-loader'</span>, &#123;</span><br><span class="line">        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          importLoaders: <span class="number">1</span>,</span><br><span class="line">          modules: <span class="literal">true</span>,</span><br><span class="line">          localIdentName: <span class="string">'[name]_[local]_[hash:base64:5]'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(config, serverConfig);</span><br></pre></td></tr></table></figure><h4 id="webpack-node-externals"><a href="#webpack-node-externals" class="headerlink" title="webpack-node-externals"></a>webpack-node-externals</h4><p>不打包引入 的 node modules</p><h4 id="isomorphic-style-loader"><a href="#isomorphic-style-loader" class="headerlink" title="isomorphic-style-loader"></a>isomorphic-style-loader</h4><p>服务端打包 CSS 可以通过这个插件在对应的 DOM 元素上生成 class 类名，然后返回 CSS 样式代码。在高阶组件中，利用插件内置 API <code>._getCss()</code>将CSS 数据通过注水与脱水的方式在服务端获取，将这些字符串格式的 css 添加到服务器渲染的 HTML 就可以完成 CSS 服务器渲染</p><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.base.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clientConfig = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/client/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'index.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'public'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.css?$/</span>,</span><br><span class="line">      use: [<span class="string">'style-loader'</span>, &#123;</span><br><span class="line">        loader: <span class="string">'css-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          importLoaders: <span class="number">1</span>,</span><br><span class="line">          modules: <span class="literal">true</span>,</span><br><span class="line">          localIdentName: <span class="string">'[name]_[local]_[hash:base64:5]'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(config, clientConfig);</span><br></pre></td></tr></table></figure><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"server"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">"react-ssr"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"npm-run-all --parallel dev:**"</span>,</span><br><span class="line">    <span class="attr">"dev:start"</span>: <span class="string">"nodemon --watch build --exec node \"./build/bundle.js\""</span>,</span><br><span class="line">    <span class="attr">"dev:build:server"</span>: <span class="string">"webpack --config webpack.server.js --watch"</span>,</span><br><span class="line">    <span class="attr">"dev:build:client"</span>: <span class="string">"webpack --config webpack.client.js --watch"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [</span><br><span class="line">    <span class="string">"react"</span>,</span><br><span class="line">    <span class="string">"ssr"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">"lbh"</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"axios"</span>: <span class="string">"^0.18.0"</span>,</span><br><span class="line">    <span class="attr">"babel-core"</span>: <span class="string">"^6.26.3"</span>,</span><br><span class="line">    <span class="attr">"babel-loader"</span>: <span class="string">"^7.1.5"</span>,</span><br><span class="line">    <span class="attr">"babel-preset-env"</span>: <span class="string">"^1.7.0"</span>,</span><br><span class="line">    <span class="attr">"babel-preset-react"</span>: <span class="string">"^6.24.1"</span>,</span><br><span class="line">    <span class="attr">"babel-preset-stage-0"</span>: <span class="string">"^6.24.1"</span>,</span><br><span class="line">    <span class="attr">"css-loader"</span>: <span class="string">"^2.1.1"</span>,</span><br><span class="line">    <span class="attr">"express"</span>: <span class="string">"^4.16.4"</span>,</span><br><span class="line">    <span class="attr">"express-http-proxy"</span>: <span class="string">"^1.5.1"</span>,</span><br><span class="line">    <span class="attr">"isomorphic-style-loader"</span>: <span class="string">"^5.0.1"</span>,</span><br><span class="line">    <span class="attr">"react"</span>: <span class="string">"^16.8.6"</span>,</span><br><span class="line">    <span class="attr">"react-dom"</span>: <span class="string">"^16.8.6"</span>,</span><br><span class="line">    <span class="attr">"react-helmet"</span>: <span class="string">"^5.2.0"</span>,</span><br><span class="line">    <span class="attr">"react-redux"</span>: <span class="string">"^7.0.1"</span>,</span><br><span class="line">    <span class="attr">"react-router-config"</span>: <span class="string">"^5.0.0"</span>,</span><br><span class="line">    <span class="attr">"react-router-dom"</span>: <span class="string">"^5.0.0"</span>,</span><br><span class="line">    <span class="attr">"redux"</span>: <span class="string">"^4.0.1"</span>,</span><br><span class="line">    <span class="attr">"redux-thunk"</span>: <span class="string">"^2.3.0"</span>,</span><br><span class="line">    <span class="attr">"style-loader"</span>: <span class="string">"^0.23.1"</span>,</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.29.6"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.0"</span>,</span><br><span class="line">    <span class="attr">"webpack-merge"</span>: <span class="string">"^4.2.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-node-externals"</span>: <span class="string">"^1.7.2"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="nodemon"><a href="#nodemon" class="headerlink" title="nodemon"></a>nodemon</h4><p>一个本地服务器，可以监控文件的变化来重启服务器，全局安装</p><h4 id="npm-run-all"><a href="#npm-run-all" class="headerlink" title="npm-run-all"></a>npm-run-all</h4><p>并行运行同名前缀的所有 <code>script</code> 语句，全局安装</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;React-SSR-同构浅析&quot;&gt;&lt;a href=&quot;#React-SSR-同构浅析&quot; class=&quot;headerlink&quot; title=&quot;React SSR 同构浅析&quot;&gt;&lt;/a&gt;React SSR 同构浅析&lt;/h2&gt;&lt;h2 id=&quot;客户端渲染（CSR）&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="react" scheme="http://laibh.top/categories/react/"/>
    
    
      <category term="react" scheme="http://laibh.top/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题目汇总摘录（JS 基础篇3）</title>
    <link href="http://laibh.top/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E6%91%98%E5%BD%95-JS%20%E5%9F%BA%E7%A1%80%E7%AF%873.html"/>
    <id>http://laibh.top/前端面试题目汇总摘录-JS 基础篇3.html</id>
    <published>2019-04-23T01:30:54.000Z</published>
    <updated>2019-10-15T09:29:49.419Z</updated>
    
    <content type="html"><![CDATA[<p>温故而知新，保持空杯心态,复习到一半的时间，突然发现了 <a href="https://yuchengkai.cn/docs/frontend">前端面试之道</a>，按学习这本书的路径来</p><h2 id="JS-基础3"><a href="#JS-基础3" class="headerlink" title="JS 基础3"></a>JS 基础3</h2><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>前端监控一般分为三种，页面埋点、性能监控以及异常监控</p><h3 id="页面埋点"><a href="#页面埋点" class="headerlink" title="页面埋点"></a>页面埋点</h3><p>页面埋点一般会监控下面几个数据：</p><ul><li>PV/UV</li><li>停留时长</li><li>流量来源</li><li>用户交互</li></ul><p>实现的思路分成两种，手写埋点和无埋点的方式</p><p>第一种自主选择需要监控的数据然后在相应的地方写入代码，这种方式灵活性很大，唯一的缺点就是工作量大，每个需要监控的地方都要插入代码</p><p>另一种的无埋点的方式基本不需要开发者手写埋点，而是统计所有的事件并且定时上报，这种方式虽然没有前一种繁琐，但是因为统计的是所有事件，所以还需要后期过滤出需要的数据</p><h3 id="性能监控"><a href="#性能监控" class="headerlink" title="性能监控"></a>性能监控</h3><p>可以使用浏览器期自带的  <a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FAPI%2FPerformance">Performance API</a> 来实现功能。一行代码就可以获得页面中各种详细的性能</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">performance.getEntriesByType(<span class="string">'navigation'</span>)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">[</span></span><br><span class="line"><span class="comment">    PerformanceNavigationTiming:&#123;</span></span><br><span class="line"><span class="comment">        connectEnd: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        connectStart: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        decodedBodySize: 0</span></span><br><span class="line"><span class="comment">        domComplete: 22873.60000000001</span></span><br><span class="line"><span class="comment">        domContentLoadedEventEnd: 22690.200000000004</span></span><br><span class="line"><span class="comment">        domContentLoadedEventStart: 22689.999999999996</span></span><br><span class="line"><span class="comment">        domInteractive: 22689.999999999996</span></span><br><span class="line"><span class="comment">        domainLookupEnd: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        domainLookupStart: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        duration: 22873.700000000015</span></span><br><span class="line"><span class="comment">        encodedBodySize: 0</span></span><br><span class="line"><span class="comment">        entryType: "navigation"</span></span><br><span class="line"><span class="comment">        fetchStart: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        initiatorType: "navigation"</span></span><br><span class="line"><span class="comment">        loadEventEnd: 22873.700000000015</span></span><br><span class="line"><span class="comment">        loadEventStart: 22873.60000000001</span></span><br><span class="line"><span class="comment">        name: ""</span></span><br><span class="line"><span class="comment">        nextHopProtocol: ""</span></span><br><span class="line"><span class="comment">        redirectCount: 0</span></span><br><span class="line"><span class="comment">        redirectEnd: 0</span></span><br><span class="line"><span class="comment">        redirectStart: 0</span></span><br><span class="line"><span class="comment">        requestStart: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        responseEnd: 726.4000000000124</span></span><br><span class="line"><span class="comment">        responseStart: 3.9999999999906777</span></span><br><span class="line"><span class="comment">        secureConnectionStart: 0</span></span><br><span class="line"><span class="comment">        serverTiming: []</span></span><br><span class="line"><span class="comment">        startTime: 0</span></span><br><span class="line"><span class="comment">        transferSize: 0</span></span><br><span class="line"><span class="comment">        type: "back_forward"</span></span><br><span class="line"><span class="comment">        unloadEventEnd: 0</span></span><br><span class="line"><span class="comment">        unloadEventStart: 0</span></span><br><span class="line"><span class="comment">        workerStart: 0</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-性能监控.png" alt="性能监控"></p><h3 id="异常监控"><a href="#异常监控" class="headerlink" title="异常监控"></a>异常监控</h3><p>对于代码运行错误，通常的办法是使用 window.onerror 拦截报错，该方法能拦截到大部分的详细报错信息，但是也有例外的</p><ul><li>对于跨域的代码运行错误会显示 script error 对于这种情况需要给 script 标签添加 crossorigin 属性</li><li>对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 arguments.callee.caller 来做栈递归</li></ul><p>对于异步代码来说，可以使用 catch 的方式捕获错误。比如 Promise 可以直接使用 catch 函数，async await 可以使用 try catch</p><p>线上的代码是经过压缩的，打包的时候要设置 sourceMap</p><h2 id="常考的面试题目：UDP-与-TCP-的区别是什么？"><a href="#常考的面试题目：UDP-与-TCP-的区别是什么？" class="headerlink" title="常考的面试题目：UDP 与 TCP 的区别是什么？"></a>常考的面试题目：UDP 与 TCP 的区别是什么？</h2><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP 协议是面向无连接，不需要在正式传递数据之前先连接双方，然后 UDP 协议只是数据报文的搬运工，不保证有序且不丢失的传递到对端，并且 UDP 协议也没有任何控制流量的算法，总的来说 UDP 相较于 TCP 更加的轻便</p><h3 id="面向无连接"><a href="#面向无连接" class="headerlink" title="面向无连接"></a>面向无连接</h3><p>UDP 不要跟 TCP 一样在发送数据前进行三次握手建立连接，想发数据就可以发送了。</p><p>并且也只是数据的搬运工，不会对数据进行拆分和拼接操作。</p><p>具体来说：</p><ul><li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给应用层了</li><li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作。</li></ul><h3 id="不可靠性"><a href="#不可靠性" class="headerlink" title="不可靠性"></a>不可靠性</h3><p>不可靠性体现在无连接上，通信都不需要建立连接，想发就发。不用备份，也不用关心对方是否已经正确接收到数据。UDP 没有拥塞控制，一直会以恒定的速度发送数据，即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端是在网络条件不好的情况下可能会导致丢包，但是优点很明显是在某些实时性要求很高的场景（如电话会议）就需要使用 UDP 而不是 TCP</p><h3 id="高效"><a href="#高效" class="headerlink" title="高效"></a>高效</h3><p>UDP 的头部开销小，只有八字节，相比 TCP 的至少二十字节要小得多，在传输数据报文时是很高效的。</p><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-UDP.png" alt="UDP"></p><p>UDP 头部包含了以下几个数据：</p><ul><li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li><li>整个数据报文的长度</li><li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误</li></ul><h3 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h3><p>UDP 不止支持一对一的传输方式，同样支持一对多，多对一的方式，也就说说 UDP 提供了单播，多播，广播的功能。</p><h3 id="适用的场景"><a href="#适用的场景" class="headerlink" title="适用的场景"></a>适用的场景</h3><p>在很多实时性要求很高的地方都可以看到 UDP 的身影</p><h4 id="直播"><a href="#直播" class="headerlink" title="直播"></a>直播</h4><p>如果使用基于 TCP 的协议，TCP 会严格控制传输的正确性，一旦有某个数据对端没有收到，就会停下来直到对端收到这个数据。这种问题在网络条件不错的情况下不会有问题，但是如果网络差就会变成画面卡着，然后在继续播放下一帧的情况。</p><p>TCP 这种情况下会降低用户体验，不适合</p><h4 id="王者荣耀"><a href="#王者荣耀" class="headerlink" title="王者荣耀"></a>王者荣耀</h4><p>作者说不知道王者荣耀底层是使用了什么协议，但是对于这种实时性很高的游戏来说，UDP 是跑不了的。用户体量相当大的情况下，如果使用 TCP 连接可能会出现服务器不够用情况，因为每台服务器可供支撑的 TCP 连接数据是有限制的。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-TCP.png" alt="TCP"></p><p>对于TCP 头部来说，以下几个字段是很重要的</p><ul><li>Sequence number，这个序号保证了 TCP 传输的报文都是有序的，对端可以通过序号顺序的拼接报文</li><li>Acknowledgement Number，这个序号表示数据接收端期望接受的下一个字节编号是多少，同时也表示上一序号的数据已经收到</li><li>Window Size,窗口大小，表示还能接受多少字节的数据，用于流量控制</li><li>标识符<ul><li>UGR=1：该字段为一表示本数据报的数据部分包含紧急信息，是一个高优先级数据报文，此时紧急指针有效。紧急数据一定位于当前数据包数据部分的最前面，紧急指标标明了紧急数据的尾部。</li><li>ACK=1：该字段为一表示确认号字段有效。此外，TCP 还规定在连接建立后传送的所有报文段都必须要把 ACK 置为一</li><li>PSH=1：该字段为一表示接收端应该立即将数据 push 给应用层，而不是等到缓冲区满后再提交</li><li>RST=1：该字段为一表示当前 TCP 连接出现严重问题，可能需要重新建立连接，也可以用于拒绝非法的报文段和拒绝连接请求</li><li>SYN=1：当 SYN = 1,ACK=0时，表示当前报文段是一个连接请求报文。当 SYN=1,ACK=1时，表示当前报文daunt是一个同意连接的应答报文</li><li>FIN=1：该字段为一表示此报文是一个释放连接的请求报文</li></ul></li></ul><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>TCP 的状态机是很复杂的，并且与建立连接时的握手息息相关</p><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-状态机.png" alt="状态机"></p><p>一个重要的性能指标 RTT.该指标表示发送端发送数据到接收到对端所需的往返时间</p><h3 id="建立连接三次握手"><a href="#建立连接三次握手" class="headerlink" title="建立连接三次握手"></a>建立连接三次握手</h3><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-三次握手.png" alt="三次握手"></p><p>首先假设主动发起请求的一端为客户端，被动连接的一端称为服务端。不管是客户端还是服务端，TCP 连接建立完后都可以发送和接收数据，所以 TCP 是一个全双工的协议。</p><p>起初，两端都是 CLOSED 状态，在通信开始前，双方都会建立 TCB,服务端创建完TCB 后便进入 LISTEN 状态，此时开始等待客户端发送数据</p><h4 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h4><p>客户端向服务端发送连接请求报文段，该报文段中包含自身数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态</p><h4 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h4><p>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</p><h4 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h4><p>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端接收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功</p><p>第三次握手中可以包含数据，通过快速打开（TFO）技术就可以实现这一功能。其中只要涉及到握手的协议，都可以使用类似 TFO 方式，客户端和服务端存储相同的 cookie ，下次握手发出 cookie 达到减少 RTT 的目的。</p><p><strong>为什么TCP 建立连接需要三次握手，明明两次就可以建立起连接？</strong></p><p>因为这是为了防止出现失效的连接请求报文段被服务端接收后，从而产生错误。</p><p>如果客户端发送了一个连接报文请求A，但是因为网络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送一个连接请求报文B。此时请求顺利达到服务器，服务端应答完就建立了请求，然后接受数据后释放了连接。</p><p>假设这时候请求 A 在两端关闭后终于达到了服务端，那么此时服务端会认为客户端有需要建立 TCP 连接，从而应答了该请求并进入了 ESTABLISHED 状态，但是实际上客户端是 CLOSED 状态，那么就会导致服务端一直等待，造成资源的浪费。</p><p>在建立连接中，任意一端掉线，TCP 都会重发 SYN 包，一般会重试5次，在建立连接可能遇到 SYN Flood 攻击。遇到这种情况可以选择调低重试次数或者干脆在不能处理的情况下拒绝请求。</p><h3 id="断开连接四次握手"><a href="#断开连接四次握手" class="headerlink" title="断开连接四次握手"></a>断开连接四次握手</h3><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-断开连接四次握手.png" alt="四次握手"></p><p>TCP 是全双工的，在断开连接时两端都需要发送 FIN 和 ACK</p><h4 id="第一次握手-1"><a href="#第一次握手-1" class="headerlink" title="第一次握手"></a>第一次握手</h4><p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。</p><h4 id="第二次握手-1"><a href="#第二次握手-1" class="headerlink" title="第二次握手"></a>第二次握手</h4><p>B 收到连接释放请求后，会告诉应用层就要释放 TCP 连接，然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明 A 到 B 的连接已经释放，不再接收 A 发的数据了。但是因为 TCP 连接是双工的，所以 B 依旧可以发送数据给 A</p><h4 id="第三次握手-1"><a href="#第三次握手-1" class="headerlink" title="第三次握手"></a>第三次握手</h4><p>B 如果此时还有没有发完的数据会继续发送，完毕后向 A 发送连接释放请求，然后 B 便进入 LAST-ACK 状态。通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送</p><h4 id="第四次握手"><a href="#第四次握手" class="headerlink" title="第四次握手"></a>第四次握手</h4><p>A 收到释放请求后，向 B 发送确认应答，A 进入 TIME-WAIT 状态。该状态会持续 2MSL(最大生存期，指报文段在网络中生存的时间，超时会被抛弃)时间，若该时间段内没有 B 的重发请求的话，就会进入 CLOSED 状态。当 B 收到确认应答后，也便进入 CLOSED 状态</p><p><strong>为什么 A 要进入 TIME-WAIT 状态，等待 2MSL 时间后再进入CLOSED 状态？</strong></p><p>为了保证 B 能接受到 A 的确认应答，若 A 发完确认应答后直接进入 CLOSED 状态，如果确认应答因为网络问题一直没有到达，那么会造成 B 不能正常关闭</p><h2 id="ARQ-协议"><a href="#ARQ-协议" class="headerlink" title="ARQ 协议"></a>ARQ 协议</h2><p>ARQ 协议也就是超时重传机制。通过确认和超时机制保证了数据的正确送达，ARQ 协议包含停止等待 ARQ 和连续 ARQ 两种协议</p><h3 id="停止等待-ARQ"><a href="#停止等待-ARQ" class="headerlink" title="停止等待 ARQ"></a>停止等待 ARQ</h3><h4 id="正常传输协议"><a href="#正常传输协议" class="headerlink" title="正常传输协议"></a>正常传输协议</h4><p>只要 A 向 B 发送一段报文，都要停止发送并且启动一个定时器，等待对端应答，在定时器内接收到对端应答就取消定时器并发送下一段报文</p><h4 id="报文丢失或者出错"><a href="#报文丢失或者出错" class="headerlink" title="报文丢失或者出错"></a>报文丢失或者出错</h4><p>在报文传输过程中可能会出现丢包，这时候超过定时器设定的时间就会再次发送丢失的数据直到对端响应，所以需要每次都备份发送的数据</p><p>即使报文正常传输到对端，有可能出现在传输过程中的报文出错的问题。这时候对端会抛弃该报文并等待 A 端重传</p><p>一般定时器设定的时间会大于一个 RTT 的平均时间</p><h4 id="ACK-超时或者丢失"><a href="#ACK-超时或者丢失" class="headerlink" title="ACK 超时或者丢失"></a>ACK 超时或者丢失</h4><p>对端传输的应答也可能出现丢失或者超时的情况，那么超过定时器时间 A 端照样会重报文，这时候 B 端会接收到相同序号的报文之后丢弃该报文并重传应答，直到 A 端发送下一个序号的报文。</p><p>在超时的情况下也可能会出现应答很迟到达，这时候 A 端会判断该序号是否已经接收过，如果接收过只需要丢弃应答即可。</p><p>假设在良好的网络环境中，每次发送数据都需要等待片刻肯定是不能接受的，这个协议看起来不是很高效。</p><h3 id="连续ARQ"><a href="#连续ARQ" class="headerlink" title="连续ARQ"></a>连续ARQ</h3><p>在连续 ARQ 中，发送端拥有一个发送窗口，可以在没有收到应答的情况下持续发送窗口内的数据，这样相比停止等待 ARQ 协议来说减少了等待时间，提高了效率</p><h4 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h4><p>连续 ARQ 中，接收端会持续不断收到报文，如果和停止等待 ARQ 中接收一个报文就发送一个应答一样，就太浪费资源了。通过累计确认，可以在收到多个报文以后统一回复一个应答报文。报文中的 ACK 标示位可以用来告诉发送端这个序号之前的数据已经全部接收到了，下次请发送这个序号后的数据。</p><p>但是累计确认也有一个弊端，在连续接收报文时，可能会遇到接收到序号5 的报文后，并未接收到序号6 的报文，然而序号7 的报文已经接收。遇到这种情况，ACK 只能回复 6，这样就会造成发送端重复发送数据的情况。</p><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>TCP 中，两端其实都维护者窗口，分别为发送端窗口和接收端窗口</p><p>发送端窗口包含已经发送但未收到应答的数据和可以发送但是未发送的数据</p><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-滑动窗口1.png" alt="滑动窗口1"></p><p>发送端窗口是由接收端窗口剩余大小决定的。接收方会把当前接收窗口的剩余大小写入应答报文，发送端收到应答后根据该值和当前网络拥塞情况设置发送窗口的大小，所以发送窗口的大小是不断变化的。</p><p>当发送端接收到应答报文后，会随着窗口进入滑动。</p><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-滑动窗口2.png" alt="滑动窗口2"></p><p>滑动窗口是一个很重要概念，它帮助了 TCP 实现了流量控制的功能。接收方通过报文告知发送方还可以发送多少数据，从而保证了接收方能够来得及接收数据，防止出现接收方带宽已满，但是发送方还是一直发送数据的情况。</p><h4 id="zero-窗口"><a href="#zero-窗口" class="headerlink" title="zero 窗口"></a>zero 窗口</h4><p>在发送报文的过程中，可能会遇到对端出现零窗口的情况，在该情况下，发送端会停止发送数据，并启动 persistent timer.该定时器会定时发送请求给对端，让对端告知窗口大小。在重试次数超过一定次数后，可能会中断 TCP 链接。</p><h3 id="拥塞处理"><a href="#拥塞处理" class="headerlink" title="拥塞处理"></a>拥塞处理</h3><p>拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接收数据，而后者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。</p><p>拥塞处理包括了四个算法，分别是：慢开始，拥塞避免，快速重传，快递恢复</p><h4 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h4><p>慢开始算法，就是在传输开始时将发送窗口慢慢指数等级扩大，从而避免一开始就传输最大量数据导致网络阻塞。</p><p>慢开始算法步骤具体如下：</p><ol><li>连接初始设置拥塞窗口（Congestion Window）为 1 MSS(一个分段的最大数据量)</li><li>每过一个 RTT 将窗口大小乘二</li><li>指数级增加肯定不能没有限制的，所以有一个阈值限制，当窗口大于阈值就会启动拥塞避免算法</li></ol><h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4><p>拥塞避免算法相比简单点，每过一个 RTT 窗口大小只加一，这样就能避免指数级增长导致网络拥塞，慢慢将大小调整到最佳值</p><p>在传输过程中可能定时器超时的情况，这时候 TCP 会认为网络拥塞，会马上进行一下步骤：</p><ol><li>将阈值设定为当前拥塞窗口的一半</li><li>将拥塞窗口设定为 1MSS</li><li>启动拥塞避免算法</li></ol><h4 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h4><p>快速重传一般和快恢复一起出现。一旦接收端收到的报文出现失序的情况，接收端只会回复最后一个顺序正确的报文序号。如果发送端收到三个重复的 ACK ,无需等待定时器超时而是启动快速重传算法。具体是：<br>TCP Taho 的实现：</p><ul><li>将阈值设为当前阈值的一般</li><li>将拥塞窗口设为 1MSS</li><li>重新开始慢开始算法</li></ul><p>TCP Reno 实现：</p><ul><li>拥塞窗口减半</li><li>将阈值设定为当前拥塞窗口</li><li>进入块恢复阶段（重发对端需要的包，一旦接收到一个新的 ACK 答复就退出该阶段），这种方在丢失多个包的情况下就不那么友好了</li><li>使用拥塞避免算法</li></ul><h4 id="TCP-New-Ren-改进后的快恢复"><a href="#TCP-New-Ren-改进后的快恢复" class="headerlink" title="TCP New Ren 改进后的快恢复"></a>TCP New Ren 改进后的快恢复</h4><p><strong>TCP New Reno</strong> 算法改进了之前 <strong>TCP Reno</strong> 算法的缺陷。在之前，快恢复中只要收到一个新的 ACK 包，就会退出快恢复。</p><p>在 <strong>TCP New Reno</strong> 中，TCP 发送方先记下三个重复 ACK 的分段的最大序号。</p><p>假如我有一个分段数据是 1 ~ 10 这十个序号的报文，其中丢失了序号为 3 和 7 的报文，那么该分段的最大序号就是 10。发送端只会收到 ACK 序号为 3 的应答。这时候重发序号为 3 的报文，接收方顺利接收的话就会发送 ACK 序号为 7 的应答。这时候 TCP 知道对端是有多个包未收到，会继续发送序号为 7 的报文，接收方顺利接收并会发送 ACK 序号为 11 的应答，这时发送端认为这个分段接收端已经顺利接收，接下来会退出快恢复阶段。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>TCP建立连接需要三次握手，断开连接需要四次握手</li><li>滑动窗口解决了数据的丢包、顺序不对和流量控制的问题</li><li>拥塞窗口实现了对流量的控制，保证全天候环境下最优的传递数据</li></ul><h2 id="HTTP-以及-TLS"><a href="#HTTP-以及-TLS" class="headerlink" title="HTTP 以及 TLS"></a>HTTP 以及 TLS</h2><h3 id="HTTP-请求的内容"><a href="#HTTP-请求的内容" class="headerlink" title="HTTP 请求的内容"></a>HTTP 请求的内容</h3><p>HTTP 请求由三部分组成，分别是：</p><ul><li>请求行</li><li>首部</li><li>实体</li></ul><p>请求行基本由请求方法、URL、版本协议组成。</p><p>请求方法分很多种，POST,GET,HEAD,OPTION,等等，更多具体的<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods">点击这里</a></p><h3 id="副作用和幂等"><a href="#副作用和幂等" class="headerlink" title="副作用和幂等"></a>副作用和幂等</h3><p>副作用是指对服务器上的资源做改变，搜素是无副作用的，注册是副作用的。</p><p>幂等指发送 M 和 N 次请求（两者不同且大于1），服务器上资源的状态一致，比如注册10个和11个账号是不幂等的，对文章进行更改10次和11次是幂等的。因为前者多了一个账号（资源），后者只是更新同一个资源</p><p>在规范的应用场景来说，Get 多用于无副作用的，幂等的场景，例如搜索关键字。Post 多用于副作用的，不幂等的场景，例如注册</p><p>技术上来说：</p><ul><li>Get 请求能缓存，Post 不能</li><li>Post 相对 Get 安全一点，因为GET 请求都包含在 URL 里面，且会被浏览器保存历史记录。而 Post 不会，但是在抓包的情况下是一样的。</li><li>URL 有长度限制，会影响 GET 请求，但是这个长度限制是浏览器限制的，不是 RFC 规定的</li><li>Post 支持更多的编码并且不对数据类型限制</li></ul><h3 id="首部"><a href="#首部" class="headerlink" title="首部"></a>首部</h3><p>首部分成请求首部和响应首部，并且部分首部两种通用。下面是常见的首部</p><h4 id="通用首部"><a href="#通用首部" class="headerlink" title="通用首部"></a>通用首部</h4><table><thead><tr><th>通用字段</th><th>作用</th></tr></thead><tbody><tr><td>Cache-Control</td><td>控制缓存的行为</td></tr><tr><td>Connection</td><td>浏览器想要优先使用的连接类型，比如 keep-alive</td></tr><tr><td>Date</td><td>创建报文的时间</td></tr><tr><td>Pragma</td><td>报文指令</td></tr><tr><td>Via</td><td>代理服务器相关信息</td></tr><tr><td>Transfer-Encoding</td><td>制定报文主体的传输编码方式</td></tr><tr><td>Upgrade</td><td>要求客户端升级协议</td></tr><tr><td>Warning</td><td>在内容中可能存在错误</td></tr></tbody></table><p>具体解释的可以<a href="http://laibh.top/2018-08-16-read-%E5%9B%BE%E8%A7%A3HTTP-Part6%E4%B8%8A.html">点击这里</a></p><h4 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h4><table><thead><tr><th>请求首部</th><th>作用</th></tr></thead><tbody><tr><td>Accept</td><td>能正确接收的媒体类型</td></tr><tr><td>Accept-Charset</td><td>能正确接收的字符集</td></tr><tr><td>Accept-Encoding</td><td>能正确接收的编码格式列表</td></tr><tr><td>Accept-Language</td><td>能正确接收的语言列表</td></tr><tr><td>Expect</td><td>期待服务端的指定行为</td></tr><tr><td>From</td><td>请求方邮箱地址</td></tr><tr><td>Host</td><td>服务器的域名</td></tr><tr><td>If-Match</td><td>两端资源标记比较</td></tr><tr><td>If-Modified-Since</td><td>本地资源未修改返回 304（比较时间）</td></tr><tr><td>If-None-Match</td><td>本地资源未修改返回 304（比较标记）</td></tr><tr><td>User-Agent</td><td>客户端信息</td></tr><tr><td>Max-Forwards</td><td>限制可被代理以及网关转发的次数</td></tr><tr><td>Proxy-Authorization</td><td>向代理服务器发送验证信息</td></tr><tr><td>Range</td><td>请求某个内容的一部分</td></tr><tr><td>Referer</td><td>表示浏览器所访问的前一个页面</td></tr><tr><td>TE</td><td>传输编码方式</td></tr></tbody></table><h4 id="响应首部"><a href="#响应首部" class="headerlink" title="响应首部"></a>响应首部</h4><table><thead><tr><th>响应头部</th><th>作用</th></tr></thead><tbody><tr><td>Accept-Ranges</td><td>是否支持某些种类的范围</td></tr><tr><td>Age</td><td>资源在代理缓存中存在的时间</td></tr><tr><td>ETag</td><td>资源标识</td></tr><tr><td>Location</td><td>客户端重定向到某个 URL</td></tr><tr><td>Proxy-Authenticate</td><td>想代理服务器发送验证信息</td></tr><tr><td>Server</td><td>服务器名字</td></tr><tr><td>WWW-Authenticate</td><td>获取资源需要的验证信息</td></tr></tbody></table><h4 id="实体首部"><a href="#实体首部" class="headerlink" title="实体首部"></a>实体首部</h4><table><thead><tr><th>实体首部</th><th>作用</th></tr></thead><tbody><tr><td>Allow</td><td>资源的正确请求方式</td></tr><tr><td>Content-Encoding</td><td>内容编码的格式</td></tr><tr><td>Content-Language</td><td>内容使用的语言</td></tr><tr><td>Content-Length</td><td>request body 长度</td></tr><tr><td>Content-Location</td><td>返回数据的备用地址</td></tr><tr><td>Content-MD5</td><td>Base64 加密格式的内容 MD5 校验值</td></tr><tr><td>Content-Range</td><td>内容的位置范围</td></tr><tr><td>Content-Type</td><td>内容的媒体类型</td></tr><tr><td>Expires</td><td>内容的过期时间</td></tr><tr><td>Last_modified</td><td>内容的最后修改时间</td></tr></tbody></table><h3 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h3><p>状态码的责任是当客户端向服务端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务单是正常处理了请求，还是出现了错误。</p><h4 id="状态码的类别"><a href="#状态码的类别" class="headerlink" title="状态码的类别"></a>状态码的类别</h4><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">类别</th><th style="text-align:left">原因短语</th></tr></thead><tbody><tr><td style="text-align:left">1XX</td><td style="text-align:left">Information（信息性状态码）</td><td style="text-align:left">接受的请求正在处理</td></tr><tr><td style="text-align:left">2XX</td><td style="text-align:left">Success（成功状态码）</td><td style="text-align:left">请求正常处理完毕</td></tr><tr><td style="text-align:left">3XX</td><td style="text-align:left">Redirection（重定向状态码）</td><td style="text-align:left">需要进行附加操作以完成请求</td></tr><tr><td style="text-align:left">4XX</td><td style="text-align:left">Client Error（客户端错误状态码）</td><td style="text-align:left">服务器无法处理请求</td></tr><tr><td style="text-align:left">5XX</td><td style="text-align:left">Server Error（服务器错误状态码）</td><td style="text-align:left">服务器处理请求出错</td></tr></tbody></table><h4 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h4><ul><li>200 OK,表示从客户端发来的请求在服务端被正确处理</li><li>204，No content，表示请求成功，但响应报文不含实体的主体部分</li><li>205，Reset Content，表示请求成功，但响应报文不含实体的主体部分，与204响应不同的是要求请求方重置内容</li><li>206 Partial Content，表示对客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求，响应报文中由 Content-Range 指定范围的实体内容</li></ul><h4 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h4><ul><li>301 moved permanently,永久性重定向，表示资源已被分配到了新的 URL</li><li>302 found,临时重定向，表示资源临时被分配了新的 URL</li><li>303 see other，表示资源存在着另一个 URL应使用 GET 方法获取资源</li><li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li><li>307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求。</li></ul><h4 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h4><ul><li>400 bad request，请求报文存在语法错误</li><li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证消息</li><li>403 fobidden，表示对请求资源的访问被服务器拒绝</li><li>404 no found,表示在服务器上没有找到请求的资源</li></ul><h4 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h4><ul><li>500 internal server error,表示服务器端在执行请求时发生了错误</li><li>501 Not Implemented,表示服务器不支持当期请求所需要的某个功能</li><li>503 service unavaliable,表示服务器暂时处于超负载或者停机服务，无法处理请求</li></ul><h3 id="TLS"><a href="#TLS" class="headerlink" title="TLS"></a>TLS</h3><p>HTTPS 通过 HTTP 来传输信息，但是信息通过 TLS 协议进行了 加密</p><p>TLS 协议位于传输层之上，应用层之下。首先进行 TLS 协议传输需要两个 RTT,可以通过 Session Resumption 减少到一个 RTT</p><p>在 TLS 中使用了两种加密技术，分别为：对称加密和非对称加密。</p><h4 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h4><p>对称加密就是两边都拥有相同的密钥，两边都知道药怎么将密文加密解密</p><p>这种加密方式缺点在于因为传输数据走的都是网络，如果密钥被截获那就没有加密的意义了</p><h4 id="非对称机密"><a href="#非对称机密" class="headerlink" title="非对称机密"></a>非对称机密</h4><p>有公钥私钥之分，公钥所有人都可以知道，如果将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。</p><p>这种加密方式就可以完美解决对称加密存在的问题，假设两端都需要使用对称加密，那么在这之前，可以先使用非对称加密交换密钥。</p><p>简单流程化如下：服务端将公钥发布出去，那么客户端也知道公钥，就下来客户端创建了一个密钥，然后通过公钥加密后发送给服务端，服务端接收到私钥解密出正确的密钥，这时候两端就都知道密钥是什么了。</p><p>TLS 握手过程如下图：</p><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-TLS握手协议.png" alt="TLS 握手协议"></p><ol><li>客户端发送一个随机值以及需要的协议和加密方式</li><li>服务端收到客户端的随机值，自己也产生了一个随机值，并根据客户端的需求的协议和加密方式来使用对应的方式，并且发送自己的证书（如果需要验证客户端证书需要说明）</li><li>客户端收到服务端的证书验证是否有效，验证通过会生成一个随机值，通过服务端证书的公钥加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书</li><li>服务端收到加密过的随机值并使用私钥解密获得三个随机值，这时候两端都有三个随机值，可以通过这三个随机值按照之前的约定的加密方式生成密钥，接下来的通信既可以使用该密钥加密解密了。</li></ol><p>通过上面步骤，可以知道 TLS 握手阶段，两端使用非对称加密的方式进行通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据的时候，两端使用对称加密的方式进行通信。</p><p>关于 http 安全的具体可以<a href="http://laibh.top/2018-08-29-read-%E5%9B%BE%E8%A7%A3HTTP-Part7.html">点击这里</a></p><h3 id="HTTP-2-以及-HTTP-3"><a href="#HTTP-2-以及-HTTP-3" class="headerlink" title="HTTP/2 以及 HTTP/3"></a>HTTP/2 以及 HTTP/3</h3><p>HTTP/2 很好的解决了当下最常用的 HTTP/1 所存在的一些性能问题，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，当然兼容问题以及如何优雅降级应该是国内还不普遍使用的原因之一。</p><p>虽然 HTTP/2 已经解决了很多问题，但是并不代表它已经是完美的了，HTTP/3 就是为了解决 HTTP/2 所存在的一些问题而被推出来的。</p><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><p>HTTP/2 相比对 HTTP/1 可以说是大幅度提高了网页的性能。</p><p>在 HTTP/1 为了性能考虑，我们会引入雪碧图、将小图内联、使用多个域名等等的方式。这一切都是因为浏览器限制了同一个域名下的请求数量（Chrome 下一般是限制六个连接），当页面中需要请求很多资源的时候，队头阻塞（Head of line blocking）会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。</p><p>在 HTTP/2 中引入了多路复用的技术，这个技术可以只通过一个 TCP 连接就可以传输所有的请求数据。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也接更容易实现全速传输，毕竟新开一个 TCP 连接都需要慢慢提升传输速度。</p><p>大家可以通过 <a href="https://link.juejin.im/?target=https%3A%2F%2Fhttp2.akamai.com%2Fdemo">该链接</a> 感受下 HTTP/2 比 HTTP/1 到底快了多少。</p><h3 id="二进制传输"><a href="#二进制传输" class="headerlink" title="二进制传输"></a>二进制传输</h3><p>HTTP/2 中所有加强性能的核心在于此，在之前的 HTTP 版本，我们是通过文本的方式传输数据，在 HTTP/2 中引入了新的编码机制，所有的传输数据都会被分割，并采用二进制格式编码。</p><p><img src="./images/前端面试题目汇总摘录-JS 基础篇3-二进制传输.png" alt="二进制传输"></p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>在 HTTP/2 中有两个非常重要的概念，分别是 帧（frame）和 流 （stream）</p><p>帧代表着最小的数据单位，每个帧都会标识出该帧属于哪个流，流也就是多个帧组成的数据流</p><p>多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的对头阻塞的问题，极大提高了传输的性能。</p><h3 id="Header-压缩"><a href="#Header-压缩" class="headerlink" title="Header 压缩"></a>Header 压缩</h3><p>在 HTTP/1 中使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千字节。</p><p>在 HTTP/2 中使用 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header。后面在传输过程中可以传输以及记录过的 header 的键名，对端收到的数据后就可以通过键名找到对应的值</p><h3 id="服务端-Push"><a href="#服务端-Push" class="headerlink" title="服务端 Push"></a>服务端 Push</h3><p>在 HTTP/2 中，服务端可以在客户端某个请求后，主动推送其他资源</p><p>某些资源客户端是一定会请求的，这时候可以采用服务端 push 的技术，提前给客户端推送必要的资源，这样就可以相对减少一点延迟时间。当然在浏览器兼容的情况下也可以使用 prefetch</p><h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3><p>底层的 TCP 协议导致 HTTP/2 版本存在一个问题，因为使用了多路复用，一般来说同一个域名下面只需要一个 TCP 连接。当这个连接中出现了丢包的情况，就会导致 HTTP/2 的表现不如 HTTP/1</p><p>在丢包的情况下，整个 TCP 都要开始等待重传，就导致了后面的所有的数据都会被阻塞。但是对于 HTTP/1 来说可以开启多个 TCP 连接，出现这种情况只会影响一个连接，剩余的 TCP 连接可以正常传输数据</p><p>这个协议是由操作系统实现的，如果要去修改 TCP 协议看起来不怎么现实。</p><p>基于这个原因，Google 就更起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上，</p><p>HTTP/3 之前名为 HTTP-over-QUIC</p><h4 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h4><p>UDP 协议虽然效率很高，但是并不是那么的可靠.QUIC 是基于 UDP ,在原生的基础上新增了很多功能，比如多路复用、0-RTT、使用 TLS1.3 加密、流量控制、有序交付、重传等功能。</p><h4 id="多路复用-1"><a href="#多路复用-1" class="headerlink" title="多路复用"></a>多路复用</h4><p>虽然 HTTP/2 支持多路复用，但是 TCP 协议终究是没有这个功能的。QUIC 就原生实现了这个功能，并且传输的单个数据流可以保证有序交付但不会影响其他的数据流，这样的技术就解决了之前的 TCP 存在的问题。</p><p>并且 QUIC 在移动端会比 TCP 好，因为 TCP 是基于 IP 和端口去识别连接的，这种方式在多变的移动端网络环境下是很脆弱的。但是因为 QUIC 是通过 ID 的方式去识别一个连接的，不会随着网络的变化而变化，可以迅速重连上。</p><h4 id="0-RRT"><a href="#0-RRT" class="headerlink" title="0-RRT"></a>0-RRT</h4><p>通过使用类似 TCP 的快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。</p><h4 id="纠错机制"><a href="#纠错机制" class="headerlink" title="纠错机制"></a>纠错机制</h4><p>假如说这次我要发送三个包，那么协议会算出这三个包的异或值并单独发出一个校验包，也就是总共发出了四个包。当出现其中的非校验丢包的 情况的时候，可以通过另外三个包计算出丢失的数据包的内容。</p><p>当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。</p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li>HTTP/2 通过多路复用、二进制流、header 压缩等技术，极大提高了性能，但是还是存在着问题</li><li>QUIC 基于 UDP 实现，是 HTTP/3 中底层支撑协议，该协议基于 UDP，而且拿了 TCP 中的精华，实现了又快有可靠的协议</li></ul><p>关于 HTTP/3 更多<a href="http://www.sohu.com/a/299243519_115128">点击这里</a></p><h2 id="输入-URL-到页面渲染的整个过程"><a href="#输入-URL-到页面渲染的整个过程" class="headerlink" title="输入 URL 到页面渲染的整个过程"></a>输入 URL 到页面渲染的整个过程</h2><p>首先是 DNS 查询，如果这一步做到了智能 DNS 解析的话，会提供速度最快的 IP 地址回来</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>DNS 的作用就是通过域名查询到具体的 IP 地址</p><p>因为 IP 存在数据和英文的组合（IPv6），不利于记忆，所以就出现了域名，可以把它看成某个 IP 地址的别名，DNS 就是通过这个别名去查询真正的名字是什么</p><p>在 TCP 握手之前以及先进行了 DNS 查询，这个查询是操作系统自己做的，在浏览器中访问 <a href="http://www.googel.com">www.googel.com</a> 的时候，会进行以下的操作：</p><ol><li>操作系统会首先在本地缓存中查询 IP</li><li>没有的话就会去系统配置的 DNS 服务器中查询</li><li>如果这时候还没有找到，就会直接去 DNS 根服务器查询，这一步查询会找出负责 <code>com</code>这个域名的服务器</li><li>然后去该服务器查询  <code>google</code>这个二级域名</li><li>接下来是三级域名的查询，这个是我们自己配置的，可以给 <code>www</code> 这个域名配置一个IP,然后还可以给别的三级域名配置一个 IP</li></ol><p>上面是DNS 迭代查询，还有一种格式递归查询，区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果将数据返回给客户端。</p><p>DNS 是基于 UDP 做的查询</p><p>接下来是 TCP 握手协议，应用层会下发数据给传输层，这里的 TCP 协议会指明两端的端口号，然后下发给网络层。网络层的 IP 协议会确定 IP 地址，并制定了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了。</p><p>在这一部分中，TCP 握手结束后，会进行 TLS 握手，然后开始正式的传输数据了。</p><p>数据在进入服务端之前，可能还会警告负责负载均衡的服务器，它的作用是将请求合理的分发到多态服务器上面，这时假设服务端会响应一个 HTML 文件</p><p>首先浏览器会判断状态码是什么，如果是200 就继续解析，如果是 400 或者 500 的话就会报错，如果是 300 就会重定向，这里会有一个 重定向计数器，避免多次的重定向，超过次数也会报错。</p><p>浏览器开始解析文件，如果是 gzip 格式的会先解压一下，然后通过文件的编码格式知道该如何取解码文件。</p><p>文件解码后就会正式开始渲染流程，先根据 HTML 创建 DOM 树，有 CSS 的话就是 CSSOM 树，如果遇到 script 标签的话，会判断是否存在 async 或者 defer,前者会并行进行下载并执行 JS,后者会先下载文件，然后等待 HTML 解析完成后顺序执行。</p><p>如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到下载文件就会去下载文件，如果使用 HTTP/2 协议的话就会极大提高多图的下载效率</p><p>CSSOM 树 和 DOM 树构建完成之后会生成 render 树，这一步就是确定页面布局、样式等诸多方面的东西。</p><p>在生成 Render 树的过程中，浏览器就会开始调用 GPU 绘制，合成图层，将内容显示在 屏幕上了。</p><p>关于这个流程，更多的可以<a href="https://github.com/skyline75489/what-happens-when-zh_CN">点击这里</a></p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>关于具体的设计模式我有过一些<a href="http://laibh.top/tags/javaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">笔记</a></p><p>下面还是根据作者的脚步来回顾这一点知识点</p><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>有一份很复杂的代码需要用户去调用，但是用户并不关心这些代码是怎么实现的，只需要提供一个接口去调用，用户只负责传递需要的参数。参数的使用都在内部逻辑去完成，不暴露出来给用户。只要给用户返回一个实例，这种构造过程就是工厂。</p><p>简而言之就是隐藏了创建实例的复杂度，只需要提供一个接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    alertName()&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Factory</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> create(name)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Man(name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Factory.create(<span class="string">'haha'</span>).alertName()</span><br></pre></td></tr></table></figure><p>Vue 源码中，也可以看到工厂模式的使用，比如创建异步组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">export function createComponent(</span><br><span class="line">  Ctor: Class&lt;Component&gt; | Function | Object | void,</span><br><span class="line">  data: ?VNodeData,</span><br><span class="line">  context: Component,</span><br><span class="line">  children: ?Array&lt;VNode&gt;,</span><br><span class="line">  tag?: string</span><br><span class="line">): VNode | Array&lt;VNode&gt; | void &#123;</span><br><span class="line"></span><br><span class="line">  // 逻辑处理...</span><br><span class="line"></span><br><span class="line">  const vnode = new VNode(</span><br><span class="line">    `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : &apos;&apos;&#125;`,</span><br><span class="line">    data, undefined, undefined, undefined, context,</span><br><span class="line">    &#123; Ctor, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  return vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们可以看到我们只需要调用 <code>createComponent</code> 传入参数就能创建一个组件实例，但是创建这个实例是很复杂的一个过程，工厂帮助我们隐藏了这个复杂的过程，只需要一句代码调用就能实现功能。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式很常用，比如全局缓存、全局状态管理等等只需要一个对象，就可以使用单例模式</p><p>单例模式的核心就是保证全局只有一个对象可以访问。因为 JS 是门无类的语言，所以别的语言实现单例的方式不能套入 JS 中，我们需要用一个变量确保值创建一次就可以了，下面是如何实现单例模式的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">Singleton.getInstance = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> instance;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!instance) &#123;</span><br><span class="line">      instance = <span class="keyword">new</span> Singleton()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> Singleton.getInstance();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> Singleton.getInstance();</span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在 Vuex 源码中也可以看到单例模式的运用，虽然实现的方式不大一样，通过一个外部变量来控制只安装一次 Vuex</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Vue <span class="comment">// bind on install</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">install</span> (<span class="params">_Vue</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Vue &amp;&amp; Vue === Vue)&#123;</span><br><span class="line">       <span class="comment">// 如果发现 Vue 有值，就不重新创建实例了</span></span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Vue = _Vue;</span><br><span class="line">    applyMixin(Vue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器用来解决两个接口不兼容的情况，不需要改变已有的接口，通过包装一层的方式实现两个接口的正常协作</p><p>简单实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Plug</span></span>&#123;</span><br><span class="line">    getName()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'港版插头'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.plug = <span class="keyword">new</span> Plug()</span><br><span class="line">    &#125;</span><br><span class="line">    getName()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.plug.getName() + <span class="string">' 适配转二脚插头'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> target = <span class="keyword">new</span> Target();</span><br><span class="line">target.getName(); <span class="comment">// 港版插头 适配转二脚插头</span></span><br></pre></td></tr></table></figure><p>在 Vue 中经常使用到适配器模式，比如父组件传递给子组件一个时间戳属性，组件内部需要将时间戳转为正常的日期显示，一般会使用 computed 来做转换这件事情，这个过程就是用到了适配器模式</p><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>装饰模式不需要改变已有的接口，作用是给对象添加功能，就像我们经常需要给手机戴个保护套防摔一样，不改变手机自身，给手机添加了保护套提供防摔的功能。</p><p>以下是如何实现装饰模式的例子，使用了 ES7 中的装饰器语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target,key,descriptor</span>)</span>&#123;</span><br><span class="line">    descriptor.writable = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> descriptor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    @readonly</span><br><span class="line">    name = <span class="string">'haha'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> t = <span class="keyword">new</span> Test();</span><br><span class="line">t.haha = <span class="string">'11'</span>; <span class="comment">// 不可修改</span></span><br></pre></td></tr></table></figure><p>在 React 中，装饰模式是随处可见的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(mapStateToProps)(MyComponent)</span><br></pre></td></tr></table></figure><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>代理是为了控制对对象的访问，不让外部直接访问到对象，事件代理也是用到了代理模式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#ul'</span>);</span></span><br><span class="line"><span class="javascript">    ul.addEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.target);</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为存在太多 li，不可能每个都去绑定事件，这时候可以通过给父节点绑定一个事件，让父节点作为代理去拿到真实点击的节点。</p><h3 id="发布-订阅模式"><a href="#发布-订阅模式" class="headerlink" title="发布-订阅模式"></a>发布-订阅模式</h3><p>发布-订阅模式也叫做观察者模式，通过一对一或者一对多的依赖关系，当对象发生改变的时候，订阅方都会收到通知。现实生活中的例子是当我需要在购物网站购买一个产品的时候，但是发现该产品目前处于缺货状态，这时候我们可以点击有货通知的按钮，让网站在产品有货的时候通过短信通知我。</p><p>在实际代码中，其实发布-定于模式也很常见，比如我们点击一个按钮触发了点击事件其实就是使用了该模式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#ul'</span>);</span></span><br><span class="line"><span class="javascript">    ul.addEventListener(<span class="string">'click'</span>,(e)=&gt;&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(e.target);</span></span><br><span class="line"><span class="undefined">    &#125;)    </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 Vue 中，如何实现响应式也是使用了该模式，对于需要实现想爱你过隐式的对象来说，在 get 的时候会进行依赖手机，当改变了对象的属性的时候，就会触发派发更新</p><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>外观模式提供了一个接口，隐藏了内部的逻辑，更加方便外部的调用</p><p>我们需要实现一个兼容多种浏览器的添加事件方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">elm, evType, fn, useCapture</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (elm.addEventListener) &#123;</span><br><span class="line">    elm.addEventListener(evType, fn, useCapture);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (elm.attachEvent) &#123;</span><br><span class="line">    <span class="keyword">return</span> elm.attachEvent(<span class="string">'on'</span> + evType, fn)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    elm[<span class="string">"on"</span> + evType] = fn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不同的浏览器，添加事件的方式可能会存在兼容问题，如果每次都要这样写一遍是不可能，我们将逻辑判断统一在一个接口里面，外部需要添加事件只需要调用 addEvent 就可以了</p><h2 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h2><p>关于数据结构我之前的笔记也有过记录，具体的可以<a href="http://laibh.top/tags/javaScript%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">点击这里</a></p><p>下面还是跟着作者来重温一遍常见的数据结构</p><h3 id="大O表示法"><a href="#大O表示法" class="headerlink" title="大O表示法"></a>大O表示法</h3><p>如何衡量算法的效率？通常是用资源，例如CPU（时间）占用、内存占用、硬盘占用和网络占用。当讨论大O表示法时，一般考虑的是CPU（时间）占用。</p><p>分析算法时，时常遇到以下几类函数</p><table><thead><tr><th style="text-align:left">符号</th><th style="text-align:left">名称</th></tr></thead><tbody><tr><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left">常数的</td></tr><tr><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left">对数的</td></tr><tr><td style="text-align:left"><em>O((log(n)c))</em></td><td style="text-align:left">对数多项式的</td></tr><tr><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left">线性的</td></tr><tr><td style="text-align:left"><em>O(n2)</em></td><td style="text-align:left">二次的</td></tr><tr><td style="text-align:left"><em>O(nc)</em></td><td style="text-align:left">多项式的</td></tr><tr><td style="text-align:left"><em>O(cn)</em></td><td style="text-align:left">指数的</td></tr></tbody></table><h3 id="常用数据结构的时间复杂度"><a href="#常用数据结构的时间复杂度" class="headerlink" title="常用数据结构的时间复杂度"></a>常用数据结构的时间复杂度</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><table><thead><tr><th style="text-align:left">数据结构</th><th style="text-align:left">一般情况</th><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left">最差情况</th><th style="text-align:left"></th><th style="text-align:left"></th></tr></thead><tbody><tr><td style="text-align:left"></td><td style="text-align:left">插入</td><td style="text-align:left">删除</td><td style="text-align:left">搜索</td><td style="text-align:left">插入</td><td style="text-align:left">删除</td><td style="text-align:left">搜索</td></tr><tr><td style="text-align:left">数组-栈-队列</td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td></tr><tr><td style="text-align:left">链表</td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td></tr><tr><td style="text-align:left">双向链表</td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td></tr><tr><td style="text-align:left">散列表</td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(1)</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(n)</em></td></tr><tr><td style="text-align:left">二分搜索树</td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(n)</em></td></tr><tr><td style="text-align:left">AVL树</td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td><td style="text-align:left"><em>O(log(n))</em></td></tr></tbody></table><h4 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h4><table><thead><tr><th style="text-align:left">算法（用于数组）</th><th style="text-align:left">最好情况</th><th style="text-align:left">一般情况</th><th style="text-align:left">最差情况</th></tr></thead><tbody><tr><td style="text-align:left">冒泡排序</td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(n2)</em></td><td style="text-align:left"><em>O(n2)</em></td></tr><tr><td style="text-align:left">选择排序</td><td style="text-align:left"><em>O(n2)</em></td><td style="text-align:left"><em>O(n2)</em></td><td style="text-align:left"><em>O(n2)</em></td></tr><tr><td style="text-align:left">插入排序</td><td style="text-align:left"><em>O(n)</em></td><td style="text-align:left"><em>O(n2)</em></td><td style="text-align:left"><em>O(n2)</em></td></tr><tr><td style="text-align:left">归并排序</td><td style="text-align:left"><em>O(nlog(n))</em></td><td style="text-align:left"><em>O(nlog(n))</em></td><td style="text-align:left"><em>O(nlog(n))</em></td></tr><tr><td style="text-align:left">快速排序</td><td style="text-align:left"><em>O(nlog(n))</em></td><td style="text-align:left"><em>O(nlog(n))</em></td><td style="text-align:left"><em>O(n2)</em></td></tr><tr><td style="text-align:left">堆排序</td><td style="text-align:left"><em>O(nlog(n))</em></td><td style="text-align:left"><em>O(nlog(n))</em></td><td style="text-align:left"><em>O(nlog(n))</em></td></tr><tr><td style="text-align:left">桶排序</td><td style="text-align:left"><em>O(n+k)</em></td><td style="text-align:left"><em>O(n+k)</em></td><td style="text-align:left"><em>O(n2)</em></td></tr><tr><td style="text-align:left">基数排序</td><td style="text-align:left"><em>O(nk)</em></td><td style="text-align:left"><em>O(nk)</em></td><td style="text-align:left"><em>O(nk)</em></td></tr></tbody></table><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一个线性结构，在计算机中是一个相当常见的数据结构，栈的特点是只能在某一端添加或者删除数据，遵循先进后出的规则（FILO）的原则</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加一个或者结构新元素到栈顶</span></span><br><span class="line">  push(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 移除栈顶的元素</span></span><br><span class="line">  pop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack.pop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回栈顶的元素</span></span><br><span class="line">  peek() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack[<span class="keyword">this</span>.size() - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack.length</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size() === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = [];</span><br><span class="line">  &#125;</span><br><span class="line">  getStack() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>题意是匹配括号，可以通过栈的特性来完成这道题目</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isVaild = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = &#123;</span><br><span class="line">    <span class="string">"("</span>: <span class="number">-1</span>,</span><br><span class="line">    <span class="string">")"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"["</span>: <span class="number">-2</span>,</span><br><span class="line">    <span class="string">"]"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">"&#123;"</span>: <span class="number">-3</span>,</span><br><span class="line">    <span class="string">"&#125;"</span>: <span class="number">3</span>,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">new</span> Stack();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map[s[i]] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      stack.push(s[i])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> last = stack.pop()</span><br><span class="line">      <span class="keyword">if</span> (map[last] + map[s[i]] != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (stack.size() === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Vue  中关于模板解析的代码，就有应用到匹配尖括号的内容</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一个线性结构，特点是在某一段添加数据，在另一端删除数据，遵循先进先出的原则（FIFO）</p><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><p>分成单链队列和循环队列</p><h5 id="单链队列"><a href="#单链队列" class="headerlink" title="单链队列"></a>单链队列</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = []</span><br><span class="line">  &#125;</span><br><span class="line">  enQueue(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  deQueue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.shift();</span><br><span class="line">  &#125;</span><br><span class="line">  front() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.length</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size() === <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = [];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为单链队列在出队操作的时候㤇 O(n)的时间复杂度，所以引入了循环队列，循环队列的出队操作平均是 O(1)的时间复杂度</p><h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sqQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(length) &#123;</span><br><span class="line">    <span class="keyword">this</span>.queue = <span class="keyword">new</span> <span class="built_in">Array</span>(length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 队头</span></span><br><span class="line">    <span class="keyword">this</span>.first = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 队尾</span></span><br><span class="line">    <span class="keyword">this</span>.last = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前队列的大小</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  enQueue(item) &#123;</span><br><span class="line">    <span class="comment">// 如果队尾 +1 是否为队头，如果是就代表需要扩容数组，%this.queue.length 是为了防止数组越界</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.first === (<span class="keyword">this</span>.last + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length) &#123;</span><br><span class="line">      <span class="keyword">this</span>.resize(<span class="keyword">this</span>.size() * <span class="number">2</span> + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.queue[<span class="keyword">this</span>.last] = item;</span><br><span class="line">    <span class="keyword">this</span>.size++;</span><br><span class="line">    <span class="keyword">this</span>.last = (<span class="keyword">this</span>.last + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length</span><br><span class="line">  &#125;</span><br><span class="line">  deQueue() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Queue is empty'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> r = <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first];</span><br><span class="line">    <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.first = (<span class="keyword">this</span>.first + <span class="number">1</span>) % <span class="keyword">this</span>.queue.length;</span><br><span class="line">    <span class="keyword">this</span>.size--;</span><br><span class="line">    <span class="comment">// 判断当前队列是否过小，为了保证不浪费空间，在队列空间等于总长度四分之一的时候且不为2时缩小总长度为当前的一半</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size === <span class="keyword">this</span>.size() / <span class="number">4</span> &amp;&amp; <span class="keyword">this</span>.size() / <span class="number">2</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.resize(<span class="keyword">this</span>.size() / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  front() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.size()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Queue is empty'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue[<span class="keyword">this</span>.first]</span><br><span class="line">  &#125;</span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.queue.length - <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.first === <span class="keyword">this</span>.last;</span><br><span class="line">  &#125;</span><br><span class="line">  resize(length) &#123;</span><br><span class="line">    <span class="keyword">let</span> q = <span class="keyword">new</span> <span class="built_in">Array</span>(length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">      q[i] = <span class="keyword">this</span>.queue[(i + <span class="keyword">this</span>.first) % <span class="keyword">this</span>.queue.length]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.queue = q;</span><br><span class="line">    <span class="keyword">this</span>.first = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.last = <span class="keyword">this</span>.size</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是一个线性结构，同时也是一个天然的递归结构。链表结构可以充分利用计算机内存空间，实现灵活的内存活动管理。但是链表失去了数组随机读取的优点，同时链表也增加了结点的指针域，空间开销比较大。</p><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>单向链表</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 链表长度</span></span><br><span class="line">    <span class="keyword">this</span>.size = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 虚拟头部</span></span><br><span class="line">    <span class="keyword">this</span>.dummyNode = <span class="keyword">new</span> Node(<span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  find(header, index, currentIndex) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index === currentIndex) <span class="keyword">return</span> header</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.find(header.next, index, currentIndex + <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  addNode(v, index) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkIndex(index);</span><br><span class="line">    <span class="comment">// 当往链表末尾插入时，prev.next 为空，其他情况时，因为要插入节点，所以插入的节点的next 应该是 prev.next 然后设置 prev.next 为插入的节点</span></span><br><span class="line">    <span class="keyword">let</span> prev = <span class="keyword">this</span>.find(<span class="keyword">this</span>.dummyNode, index, <span class="number">0</span>);</span><br><span class="line">    prev.next = <span class="keyword">new</span> Node(v, prev.next);</span><br><span class="line">    <span class="keyword">this</span>.size++;</span><br><span class="line">    <span class="keyword">return</span> prev.next;</span><br><span class="line">  &#125;</span><br><span class="line">  insertNode(v, index) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.addNode(v, index);</span><br><span class="line">  &#125;</span><br><span class="line">  addToFirst(v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.addNode(v, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  addToLast(v) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.addNode(v, <span class="keyword">this</span>.size);</span><br><span class="line">  &#125;</span><br><span class="line">  removeNode(index, isLast) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkIndex(index);</span><br><span class="line">    index = isLast ? index - <span class="number">1</span> : index;</span><br><span class="line">    <span class="keyword">let</span> prev = <span class="keyword">this</span>.find(<span class="keyword">this</span>.dummyNode, index, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> node = prev.next;</span><br><span class="line">    prev.next = node.next;</span><br><span class="line">    node.next = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">this</span>.size--;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">  removeFirstNode() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.removeNode(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  removeLastNode() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.removeNode(<span class="keyword">this</span>.size, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  checkIndex(index) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; <span class="keyword">this</span>.size) <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Index error'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  getNode(index) &#123;</span><br><span class="line">    <span class="keyword">this</span>.checkIndex(index);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.find(<span class="keyword">this</span>.dummyNode, index, <span class="number">0</span>).next;</span><br><span class="line">  &#125;</span><br><span class="line">  isEmpty() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size === <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  size() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><p>树拥有很多种结构，二叉树是树中最常见的结构，同时也是一个天然的递归结构</p><p>二叉树拥有一个根节点，每个节点至多拥有两个子节点，分别为：左节点和右节点。树的最底部节点称之为叶节点，当一棵树的数量为满，该树就可以称之为二叉树</p><pre class="mermaid">graph TDA[2] --> B[7]A[2] --> C[5]C[5] --> F[9]F[9] --> J[4]B[7] --> D[2]B[7] --> E[6]E[6] --> G[5]E[6] --> H[11]</pre><h4 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h4><p>二分搜索树也是二叉树，拥有二叉树的特性。但是区别于在二分搜索树每个节点的值都比它的左子树的值大，比右子树的值小。</p><p>这种存储方式很适合数据搜索。如下图显示，当需要查找6的时候，因为需要查找的值比根节点的值大，所以只需要在根节点的右子树上寻找，大大提高了搜索效率</p><pre class="mermaid">graph TDA[5] --> B[2]B[2] --> C[1]B[2] --> D[4]D[4] --> E[3]A[5] --> F[6]F[6] --> G[7]</pre><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><p>具体可以<a href="http://laibh.top/2018-11-05-JavaScipt%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95Part8.html">点击这里</a></p><h2 id="CSS-常考面试题目资料"><a href="#CSS-常考面试题目资料" class="headerlink" title="CSS 常考面试题目资料"></a>CSS 常考面试题目资料</h2><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000013325778">50道CSS基础面试题（附答案）</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000013860482">《50道CSS基础面试题（附答案）》中的答案真的就只是答案吗？</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Ffunteas.com%2Ftopic%2F5ada8eac230d1e5e25e45b89">CSS 面试题总结</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fyangshun%2Ffront-end-interview-handbook%2Fblob%2Fmaster%2FTranslations%2FChinese%2Fquestions%2Fcss-questions.md">front-end-interview-handbook</a></li></ul><h2 id="推荐的资料"><a href="#推荐的资料" class="headerlink" title="推荐的资料"></a>推荐的资料</h2><h3 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h3><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fgetify%2FYou-Dont-Know-JS">You-Dont-Know-JS</a>，这套书深入的讲解很多 JS 的内容，英文版是开源免费阅读的，如果你英文不好的话，国内这套书已经有出版了，可以选择购买。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fgetify%2FFunctional-Light-JS">Functional-Light-JS</a>，这本书是讲解函数式编程的，函数式编程也是一种编程范式，轻量级的函数式可以很方便的解决很多问题，有兴趣的可以一读。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fleonardomso%2F33-js-concepts">33-js-concepts</a>，这份资料讲解了 33 个前端开发必须知道的 JS 概念，内容是英文的，如果你英文不好的话，可以寻找这份资料的中文版。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fdt-fe%2Fweekly">前端精读周刊</a>，这是一份前端好文集合，每周都会更新，目前已经更新了 84 篇文章。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FJohnsenZhou%2FFront-End-Performance-Checklist">前端性能清单</a>，这是一份前端性能清单，如果你需要优化一个项目的话，可以根据这份清单一个个来检查优化项。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2F30-seconds%2F30-seconds-of-code">30-seconds-of-code</a>，30 秒系列，很短的代码片段让你了解一个知识点。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FAllThingsSmitty%2Fmust-watch-javascript">must-watch-javascript</a>，这份资料包含了很多高质量的前端相关视频，值得一看。</li></ul><h3 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h3><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FAllThingsSmitty%2Fcss-protips">css-protips</a>，通过这份资料你可以学习到很多 tips 来提高你的 CSS 技能。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2F30-seconds%2F30-seconds-of-css">30-seconds-of-css</a>，30 秒系列，很短的代码片段让你了解一个知识点</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fitem.jd.com%2F12262251.html">CSS 世界</a>，张鑫旭出版的书籍，没什么好说的了，看就是了。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fchokcoco%2FiCSS">一些有趣的 CSS 话题</a>，CSS 奇技淫巧，在这里，都有。</li></ul><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>React 核心团队成员 Dan Abramov 的 <a href="https://link.juejin.im/?target=https%3A%2F%2Foverreacted.io%2F">blog</a>。</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fnswbmw%2Fnode-in-debugging">Node.js 调试指南</a>，这是一本专注于讲解 Node 调试的书籍，已经出版了，但是可以开源免费阅读。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fitem.jd.com%2F12380404.html">Node.js：来一打 C++ 扩展</a>，死月出版的书籍，没什么好说的，看就是了。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fi0natan%2Fnodebestpractices%2Fblob%2Fmaster%2FREADME.chinese.md">Node.js 最佳实践</a>，这是对 Node.js 最佳实践中排名最高的内容的总结和分享</li></ul><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Ftrimstray%2Fthe-book-of-secret-knowledge">the-book-of-secret-knowledge</a>，这是一份安全领域的资料，如果你对安全感兴趣的话，可以阅读一下内容。</li></ul><h3 id="周报"><a href="#周报" class="headerlink" title="周报"></a>周报</h3><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fweekly.75team.com%2F">奇舞周刊</a>，每周都会整理一份不错的中文文章合集。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fweekly.techbridge.cc%2F">TechBridge Weekly</a>，这是一份台湾地区整理的一份多个技术领域的周报。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fjavascriptweekly.com%2F">JavaScript Weekly</a>，这是一份相当有名气的英文周报，整理的文章质量都很高，如果你只想订阅一份周报，那就是它了。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fponyfoo.com%2Fweekly">Pony Foo Weekly</a>，这也是一份不错的英文周报，文章质量也很高，并且和上一份周报重叠的内容不多。</li></ul><h3 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h3><p>Medium 上我并没有怎么固定阅读，更多的是订阅它的日报或者从别的周报上看到的 Medium 的文章，但是如果一定要推荐两个组织的话，我只推荐这两个，毕竟他们的文章质量都很高。</p><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fmedium.freecodecamp.org%2F">freecodecamp</a></li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fhackernoon.com%2F">hackernoon</a></li></ul><h3 id="Youtube"><a href="#Youtube" class="headerlink" title="Youtube"></a>Youtube</h3><p>Youtube 有很多高质量的视频，但是门槛大家都知道，这里我推荐一些值得订阅的频道。</p><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fchannel%2FUCzoVCacndDCfGDf41P-z0iA">JSConf</a>，很多会议的视频你都可以在这里找到。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fchannel%2FUCnUYZLuoy1rq1aVMwx4aTzw">Google Chrome Developers</a>，Google 金字招牌，没啥好说的。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fchannel%2FUC9-y-6csu5WGm29I7JiwpnA">Computerphile</a>，内容偏向于计算机领域。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fchannel%2FUCtxCXg-UvSnTKPOzLH4wJaQ%2Fvideos">Coding Tech</a>，内容偏向于入门。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fchannel%2FUCO1cgjhGzsSYb1rsB4bFe4Q">Fun Fun Function</a>，如果你想学习函数式编程的一些内容，这是一个值得订阅的频道。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.youtube.com%2Fuser%2FDevTipsForDesigners%2Fvideos">DevTips</a>，每周更新一个视频，能够学习到不少开发中的 Tips。</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fdavideuler%2Farchitecture.of.internet-product">互联网公司技术架构</a>，这份资料介绍了当下互联网公司的一个技术架构。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Ftrekhleb%2Fjavascript-algorithms">javascript-algorithms</a>，这份资料作者使用了 JS 来实现了大部分的数据结构和算法。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fjamiebuilds%2Fthe-super-tiny-compiler">小型编译器</a>，这份资料告诉了我们该如何去实现一个小型的编译器，很适合前端开发者阅读。</li><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fmtdvio%2Fevery-programmer-should-know">every-programmer-should-know</a>，这份资料列举了很多每个开发者都应该知道的知识点。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;温故而知新，保持空杯心态,复习到一半的时间，突然发现了 &lt;a href=&quot;https://yuchengkai.cn/docs/frontend&quot;&gt;前端面试之道&lt;/a&gt;，按学习这本书的路径来&lt;/p&gt;
&lt;h2 id=&quot;JS-基础3&quot;&gt;&lt;a href=&quot;#JS-基础3&quot; cla
      
    
    </summary>
    
      <category term="前端面试" scheme="http://laibh.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端面试题" scheme="http://laibh.top/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>webpack4.x从基础到实战</title>
    <link href="http://laibh.top/2019-04-13-webpack4x%E4%BB%8E%E5%9F%BA%E7%A1%80%E5%88%B0%E5%AE%9E%E6%88%98.html"/>
    <id>http://laibh.top/2019-04-13-webpack4x从基础到实战.html</id>
    <published>2019-04-13T08:30:00.000Z</published>
    <updated>2019-10-15T09:29:49.415Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://coding.imooc.com/learn/list/316.html">DellLee 老师的 webpack 学习与记录</a></p><p>知识点：</p><blockquote><p><code>Loader</code> <code>HMR</code> <code>Create React App</code> <code>Caching</code> <code>Plugin</code> <code>SourceMap</code> <code>Vue Cli 3.0</code> <code>Shimming</code> <code>WebpackDevServer</code> <code>TreeShaking</code>  <code>CodeSplitting</code> <code>Babel</code> <code>React</code> <code>Library</code> <code>Eslint</code> <code>PWA</code> <code>Vue</code> <code>Mode</code> <code>性能优化</code> <code>多页应用</code> <code>原理</code> <code>PreLoading</code> <code>PreFetching</code> <code>环境变量</code>  <code>TypeScript</code></p></blockquote><h2 id="Webpack-是什么"><a href="#Webpack-是什么" class="headerlink" title="Webpack 是什么"></a>Webpack 是什么</h2><p>本质上，<em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)</em>。当 webpack 处理应用程序时，它会递归地构建一个<em>依赖关系图(dependency graph)</em>，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 <em>bundle</em>。</p><p><a href="https://webpack.js.org/concepts/modules/">扩展阅读-Modules</a></p><h2 id="webapack-打包浅析"><a href="#webapack-打包浅析" class="headerlink" title="webapack 打包浅析"></a>webapack 打包浅析</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// production 模式下代码压缩，development 代码不压缩</span></span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Loader"><a href="#Loader" class="headerlink" title="Loader"></a>Loader</h2><p>module 处理方案，loader 有先后顺序，从下到上，从右到左</p><h3 id="file-loader"><a href="#file-loader" class="headerlink" title="file-loader"></a><strong>file-loader</strong></h3><p>处理图片</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 开发还是生产环境</span></span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  <span class="comment">// 进口</span></span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  <span class="comment">// 模块处理</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 规则</span></span><br><span class="line">    rules: [&#123;</span><br><span class="line">      <span class="comment">// 匹配</span></span><br><span class="line">      test: <span class="regexp">/\.jpg$/</span>,</span><br><span class="line">      <span class="comment">// loader 运用</span></span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span>,</span><br><span class="line">        <span class="comment">// 占位符</span></span><br><span class="line">        options: &#123;</span><br><span class="line">          <span class="comment">// 定义文件的名字：原来的名字_哈希值.原来的后缀</span></span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          <span class="comment">// 图片输出路径</span></span><br><span class="line">          outputPath:<span class="string">'./images/'</span></span><br><span class="line">        &#125;          </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 或者是用方法的方式</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 开发还是生产环境</span></span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  <span class="comment">// 进口</span></span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  <span class="comment">// 模块处理</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="comment">// 规则</span></span><br><span class="line">    rules: [&#123;</span><br><span class="line">      <span class="comment">// 匹配</span></span><br><span class="line">      test: <span class="regexp">/\.jpg$/</span>,</span><br><span class="line">      <span class="comment">// loader 运用</span></span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span>,</span><br><span class="line">        <span class="comment">// 占位符</span></span><br><span class="line">        options: &#123;</span><br><span class="line">          <span class="comment">// 定义文件的名字：原来的名字_哈希值.原来的后缀</span></span><br><span class="line">        name(file)&#123;</span><br><span class="line">            <span class="keyword">if</span>(process.env.NODE_ENV === <span class="string">'development'</span>)&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="string">'[path][name].[ext]'</span>,</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'[hash][ext]'</span></span><br><span class="line">        &#125;,</span><br><span class="line">          <span class="comment">// 图片输出路径</span></span><br><span class="line">          outputPath:<span class="string">'./images/'</span></span><br><span class="line">        &#125;          </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 输出</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="url-loader"><a href="#url-loader" class="headerlink" title="url-loader"></a><strong>url-loader</strong></h3><p>会把图片打包到js 文件中，如果图片很小（1-2kb）的话就适合以base64的形式打包到js里面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          outputPath: <span class="string">'images/'</span>,</span><br><span class="line">          <span class="comment">// 限制图片的大小（Kb）,小于的会被打包到js里面，大于则打包到指定目录下</span></span><br><span class="line">          limit: <span class="number">2048</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用来处理字体文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [&#123;</span><br><span class="line">    test:<span class="regexp">/\.(eot|ttf|svg|woff)$/</span>,</span><br><span class="line">    use:&#123;</span><br><span class="line">      loader:<span class="string">'file-loader'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="style-loader、css-loader"><a href="#style-loader、css-loader" class="headerlink" title="style-loader、css-loader"></a><strong>style-loader</strong>、<strong>css-loader</strong></h3><p>处理css 样式</p><p>css-loader 分析有几个css文件以及它们之间的关系是怎么样的然后合并为一个css</p><p>style-loader 会把 css-loader 合并的内容挂载到页面上</p><p>node-sass、sass-loader：应对 sass 文件，上面的组合处理sass 文件不会报错，但是不会转义sass 特殊的语法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [ &#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">    use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h3 id="postcss-loader、autoprefixer"><a href="#postcss-loader、autoprefixer" class="headerlink" title="postcss-loader、autoprefixer"></a><strong>postcss-loader</strong>、<strong>autoprefixer</strong></h3><p>自动添加css前缀</p><p>在文件的根目录配置 postcss.config.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webapck.config.js 更改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [ &#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">    use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'sass-loader'</span>,<span class="string">'postcss-loader'</span>]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>如果有样式引用其他样式的情况要重新定义 css-loader 使得被引入的 scss 等有语义的css 文件可以重新跑多一次全部的 loader</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [ &#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      <span class="comment">// 当 loader 有参数配置的时候使用对象</span></span><br><span class="line">      use: [<span class="string">'style-loader'</span>, &#123;</span><br><span class="line">          loader:<span class="string">'css-loader'</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">              importLoaders:<span class="number">2</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="string">'sass-loader'</span>,<span class="string">'postcss-loader'</span>]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>开启模块化：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  rules: [ &#123;</span><br><span class="line">    test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      <span class="comment">// 当 loader 有参数配置的时候使用对象</span></span><br><span class="line">      use: [<span class="string">'style-loader'</span>, &#123;</span><br><span class="line">          loader:<span class="string">'css-loader'</span>,</span><br><span class="line">          options:&#123;</span><br><span class="line">              importLoaders:<span class="number">2</span>,</span><br><span class="line">              <span class="comment">// css 模块化</span></span><br><span class="line">              modules:<span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;, <span class="string">'sass-loader'</span>,<span class="string">'postcss-loader'</span>]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><a href="https://webpack.js.org/loaders">其他具体的loader</a></p><h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><p>可以在webpack 运行打包到某个时刻帮你实现一些事情</p><h3 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h3><p>会在打包结束后自动生成一个 html 文件，并把打包生成的 js 自动引入到这个 html 文件中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [<span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        <span class="comment">// 设置默认的模板</span></span><br><span class="line">        template: <span class="string">'src/index.html'</span></span><br><span class="line">    &#125;)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>打包之前去掉旧的dist 项目</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'src/index.html'</span> &#125;),</span><br><span class="line">  <span class="keyword">new</span> CleanWebpackPlugin()</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p><a href="https://github.com/johnagan/clean-webpack-plugin/blob/master/src/clean-webpack-plugin.ts#L315">clean-webpack-plugin2.0 的新参数</a></p><h2 id="Output、Entry"><a href="#Output、Entry" class="headerlink" title="Output、Entry"></a><strong>Output、Entry</strong></h2><p>多文件输出预设的名字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">    entry:&#123;</span><br><span class="line">        main:<span class="string">'./src/index.js'</span>,</span><br><span class="line">        sub:<span class="string">'./src/index.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        <span class="comment">// 可以定义输出的跟路径，如果图片是cdn上面的，可以在从这里设置，html 引入这个js会自动加上</span></span><br><span class="line">        publicPath:<span class="string">'xx'</span>,</span><br><span class="line">        filename:<span class="string">'[name].js'</span></span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'dist'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SouceMap"><a href="#SouceMap" class="headerlink" title="SouceMap"></a>SouceMap</h2><p>development  模式下 devtool 默认是true,开启souceMap 通过映射当代码出错的时候可以找到源文件是哪里出错而不是编译后的文件哪里出错.</p><p>当然建立这种映射会影响打包速度</p><p><a href="https://webpack.js.org/configuration/devtool#devtool">具体内容</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  <span class="comment">// 这里可以关闭 sourceMap，开启则是'source-map'</span></span><br><span class="line">  devtool: <span class="string">'none'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>souce-map会在dist 自动生成一个 js.map 映射文件，而inline-souce-map 则是将这个关系包含在 打包的js文件里面。</p><p>使用 cheap-xxx–xxx 的参数会加快打包方式，但是只会提示到几行不会精确到几列。</p><p>开发环境（development）推荐使用：cheap-module-eval-source-map（module代表module里面的错误也可以检测到，eval 可以加快编译速度）</p><p>生产环境（pruduction）则是：cheap-module-source-map</p><h2 id="WebpackDevServer"><a href="#WebpackDevServer" class="headerlink" title="WebpackDevServer"></a>WebpackDevServer</h2><p>webpack-dev-server 帮助打包后的运行在自动打开的服务器，并会跟随文件的改变而改变</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    devServer:&#123;</span><br><span class="line">        <span class="comment">// 要打开的文件地址</span></span><br><span class="line">        contentBase:<span class="string">'./dist'</span>,</span><br><span class="line">        <span class="comment">// 是否自动打开默认浏览器</span></span><br><span class="line">        open:<span class="literal">true</span>,</span><br><span class="line">        <span class="comment">// 端口号，默认端口是8080</span></span><br><span class="line">        port:<span class="number">8080</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"webpack-dev-server"</span>,</span><br><span class="line">    <span class="string">"watch"</span>: <span class="string">"webpack --watch"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack-dev-server 打包的时候会把打包的 dist 目录内置到内存里面而不会显示出来，可以提高编译速度</p><p><a href="https://webpack.js.org/configuration/dev-server">相关内容</a></p><p>一开始的时候webpack-dev-server 因为配置不是很完善，一般人都会自己创建一个 server.js 文件来自己建一个服务器</p><p>这里使用 express 和 webpack-dev-middleware 来实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="comment">// 中间件可以监听，随着页面内容的改变而更改</span></span><br><span class="line"><span class="keyword">const</span> webpackDevMiddleware = <span class="built_in">require</span>(<span class="string">'webpack-dev-middleware'</span>);</span><br><span class="line"><span class="keyword">const</span> config = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>);</span><br><span class="line"><span class="comment">// 使用 webpack 的配置来返回一个编译器</span></span><br><span class="line"><span class="keyword">const</span> complier = webpack(config);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line">app.use(webpackDevMiddleware(complier,&#123;</span><br><span class="line">  publicPath:config.output.publicPath</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>,()=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server is running on port 3000'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"middleware"</span>: <span class="string">"node server.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是上面的内容是没有实现浏览器自动加载的。</p><h2 id="Hot-Module-Replacement-HMR"><a href="#Hot-Module-Replacement-HMR" class="headerlink" title="Hot Module Replacement(HMR)"></a>Hot Module Replacement(HMR)</h2><p>热模块更新，不刷新页面，重新加载css文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    <span class="comment">// 启动热模块加载</span></span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 即便 html 不生效也不会自动刷新</span></span><br><span class="line">    hotOnly: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[</span><br><span class="line"><span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只修改对应的 js 文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">module</span>.hot)&#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.accept(<span class="string">'./文件名.js'</span>,()=&gt;&#123;</span><br><span class="line">        <span class="comment">// 运用页面的函数</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而css 对应的代码是在 css-loader 里面底层实现了，所以不用手写 module.hot</p><h2 id="Babel-处理-ES6-语法"><a href="#Babel-处理-ES6-语法" class="headerlink" title="Babel 处理 ES6 语法"></a>Babel 处理 ES6 语法</h2><p>babel-loader 与 @babel-core(webpack与 babel 桥梁)</p><p>@babel/preset-env</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            text:<span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">            loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">                presets:[<span class="string">'@babel/preset-env'</span>]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以将 ES6 语法转换为 ES5 语法，但是还不完善，接着在index.js里面直接引入 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'@babel/polyfill'</span></span><br></pre></td></tr></table></figure><p>@babel/polyfill 可以自动添加内容实现兼容低版本的浏览器。打包之后会发现打包的js会很大，因为它把所有低版本可能要兼容的代码都写了进去，而不是按需要来增加内容。这个时候可以通过配置来达到按需</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            text:<span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">            loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">                presets:[[<span class="string">'@babel/preset-env'</span>],&#123;</span><br><span class="line">                    useBuiltIns:<span class="string">'usage'</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack 进行打包的时候发现会报错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Module not found: Error: Can't resolve 'core-js/modules/es6.array.map'</span><br></pre></td></tr></table></figure><p>之类的错误，通过查阅发现要下载一个 core-js 的插件便可以解决问题，具体可以查看 <a href="https://www.npmjs.com/package/core-js">core-js</a></p><p>而当你使用这个按需加载的时候，就会提示你去掉文件中 import ‘@babel/polyfill’ ,因为会自动加载，另外可以配置要兼容的浏览器版本来判断需要引入那些兼容代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            text:<span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">            loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">                presets:[[<span class="string">'@babel/preset-env'</span>],&#123;</span><br><span class="line">                    useBuiltIns:<span class="string">'usage'</span>,</span><br><span class="line">                    targets:&#123;</span><br><span class="line">                        chrome:<span class="string">'67'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而上面的版本的谷歌浏览器是支持 ES6 语法的，因为打包出来的文件就会很小。可以看出来上面的方式有可能会全局污染(适合小项目)，可以使用另外一种方式去配置（适合多模块）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">            loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">            options:&#123;</span><br><span class="line">                plugins:[[<span class="string">'@babel/plugin-transform-runtime'</span>,&#123;</span><br><span class="line">                    corejs:<span class="number">2</span>,</span><br><span class="line">                    helpers:<span class="literal">true</span>,</span><br><span class="line">                    regenerator:<span class="literal">true</span>,</span><br><span class="line">                    useESModules:<span class="literal">false</span></span><br><span class="line">                &#125;]]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置上面的内容之前需要安装以下几个依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D @babel/runtime @babel/plugin-transfrom-runtime @babel/runtime-corejs2</span><br></pre></td></tr></table></figure><p>具体可以查看<a href="https://coding.imooc.com/lesson/316.html#mid=22337">这里</a></p><p>另外可以把 babel-loader options 里面的内容放在一个单独名为 .babelrc 的文件中</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/plugin-transform-runtime"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"corejs"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"helpers"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"regenerator"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"useESModules"</span>: <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打包-React-代码"><a href="#打包-React-代码" class="headerlink" title="打包 React 代码"></a>打包 React 代码</h2><p>安装依赖包 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -D @babel/preset-react</span><br></pre></td></tr></table></figure><p>配置 .babelrc</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"targets"</span>: &#123;</span><br><span class="line">          <span class="attr">"chrome"</span>: <span class="string">"67"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-react"</span></span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的顺序也是从下往上</p><p><a href="https://babeljs.io/docs/en/babel-preset-react">具体点击这里</a></p><h2 id="Tree-Shaking"><a href="#Tree-Shaking" class="headerlink" title="Tree Shaking"></a>Tree Shaking</h2><p>development 环境，按需加载，只支持 ES Module ，底层是一个静态引入实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js 只引入 add 的打包结果</span></span><br><span class="line"><span class="comment">/*! exports provided: add, minus */</span></span><br><span class="line"><span class="comment">/*! exports used: add */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过下面的配置</span></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    optimization:<span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 因为只是单纯引入，挂载在全局而不用去使用里面具体的，以防止被去掉，使用这个参数可以做一个过滤不作 tree Shaking</span></span><br><span class="line">    <span class="string">"sideEffects"</span>:[<span class="string">"@babel/polyi-fill"</span>,<span class="string">"*.css"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>production 环境甚至需要 optimization 配置，会自动配置，但是 package.json 中的 sideEffects 需要保留</p><h2 id="Development-和-Production-模式的区分打包"><a href="#Development-和-Production-模式的区分打包" class="headerlink" title="Development 和 Production 模式的区分打包"></a>Development 和 Production 模式的区分打包</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server --config webpack.dev.js"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --config webpack.prod.js"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.dev.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    hot: <span class="literal">true</span>,</span><br><span class="line">    hotOnly: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">      loader:<span class="string">'babel-loader'</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          outputPath: <span class="string">'images/'</span>,</span><br><span class="line">          limit: <span class="number">2048</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        <span class="string">'style-loader'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'css-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            importLoaders: <span class="number">2</span>,</span><br><span class="line">            <span class="comment">// modules: true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">        <span class="string">'postcss-loader'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.(eot|ttf|svg|woff)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'src/index.html'</span> &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    usedExports:<span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">'/'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-source-map'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">      loader:<span class="string">'babel-loader'</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          outputPath: <span class="string">'images/'</span>,</span><br><span class="line">          limit: <span class="number">2048</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        <span class="string">'style-loader'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'css-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            importLoaders: <span class="number">2</span>,</span><br><span class="line">            <span class="comment">// modules: true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">        <span class="string">'postcss-loader'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.(eot|ttf|svg|woff)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'src/index.html'</span> &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">'/'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出上面有很多重复的代码，可以进行抽取优化，用 webpack-merge 进行合并</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">      loader:<span class="string">'babel-loader'</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          outputPath: <span class="string">'images/'</span>,</span><br><span class="line">          limit: <span class="number">2048</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">      use: [</span><br><span class="line">        <span class="string">'style-loader'</span>,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'css-loader'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            importLoaders: <span class="number">2</span>,</span><br><span class="line">            <span class="comment">// modules: true</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">        <span class="string">'postcss-loader'</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      test: <span class="regexp">/\.(eot|ttf|svg|woff)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'src/index.html'</span> &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(),</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">'/'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// webpack.dev.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devConfig = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    hot: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    usedExports:<span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig,devConfig);</span><br><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-source-map'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig,prodConfig);</span><br></pre></td></tr></table></figure><h2 id="Webpack-和-Code-Splitting"><a href="#Webpack-和-Code-Splitting" class="headerlink" title="Webpack 和 Code Splitting"></a>Webpack 和 Code Splitting</h2><h3 id="同步代码"><a href="#同步代码" class="headerlink" title="同步代码"></a>同步代码</h3><p>遇到公共类库，会自动打包出来一个文件，例如 vendors~main.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    splitChunks:&#123;</span><br><span class="line">        chunks:<span class="string">'all'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异步代码"><a href="#异步代码" class="headerlink" title="异步代码"></a>异步代码</h3><p>安装 babel-plugin-dynamic-import-webpack 后在 .babelrc 里面配置,这个插件不是官方的，所以不支持魔法注释</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"targets"</span>: &#123;</span><br><span class="line">          <span class="attr">"chrome"</span>: <span class="string">"67"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-react"</span></span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>:[<span class="string">"dynamic-import-webpack"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>官方的 @babel/plugin-syntax-dynamic-import 可以支持魔术注释</p><p>重新配置 .babelrc</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-env"</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"targets"</span>: &#123;</span><br><span class="line">          <span class="attr">"chrome"</span>: <span class="string">"67"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">"useBuiltIns"</span>: <span class="string">"usage"</span></span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    [</span><br><span class="line">      <span class="string">"@babel/preset-react"</span></span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"plugins"</span>:[<span class="string">"@babel/plugin-syntax-dynamic-import"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack.common.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    splitChunks:&#123;</span><br><span class="line">        chunks:<span class="string">'all'</span>,</span><br><span class="line">        cacheGroups:&#123;</span><br><span class="line">            <span class="comment">// 取消名字前面的默认名称</span></span><br><span class="line">            vendors:<span class="literal">false</span>,</span><br><span class="line">            <span class="keyword">default</span>:<span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用魔法注释</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"lodash" */</span><span class="string">'lodash'</span>).then(<span class="function">(<span class="params">&#123;<span class="keyword">default</span>:_&#125;</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    element.innerHTML = _.join([<span class="string">'Dell'</span>,<span class="string">'Lee'</span>],<span class="string">'_'</span>);</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getComponent().then(<span class="function"><span class="params">element</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>打包编译之后就可以看到异步引入的库被自己定义的名字打包出来了</p><h3 id="splitChunksPlugins"><a href="#splitChunksPlugins" class="headerlink" title="splitChunksPlugins"></a>splitChunksPlugins</h3><p>默认配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      <span class="comment">// 只对异步代码生效 all 则是全部代码，inintal 则是同步代码</span></span><br><span class="line">      chunks: <span class="string">'async'</span>,</span><br><span class="line">      <span class="comment">// 引入的模块/包/库 大于 30kb 则会代码分割</span></span><br><span class="line">      minSize: <span class="number">30000</span>,</span><br><span class="line">      <span class="comment">// 会尝试将 大于这个尺寸的库重新拆分为n个 maxSize 大的库，但是一般这个参数不会生效</span></span><br><span class="line">      maxSize: <span class="number">0</span>,</span><br><span class="line">      <span class="comment">// 打包生成的库的次数少于 minChunks次 则不会分割</span></span><br><span class="line">      minChunks: <span class="number">1</span>,</span><br><span class="line">      maxAsyncRequests: <span class="number">5</span>,</span><br><span class="line">      maxInitialRequests: <span class="number">3</span>,</span><br><span class="line">      <span class="comment">// 自动生成的文件的中间符</span></span><br><span class="line">      automaticNameDelimiter: <span class="string">'~'</span>,</span><br><span class="line">      name: <span class="literal">true</span>, <span class="comment">// 配合 cacheGroups 使用</span></span><br><span class="line">      <span class="comment">// 缓存组</span></span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        vendors: &#123;</span><br><span class="line">          <span class="comment">// 如果引入的库在 node_modules 里面，符合这个组打包出来的文件前缀会有vendors~入口.js</span></span><br><span class="line">          test: <span class="regexp">/[\\/]node_modules[\\/]/</span>,</span><br><span class="line">          <span class="comment">// 优先级 符合 在 node_modules 优先级大于在默认的，那么打包就会打包在 vendors 这个相关配置里面</span></span><br><span class="line">          priority: <span class="number">-10</span>,</span><br><span class="line">          <span class="comment">// 强制定义在同一个文件里面，可以不配置</span></span><br><span class="line">          filename:<span class="string">'vendors.js'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 默认处理途径</span></span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line">          minChunks: <span class="number">2</span>,</span><br><span class="line">          priority: <span class="number">-20</span>,</span><br><span class="line">          <span class="comment">// 如果 模块在前面打包过了就不会重复打包</span></span><br><span class="line">          reuseExistingChunk: <span class="literal">true</span>，</span><br><span class="line">          filename:<span class="string">'common.js'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Lazy-loading-懒加载"><a href="#Lazy-loading-懒加载" class="headerlink" title="Lazy loading 懒加载"></a>Lazy loading 懒加载</h2><p>通过 import 语法来异步加载，什么时候要使用则是取决于个人</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"lodash" */</span><span class="string">'lodash'</span>).then(<span class="function">(<span class="params">&#123;<span class="keyword">default</span>:_&#125;</span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    element.innerHTML = _.join([<span class="string">'Dell'</span>,<span class="string">'Lee'</span>],<span class="string">'_'</span>);</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">  getComponent().then(<span class="function"><span class="params">element</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// async await 改进</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">getComponent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="attr">default</span>:_&#125; = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName:"lodash" */</span><span class="string">'lodash'</span>);</span><br><span class="line">  <span class="keyword">const</span> element = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">  element.innerHTML = _.join([<span class="string">'Dell'</span>,<span class="string">'Lee'</span>],<span class="string">'_'</span>);</span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">  getComponent().then(<span class="function"><span class="params">element</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(element);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="打包分析"><a href="#打包分析" class="headerlink" title="打包分析"></a>打包分析</h2><p>配置 package.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"scripts"</span>:&#123;</span><br><span class="line">        <span class="attr">"dev-build"</span>:<span class="string">"webpack --profile --json &gt; stats.json --config ./build/webpack.dev.js"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的意思是分析webapck 打包的文件生成后生成 stats.json 。</p><p><a href="http://webpack.github.io/analyse/">点击这个网站</a>可以将这个json 文件上传，会帮你自动分析版本，时长以及相关错误，模块之间的关系等等</p><p><a href="https://webpack.js.org/guides/code-splitting/#bundle-analysis">更多相关工具</a></p><h2 id="Preloading-Prefetching"><a href="#Preloading-Prefetching" class="headerlink" title="Preloading,Prefetching"></a>Preloading,Prefetching</h2><p>在谷歌浏览器 ctrl+shift+p 输入show Coverage 点击录制后可以看到一个网站首屏加载 js 文件的利用率，以及可以优化的可能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当浏览器空闲的时候，可以先加载这个文件</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackPrefetch:true*/</span><span class="string">'./click.js'</span>).then(<span class="function">(<span class="params">&#123;<span class="keyword">default</span>:func&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    func();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个则是和核心文件一起加载</span></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,()=&gt;&#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="comment">/* webpackPreloading:true*/</span><span class="string">'./click.js'</span>).then(<span class="function">(<span class="params">&#123;<span class="keyword">default</span>:func&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    func();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>性能优化在缓存上面可以优化的地方有限，可以考虑更多是代码的使用率，将一开始不会用的代码尽量使用异步加载的方式来加载</p><h2 id="CSS-文件的代码分割"><a href="#CSS-文件的代码分割" class="headerlink" title="CSS 文件的代码分割"></a>CSS 文件的代码分割</h2><p>mini-css-extract-plugin,没有实现  HMR 需要手动配置，所以一般是适用在线上环境使用。</p><p>配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">      loader:<span class="string">'babel-loader'</span></span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          outputPath: <span class="string">'images/'</span>,</span><br><span class="line">          limit: <span class="number">2048</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(eot|ttf|svg|woff)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'src/index.html'</span> &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">      cleanOnceBeforeBuildPatterns:[path.resolve(__dirname,<span class="string">'../dist'</span>)],</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    usedExports:<span class="literal">true</span>,</span><br><span class="line">    splitChunks:&#123;</span><br><span class="line">      chunks:<span class="string">'all'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">'./'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// webpack.dev.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devConfig = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    hot: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">2</span>,</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">          <span class="string">'postcss-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">  optimization:&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig,devConfig);</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> merge = <span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> commonConfig = <span class="built_in">require</span>(<span class="string">'./webpack.common.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-source-map'</span>,</span><br><span class="line">  plugins:[</span><br><span class="line">      <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">        <span class="comment">// template 要引入的</span></span><br><span class="line">      filename:<span class="string">'[name].css'</span>,</span><br><span class="line">        <span class="comment">// 间接引入的走这个</span></span><br><span class="line">      chunkFilename:<span class="string">'[name].chunk.css'</span>          </span><br><span class="line">      &#125;)</span><br><span class="line">  ],</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">2</span>,</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">          <span class="string">'postcss-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = merge(commonConfig,prodConfig);</span><br></pre></td></tr></table></figure><p>将之前共同配置的 webpack,common.js  module rules 里面关于css 的配置移动到 webpack.dev.js 里面不作修改。然后同样复制一遍到 webpack.prod.js 里面，把关于css-loader 里面的的 style-loader 换成 MiniCssExtractPlugin.loader 作为最后一步来处理。</p><p>一个要注意的点是在公共的 optimization 里面加了一个 usedExports：true,同时也要在 package.json 里面配置 sideEffects：[‘@babel/polyfill’,’*.css’]</p><p>运行 npm run build 便可以打包分割开 css 文件了</p><h3 id="压缩-css-代码"><a href="#压缩-css-代码" class="headerlink" title="压缩 css 代码"></a>压缩 css 代码</h3><p>optimize-css-assets-webpack-plugin</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    optimization:&#123;</span><br><span class="line">        minimizer:[</span><br><span class="line">            <span class="keyword">new</span> OptimizeCSSAssetPlugin(&#123;&#125;)</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个css文件打包到同一个css里面"><a href="#多个css文件打包到同一个css里面" class="headerlink" title="多个css文件打包到同一个css里面"></a>多个css文件打包到同一个css里面</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    optimization:&#123;</span><br><span class="line">        <span class="comment">// 底层依旧是 splitChunks 实现的</span></span><br><span class="line">        splitChunks:&#123;</span><br><span class="line">            cacheGroups:&#123;</span><br><span class="line">                styles:&#123;</span><br><span class="line">                    name:<span class="string">'styles'</span>,</span><br><span class="line">                    test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">                    chunks:<span class="string">'all'</span>,</span><br><span class="line">                    enforce:<span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多个css文件按入口文件来打包"><a href="#多个css文件按入口文件来打包" class="headerlink" title="多个css文件按入口文件来打包"></a>多个css文件按入口文件来打包</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    optimization:&#123;</span><br><span class="line">        splitChunks:&#123;</span><br><span class="line">            cacheGroups:&#123;</span><br><span class="line">                fooStyles:&#123;</span><br><span class="line">                    name:<span class="string">'foo'</span>,</span><br><span class="line">                    test: <span class="function">(<span class="params">m, c, entry = <span class="string">'foo'</span></span>) =&gt;</span> m.constructor.name === <span class="string">'CssModule'</span> &amp;&amp; recursiveIssuer(m) === entry,</span><br><span class="line">                    chunks:<span class="string">'all'</span>,</span><br><span class="line">                    enforce:<span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                barStyles:&#123;</span><br><span class="line">                    name:<span class="string">'bar'</span>,</span><br><span class="line">                    test: <span class="function">(<span class="params">m, c, entry = <span class="string">'foo'</span></span>) =&gt;</span> m.constructor.name === <span class="string">'CssModule'</span> &amp;&amp; recursiveIssuer(m) === entry,</span><br><span class="line">                    chunks:<span class="string">'all'</span>,</span><br><span class="line">                    enforce:<span class="literal">true</span>                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Webpack-与浏览器缓存（Caching）"><a href="#Webpack-与浏览器缓存（Caching）" class="headerlink" title="Webpack 与浏览器缓存（Caching）"></a>Webpack 与浏览器缓存（Caching）</h2><p>增加 hash 值,如果文件没有改变的话，那么打包前后几次打包出来的文件里面的哈希值就不会发生变化，浏览器的缓存也就起到了作用。如果改变了，浏览器则会去请求先的文件而不是继续用原来的缓存文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:<span class="string">'[name].[contenthash].js'</span>,</span><br><span class="line">        chunkFilename:<span class="string">'[name].[contenthash].js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的配置是新版本的webpack直接有的，但是旧版本的 webpack 每次打包 hash 值都会发生变化，可以在 webpack.common.js 里面配置一个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    optimization:&#123;</span><br><span class="line">        runtimeChunk:&#123;</span><br><span class="line">            name:<span class="string">'runtime'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个参数会把旧版本中的 manifest 单独抽离出来一个 runtime 开头的 js文件里面，这个 文件主要描述的是库与业务逻辑代码之间的一些关系，旧版本webpack 中这个关系会因为每次打包而发生变化。</p><h2 id="Shimming"><a href="#Shimming" class="headerlink" title="Shimming"></a>Shimming</h2><h3 id="自动引入某个库"><a href="#自动引入某个库" class="headerlink" title="自动引入某个库"></a>自动引入某个库</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">            _:<span class="string">'lodash'</span>,</span><br><span class="line">            <span class="comment">// 花式引用</span></span><br><span class="line">            _join:[<span class="string">'lodash'</span>,<span class="string">'join'</span>]</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局this-指向-window"><a href="#全局this-指向-window" class="headerlink" title="全局this 指向 window"></a>全局this 指向 window</h3><p>imports-loader</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">            use:[&#123;</span><br><span class="line">                loader:<span class="string">'babel-loader'</span></span><br><span class="line">            &#125;,&#123;</span><br><span class="line">                loader:<span class="string">'imports-loader？this=&gt;window'</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>可以考虑使用，用个人，具体是在 package.json 里面传递一个 env 参数</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"dev-build"</span>: <span class="string">"webpack --profile --json &gt; stats.json --config ./build/webpack.common.js"</span>,</span><br><span class="line">    <span class="attr">"dev"</span>: <span class="string">"webpack-dev-server --config ./build/webpack.common.js"</span>,</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack --env.production --config ./build/webpack.common.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 开发与生产环境的webpack 则是都放到 common 里面来判断分发</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.dev.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> devConfig = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">    open: <span class="literal">true</span>,</span><br><span class="line">    port: <span class="number">8080</span>,</span><br><span class="line">    hot: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="string">'style-loader'</span>,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">2</span>,</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">          <span class="string">'postcss-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">'./'</span>,</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    chunkFilename:<span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = devConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.prod.js</span></span><br><span class="line"><span class="keyword">const</span> MiniCssExtractPlugin = <span class="built_in">require</span>(<span class="string">'mini-css-extract-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> OptimizeCSSAssetsPlugin = <span class="built_in">require</span>(<span class="string">'optimize-css-assets-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> prodConfig = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  devtool: <span class="string">'cheap-module-source-map'</span>,</span><br><span class="line">  <span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.scss$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          MiniCssExtractPlugin.loader,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              importLoaders: <span class="number">2</span>,</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="string">'sass-loader'</span>,</span><br><span class="line">          <span class="string">'postcss-loader'</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;, &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [MiniCssExtractPlugin.loader, <span class="string">'css-loader'</span>, <span class="string">'postcss-loader'</span>]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    minimizer:[</span><br><span class="line">      <span class="keyword">new</span> OptimizeCSSAssetsPlugin(&#123;&#125;)</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> MiniCssExtractPlugin(&#123;</span><br><span class="line">      filename:<span class="string">'[name].css'</span>,</span><br><span class="line">      chunkFilename:<span class="string">'[name].chunk.css'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: <span class="string">'./'</span>,</span><br><span class="line">    filename: <span class="string">'[name].[contenthash].js'</span>,</span><br><span class="line">    chunkFilename:<span class="string">'[name].[contenthash].js'</span>,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = prodConfig;</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>)</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> merge =<span class="built_in">require</span>(<span class="string">'webpack-merge'</span>);</span><br><span class="line"><span class="keyword">const</span> devConfig = <span class="built_in">require</span>(<span class="string">'./webpack.dev.js'</span>);</span><br><span class="line"><span class="keyword">const</span> prodConfig = <span class="built_in">require</span>(<span class="string">'./webpack.prod.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonConfig = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">      test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">      exclude:<span class="regexp">/node_modules/</span>,</span><br><span class="line">      use:[&#123;</span><br><span class="line">        loader:<span class="string">'babel-loader'</span></span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        loader:<span class="string">'imports-loader?this=&gt;window'</span></span><br><span class="line">      &#125;]</span><br><span class="line">      </span><br><span class="line">    &#125;,&#123;</span><br><span class="line">      test: <span class="regexp">/\.(jpg|png|gif)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          name: <span class="string">'[name]_[hash].[ext]'</span>,</span><br><span class="line">          outputPath: <span class="string">'images/'</span>,</span><br><span class="line">          limit: <span class="number">2048</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      test: <span class="regexp">/\.(eot|ttf|svg|woff)$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        loader: <span class="string">'file-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'src/index.html'</span> &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">      cleanOnceBeforeBuildPatterns:[path.resolve(__dirname,<span class="string">'../dist'</span>)],</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">      _:<span class="string">'lodash'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  optimization:&#123;</span><br><span class="line">    usedExports:<span class="literal">true</span>,</span><br><span class="line">    splitChunks:&#123;</span><br><span class="line">      chunks:<span class="string">'all'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function">(<span class="params">env</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(env &amp;&amp; env.production)&#123;</span><br><span class="line">    <span class="keyword">return</span> merge(commonConfig,prodConfig)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> merge(commonConfig,devConfig)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Library-的打包"><a href="#Library-的打包" class="headerlink" title="Library 的打包"></a>Library 的打包</h2><p>简单配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  externals: [<span class="string">'lodash'</span>],</span><br><span class="line">  output: &#123;</span><br><span class="line">    path:path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">    filename:<span class="string">'library.js'</span>,</span><br><span class="line">    <span class="comment">// 可以通过 script src=library.js 来引用这个库</span></span><br><span class="line">    library:<span class="string">'library'</span>,</span><br><span class="line">    <span class="comment">// 通用打包 CommonJS 或者 UMD，上面文件的挂载处（可以为this 或者 window）</span></span><br><span class="line">    libraryTarget:<span class="string">'umd'</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PWA-Progressive-Web-Application-的打包"><a href="#PWA-Progressive-Web-Application-的打包" class="headerlink" title="PWA(Progressive Web Application) 的打包"></a>PWA(Progressive Web Application) 的打包</h2><p>网站在被访问过一次之后，如果服务器挂掉了，浏览器还可以利用缓存来访问这个网站。</p><p>workbox-webpack-plugin</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置 webpack.prod.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> WorkboxPlugin.GenerateSW(&#123;</span><br><span class="line">            clientsClaim:<span class="literal">true</span>,</span><br><span class="line">            skipWaiting:<span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后打包编译的是时候会生成多一个 service-worker.js 文件，在项目中运用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">if</span>(<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator)&#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">'/service-worker.js'</span>).then(<span class="function"><span class="params">registration</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'service-worker registed'</span>);</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">error</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'service-worker register error'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样配置之后，当用户访问过一次网站之后便会进行缓存，如果当服务器挂掉的时候，用户还是可以在浏览器访问到网站</p><h2 id="TypeScript-的打包配置"><a href="#TypeScript-的打包配置" class="headerlink" title="TypeScript 的打包配置"></a>TypeScript 的打包配置</h2><p>webpack基本配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mode:<span class="string">'production'</span>,</span><br><span class="line">    entry:<span class="string">'./src/index.tsx'</span>,</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:[&#123;</span><br><span class="line">            test:<span class="regexp">/\.tsx?$/</span>,</span><br><span class="line">            use:<span class="string">'ts-loader'</span>,</span><br><span class="line">            exclude:<span class="regexp">/node_modules/</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    output:&#123;</span><br><span class="line">        filename:<span class="string">'bundle.js'</span>,</span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'dist'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了webpack 配置之后，在 打包 ts 的时候还必须要配置一个 tsconfig.json</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"compilerOptions"</span>: &#123;</span><br><span class="line">    // 出口</span><br><span class="line">    "outDir": "./dist",</span><br><span class="line">    // 要处理的模块</span><br><span class="line">    "module": "es6",</span><br><span class="line">    // 编译成es5的</span><br><span class="line">    "target": "es5",</span><br><span class="line">    // 运行在文件中引入其他的js</span><br><span class="line">    "allowJs": true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要引入其他的库，例如 lodash ，需要安装对应的说明，@types/lodash ，具体的可以<a href="https://github.com/DefinitelyTyped/DefinitelyTyped">查看这里</a></p><h2 id="WebpackDevServer-1"><a href="#WebpackDevServer-1" class="headerlink" title="WebpackDevServer"></a>WebpackDevServer</h2><h3 id="开发环境实现请求代理转发"><a href="#开发环境实现请求代理转发" class="headerlink" title="开发环境实现请求代理转发"></a>开发环境实现请求代理转发</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本配置</span></span><br><span class="line"><span class="built_in">module</span>.exports =  &#123;</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        contentBase: <span class="string">'./dist'</span>,</span><br><span class="line">        open: <span class="literal">true</span>,</span><br><span class="line">        port: <span class="number">8080</span>,</span><br><span class="line">        hot: <span class="literal">true</span>,</span><br><span class="line">        hotOnly: <span class="literal">true</span>,</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">'/react/api'</span>: &#123;</span><br><span class="line">                <span class="comment">// 代理转发的url</span></span><br><span class="line">                target: <span class="string">'https://www.dell-lee.com/'</span>,</span><br><span class="line">                <span class="comment">// 当是 https 的时候可以设置这个参数</span></span><br><span class="line">                secure: <span class="literal">false</span>,</span><br><span class="line">                <span class="comment">// 拦截</span></span><br><span class="line">                bypass: <span class="function"><span class="keyword">function</span> (<span class="params">req, res, proxyOptions</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (req.headers.accept.indexOf(<span class="string">'html'</span>) !== <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="built_in">console</span>.log(<span class="string">'Shipping proxy for browser request'</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">'/index.html'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// 路径重写</span></span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    <span class="string">'header.json'</span>: <span class="string">'demo.json'</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">// 配置 headers 主机名与cookie 等等</span></span><br><span class="line">                headers:&#123;</span><br><span class="line">                    host:<span class="string">'xx'</span>,</span><br><span class="line">                    cookie:<span class="string">''</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://webpack.js.org/configuration/dev-server/#devserver">具体文档</a></p><p>底层是 <a href="https://github.com/webpack/webpack-dev-middleware">webpack-dev-middleware</a></p><h3 id="解决单页面应用路由问题"><a href="#解决单页面应用路由问题" class="headerlink" title="解决单页面应用路由问题"></a>解决单页面应用路由问题</h3><p>当配置路由发现找不到内容的时候，可以配置 <a href="https://webpack.js.org/configuration/dev-server#devserverhistoryapifallback">historyApiFallback</a></p><h2 id="ESLint-的配置"><a href="#ESLint-的配置" class="headerlink" title="ESLint 的配置"></a>ESLint 的配置</h2><p>先安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i eslint -D</span><br></pre></td></tr></table></figure><p>接着是初始化配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eslint -init</span><br></pre></td></tr></table></figure><p>采用目前流行 airbnb 的方式</p><p>会看到项目生成一个 .eslintrc.js</p><p>如果没有使用vscode 只能用 eslint src 命令行来查看错误信息</p><p>可以进行基本配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="string">"extends"</span>: <span class="string">"airbnb"</span>,</span><br><span class="line">    <span class="string">"parser"</span>: <span class="string">"babel-eslint"</span>,</span><br><span class="line">    <span class="string">"rules"</span>: &#123;</span><br><span class="line">        <span class="string">""</span>: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    globals:&#123;</span><br><span class="line">        <span class="built_in">document</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="eslint-loader"><a href="#eslint-loader" class="headerlink" title="eslint-loader"></a>eslint-loader</h3><p>webpack 也有先关的配置，但是会影响打包的速度，一般会建议使用这种方式来配置。还是使用 vscode 的插件式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [&#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">        use: [</span><br><span class="line">            &#123; <span class="attr">loader</span>: <span class="string">'babel-loader'</span> &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">                options: &#123;</span><br><span class="line">                    <span class="comment">// 自动修复</span></span><br><span class="line">                    fix: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://webpack.js.org/loaders/eslint-loader">具体点击</a></p><p>devServer 配置 overlay 可以在页面提示错误信息</p><h2 id="webpack-性能优化"><a href="#webpack-性能优化" class="headerlink" title="webpack 性能优化"></a>webpack 性能优化</h2><p>1.升级工具的版本（node,npm,yarn）</p><p>2.loader（include/exclude）在尽可能少的模块上使用</p><p>3.plugin 尽可能精简可靠</p><p>4.resolve 参数合理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports =&#123;</span><br><span class="line">    resolve:&#123;</span><br><span class="line">        extensions:[<span class="string">'.js'</span>,<span class="string">'.jsx'</span>],</span><br><span class="line">       <span class="comment">// 使用别名</span></span><br><span class="line">        alias:&#123;</span><br><span class="line">            haha:path.resolve(__dirname,<span class="string">'../src/child/'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.使用 DllPlugin 提高打包速度</p><p>add-asset-html-webpack-plugin</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.dll.js</span></span><br><span class="line"><span class="comment">// 将共用的库放到一个文件里面去单独打包，用 library 暴露出来。然后用 webpack.DllPlugin 这个插件对这些库分析出一种文件关系映射.json 文件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack =<span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    vendors: [<span class="string">'lodash'</span>],</span><br><span class="line">    react: [<span class="string">'react'</span>, <span class="string">'react-dom'</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].dll.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../dll'</span>),</span><br><span class="line">    library: <span class="string">'[name]'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins:[</span><br><span class="line">    <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">      name:<span class="string">'[name]'</span>,</span><br><span class="line">      path:path.resolve(__dirname,<span class="string">'../dll/[name].manifest.json'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在webpack.common.js 文件里面配置（也可以只配置生产环境）,将上面生成文件挂载到 template index.html上面</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">            filepath:path.resolve(__dirname,<span class="string">'../dll/verndors.dll.js'</span>)</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">            filepath:path.resolve(__dirname,<span class="string">'../dll/react.dll.js'</span>)</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> webpack.DllRefercencePlugin(&#123;</span><br><span class="line">            mainfest:path.resolve(__dirname,<span class="string">'../dll/vendors.mainfest.json'</span>)</span><br><span class="line">        &#125;),</span><br><span class="line">                <span class="keyword">new</span> webpack.DllRefercencePlugin(&#123;</span><br><span class="line">            mainfest:path.resolve(__dirname,<span class="string">'../dll/react.mainfest.json'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 进行优化自动注入</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> plugins = [</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">        template:<span class="string">'src/index.html'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> CleanWebpackPlugin(&#123;</span><br><span class="line">      cleanOnceBeforeBuildPatterns: [path.resolve(__dirname, <span class="string">'../dist'</span>)],</span><br><span class="line">    &#125;)</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> files = fs.readdirSync(path.resolve(__dirname,<span class="string">'../dll'</span>))</span><br><span class="line">files.forEach(<span class="function"><span class="params">file</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/.*\.dll.js/</span>.test(file))&#123;</span><br><span class="line">        plugins.push(<span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">            filepath:path.resolve(__dirname,<span class="string">'../dll'</span>,file)</span><br><span class="line">        &#125;)) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="regexp">/.*\.mainfest.json/</span>.test(file))&#123;</span><br><span class="line">        plugins.push(<span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">            filepath:path.resolve(__dirname,<span class="string">'../dll'</span>,file)</span><br><span class="line">        &#125;)) </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6.控制包文件的大小</p><p>7.thread-loader,parallel-webpack,happypack 多进程打包</p><p>8.合理使用 sourceMap(信息越详细打包越久)</p><p>9.结合打包分析 stats.json 优化分析</p><p>10.开发环境内存编译，无用插件剔除</p><h2 id="多页面打包配置"><a href="#多页面打包配置" class="headerlink" title="多页面打包配置"></a>多页面打包配置</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.common.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">      main: <span class="string">'./src/index.js'</span>,</span><br><span class="line">      list: <span class="string">'./src/list.js'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123; </span><br><span class="line">          filename:<span class="string">'index.html'</span>,</span><br><span class="line">          template: <span class="string">'src/index.html'</span>,</span><br><span class="line">          chunks:[<span class="string">'runtime'</span>,<span class="string">'vendors'</span>,<span class="string">'main'</span>]</span><br><span class="line">        &#125;),</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123; </span><br><span class="line">          filename:<span class="string">'list.html'</span>,</span><br><span class="line">          template: <span class="string">'src/index.html'</span>,</span><br><span class="line">          chunks:[<span class="string">'runtime'</span>,<span class="string">'vendors'</span>,<span class="string">'list'</span>]</span><br><span class="line">        &#125;),        </span><br><span class="line">    ] </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="keyword">const</span> configs  = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span>,</span><br><span class="line">    list: <span class="string">'./src/list.js'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 其他所有配置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> makePlugins = <span class="function">(<span class="params">configs</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> plugins = [<span class="string">'其他的plugins'</span>];</span><br><span class="line">    <span class="built_in">Object</span>.keys(configs.entry).forEach(<span class="function"><span class="params">item</span>=&gt;</span>&#123;</span><br><span class="line">        plugins.push(</span><br><span class="line">            <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">                template:<span class="string">'src/index.html'</span>,</span><br><span class="line">                filename:<span class="string">`<span class="subst">$&#123;item&#125;</span>.html`</span>,</span><br><span class="line">                chunks:[<span class="string">'runtime'</span>,<span class="string">'vendors'</span>,<span class="string">'item'</span>]</span><br><span class="line">            &#125;)</span><br><span class="line">        )</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上面优化的代码</span></span><br><span class="line">    <span class="keyword">const</span> files = fs.readdirSync(path.resolve(__dirname,<span class="string">'../dll'</span>))</span><br><span class="line">    files.forEach(<span class="function"><span class="params">file</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="regexp">/.*\.dll.js/</span>.test(file))&#123;</span><br><span class="line">            plugins.push(<span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">                filepath:path.resolve(__dirname,<span class="string">'../dll'</span>,file)</span><br><span class="line">            &#125;)) </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="regexp">/.*\.mainfest.json/</span>.test(file))&#123;</span><br><span class="line">            plugins.push(<span class="keyword">new</span> AddAssetHtmlWebpackPlugin(&#123;</span><br><span class="line">                filepath:path.resolve(__dirname,<span class="string">'../dll'</span>,file)</span><br><span class="line">            &#125;)) </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;)  </span><br><span class="line">    <span class="keyword">return</span> plugins;</span><br><span class="line">&#125;</span><br><span class="line">configs.plugins = makePlugins(configs);</span><br><span class="line"><span class="built_in">module</span>.export = configs;</span><br></pre></td></tr></table></figure><h2 id="如何编写一个-Loader"><a href="#如何编写一个-Loader" class="headerlink" title="如何编写一个 Loader"></a>如何编写一个 Loader</h2><h3 id="简单的实现"><a href="#简单的实现" class="headerlink" title="简单的实现"></a>简单的实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// replaceLoader.js </span></span><br><span class="line"><span class="comment">// loader-utils 是官方一个符合 loader 规范的工具</span></span><br><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> source.replace(<span class="string">'haha'</span>, <span class="string">'world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// replaceLoaderAsync.js </span></span><br><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = loaderUtils.getOptions(<span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">const</span> callback = <span class="keyword">this</span>.async();</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = source.replace(<span class="string">'lbh'</span>, options.name);</span><br><span class="line">    callback(<span class="literal">null</span>, result);</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello lbh'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// loader 的位置，先查找 node_modules 如果没有就往下找，那么自定义的 loader 就不用写全路径了</span></span><br><span class="line">  resolveLoader: &#123;</span><br><span class="line">    modules: [<span class="string">'node_modules'</span>, <span class="string">'./loaders'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js?$/</span>,</span><br><span class="line">        use: [&#123;</span><br><span class="line">          loader: <span class="string">'replaceLoader.js'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          loader: <span class="string">'replaceLoaderAsync.js'</span>,</span><br><span class="line">          options: &#123;</span><br><span class="line">            name: <span class="string">'haha'</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义 loader 的用途很多，可以拿来做一个简单的错误检验</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> loaderUtils = <span class="built_in">require</span>(<span class="string">'loader-utils'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> source.replace(<span class="string">'haha'</span>, <span class="string">'world'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者是国际化,在相关页面弄一个占位符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">source</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Node全局变量 === <span class="string">'中文'</span>)&#123;</span><br><span class="line">       source.replace(<span class="string">'&#123;&#123;title&#125;&#125;'</span>, <span class="string">'中文标题'</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">       source.replace(<span class="string">'&#123;&#123;title&#125;&#125;'</span>, <span class="string">'engilsh title'</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以具体参数可以<a href="https://webpack.js.org/api/loaders">点击这里</a></p><h2 id="如何编写一个-Plugin"><a href="#如何编写一个-Plugin" class="headerlink" title="如何编写一个 Plugin"></a>如何编写一个 Plugin</h2><p>简单的实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// plugin/copyright-webpack-plugin</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CopyRightWebpackPlugin</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(options)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//compiler:webpack 的实例</span></span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    <span class="comment">// 同步</span></span><br><span class="line">    compiler.hooks.compile.tap(<span class="string">'CopyRightWebpackPlugin'</span>, (compilation) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'compiler'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 异步</span></span><br><span class="line">    compiler.hooks.emit.tapAsync(<span class="string">'CopyRightWebpackPlugin'</span>, (compilation, cb) =&gt; &#123;</span><br><span class="line">      <span class="keyword">debugger</span>;</span><br><span class="line">      compilation.assets[<span class="string">'copyright.txt'</span>]=&#123;</span><br><span class="line">        source:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="string">'copyright by hahaha'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        size:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">19</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cb();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = CopyRightWebpackPlugin;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> CopyRightWebpackPlugin = <span class="built_in">require</span>(<span class="string">'./plugin/copyright-webpack-plugin.js'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'development'</span>,</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="string">'main'</span>: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> CopyRightWebpackPlugin(&#123;</span><br><span class="line">      name:<span class="string">'haha'</span></span><br><span class="line">    &#125;)</span><br><span class="line">  ],</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调试</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"plugin"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"build"</span>: <span class="string">"webpack"</span>,</span><br><span class="line">    <span class="attr">"debug"</span>: <span class="string">"node --inspect --inspect-brk node_modules/webpack/bin/webpack.js"</span>,</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.30.0"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.0"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>npm run debug </p><p>进入下一步，添加 watch compilation 可以对一些类似这样的参数进行调试观察</p><p>具体的可以<a href="https://webpack.js.org/api/compiler-hooks">点击这里</a></p><h2 id="Bundler-源码编写（模块分析）"><a href="#Bundler-源码编写（模块分析）" class="headerlink" title="Bundler 源码编写（模块分析）"></a>Bundler 源码编写（模块分析）</h2><p>文件目录src 下面有三个文件，分别是 index.js message.js word.js ，引用关系是从左到右导入下一个的文件，具体代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// word.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> word = <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// message.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; word &#125; <span class="keyword">from</span> <span class="string">'./word.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">`say <span class="subst">$&#123;word&#125;</span>`</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> message; </span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> message <span class="keyword">from</span> <span class="string">'./message.js'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(message);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本配置</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> parser = <span class="built_in">require</span>(<span class="string">'@babel/parser'</span>);</span><br><span class="line"><span class="keyword">const</span> traverse = <span class="built_in">require</span>(<span class="string">'@babel/traverse'</span>).default;</span><br><span class="line"><span class="keyword">const</span> babel = <span class="built_in">require</span>(<span class="string">'@babel/core'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入口文件的分析</span></span><br><span class="line"><span class="keyword">const</span> moduleAnalyser = <span class="function">(<span class="params">filename</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> content = fs.readFileSync(filename, <span class="string">'utf-8'</span>);</span><br><span class="line">  <span class="comment">// 抽象语法树</span></span><br><span class="line">  <span class="keyword">const</span> ast = parser.parse(content, &#123;</span><br><span class="line">    sourceType: <span class="string">'module'</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 依赖文件，键值对，键：依赖文件的相对路径，值：依赖文件的相对于bundler 的路径（绝对路径）</span></span><br><span class="line">  <span class="keyword">const</span> dependencies = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 分析抽象语法树</span></span><br><span class="line">  traverse(ast, &#123;</span><br><span class="line">    <span class="comment">// 入口声明</span></span><br><span class="line">    ImportDeclaration(&#123; node &#125;) &#123;</span><br><span class="line">      <span class="comment">// 路径转换</span></span><br><span class="line">      <span class="keyword">const</span> dirname = path.dirname(filename);</span><br><span class="line">      <span class="keyword">const</span> newFile = <span class="string">'./'</span> + path.join(dirname, node.source.value)</span><br><span class="line">      dependencies[node.source.value] = newFile</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 抽象语法树的转换，提取可以在浏览器运行的代码</span></span><br><span class="line">  <span class="keyword">const</span> &#123; code &#125; = babel.transformFromAst(ast, <span class="literal">null</span>, &#123;</span><br><span class="line">    <span class="comment">// 插件的集合</span></span><br><span class="line">    presets: [<span class="string">"@babel/preset-env"</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    filename,</span><br><span class="line">    dependencies,</span><br><span class="line">    code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 依赖图谱</span></span><br><span class="line"><span class="keyword">const</span> makeDependenciesGraph = <span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> entryModule = moduleAnalyser(entry)</span><br><span class="line">  <span class="keyword">const</span> graphArray = [entryModule];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; graphArray.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> item = graphArray[i];</span><br><span class="line">    <span class="comment">// 获取依赖关系</span></span><br><span class="line">    <span class="keyword">const</span> &#123; dependencies &#125; = item;</span><br><span class="line">    <span class="keyword">if</span> (dependencies) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> j <span class="keyword">in</span> dependencies) &#123;</span><br><span class="line">        graphArray.push(</span><br><span class="line">          moduleAnalyser(dependencies[j])</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 格式转换</span></span><br><span class="line">  <span class="keyword">const</span> graph = &#123;&#125;</span><br><span class="line">  graphArray.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    graph[item.filename] = &#123;</span><br><span class="line">      dependencies: item.dependencies,</span><br><span class="line">      code: item.code</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成浏览器可以用的代码</span></span><br><span class="line"><span class="keyword">const</span> generateCode = <span class="function">(<span class="params">entry</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 转为字符串</span></span><br><span class="line">  <span class="keyword">const</span> graph = <span class="built_in">JSON</span>.stringify(makeDependenciesGraph(entry));</span><br><span class="line">  <span class="comment">// graph code 里面有 exports 跟 require 的方法,但是浏览器没有这两个函数，需要我们自己去实现</span></span><br><span class="line">  <span class="built_in">console</span>.log(graph);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">  (function (graph) &#123;</span></span><br><span class="line"><span class="string">    function require(module) &#123;</span></span><br><span class="line"><span class="string">      function localRequire(relativePath) &#123;</span></span><br><span class="line"><span class="string">        return require(graph[module].dependencies[relativePath])</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      var exports = &#123;&#125;;</span></span><br><span class="line"><span class="string">      (function (require, exports, code) &#123;</span></span><br><span class="line"><span class="string">        eval(code)</span></span><br><span class="line"><span class="string">      &#125;)(localRequire, exports, graph[module].code);</span></span><br><span class="line"><span class="string">      return exports;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    require('<span class="subst">$&#123;entry&#125;</span>')</span></span><br><span class="line"><span class="string">  &#125;)(<span class="subst">$&#123; graph&#125;</span>)</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Info = generateCode(<span class="string">'./src/index.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Info);</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node bundler.js | highlight</span><br></pre></td></tr></table></figure><p>控制台输出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">graph</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">require</span>(<span class="params">module</span>) </span>&#123; <span class="comment">// ./message.js 通过相对路径来拿到绝对路径</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">localRequire</span>(<span class="params">relativePath</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">require</span>(graph[<span class="built_in">module</span>].dependencies[relativePath])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> exports = &#123;&#125;;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params">require, exports, code</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">eval</span>(code)</span><br><span class="line">    &#125;)(localRequire, exports, graph[<span class="built_in">module</span>].code);</span><br><span class="line">    <span class="keyword">return</span> exports;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">require</span>(<span class="string">'./src/index.js'</span>)</span><br><span class="line">&#125;)(&#123;<span class="string">"./src/index.js"</span>:&#123;<span class="string">"dependencies"</span>:&#123;<span class="string">"./message.js"</span>:<span class="string">"./src\\message.js"</span>&#125;,<span class="string">"code"</span>:<span class="string">"\"use strict\";\n\nvar _message = _interopRequireDefault(require(\"./message.js\"));\n\nfunction _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; \"default\": obj &#125;; &#125;\n\nconsole.log(_message[\"default\"]);"</span>&#125;,<span class="string">"./src\\message.js"</span>:&#123;<span class="string">"dependencies"</span>:&#123;<span class="string">"./word.js"</span>:<span class="string">"./src\\word.js"</span>&#125;,<span class="string">"code"</span>:<span class="string">"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", &#123;\n  value: true\n&#125;);\nexports[\"default\"] = void 0;\n\nvar _word = require(\"./word.js\");\n\nvar message = \"say \".concat(_word.word);\nvar _default = message;\nexports[\"default\"] = _default;"</span>&#125;,<span class="string">"./src\\word.js"</span>:&#123;<span class="string">"dependencies"</span>:&#123;&#125;,<span class="string">"code"</span>:<span class="string">"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", &#123;\n  value: true\n&#125;);\nexports.word = void 0;\nvar word = 'hello';\nexports.word = word;"</span>&#125;&#125;)</span><br></pre></td></tr></table></figure><p>复制粘贴到浏览器便可以运行</p><p>graph 输出内容是</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"./src/index.js"</span>: &#123;</span><br><span class="line">    <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">      <span class="attr">"./message.js"</span>: <span class="string">"./src\\message.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"code"</span>: <span class="string">"\"use strict\";\n\nvar _message = _interopRequireDefault(require(\"./message.js\"));\n\nfunction _interopRequireDefault(obj) &#123; return obj &amp;&amp; obj.__esModule ? obj : &#123; \"default\": obj &#125;; &#125;\n\nconsole.log(_message[\"default\"]);"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"./src\\message.js"</span>: &#123;</span><br><span class="line">    <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">      <span class="attr">"./word.js"</span>: <span class="string">"./src\\word.js"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"code"</span>: <span class="string">"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", &#123;\n  value: true\n&#125;);\nexports[\"default\"] = void 0;\n\nvar _word = require(\"./word.js\");\n\nvar message = \"say \".concat(_word.word);\nvar _default = message;\nexports[\"default\"] = _default;"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"./src\\word.js"</span>: &#123;</span><br><span class="line">    <span class="attr">"dependencies"</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">"code"</span>: <span class="string">"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", &#123;\n  value: true\n&#125;);\nexports.word = void 0;\nvar word = 'hello';\nexports.word = word;"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 code 里面的内容有一个require 函数和一个 exports 对象，所以为了这些代码能够在浏览器运行，我们需要自己创建一个 require函数和exports 空对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://coding.imooc.com/learn/list/316.html&quot;&gt;DellLee 老师的 webpack 学习与记录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;知识点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Loader&lt;/code&gt; 
      
    
    </summary>
    
      <category term="webpack" scheme="http://laibh.top/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://laibh.top/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题目汇总摘录（浏览器与性能基础篇）</title>
    <link href="http://laibh.top/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E6%91%98%E5%BD%95-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9F%BA%E7%A1%80%E7%AF%87.html"/>
    <id>http://laibh.top/前端面试题目汇总摘录-浏览器基础篇.html</id>
    <published>2019-04-08T01:30:54.000Z</published>
    <updated>2019-10-15T09:29:49.419Z</updated>
    
    <content type="html"><![CDATA[<p>温故而知新，保持空杯心态.续 <a href="https://yuchengkai.cn/docs/frontend">前端面试之道</a>继续复习浏览器相关内容</p><h2 id="浏览器基础"><a href="#浏览器基础" class="headerlink" title="浏览器基础"></a>浏览器基础</h2><h3 id="事件机制"><a href="#事件机制" class="headerlink" title="事件机制"></a>事件机制</h3><h4 id="事件触发三阶段"><a href="#事件触发三阶段" class="headerlink" title="事件触发三阶段"></a>事件触发三阶段</h4><ul><li>window 往事件 触发处传播，遇到注册的捕获事件会触发</li><li>传播到事件触发处时触发注册的事件</li><li>从事件触发处往 window 传播，遇到注册的冒泡事件会触发</li></ul><p>事件触发一般来说会按照上面的顺序进行，但是也有特例，如果给一个目标节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面会先打印冒泡然后捕获</span></span><br><span class="line">node.addEventListener(</span><br><span class="line">    <span class="string">'click'</span>,</span><br><span class="line">    event =&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">node.addEventListener(</span><br><span class="line"><span class="string">'click'</span>,</span><br><span class="line">    event =&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'捕获'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">true</span>    </span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h4><p>addEventListener 注册事件，改函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 useCapture 参数来说，该参数默认值为 false。useCapture 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用下面几个属性：</p><ul><li>capture ，布尔值，和 useCapture 作用一样</li><li>once,布尔值，值为 true 表示该回调值调用一次，调用后会移除监听</li><li>passive，布尔值，表示永远不会调用 preventDefault</li></ul><p>如果我们希望事件只触发在目标上，可以调用 stopPropagation 来阻止事件的进一步传播。通常我们认为 stopPropagation 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。stopImmediatePropagation 同样也可以实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">node.addEventListener(</span><br><span class="line">    <span class="string">'click'</span>,</span><br><span class="line">    event =&gt;&#123;</span><br><span class="line">        event.stopImmediatePropagation()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'冒泡'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">// 点击 node 只会执行上面的函数，下面的不会执行</span></span><br><span class="line">node.addEventListener(</span><br><span class="line">    <span class="string">'click'</span>,</span><br><span class="line">    event =&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'捕获'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h4><p>如果一个节点中的子节点是动态生成的，那么子节点需要注册事件的话应该注册在父节点上面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'#ul'</span>);</span></span><br><span class="line"><span class="javascript">    ul.addEventListener(<span class="string">'click'</span>,event=&gt;&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(event.target);</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>事件代理的方法相对于直接给目标注册事件来说，有以下优点：</p><ul><li>节省内存</li><li>不需要给子节点注销事件</li></ul><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSONP 原理很简单，就是利用 <code>&lt;script&gt;</code> 标签没有跨域限制的漏洞。通过 <code>&lt;script&gt;</code> 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯的时候</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://domain/api?param1=a&amp;param2=b&amp;callback=jsonp"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(data)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JSONP 使用简单且兼容性不错，但是只限于 get 请求</p><p>在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP ，下面是简单的实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">jsonp</span>(<span class="params">url,jsonpCallback,success</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">    script.src = url;</span><br><span class="line">    script.async = <span class="literal">true</span>;</span><br><span class="line">    script.type = <span class="string">'text/javascript'</span></span><br><span class="line">    <span class="built_in">window</span>[jsonpCallback] = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">        success &amp;&amp; success(data)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line">jsonp(<span class="string">'http://xxx'</span>,<span class="string">'callback'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>CORS 需要浏览器和后端同时支持，IE8 和 9 需要通过 XDomainRequest 来实现</p><p>浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端，只要后端实现了 CORS 就实现了跨域。</p><p>服务端设置了 Access-Control-Allow-Origin 就可以开启 CORS ,该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都是可以访问资源的。</p><p>会在发送请求时出现两种情况，分别为简单请求和复杂请求</p><p><strong>简单请求</strong></p><p>以Ajax 为例，当满足下面的条件的时候会触发简单请求</p><p>1.使用 Get,HEAD,POST </p><p>2.Content-type 的值仅限 text/plain,multipart/form-data,application/x-www-form-urlencoded 之一</p><p>请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器，也可以使用 XMLHttpRequest.upload 属性访问</p><p><strong>复杂请求</strong></p><p>对于复杂的请求，首先会发起一个预检请求，该请求是 option 方法，通过该请求来指点服务端是否运行跨域请求。</p><p>对于预检请求，使用 Node 来设置 CORS 的话，可能会遇到一个坑，以 express 为例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function">(<span class="params">req,res,next</span>)=&gt;</span>&#123;</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Origin'</span>,<span class="string">'*'</span>)</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-Methods'</span>,<span class="string">'PUT,POST,GET,DELETE,OPTIONS'</span>)</span><br><span class="line">    res.header(<span class="string">'Access-Control-Allow-headers'</span>,<span class="string">'Origin,X-Requested-With,Content-Type,Accept,Authorization,Access-Control-Allow-Credentials'</span>)</span><br><span class="line">    next()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面的这个代码会验证 Authorization 子段，如果没有话的就会报错</p><p>当前端发起了复杂请求，返回的结果永远是报错的。因为预检请求也会进入到回调中，也会触发 next 方法，因为预检请求并不包含 Authorization 子弹，所以服务端也会报错。想要解决这个问题很简单，只要在 回调中过滤掉 option 就可以了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">res.statusCode = <span class="number">204</span>;</span><br><span class="line">res.setHeader(<span class="string">'Content-Length'</span>,<span class="string">'0'</span>);</span><br><span class="line">res.send();</span><br></pre></td></tr></table></figure><h4 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h4><p>该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。</p><p>只需要给页面添加 document.domian = ‘test.com’ 表示二级域名都相同就可以实现跨域</p><h4 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h4><p>这种方式通常用于获取嵌入页面中的第三方页面数据，一个页面发送消息，另一个页面判断来源并接受消息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送消息端</span></span><br><span class="line"><span class="built_in">window</span>.parent.postMessage(<span class="string">'message'</span>,<span class="string">'http://test.com'</span>);</span><br><span class="line"><span class="comment">// 接受消息端</span></span><br><span class="line"><span class="keyword">const</span> mc = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">mc.addEventListener(<span class="string">'message'</span>,event=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> origin = event.origin || event.originalEvent.origin;</span><br><span class="line">    <span class="keyword">if</span>(origin === <span class="string">'http://test.com'</span>)&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'验证通过'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="Event-loop"><a href="#Event-loop" class="headerlink" title="Event loop"></a>Event loop</h3><p>JS 是门非阻塞单线程语言</p><p>JS 在执行过程中会产生执行环境，这些执行环境会被顺序的加入到执行栈中。如果遇到异步的代码，会被挂起并加入到 Task(有多种 task) 队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要执行的代码并放入执行栈中执行，所以本质上来说 JS 中的异步还是同步行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>);</span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure><p>以上代码虽然 <code>setTimeout</code> 延时为 0，其实还是异步。这是因为 HTML5 标准规定这个函数第二个参数不得小于 4 毫秒，不足会自动增加。所以 <code>setTimeout</code> 还是会在 <code>script end</code> 之后打印。</p><p>不同的任务源会被分配到不同的 Task 队列中，任务源可以分为 微任务（microtask） 和 宏任务（macrotask）。在 ES6 规范中，microtask 称为 <code>jobs</code>，macrotask 称为 <code>task</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure><p>微任务包括 <code>process.nextTick</code> ，<code>promise</code> ，<code>Object.observe</code> ，<code>MutationObserver</code></p><p>宏任务包括 <code>script</code> ， <code>setTimeout</code> ，<code>setInterval</code> ，<code>setImmediate</code> ，<code>I/O</code> ，<code>UI rendering</code></p><p>宏任务中包括了 <code>script</code> ，浏览器会先执行一个宏任务，接下来有异步代码的话就先执行微任务。</p><p>正确的一次 Event Loop 顺序是这样的</p><ol><li>执行同步代码，属于宏观任务</li><li>执行栈为空，查询是否有微任务需要执行</li><li>执行所有微任务</li><li>必要的话渲染 UI</li><li>然后开始下一轮 Event Loop ，执行宏任务中的异步代码</li></ol><p>如果宏任务中的异步代码有大量的计算并且需要操作 DOM 的话，为了更快的界面响应，可以把操作 DOM 放入 微任务中。</p><h4 id="Node-的-Event-loop"><a href="#Node-的-Event-loop" class="headerlink" title="Node 的 Event loop"></a>Node 的 Event loop</h4><p>Node 中的 Event loop 和浏览器的不相同</p><p>Node 中的 Event loop 分成了6个阶段，它们会按照顺序反复执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><h4 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h4><p>timer 阶段会执行 setTimeout 和 setInterval</p><p>一个 timer 指定的时间并不是准确的时间，而是达到这个事件后尽快执行回调，可能会因为系统正在执行别的事务而延迟</p><p>下限的时间有一个范围：[1,2147483647]，如果设置的时间不在范围内，将被设置为 1.</p><h4 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h4><p>I/O 阶段会执行除了 close 事件，定时器和 setImmediate 的回调</p><h4 id="idle-prepare"><a href="#idle-prepare" class="headerlink" title="idle,prepare"></a>idle,prepare</h4><p>idle，prepare 阶段内部实现</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll 阶段很重要，在这一阶段中，系统会做两件事情</p><ol><li>执行到点的定时器</li><li>执行 poll 队列中的事件</li></ol><p>并且当 poll 中没有定时器的情况下，会发现以下两件事情</p><ul><li>如果poll队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制</li><li>如果poll队列为空,会发生两件事情<ul><li>如果有 setImmediate 需要执行的时候，poll 阶段会停止并且进入到 check 阶段执行 setImmediate</li><li>如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调</li></ul></li></ul><h4 id="check"><a href="#check" class="headerlink" title="check"></a>check</h4><p>check 阶段执行 setImmediate</p><h4 id="close-callbacks"><a href="#close-callbacks" class="headerlink" title="close callbacks"></a>close callbacks</h4><p>close callbacks 阶段执行 close 事件</p><p>并且在 Node 中，有些情况下的定时器执行顺序是随机的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>); </span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line">setImmediate(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setImmediate'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 这里可能会输出 setTimeout，setImmediate</span></span><br><span class="line"><span class="comment">// 可能也会相反的输出，这取决于性能</span></span><br><span class="line"><span class="comment">// 因为可能进入 event loop 用了不到 1 毫秒，这时候会执行 setImmediate</span></span><br><span class="line"><span class="comment">// 否则会执行 setTimeout</span></span><br></pre></td></tr></table></figure><p>当然在这种情况下，执行顺序是相同的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'timeout'</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  setImmediate(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'immediate'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 因为 readFile 的回调在 poll 中执行</span></span><br><span class="line"><span class="comment">// 发现有 setImmediate ，所以会立即跳到 check 阶段执行回调</span></span><br><span class="line"><span class="comment">// 再去 timer 阶段执行 setTimeout</span></span><br><span class="line"><span class="comment">// 所以以上输出一定是 setImmediate，setTimeout</span></span><br></pre></td></tr></table></figure><p>上面介绍的都是 macrotask 的执行情况，microtask 会在以上每个阶段完成后立即执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer2'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上代码在浏览器和 node 中打印情况是不同的</span></span><br><span class="line"><span class="comment">// 浏览器中一定打印 timer1, promise1, timer2, promise2</span></span><br><span class="line"><span class="comment">// node 中可能打印 timer1, timer2, promise1, promise2</span></span><br><span class="line"><span class="comment">// 也可能打印 timer1, promise1, timer2, promise2</span></span><br></pre></td></tr></table></figure><p>Node 中的 <code>process.nextTick</code> 会先于其他 microtask 执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// nextTick, timer1, promise1</span></span><br></pre></td></tr></table></figure><h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><h4 id="cookie-localStorage-sessionStorage-indexDB"><a href="#cookie-localStorage-sessionStorage-indexDB" class="headerlink" title="cookie,localStorage,sessionStorage,indexDB"></a>cookie,localStorage,sessionStorage,indexDB</h4><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:center">cookie</th><th style="text-align:center">localStorage</th><th style="text-align:center">sessionStorage</th><th style="text-align:center">indexDB</th></tr></thead><tbody><tr><td style="text-align:left">数据生命周期</td><td style="text-align:center">一般由服务器生成，可以设置过期时间</td><td style="text-align:center">除非被清理，否则一直都在</td><td style="text-align:center">页面关闭就清理</td><td style="text-align:center">除非被处理，否则一直都在</td></tr><tr><td style="text-align:left">数据存储大小</td><td style="text-align:center">4K</td><td style="text-align:center">5M</td><td style="text-align:center">5M</td><td style="text-align:center">无限</td></tr><tr><td style="text-align:left">与服务端通信</td><td style="text-align:center">每次都会携带在 header 中，对于请求性能影响</td><td style="text-align:center">不参与</td><td style="text-align:center">不参与</td><td style="text-align:center">不参与</td></tr></tbody></table><p>cookie 不建议用于存储，如果没有大量的数据存储需求的话，可以使用 localStorage 和 sessionStorage。对于不怎么改变的数据使用 localStorage 存储，否则可以用 sessionStorage 存储。</p><p>对于 cookie 我们还需要 注意安全性</p><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>value</td><td>如果用于保存用户登录状态，应该将该值加密，不能使用明文的用户标识</td></tr><tr><td>http-only</td><td>不能通过 JS 访问 Cookie，减少 XSS 攻击</td></tr><tr><td>secure</td><td>只能在协议为 HTTPS 的请求中携带</td></tr><tr><td>same-site</td><td>规定浏览器不能在跨域请求中携带 Cookie，减少 CSRF 攻击</td></tr></tbody></table><h4 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h4><blockquote><p>Service Worker 是运行在浏览器后面的独立线程，一般可以用来实现缓存功能，使用 Service Worker 传输协议必须为 HTTPS，以为 Service Worker 中涉及到拦截，所以必须使用 HTTPS 协议来保障安全。</p><p>Service Worker 实现缓存功能一般分成三个步骤：首先你需要先注册 Service Worker ，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查找是否存在缓存。，存在缓存的话就可以直接读取缓存文件，否则就去请求数据，下面是这个步骤的实现：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">if</span>(navigator.serviceWorker)&#123;</span><br><span class="line">   navigator.serviceWorker.register(<span class="string">'sw.js'</span>)</span><br><span class="line">     .then(<span class="function"><span class="keyword">function</span>(<span class="params">registration</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'service worker 注册成功'</span>);</span><br><span class="line">   &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'service worker 注册失败'</span>);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sw.js</span></span><br><span class="line"><span class="comment">// 监听 install 事件，回调中缓存所需文件</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>,e=&gt;&#123;</span><br><span class="line">    e.waitUntil(</span><br><span class="line">        caches.open(<span class="string">'my-cache'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cache.addAll([<span class="string">'./index.html'</span>,<span class="string">'./index.js'</span>])</span><br><span class="line">        &#125;);</span><br><span class="line">    )</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拦截所有请求</span></span><br><span class="line"><span class="comment">// 如果缓存中已经有请求的数据就直接用缓存，否则就去请求数据</span></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>,e=&gt;&#123;</span><br><span class="line">    e.respondWith(</span><br><span class="line">        cache.match(e.request).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(response) <span class="keyword">return</span> response;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'fetch source'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个内容在 我的一篇 webpack4.x从基础到实战笔记中也有提及</p><h3 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h3><p>性能优化领域相关面试题目</p><p>缓存是性能优化中简单高效的一种优化方式，可以显著减少网络传输带来的损耗</p><p>对于一个数据来说，可以分成网络请求，后端处理，浏览器响应三个步骤。浏览器缓存可以帮助我们在第一步和第三步中优化性能。如果直接使用缓存而不发起请求，或者发送了请求但是后端存储的数据和前端的一样，那么就没有必要再将数据回传过来，这样就减少了响应数据。</p><p>可以分几个部分来讲这个浏览器缓存机制：</p><h4 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h4><ol><li>Service Worker</li><li>Memory Cache</li><li>Disk Cache</li><li>Push Cache</li><li>网络请求</li></ol><p><strong>Service Worker</strong></p><p>Service Worker 的缓存与浏览器中其他内建的缓存机制是不同的，它可以让我们自由控制缓存文件，如何匹配、读取缓存，并且缓存是持续性的。</p><p>当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</p><p><strong>Memory Cache</strong></p><p>Memory Cache 也就是内存中的缓存，读取内存中的数据肯定比磁盘的块。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放，一旦我们关闭了 Tag 页面，内存中的缓存也就被释放了。</p><p><strong>Dish Cache</strong></p><p>Disk Cache 也就是存储在硬盘中的缓存，读取速度是慢点，但是什么都能存储在磁盘中，与 Memory Cache 相比胜在容量和 存储时效性上面。</p><p>在所有浏览器中，Disk Cache 覆盖面基本是最大的，它会根据 HTTP Header 中的字段来判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且及时在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</p><p><strong>Push Cache</strong></p><p>Push Cache 是 HTTP/2 中的内容。当以上三种缓存都没有命中时才会被使用，并且缓存时间也很短暂，只会在会话 （session）中存在，一旦会话结束便会被释放。</p><ul><li>所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好</li><li>可以推送 <code>no-cache</code> 和 <code>no-store</code> 的资源</li><li>一旦连接被关闭，Push Cache 就被释放</li><li>多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存</li><li>Push Cache 中的缓存只能被使用一次</li><li>浏览器可以拒绝接受已经存在的资源推送</li><li><p>你可以给其他域名推送资源</p><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fjakearchibald.com%2F2017%2Fh2-push-tougher-than-i-thought%2F">HTTP/2 push is tougher than I thought</a> </p></li></ul><p><strong>网络请求</strong></p><p>如果所有缓存都没有命中的话，那么只能发起网络请求来获取资源了。</p><p>在性能上面考虑，大部分接口都应该选择好缓存策略</p><h4 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h4><p>通常浏览器的缓存策略分成两种，强缓存和协商缓存，并且缓存策略都是通过设置 HTTP  Header 来实现的。</p><p><strong>强缓存</strong></p><p>强缓存可以设置两种 HTTP Header 来实现：Expires 和 Cache-Control。强缓存表示在缓存期间不需要请求，state code 为 200</p><p><strong>Expires</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Expires</span>:  Sat,20,Apr 2019 10:06:00 GMT</span><br></pre></td></tr></table></figure><p>Expires 是 HTTP/1 的产物，表示资源会在 Sat,20,Apr 2019 10:06:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p><p><strong>Cache-Control</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control:max-age=30</span><br></pre></td></tr></table></figure><p>Cache-Control 出现于 HTTP/1.1，优先级高于 Expires，该属性值表示资源会在 30秒后过去，需要再次请求。</p><p>Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令。比如希望资源能被缓存下来，并且是客户端是代理服务器都能缓存，还能设置缓存失效时间等。</p><table><thead><tr><th>指令</th><th>作用</th></tr></thead><tbody><tr><td>public</td><td>表示响应可以被客户端和代理服务器缓存</td></tr><tr><td>private</td><td>表示响应只可以被客户端缓存</td></tr><tr><td>max-age=30</td><td>缓存30秒后失效，需要重新请求</td></tr><tr><td>s-maxage=30</td><td>覆盖 max-age 作用是一样的，只在代理服务器中生效</td></tr><tr><td>no-store</td><td>不缓存任何响应</td></tr><tr><td>no-cache</td><td>资源被缓存，但是立即失效，下次会发起请求验证资源是否过期</td></tr><tr><td>max-stale=30</td><td>30秒内，即使缓存失效了，也使用该缓存</td></tr><tr><td>min-fresh=30</td><td>希望30秒内获取最新的响应</td></tr></tbody></table><p><strong>协商缓存</strong></p><p>如果缓存过期了，就需要发起请求验证资源是否需要更新。协商缓存可以通过设置两种 Http header 来实现：Last-Modifier 和 ETag</p><p>当浏览器发起请求验证资源的时候，如果资源没有做改变，那么服务器就会返回 304 状态码，并且更新浏览器缓存的有效期。</p><p><strong>Last-Modified 和 If-Modified-Since</strong></p><p>Last-Modified 表示本地文件最后修改日期。If-Modifier-Since 会将 Last-Modifier 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码</p><p>但是 Last-Modifier 存在一些弊端：</p><ul><li>如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 <code>Last-Modified</code> 被修改，服务端不能命中缓存导致发送相同的资源</li><li>因为 <code>Last-Modified</code> 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源</li></ul><p>因为这些弊端所有出现了 ETag</p><p><strong>ETag 和 If-None-Match</strong></p><p>ETag 类似于文件指纹，If-None-Match 会将当前的 Etag 发送给服务器，询问该资源 ETag 是否发生了变化，如果有变动的话就将新的资源发送回来。并且 ETag 的优先级比 Last-Modifier 搞。</p><p>那么如果什么缓存策略都没有设置，浏览器会怎么处理？</p><p>对于这种情况，浏览器会采用一个启发式算法，通常会取响应头的 Date 减去 Last-Modifier 值的 10% 作为缓存时间。</p><h4 id="实际场景引用缓存策略"><a href="#实际场景引用缓存策略" class="headerlink" title="实际场景引用缓存策略"></a>实际场景引用缓存策略</h4><p><strong>频繁变动的资源</strong></p><p>首先使用 Cache-Control：no-cache 使得浏览器每次都请求服务器，然后配合 ETag 和 Last-Modifier 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小</p><p><strong>代码文件</strong></p><p>指除了 HTML 之外的代码的文件。因为HTML 文件一般不缓存或者缓存时间很短。</p><p>一般来说，都会使用打包工具，webpack 等等来对文件名进行哈希处理，只有当代码修改过后才会生成新的文件名。这样我们就可以给文件设置一个缓存有效期一年 Cache-Control:max-age=31536000 这样就只有当 HTML 文件引入的文件名发生了改变的时候才会去下载最新的代码文件，否则就会一直使用缓存。</p><h4 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h4><p>其实除了缓存的优化可以让性能显著提高，另外一个很重要点的是在开发阶段，尽量使用按需加载的原则来开发，增加代码的使用率从源头来优化性能，可能效果会更加显著。</p><h3 id="在浏览器地址栏键入-URL，按下回车之后会经历一下流程"><a href="#在浏览器地址栏键入-URL，按下回车之后会经历一下流程" class="headerlink" title="在浏览器地址栏键入 URL，按下回车之后会经历一下流程"></a>在浏览器地址栏键入 URL，按下回车之后会经历一下流程</h3><ol><li>解析 url 到 dns 服务器</li><li>dns 服务器返回 ip 地址到浏览器</li><li>跟随协议将 ip 发送到网络中</li><li>经过局域网达到服务器</li><li>进入服务器的 MVC 架构 controller</li><li>经过逻辑处理，请求分发，调用 Model</li><li>Model 与数据 进行交互，然后读取数据库，将结果通过 view 层返回到网络回到浏览器</li><li>浏览器根据请求回来的 html 和关联的css js 文件进行渲染</li><li>在渲染的过程中，浏览器根据 html 生成 dom 树，根据 css 生成 css 树</li><li>将 dom 树和 css 树进行整合，最终知道 dom 节点的样式，在页面上进行样式渲染</li><li>浏览器去执行 js 脚本</li><li>最终展示页面</li></ol><h3 id="渲染机制"><a href="#渲染机制" class="headerlink" title="渲染机制"></a>渲染机制</h3><h4 id="HTML-gt-DOM-树"><a href="#HTML-gt-DOM-树" class="headerlink" title="HTML=&gt;DOM 树"></a>HTML=&gt;DOM 树</h4><p>打开一个网页时，浏览器会去请求对应的 HTML 文件，拿到 JS/CSS/HTML  文件的字符串，但是计算机是不理解这些字符串的，在网络中传输的内容都是01 字节数据。当浏览器接收到这些字节数据后，它会将这些字节数据转换为字符串，也就是我们写的代码。</p><p>当数据被转换成字符以后，浏览器会将这些字符串通过词法分析转换为标记（Token），这一过程叫做标价化（tokenization）</p><p>打标记会将代码分成一块块，然后打上标记，便于理解这些最小单位的代码的含义。结束标记化后开始转换为 Node，最后这些 Node 会根据不同 Node 之间的联系构建为一颗 DOM 树</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字节数据 =&gt; 字符串 =&gt; Token =&gt; Node =&gt; DOM</span><br></pre></td></tr></table></figure><h4 id="CSS-gt-CSSDOM-树"><a href="#CSS-gt-CSSDOM-树" class="headerlink" title="CSS =&gt; CSSDOM 树"></a>CSS =&gt; CSSDOM 树</h4><p>与上面的过程是类似的。在这一过程中浏览器会确定下每一个节点的样式是什么，并且在这一过程中是很消耗资源的。浏览器得递归 CSSDOM 树，然后确定具体的元素到底是什么样式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字节数据 =&gt; 字符串 =&gt; Token =&gt; Node =&gt; CSSDOM</span><br></pre></td></tr></table></figure><h4 id="生成渲染树"><a href="#生成渲染树" class="headerlink" title="生成渲染树"></a>生成渲染树</h4><p>将 DOM 与 CSSOM 合并为一个渲染树</p><p>这一过程不是简单将两者结合，渲染树只会包括㤇显示的节点和这些节点样式信息，如果某个节点是 display:none 的，那么就不会在渲染树中显示</p><p>当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流），然后调用 GPU 绘制，合成图层，显示在屏幕上。</p><h4 id="浏览器的渲染机制一般分成下面几个步骤"><a href="#浏览器的渲染机制一般分成下面几个步骤" class="headerlink" title="浏览器的渲染机制一般分成下面几个步骤"></a>浏览器的渲染机制一般分成下面几个步骤</h4><ol><li>处理 HTML 并构建 DOM 树</li><li>处理 CSS 构建 CSSOM 树</li><li>将 DOM 与 CSSOM 合并为一个渲染树</li><li>根据渲染树来布局，计算每个节点位置</li><li>调用 GPU 绘制，合成图层，显示在屏幕上</li></ol><h4 id="经典面试题目：插入几万个-DOM，如何实现页面不卡顿？"><a href="#经典面试题目：插入几万个-DOM，如何实现页面不卡顿？" class="headerlink" title="经典面试题目：插入几万个 DOM，如何实现页面不卡顿？"></a>经典面试题目：插入几万个 DOM，如何实现页面不卡顿？</h4><p>因为 DOM 是属于渲染引擎中的东西，而 JS 又是 JS 引擎中的东西。当我们通过 JS 操作 DOM 的时候，其实这个操作涉及到了两个线程之间的通信，那么势必会带来一些性能上的损耗。操作 DOM 次数一多，也就等同于一直在进行线程之间的通信，并且操作 DOM 可能还会带来重绘回流的情况，所以也就导致了性能上的问题。</p><p>对于这道题目来说，首先我们肯定不能一次性把几万个 DOM 全部插入，这样肯定会造成卡顿，所以解决问题的重点应该是如何分批次部分渲染 DOM。大部分人应该可以想到通过 <code>requestAnimationFrame</code>的方式去循环的插入 DOM，其实还有种方式去解决这个问题：<strong>虚拟滚动</strong>（virtualized scroller）。</p><p><strong>这种技术的原理就是只渲染可视区域内的内容，非可见区域的那就完全不渲染了，当用户在滚动的时候就实时去替换渲染的内容。</strong></p><p>当我们滚动页面的时候就会实时去更新 DOM，这个技术就能顺利解决这道经典面试题。了解更多点击 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fbvaughn%2Freact-virtualized">react-virtualized</a>。</p><p><a href="https://juejin.im/post/5ca1ac256fb9a05e6938d2d1#heading-23">掘金上的方案</a></p><p>方案一：分页，懒加载，把数据分页，然后每次接受一定的数据，避免一次性接收太多</p><p>方案二：setInterval，setTimeout，requestAnimationFrame 分批渲染，让数据在不同帧内去做渲染</p><p>方案三：使用 virtual-scroll，虚拟滚动。</p><p>virtual-scroll 虚拟滚动，这种方式是指根据容器元素的高度以及列表项元素的高度来显示长列表数据中的某一个部分，而不是去完整地渲染长列表，以提高无限滚动的性能。</p><p>virtual-scroll 原理，在用户滚动时，改变列表可视区域的渲染部分</p><ul><li>计算当前可见区域起始数据的 startIndex</li><li>计算当前可见区域结束数据的 endIndex</li><li>计算当前可见区域的数据，并渲染到页面中</li><li>计算 startIndex 对应的数据在整个列表中的偏移位置 startOffset 并设置到列表上</li><li>计算 endIndex 对应的数据相对于可滚动区域最底部的偏移位置 endOffset，并设置到 列表上</li></ul><p>startOffset 和 endOffset 会撑开容器元素的内容高度，让其可持续的滚动；此外，还能保持滚动条处于一个正确的位置。</p><h4 id="阻塞渲染的情况"><a href="#阻塞渲染的情况" class="headerlink" title="阻塞渲染的情况"></a>阻塞渲染的情况</h4><p>首先渲染是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染，如果想要渲染更快，就应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。</p><p>然后当浏览器在解析到 script 标签的时候，会暂停构建 DOM ，完成之后才会从暂停的地方重新开始。也就是说，，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 <code>script</code> 标签放在 <code>body</code> 标签底部的原因。</p><p>也可以给 <code>script</code> 标签添加 <code>defer</code> 或者 <code>async</code> 属性。当 <code>script</code> 标签加上 <code>defer</code> 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 <code>script</code> 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 <code>async</code> 属性，表示 JS 文件下载和解析不会阻塞渲染。</p><h4 id="Load-和-DOMContentLoaded-区别"><a href="#Load-和-DOMContentLoaded-区别" class="headerlink" title="Load 和 DOMContentLoaded 区别"></a>Load 和 DOMContentLoaded 区别</h4><p>Load 事件触发代表页面中的 DOM ，CSS ，JS ,图片已经全部加载完毕</p><p>DOMContentLoaded 事件触发代表初始的 HTML 被完全加载和解析，不需要等待 CSS，JS 和图片加载.</p><h4 id="图层"><a href="#图层" class="headerlink" title="图层"></a>图层</h4><p>一般来说，可以把普通文档流看做是一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。</p><p>通常下面几个常用属性可以生成新图层</p><ul><li>3D 变换：translate3d，translateZ</li><li>will-change</li><li>video,iframe 标签</li><li>通过动画实现的 opacity 动画转换</li><li>position：fixed</li></ul><h4 id="重绘（Repaint）-和-回流（Reflow）"><a href="#重绘（Repaint）-和-回流（Reflow）" class="headerlink" title="重绘（Repaint） 和 回流（Reflow）"></a>重绘（Repaint） 和 回流（Reflow）</h4><p>重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。</p><ul><li>重绘是当节点需要更改外观而不影响布局的时候，比如改变 color ，就叫做重绘</li><li>回流是布局或者几何属性需要改变就成为回流</li></ul><p>回流必定会引起重绘，重绘不一定会引起回流。回流所需要的成本比重绘高德多，改变深层次的节点很可能会导致父节点的一系列回流。</p><p>所以一下几个动作可能会导致性能问题：</p><ul><li>改变 window 大小</li><li>改变字体</li><li>添加或者删除样式</li><li>文字改变</li><li>定位或者浮动</li><li>盒模型</li></ul><p>重绘和回流其实和 Event Loop 有关</p><ol><li>当 Event Loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为 浏览器是 60HZ 的刷新率，也就是 16.6ms 才会更新一次</li><li>判断是否有 resize 或者 scroll ，有点话就回去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。</li><li>判断是否触发了 media query</li><li>更新动画并且发送时间</li><li>判断是否有全屏操作事件</li><li>执行 requestAnimationFrame 回调</li><li>执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上面，但是兼容性不是很好</li><li>更新界面</li><li>以上就是一帧中可能会做的事情，如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调</li></ol><h4 id="减少重绘和回流"><a href="#减少重绘和回流" class="headerlink" title="减少重绘和回流"></a>减少重绘和回流</h4><p>使用 translate 替代 top</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'test'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.test</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">position</span><span class="selector-pseudo">:absolute</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">top</span><span class="selector-pseudo">:10px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">background</span><span class="selector-pseudo">:red</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 引起回流</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.querySelector(<span class="string">'.test'</span>).style.top = <span class="string">'100px'</span>;</span></span><br><span class="line"><span class="undefined">    &#125;,1000);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 visibility 替代 display:none，因为前者只会引起重绘，后者会引起回流（改变了布局）</p><p>把 DOM 离线后修改。比如：先 把 DOM 给 display:none(有一次回流)，然后你修改100次，然后再把它显示出来。</p><p>不要把 DOM 结点的属性值放在一个循环里当做循环里的变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">    <span class="comment">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">'.test'</span>).style.offsetTop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不要使用 table 布局，可能一个很小的改动都会造成整个 table 的重新布局</p><p>动画实现的速度的选择，动画速度越快，回流次数越多，也可以使用 requestAnimationFrame </p><p>CSS 选择符从右往左匹配查找，避免 DOM 深度过深</p><p>将频繁运行的动画变成图层，图层能够阻止该节点回流影响别的元素。比如对于 video 标签，浏览器会自动将该节点变成图层</p><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h3><h4 id="DNS-预解析"><a href="#DNS-预解析" class="headerlink" title="DNS 预解析"></a>DNS 预解析</h4><p>DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//xxx.cn"</span>&gt;</span><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>缓存对于前端性能优化来说是一个重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。</p><p>通常浏览器缓存策略分成两种：强缓存和协商缓存。</p><h4 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h4><p>实现强缓存可以通过两种响应头实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code 为 200</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires:Tue,09 Apr 2019 08:39:00 GMT</span><br></pre></td></tr></table></figure><p>Expires 是 HTTP/1.0 的产物，表示资源会在上述时间后过期，需要再次请求，并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-control:max-age=30</span><br></pre></td></tr></table></figure><p>Cache-control 出现于 HTTP/1.1 优先级高于 Expires。该属性表示自愿会在 30秒后过期，需要再次请求。</p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>如果缓存过期了，我们就可以使用协商缓存来解决问题。协商缓存需要请求，如果缓存有效会返回 304,、</p><p>协商缓存需要客户和服务端共同实现，和强缓存一样，也有两种实现方式。</p><p><strong>Last-Modified 和 If-Modified-Since</strong></p><p>Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来。</p><p>但是如果在本地打开缓存文件，就会造成 Last-Modified 被修改，所以在 HTTP/1.1 出现了 ETag</p><p><strong>ETag 和 If-None-Match</strong></p><p>ETag 类似于文件指纹，If-None-Match 会将 当前的 Etag 发送给服务器，询问该资源 Etag 是否变动，如果有变动的话就将新的资源发送回来，并且 ETag 优先级比 Last-Modified 高。</p><h4 id="选择合适的缓存策略"><a href="#选择合适的缓存策略" class="headerlink" title="选择合适的缓存策略"></a>选择合适的缓存策略</h4><p>对于大部分的场景都可以使用强缓存配合协商缓存来解决，但是有一些特殊的地方可能需要选择特殊的缓存策略：</p><ul><li>对于某些不需要缓存的资源，可以使用 Cache-control:no-store 来表示该资源不需要缓存</li><li>对于频繁变动的资源，可以使用 Cache-control:no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li><li>对于代码文件来说，通常使用 Cache-control:max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li></ul><h4 id="使用-HTTP-2-0"><a href="#使用-HTTP-2-0" class="headerlink" title="使用 HTTP/2.0"></a>使用 HTTP/2.0</h4><p>因为浏览器会有并发请求的限制，在 HTTP/1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间</p><p>在 HTTP/2.0 中引入了多路复用，能够让多个请求使用同个 TCP 链接，极大的加快了网页的加载速度。还支持 Header 压缩，进一步叫上了请求的数据大小</p><p>预加载</p><p>预加载是声明式的 fetch，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使用下面的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"xxx.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>预加载可以一定程度上降低首屏的时间，因为可以将一些不响应首屏但是重要的文件延后，唯一的缺点就是兼容性不好。</p><h4 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h4><p>可以通过预渲染将下载的文件预先在后台渲染，可以使用下面的代码开启：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">ref</span>=<span class="string">"prerender"</span> <span class="attr">href</span>=<span class="string">"xxx.com"</span>&gt;</span><span class="tag">&lt;/<span class="name">link</span>&gt;</span></span><br></pre></td></tr></table></figure><p>预渲染可以提高页面的架子啊速度，但是要确保该页面百分之百会被用户之后打开，否则就白白浪费资源了。</p><h3 id="优先渲染过程"><a href="#优先渲染过程" class="headerlink" title="优先渲染过程"></a>优先渲染过程</h3><h4 id="懒执行"><a href="#懒执行" class="headerlink" title="懒执行"></a>懒执行</h4><p>懒执行就是将某些逻辑延后到使用时再计算。该即使可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的回调来唤醒</p><h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><p>懒加载就是将不关键的资源延后加载</p><p>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西，对于图片来说，先设置图片的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域的时候，就将自定义属性替换成 src 属性，这样图片就会下载资源，实现了图片的懒加载。</p><p>懒加载不仅可以用于图片，也可以使用在别的资源上，比如进入可视区域才开始播放视频等等。</p><h3 id="文件优化"><a href="#文件优化" class="headerlink" title="文件优化"></a>文件优化</h3><h4 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h4><h4 id="计算图片大小"><a href="#计算图片大小" class="headerlink" title="计算图片大小"></a>计算图片大小</h4><p>对于一张100*100 的像素的图片来说，有 10000 个像素点，如果每个像素点都是用 RGBA 存储的话，每个像素有四个通道，每个通道有 1 个字节（8位=1个字节），所以图片的大小大概为39KB（10000x1x4/1024）</p><p>但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来对应缩小图片的大小。</p><p>大致有两个思路：</p><ol><li>减少像素点</li><li>减少每个像素点能够显示的颜色</li></ol><h4 id="图片加载优化"><a href="#图片加载优化" class="headerlink" title="图片加载优化"></a>图片加载优化</h4><ol><li>不用图片，能用 CSS 显示的尽量不要使用图片</li><li>移动端来说，一般图片都用 CDN 加载，可以计算出适配屏幕宽度，然后去请求对应裁剪好的图片</li><li>小图使用 base64 格式</li><li>将多个图片整合在一张雪碧图</li><li>选择正确的图片格式<ol><li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为这个格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差别的图片质量，缺点就是兼容性不好。</li><li>小图使用 Png，其实对于大部分图标这种图片，可以使用 SVG 代替</li><li>照片使用 JPEG</li></ol></li></ol><h4 id="其他文件优化"><a href="#其他文件优化" class="headerlink" title="其他文件优化"></a>其他文件优化</h4><ul><li>CSS 文件放在 head 中</li><li>服务端开启文件压缩功能</li><li>将 script 标签放在 body 的底部，因为 JS 文件执行会阻塞渲染，当然也可以将 script 放在任何地方，然后加上 defer ,表示该文件并行下载，但是会放在 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件加上 async 表示加载和渲染文档元素的过程和 JS 文件的加载与执行并行无序进行</li><li>执行 JS 代码过长会卡住渲染，对于需要时间计算的代码可以考虑使用 Webworker 。它可以让我们另开一个线程执行脚本而不影响渲染。</li></ul><h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><p>静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意的是 CDN 域名要与主站不同，否在每次请求都会带上主站的 cookie</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="使用-Webpack-优化项目"><a href="#使用-Webpack-优化项目" class="headerlink" title="使用 Webpack 优化项目"></a>使用 Webpack 优化项目</h4><ul><li>对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩</li><li>使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码</li><li>优化图片，对于小图可以使用 base64 的方式写入文件中</li><li>按照路由拆分代码，实现按需加载</li><li>给打包出来的文件名添加哈希，实现浏览器缓存文件</li></ul><h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><p>对于代码运行错误，通常的办法是使用 <code>window.onerror</code> 拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外</p><ul><li>对于跨域的代码运行错误会显示 <code>Script error.</code> 对于这种情况我们需要给 <code>script</code> 标签添加 <code>crossorigin</code> 属性</li><li>对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 <code>arguments.callee.caller</code> 来做栈递归</li></ul><p>对于异步代码来说，可以使用 <code>catch</code> 的方式捕获错误。比如 <code>Promise</code> 可以直接使用 <code>catch</code> 函数，<code>async await</code> 可以使用 <code>try catch</code></p><p>但是要注意线上运行的代码都是压缩过的，需要在打包时生成 sourceMap 文件便于 debug。</p><p>对于捕获的错误需要上传给服务器，通常可以通过 <code>img</code> 标签的 <code>src</code> 发起一个请求。</p><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><p><strong>如何渲染几万条数据并不卡住页面</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> total = <span class="number">100000</span>;</span><br><span class="line">  <span class="keyword">const</span> once = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">const</span> loopCount = total / once;</span><br><span class="line">  <span class="keyword">let</span> countOfRender = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">'ul'</span>);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 优化性能，插入不会造成回流</span></span><br><span class="line">    <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; once; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line">      li.innerHTML = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * total);</span><br><span class="line">      fragment.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line">    ul.appendChild(fragment);</span><br><span class="line">    countOfRender += <span class="number">1</span>;</span><br><span class="line">    loop();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (countOfRender &lt; loopCount) &#123;</span><br><span class="line">      <span class="built_in">window</span>.requestAnimationFrame(add);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  loop();</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p><strong>跨网站指令码</strong>（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程式的安全漏洞攻击，是<a href="https://www.wikiwand.com/zh-hans/%E4%BB%A3%E7%A2%BC%E6%B3%A8%E5%85%A5">代码注入</a>的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了 HTML 以及使用者端脚本语言。</p><p>XSS 分为三种：反射型，存储型和 DOM-based</p><h4 id="如何攻击"><a href="#如何攻击" class="headerlink" title="如何攻击"></a>如何攻击</h4><p>XSS 通过修改 HTML 节点或者执行 JS 代码来攻击网站</p><p>例如通过 URL 获取某些参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- http://www.domain.com?name=&lt;script&gt;alert(1)&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上述 URL 输入可能会将 HTML 改为 <code>&lt;div&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/div&gt;</code> ，这样页面中就凭空多了一段可执行脚本。这种攻击类型是反射型攻击，也可以说是 DOM-based 攻击。</p><p>也有另一种场景，比如写了一篇包含攻击代码 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 的文章，那么可能浏览文章的用户都会被攻击到。这种攻击类型是存储型攻击，也可以说是 DOM-based 攻击，并且这种攻击打击面更广。</p><h4 id="如何防御"><a href="#如何防御" class="headerlink" title="如何防御"></a>如何防御</h4><p>最普遍的做法是转义输入输出的内容，对于引号，尖括号，斜杠进行转义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    str = str.replace(<span class="regexp">/&amp;/g</span>,<span class="string">'&amp;amp;'</span>)</span><br><span class="line">    str = str.replace(<span class="regexp">/&lt;/g</span>,<span class="string">'&amp;lt;'</span>)</span><br><span class="line">    str = str.replace(<span class="regexp">/&gt;/g</span>,<span class="string">'&amp;gt;'</span>)</span><br><span class="line">    str = str.replace(<span class="regexp">/"/g</span>,<span class="string">'&amp;quto;'</span>) </span><br><span class="line">    str = str.replace(<span class="regexp">/'/g</span>,<span class="string">'&amp;#39;'</span>)</span><br><span class="line">    str = str.replace(<span class="regexp">/`/g</span>,<span class="string">'&amp;#96;'</span>)</span><br><span class="line">    str = str.replace(<span class="regexp">/\//g</span>,<span class="string">'&amp;#x2F;'</span>)</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过转义可以将攻击代码 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code> 变成</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -&gt; &amp;lt;script&amp;gt;alert(1)&amp;lt;&amp;#x2F;script&amp;gt;</span></span><br><span class="line"><span class="built_in">escape</span>(<span class="string">'&lt;script&gt;alert(1)&lt;/script&gt;'</span>)</span><br></pre></td></tr></table></figure><p>对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xss = <span class="built_in">require</span>(<span class="string">'xss'</span>)</span><br><span class="line"><span class="keyword">var</span> html = xss(<span class="string">'&lt;h1 id="title"&gt;XSS Demo&lt;/h1&gt;&lt;script&gt;alert("xss");&lt;/script&gt;'</span>)</span><br><span class="line"><span class="comment">// -&gt; &lt;h1&gt;XSS Demo&lt;/h1&gt;&amp;lt;script&amp;gt;alert("xss");&amp;lt;/script&amp;gt;</span></span><br><span class="line"><span class="built_in">console</span>.log(html)</span><br></pre></td></tr></table></figure><p>以上示例使用了 <code>js-xss</code> 来实现。可以看到在输出中保留了 <code>h1</code> 标签且过滤了 <code>script</code> 标签</p><h4 id="CSP"><a href="#CSP" class="headerlink" title="CSP"></a>CSP</h4><p>内容安全策略 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/CSP">CSP</a>) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (<a href="https://developer.mozilla.org/en-US/docs/Glossary/XSS">XSS</a>) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段。</p><p>我们可以通过 CSP 来尽量减少 XSS 攻击。CSP 本质上也是建立白名单，规定了浏览器只能够执行特定来源的代码。</p><p>通常可以通过 HTTP Header 中的 <code>Content-Security-Policy</code> 来开启 CSP</p><p>只允许加载本站资源</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy:default-src 'self'</span><br></pre></td></tr></table></figure><p>只允许加载 HTTPS 协议图片</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy:img-src https://*</span><br></pre></td></tr></table></figure><p>允许加载任何来源框架</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Security-Policy:child-src 'none'</span><br></pre></td></tr></table></figure><p>更多属性可以查看 <a href="https://content-security-policy.com/">这里</a></p><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p><strong>跨站请求伪造</strong>（英语：Cross-site request forgery），也被称为 <strong>one-click attack</strong>或者 <strong>session riding</strong>，通常缩写为 <strong>CSRF</strong> 或者 <strong>XSRF</strong>， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。<a href="https://www.wikiwand.com/zh/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0#citenoteRistic1">[1]</a> 跟<a href="https://www.wikiwand.com/zh/%E8%B7%A8%E7%B6%B2%E7%AB%99%E6%8C%87%E4%BB%A4%E7%A2%BC">跨網站指令碼</a>（XSS）相比，<strong>XSS</strong> 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p><p>简单点说，CSRF 就是利用用户的登录态发起恶意请求。</p><h4 id="如何攻击-1"><a href="#如何攻击-1" class="headerlink" title="如何攻击"></a>如何攻击</h4><p>假设网站中有一个通过 Get 请求提交用户评论的接口，那么攻击者就可以在钓鱼网站中加入一个图片，图片的地址就是评论接口</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.domain.com/xxx?comment='attack'"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>如果接口是 Post 提交的，就相对麻烦点，需要用表单来提交接口</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://www.domain.com/xxx"</span> <span class="attr">id</span>=<span class="string">"CSRF"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"comment"</span> <span class="attr">value</span>=<span class="string">"attack"</span> <span class="attr">type</span>=<span class="string">"hidden"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="如何防御-1"><a href="#如何防御-1" class="headerlink" title="如何防御"></a>如何防御</h4><p>防范 CSRF 可以遵循以下几种规则：</p><ol><li>Get 请求不对数据进行修改</li><li>不让第三方网站访问到用户的 Cookie</li><li>阻止第三方网站请求接口</li><li>请求时附带验证信息，比如验证码或者是 token</li></ol><p><strong>SameSite</strong></p><p>可以对 Cookie 设置 SameSite 属性，该属性设置 Cookie 不随着跨域请求发送，该属性可以很大程度减少 CSRF 的攻击，但是该属性目前并不是所有浏览器都兼容的</p><p><strong>验证 Referer</strong></p><p>对于需要防范 CSRF 的请求，我们可以通过验证 Referer 来判断该请求是否为第三方网站发起的</p><p><strong>Token</strong></p><p>服务器下发一个随机 Token （算法不能复杂），每次发起请求时都将 Token 携带上，服务器验证 Token 是否有效</p><h3 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h3><p>是一种视觉欺骗的攻击手段</p><h4 id="如何攻击-2"><a href="#如何攻击-2" class="headerlink" title="如何攻击"></a>如何攻击</h4><p>攻击者将需要攻击的网站通过 <code>iframe</code> 嵌套的方式嵌入自己的网页中，并将 <code>iframe</code> 设置为透明，在页面中透出一个按钮诱导用户点击。</p><h4 id="如何防御-2"><a href="#如何防御-2" class="headerlink" title="如何防御"></a>如何防御</h4><p><strong>X-FRAME-OPTIONS</strong></p><p>是一个 HTTP 响应头，为了防御用 iframe 嵌套的点击劫持攻击。</p><p>可以设置三个值，分别是</p><ul><li>DENY,表示页面不允许通过 iframe 的方式来展示</li><li>SAMEORIGHT,表示页面在相同的域名下来通过 iframe 的方式展示</li><li>ALLOW-FROM,表示页面可以在指定来源的 iframe 中展示</li></ul><h3 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h3><p>中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。</p><p>通常来说不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。</p><p>当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。</p><h3 id="密码安全"><a href="#密码安全" class="headerlink" title="密码安全"></a>密码安全</h3><h4 id="加盐"><a href="#加盐" class="headerlink" title="加盐"></a>加盐</h4><p>也就是给原来的密码添加字符串，增加原密码的长度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sha256(sha1(md5(salt+password+salt)))</span><br></pre></td></tr></table></figure><p>但是加盐并不能阻止别人盗窃账号，只能确保即使数据库泄露，也不会暴露用户的真实密码。一旦攻击者得到了用户的账号，可以通过暴力破解的方式破解密码。对于这种情况，通常使用验证码增加延时或者限制尝试次数的方式。并且一旦用户输入了错误的密码，也不能直接提示用户输错密码，而是账号或者密码错误</p><h3 id="从-V8-中看性能优化"><a href="#从-V8-中看性能优化" class="headerlink" title="从 V8 中看性能优化"></a>从 V8 中看性能优化</h3><p>测试性能工具：Chrome Audits 以及 Perfomance</p><p>V8引擎引入了 TurboFan 编译器，会在特定的情况下进行优化，将代码编译成执行效率更高的 Machine  Code，当然这个编译器并不是 JS 必须需要的，只是为了提高代码执行性能，所以总的 来说 JS 更偏向于 解释型语言。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JavaScript Source Code =&gt; [Parser] =&gt; Abstract Syntax Tree =&gt; [interpreter Ignition ] =&gt; [Complier TurboFan]</span><br><span class="line">      ||       ||</span><br><span class="line">         ByteCode     &lt;=   Optimized Machine Code</span><br></pre></td></tr></table></figure><p>JS 会首先被解析为 AST ，解析过程比较慢，代码越多，解析的过程也就耗费越长，这也是我们为什么要压缩代码的原因。另外一个减少解析时间的方式是预解析，作用于未执行的函数。另外尽可能避免嵌套函数声明，可以避免重复解析。</p><p>Ignition 负责将 AST 转换为 Bytecode ,然后 TurboFan 负责编译优化后的 Machine Code，并 Machine Code 在执行效率上优于 Bytecode.</p><p>JS 是一门动态类型的语言，而且有一堆的规则，简单的加法运算代码，内容就要考虑好几种规则，比如数字相加、字符串相加、对象和字符串等等。这种情况就会导致内部要增加很多判断逻辑，降低运行效率。</p><p>如果固定了类型，就不需要执行很多判断逻辑，代码可以编译为 Machine Code。ts 的好处？</p><p>如果我们一旦传入的参数类型改变，那么 Machine Code 就会被 DeOptimized 为 ByteCode，这样就有性能上的一个损耗。所以我们如果希望diam能多的编译为 Machine Code 并且 DeOptimized 的次数减少，就应该尽可能保证传入的类型一致。</p><h2 id="框架通识"><a href="#框架通识" class="headerlink" title="框架通识"></a>框架通识</h2><h3 id="MVVM-View-Model-ViewModel"><a href="#MVVM-View-Model-ViewModel" class="headerlink" title="MVVM(View+Model+ViewModel)"></a>MVVM(View+Model+ViewModel)</h3><p>传统的 MVC 架构通常是使用控制器更新模型，视图从模型中获取数据去渲染，当有用户输入的时候，会通过控制器去更新模型，并且通知视图进行更新，但是 MVC 架构的一个巨大的缺项就是控制承担的责任太大了，随着项目的愈加复杂，控制器中的代码会越来越臃肿，导致出现不利于维护的情况。</p><p>MVVM 由三个内容组成：</p><ul><li>View：界面</li><li>Model：数据模型</li><li>ViewModel：作为桥梁负责沟通 View 和 Model</li></ul><p>在 JQuery 时期，如果需要刷新 UI 时，需要先取到对应的 DOM 再更新 UI，这样数据和业务的逻辑就和页面有强耦合。</p><p>ViewModel 只关心数据和业务的处理，不关心 View 是怎么处理数据的，这种情况下，View 和 Model 都可以独立出来，任何一方改变了也不一定需要改变另一方，并且可以将一些复用的逻辑放在一个 ViewModel 中，让多个 View 复用这个 ViewModel。以 Vue 框架为例子，ViewModel 就是组件的实例，View 就是模板，Model 在引入了 Vuex 的情况下是完全可以和组件分离的。在 MVVM 中还引入了一个隐式的 Binder 层，实现了 View 和 ViewModel 的绑定，在Vue 中，这个隐式的 Binder 层就是Vue 通过解析模板中的插值和指令从而实现 View 和 ViewModel 的绑定。</p><p>在 MVVM 中，最核心的也就是数据双向绑定，例如 Angluar 的脏数据检测，Vue 中的数据劫持。</p><h4 id="脏数据监测"><a href="#脏数据监测" class="headerlink" title="脏数据监测"></a>脏数据监测</h4><p>当触发了指定事件后会进入脏数据检测，这时会调用 <code>$digest</code> 循环遍历所有的数据观察者，判断当前值是否和先前的值有区别，如果检测到变化的话，会调用 <code>$watch</code> 函数，然后再次调用 <code>$digest</code> 循环直到发现没有变化。循环至少为二次 ，至多为十次。</p><p>脏数据检测虽然存在低效的问题，但是不关心数据是通过什么方式改变的，都可以完成任务，但是这在 Vue 中的双向绑定是存在问题的。并且脏数据检测可以实现批量检测出更新的值，再去统一更新 UI，大大减少了操作 DOM 的次数。所以低效也是相对的，这就仁者见仁智者见智了。</p><h4 id="数据劫持"><a href="#数据劫持" class="headerlink" title="数据劫持"></a>数据劫持</h4><p>Vue 内部使用了 <code>Object.defineProperty()</code> 来实现双向绑定，通过这个函数可以监听到 <code>set</code> 和 <code>get</code> 的事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;<span class="attr">name</span>:<span class="string">'yck'</span>&#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="keyword">let</span> name = data.name</span><br><span class="line">data.name = <span class="string">'yyy'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!obj || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span>=&gt;</span>&#123;</span><br><span class="line">        defineReactive(obj,key,obj[key]);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj,key,val</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 递归子属性</span></span><br><span class="line">    observe(val);</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">        enumerable:<span class="literal">true</span>,</span><br><span class="line">        configurable:<span class="literal">true</span>,</span><br><span class="line">        get:<span class="function"><span class="keyword">function</span> <span class="title">rectiveGetter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'get value'</span>);</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set:<span class="function"><span class="keyword">function</span> <span class="title">rectiveSetter</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'change value'</span>);</span><br><span class="line">            val = newVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码简单的实现了如何监听数据的 <code>set</code> 和 <code>get</code> 的事件，但是仅仅如此是不够的，还需要在适当的时候给属性添加发布订阅</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在解析如上模板代码时，遇到 <code></code> 就会给属性 <code>name</code> 添加发布订阅。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过Dep 解耦</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span>()</span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.subs = []</span><br><span class="line">    &#125;</span><br><span class="line">    addSub(sub)&#123;</span><br><span class="line">        <span class="comment">// sub 是 Watcher 实例</span></span><br><span class="line">        <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">    &#125;</span><br><span class="line">    notify()&#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span>=&gt;</span>&#123;</span><br><span class="line">            sub.update()</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局属性，通过该属性配置 Watcher</span></span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>).innerText = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(obj,key,cb)&#123;</span><br><span class="line">        <span class="comment">// Dep.target 指向自己，然后触发属性的 getter 添加监听，最后将 Dep.target 置空</span></span><br><span class="line">        Dep.target = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">this</span>.cb = cb;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">        <span class="keyword">this</span>.value = obj[key]</span><br><span class="line">        Dep.target = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    update()&#123;</span><br><span class="line">        <span class="comment">// 获得新值</span></span><br><span class="line">        <span class="keyword">this</span>.value = <span class="keyword">this</span>.obj[<span class="keyword">this</span>.key];</span><br><span class="line">        <span class="comment">// 调用 update 方法更新 dom</span></span><br><span class="line">        <span class="keyword">this</span>.cb(<span class="keyword">this</span>.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> data = &#123;<span class="attr">name</span>:<span class="string">'yck'</span>&#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="comment">// 模拟解析到 &#123;&#123;name&#125;&#125; 触发的操作</span></span><br><span class="line"><span class="keyword">new</span> Watcher(data,<span class="string">'name'</span>,update)</span><br><span class="line"><span class="comment">// update dom innerHtml</span></span><br><span class="line">data.name = <span class="string">'yyy'</span></span><br></pre></td></tr></table></figure><p>接下来,对 <code>defineReactive</code> 函数进行改造</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj,key,val</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 递归子属性</span></span><br><span class="line">    observe(val)</span><br><span class="line">    <span class="keyword">let</span> db = <span class="keyword">new</span> Dep();</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj,key,&#123;</span><br><span class="line">        enumerable:<span class="literal">true</span>,</span><br><span class="line">        configurable:<span class="literal">true</span>,</span><br><span class="line">        get:<span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'get value'</span>);</span><br><span class="line">            <span class="comment">// 将 Watcher 添加到 订阅</span></span><br><span class="line">            <span class="keyword">if</span>(Dep.traget)&#123;</span><br><span class="line">               dp.addSub(Dep.target)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> val;</span><br><span class="line">        &#125;,</span><br><span class="line">        set:<span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'change value'</span>);</span><br><span class="line">            val = newVal;</span><br><span class="line">            <span class="comment">// 执行 watcher 的 update 方法</span></span><br><span class="line">            dp.notify();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实现了一个简易的双向绑定，核心思路就是手动触发一次属性的 getter 来实现发布订阅的添加。</p><h4 id="Proxy-与-Object-defineProperty-对比"><a href="#Proxy-与-Object-defineProperty-对比" class="headerlink" title="Proxy 与 Object.defineProperty 对比"></a>Proxy 与 Object.defineProperty 对比</h4><p><code>Object.defineProperty</code> 虽然已经能够实现双向绑定了，但是他还是有缺陷的。</p><ol><li>只能对属性进行数据劫持，所以需要深度遍历整个对象</li><li>对于数组不能监听到数据的变化</li></ol><p>虽然 Vue 中确实能检测到数组数据的变化，但是其实是使用了 hack 的办法，并且也是有缺陷的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"><span class="comment">// hack 以下几个函数</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获得原生函数</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用原生函数</span></span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// 触发更新</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>反观 Proxy 就没以上的问题，原生支持监听数组变化，并且可以直接对整个对象进行拦截，所以 Vue 也将在下个大版本中使用 Proxy 替换 Object.defineProperty</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> onWatch = <span class="function">(<span class="params">obj, setBind, getLogger</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> handler = &#123;</span><br><span class="line">    get(target, property, receiver) &#123;</span><br><span class="line">      getLogger(target, property)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, property, receiver)</span><br><span class="line">    &#125;,</span><br><span class="line">    set(target, property, value, receiver) &#123;</span><br><span class="line">      setBind(value)</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, property, value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">let</span> value</span><br><span class="line"><span class="keyword">let</span> p = onWatch(</span><br><span class="line">  obj,</span><br><span class="line">  v =&gt; &#123;</span><br><span class="line">    value = v</span><br><span class="line">  &#125;,</span><br><span class="line">  (target, property) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Get '<span class="subst">$&#123;property&#125;</span>' = <span class="subst">$&#123;target[property]&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">p.a = <span class="number">2</span> <span class="comment">// bind `value` to `2`</span></span><br><span class="line">p.a <span class="comment">// -&gt; Get 'a' = 2</span></span><br></pre></td></tr></table></figure><h4 id="路由原理"><a href="#路由原理" class="headerlink" title="路由原理"></a>路由原理</h4><p>前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的页面，并且无须刷新。目前单页面使用的路由就只有两种实现方式</p><ul><li>hash 模式</li><li>history 模式</li></ul><p><a href="http://www.text.com/##/">www.text.com/##/</a> 就是 Hash URL ，当 ## 后面的 哈希值发生变化的时候，不会向服务器请求数据，可以通过 hashchaneg 事件来监听到 URL 的变化，从而进行跳转页面。</p><p><img src="http://user-gold-cdn.xitu.io/2018/7/11/164888109d57995f?w=942&amp;h=493&amp;f=png&amp;s=39581" alt="hash 模式"></p><p>History 模式是 HTML5 新推出的功能，比之 Hash URL 更加美观</p><p><img src="http://user-gold-cdn.xitu.io/2018/7/11/164888478584a217?w=1244&amp;h=585&amp;f=png&amp;s=59637" alt="History 模式"></p><h3 id="Virtual-Dom"><a href="#Virtual-Dom" class="headerlink" title="Virtual Dom"></a>Virtual Dom</h3><h4 id="为什么需要-Virtual-Dom"><a href="#为什么需要-Virtual-Dom" class="headerlink" title="为什么需要 Virtual Dom"></a>为什么需要 Virtual Dom</h4><p>操作 DOM 是一件很耗费性能的事情，可以通过 JS 对象来模拟 DOM 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ul = &#123;</span><br><span class="line">    tag:<span class="string">'ul'</span>,</span><br><span class="line">    props:&#123;</span><br><span class="line">        class:'list'</span><br><span class="line">    &#125;,</span><br><span class="line">    children:&#123;</span><br><span class="line">        tag:<span class="string">'li'</span>,</span><br><span class="line">        children:<span class="string">'1'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line"><span class="comment">/** &lt;ul class='list'&gt;</span></span><br><span class="line"><span class="comment">  &lt;li&gt;1&lt;/li&gt;</span></span><br><span class="line"><span class="comment">&lt;/ul&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设这里模拟一个 ul，其中包含了 5 个 li</span></span><br><span class="line">;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>][</span><br><span class="line">  <span class="comment">// 这里替换上面的 li</span></span><br><span class="line">  (<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>从上述例子中，我们一眼就可以看出先前的 ul 中的第三个 li 被移除了，四五替换了位置。</p><p>如果以上操作对应到 DOM 中，那么就是以下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除第三个 li</span></span><br><span class="line">ul.childNodes[<span class="number">2</span>].remove()</span><br><span class="line"><span class="comment">// 将第四个 li 和第五个交换位置</span></span><br><span class="line"><span class="keyword">let</span> fromNode = ul.childNodes[<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> toNode = node.childNodes[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> cloneFromNode = fromNode.cloneNode(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">let</span> cloenToNode = toNode.cloneNode(<span class="literal">true</span>)</span><br><span class="line">ul.replaceChild(cloneFromNode, toNode)</span><br><span class="line">ul.replaceChild(cloenToNode, fromNode)</span><br></pre></td></tr></table></figure><p>当然在实际操作中，我们还需要给每个节点一个标识，作为判断是同一个节点的依据。所以这也是 Vue 和 React 中官方推荐列表里的节点使用唯一的 <code>key</code> 来保证性能。</p><p>那么既然 DOM 对象可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM</p><p>以下是一个 JS 对象模拟 DOM 对象的简单实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * @param &#123;String&#125; tag 'div'</span></span><br><span class="line"><span class="comment">  * @param &#123;Object&#125; props &#123;class:'item'&#125;</span></span><br><span class="line"><span class="comment">  * @param &#123;Array&#125; child [Element1,'text]</span></span><br><span class="line"><span class="comment">  * @param &#123;String&#125; key option</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">constructor</span>(tag, props, children, key) &#123;</span><br><span class="line">    <span class="keyword">this</span>.tag = tag;</span><br><span class="line">    <span class="keyword">this</span>.props = props;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.children = children;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isString(children)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.key = children;</span><br><span class="line">      <span class="keyword">this</span>.children = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key) <span class="keyword">this</span>.key = key;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 渲染</span></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">let</span> root = <span class="keyword">this</span>._createElement(</span><br><span class="line">      <span class="keyword">this</span>.tag,</span><br><span class="line">      <span class="keyword">this</span>.props,</span><br><span class="line">      <span class="keyword">this</span>.children,</span><br><span class="line">      <span class="keyword">this</span>.key</span><br><span class="line">    )</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(root)</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br><span class="line">  create() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._createElement(<span class="keyword">this</span>.tag, <span class="keyword">this</span>.props, <span class="keyword">this</span>.children, <span class="keyword">this</span>.key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建节点</span></span><br><span class="line">  _createElement(tag, props, child, key) &#123;</span><br><span class="line">    <span class="comment">// 通过 tag 创建节点</span></span><br><span class="line">    <span class="keyword">let</span> el = <span class="built_in">document</span>.createElement(tag);</span><br><span class="line">    <span class="comment">// 设置节点属性</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> props) &#123;</span><br><span class="line">      <span class="keyword">if</span> (props.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="keyword">const</span> value = props[key];</span><br><span class="line">        el.setAttribute(key, value);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key) &#123;</span><br><span class="line">      el.setAttribute(<span class="string">'key'</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归添加子节点</span></span><br><span class="line">    <span class="keyword">if</span> (child) &#123;</span><br><span class="line">      child.forEach(<span class="function"><span class="params">elememt</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> child;</span><br><span class="line">        <span class="keyword">if</span> (element <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">          child = <span class="keyword">this</span>._createElement(</span><br><span class="line">            elememt.tag,</span><br><span class="line">            elememt.props,</span><br><span class="line">            elememt.children,</span><br><span class="line">            elememt.key</span><br><span class="line">          )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          child = <span class="built_in">document</span>.createTextNode(elememt)</span><br><span class="line">        &#125;</span><br><span class="line">        el.appendChild(child)</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> el;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Virtual-Dom-算法简述"><a href="#Virtual-Dom-算法简述" class="headerlink" title="Virtual Dom 算法简述"></a>Virtual Dom 算法简述</h4><p>DOM 是多叉树结构，如果需要完整的对比两棵树的差异，那么需要的时间复杂度是 O(n ^ 3)。React 团队优化了算法，实现了  O(n) 的复杂度来对比差异。</p><p>关键在于只是对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少回去跨层移动 DOM 元素。</p><p>判断差异算法分成了两步</p><ul><li>首先从上到下，从左到右遍历对象，要就是树的深度遍历，这一步会给每个节点添加索引，便于后面渲染差异</li><li>一旦节点有子元素，就去判断子元素是否有不同</li></ul><h4 id="Virtual-Dom-算法实现"><a href="#Virtual-Dom-算法实现" class="headerlink" title="Virtual Dom 算法实现"></a>Virtual Dom 算法实现</h4><p><strong>树的递归</strong></p><p>首先实现树的递归遍历，在实现该算法前，考虑两个节点对比出现的几种情况：</p><ol><li>新的节点 tagName 或者 key 和旧的不同，这种情况代表需要替换旧的节点，并也不再需要遍历新旧子元素了，因为整个旧节点都被删除掉了。</li><li>新的节点的 tagName 和 key （可能都没有）和旧的相同，开始遍历子树</li><li>没有新的节点，那么什么都不用做</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; StateEnums, isString, move &#125; <span class="keyword">from</span> <span class="string">'./util'</span></span><br><span class="line"><span class="keyword">import</span> Element <span class="keyword">from</span> <span class="string">'./element'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">diff</span>(<span class="params">oldDomTree, newDomTree</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用于记录差异</span></span><br><span class="line">  <span class="keyword">let</span> pathchs = &#123;&#125;;</span><br><span class="line">  <span class="comment">// 一开始的索引为0</span></span><br><span class="line">  dfs(oldDomTree, newDomTree, <span class="number">0</span>, pathchs)</span><br><span class="line">  <span class="keyword">return</span> pathchs</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">oldNode, newNode, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用于保存子树的更改</span></span><br><span class="line">  <span class="keyword">let</span> curPatches = [];</span><br><span class="line">  <span class="comment">// 需要判断三种情况：</span></span><br><span class="line">  <span class="comment">// 1.没有新的节点，那么什么都不做</span></span><br><span class="line">  <span class="comment">// 2.新的节点的 tagName 和 key（可能都没有）和旧的相同，开始遍历子树</span></span><br><span class="line">  <span class="comment">// 3.没有新的节点，那么什么都不用做</span></span><br><span class="line">  <span class="keyword">if</span> (!newNode) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newNode.tag === oldNode.tag &amp;&amp; newNode.key === oldNode.key) &#123;</span><br><span class="line">    <span class="comment">// 判断属性是否变更</span></span><br><span class="line">    <span class="keyword">let</span> props = diffProps(oldNode.props, newNode.props)</span><br><span class="line">    <span class="keyword">if</span> (props.length) curPatches.push(&#123; <span class="attr">type</span>: StateEnums.ChangeProps, props &#125;)</span><br><span class="line">    <span class="comment">// 遍历子树</span></span><br><span class="line">    diffChildren(oldNode.children, newNode.children, index, patches)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 节点不同，需要替换</span></span><br><span class="line">    curPatches.push(&#123; <span class="attr">type</span>: StateEnums.Replace, <span class="attr">node</span>: newNode &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (curPatches.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (patches[index]) &#123;</span><br><span class="line">      patches[index] = patches[index].concat(curPatches)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      patches[index] = curPatches;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断属性的更改</strong></p><p>判断属性的更改也分成三个步骤</p><ol><li>遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中</li><li>遍历新的属性列表，判断两个列表中都存在的属性的值是否存在变化</li><li>在第二步中同时查看是否有属性不存在与旧的属性列列表中</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffProps</span>(<span class="params">oldProps, newProps</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> change = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldProps.hasOwnProperty(key) &amp;&amp; !newProps[key]) &#123;</span><br><span class="line">      change.push(&#123; <span class="attr">prop</span>: key &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newProps.hasOwnProperty(key)) &#123;</span><br><span class="line">      <span class="keyword">const</span> prop = newProps[key];</span><br><span class="line">      <span class="keyword">if</span> (oldProps[key] &amp;&amp; oldProps[key] !== newProps[key]) &#123;</span><br><span class="line">        change.push(&#123;</span><br><span class="line">          prop: key,</span><br><span class="line">          value: newProps[key]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!oldProps[key]) &#123;</span><br><span class="line">        change.push(&#123;</span><br><span class="line">          prop: key,</span><br><span class="line">          value: newProps[key]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> change;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断列表差异算法实现</strong></p><p>整个 Virtual Dom 中最核心的算法，这里的主要步骤其实和判断属性差异是类似的，也是分成三个步骤：</p><ol><li>遍历旧的节点列表，查看每个节点是否还存在新的节点列表中</li><li>遍历新的节点列表，判断是否有新的节点</li><li>在第二步中同时判断节点是否有移动</li></ol><p>该算法只对有 key 的节点做处理</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listDiff</span>(<span class="params">oldList, newList, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 为了遍历方便，先取出两个 list 中所有的 keys</span></span><br><span class="line">  <span class="keyword">let</span> oldKeys = getKeys(oldList);</span><br><span class="line">  <span class="keyword">let</span> newKeys = getKeys(newList);</span><br><span class="line">  <span class="keyword">let</span> changes = [];</span><br><span class="line">  <span class="comment">// 用于保存变更后的节点数据，使用该数组保存有以下好处，</span></span><br><span class="line">  <span class="comment">// 1.可以正确获取被删除节点索引</span></span><br><span class="line">  <span class="comment">// 2.交换位置只需要操作一遍 dom</span></span><br><span class="line">  <span class="comment">// 3.用于 diffChildren 函数中的判断，只需要遍历</span></span><br><span class="line">  <span class="comment">// 两个树中都存在的节点，对于新增或者删除的节点来说，完全没有必要再去判断一次</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> list = [];</span><br><span class="line">  oldList &amp;&amp; oldList.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> key = item.key;</span><br><span class="line">    <span class="keyword">if</span> (isString(item)) &#123;</span><br><span class="line">      key = item</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻找新的 children 中是否含有当前节点，没有的话需要删除</span></span><br><span class="line">    <span class="keyword">let</span> index = newKeys.indexOf(key);</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">-1</span>) &#123;</span><br><span class="line">      list.push(<span class="literal">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      list.push(key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 遍历变更后的数组</span></span><br><span class="line">  <span class="keyword">let</span> length = list.length;</span><br><span class="line">  <span class="comment">// 因为删除数组元素是会更改索引的，所以从后往前删可以保证索引不变</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="comment">// 判断当前元素是否为空，为空则表示要删除</span></span><br><span class="line">    <span class="keyword">if</span> (!list[i]) &#123;</span><br><span class="line">      list.splice(i, <span class="number">1</span>)</span><br><span class="line">      changes.push(&#123; <span class="attr">type</span>: StateEnums.Remove, <span class="attr">index</span>: i &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历新的list 判断是否节点新增或者是移动，同时也对 list 做节点的新增或者是移动</span></span><br><span class="line">  newList &amp;&amp; newList.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> key = item.key;</span><br><span class="line">    <span class="keyword">if</span> (isString(item)) &#123;</span><br><span class="line">      key = item</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 寻找旧的 children 中是否含有当前节点，没有的话需要插入</span></span><br><span class="line">    <span class="keyword">let</span> index = list.indexOf(key);</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">-1</span> || index == <span class="literal">null</span>) &#123;</span><br><span class="line">      changes.push(&#123; <span class="attr">type</span>: StateEnums.Insert, <span class="attr">node</span>: item, <span class="attr">index</span>: i &#125;);</span><br><span class="line">      list.splice(i, <span class="number">0</span>, key)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 找到了，需要判断是否需要移动</span></span><br><span class="line">      <span class="keyword">if</span> (index !== i) &#123;</span><br><span class="line">        changes.push(&#123; <span class="attr">type</span>: StateEnums.Move, <span class="attr">from</span>: index, <span class="attr">to</span>: i &#125;);</span><br><span class="line">        move(list, index, i)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    changes, list</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getKeys</span>(<span class="params">list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = [];</span><br><span class="line">  <span class="keyword">let</span> text;</span><br><span class="line">  list &amp;&amp; list.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> key;</span><br><span class="line">    <span class="keyword">if</span> (isString(item)) &#123;</span><br><span class="line">      key = [item]</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">      key = item.key;</span><br><span class="line">    &#125;</span><br><span class="line">    keys.push(key)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> keys</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>遍历子元素打标识</strong></p><p>对于整个函数来说，主要的功能就两个</p><ol><li>判断两个列表差异</li><li>给节点打上标记</li></ol><p>总体来说，该函数的实现很简单</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffChildren</span>(<span class="params">oldChild, newChild, index, patches</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; changes, list &#125; = listDiff(oldChild, newChild, index, patches)</span><br><span class="line">  <span class="keyword">if</span> (changes.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (patches[index]) &#123;</span><br><span class="line">      patches[index] = patches[index].concat(changes)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      patches[index] = changes;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 记录上一次遍历过的节点</span></span><br><span class="line">  <span class="keyword">let</span> last = <span class="literal">null</span>;</span><br><span class="line">  oldChild &amp;&amp; oldChild.forEach(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> child = item &amp;&amp; item.children;</span><br><span class="line">    <span class="keyword">if</span> (child) &#123;</span><br><span class="line">      index = last &amp;&amp; last.children ? index + last.children.length + <span class="number">1</span> : index + <span class="number">1</span></span><br><span class="line">      <span class="keyword">let</span> keyIndex = list.indexOf(item.key);</span><br><span class="line">      <span class="keyword">let</span> node = newChild[keyIndex];</span><br><span class="line">      <span class="comment">// 只遍历新旧节点都存在的节点，其他新增或者删除的没有必要遍历</span></span><br><span class="line">      <span class="keyword">if</span> (node) &#123;</span><br><span class="line">        dfs(item, node, index, patches)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      index += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    last = item;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>渲染差异</strong></p><p>通过之前的算法，我们已经可以得出两个树的差异了。既然知道了差异，就需要局部去更新 DOM 了，下面就让我们来看看 Virtual Dom 算法的最后一步骤</p><p>这个函数主要两个功能</p><ol><li>深度遍历树，将需要做变更操作的取出来</li><li>局部更新 DOM</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span>(<span class="params">node, patchs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> changes = patchs[index]</span><br><span class="line">  <span class="keyword">let</span> childNodes = node &amp;&amp; node.childNodes</span><br><span class="line">  <span class="comment">// 这里的深度遍历和 diff 中是一样的</span></span><br><span class="line">  <span class="keyword">if</span> (!childNodes) index += <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> (changes &amp;&amp; changes.length &amp;&amp; patchs[index]) &#123;</span><br><span class="line">    changeDom(node, changes)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> last = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (childNodes &amp;&amp; childNodes.length) &#123;</span><br><span class="line">    childNodes.forEach(<span class="function">(<span class="params">item, i</span>) =&gt;</span> &#123;</span><br><span class="line">      index =</span><br><span class="line">        last &amp;&amp; last.children ? index + last.children.length + <span class="number">1</span> : index + <span class="number">1</span></span><br><span class="line">      patch(item, patchs)</span><br><span class="line">      last = item</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeDom</span>(<span class="params">node, changes, noChild</span>) </span>&#123;</span><br><span class="line">  changes &amp;&amp;</span><br><span class="line">    changes.forEach(<span class="function"><span class="params">change</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> &#123; type &#125; = change</span><br><span class="line">      <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> StateEnums.ChangeProps:</span><br><span class="line">          <span class="keyword">let</span> &#123; props &#125; = change</span><br><span class="line">          props.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.value) &#123;</span><br><span class="line">              node.setAttribute(item.prop, item.value)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              node.removeAttribute(item.prop)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> StateEnums.Remove:</span><br><span class="line">          node.childNodes[change.index].remove()</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> StateEnums.Insert:</span><br><span class="line">          <span class="keyword">let</span> dom</span><br><span class="line">          <span class="keyword">if</span> (isString(change.node)) &#123;</span><br><span class="line">            dom = <span class="built_in">document</span>.createTextNode(change.node)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (change.node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            dom = change.node.create()</span><br><span class="line">          &#125;</span><br><span class="line">          node.insertBefore(dom, node.childNodes[change.index])</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> StateEnums.Replace:</span><br><span class="line">          node.parentNode.replaceChild(change.node.create(), node)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">case</span> StateEnums.Move:</span><br><span class="line">          <span class="keyword">let</span> fromNode = node.childNodes[change.from]</span><br><span class="line">          <span class="keyword">let</span> toNode = node.childNodes[change.to]</span><br><span class="line">          <span class="keyword">let</span> cloneFromNode = fromNode.cloneNode(<span class="literal">true</span>)</span><br><span class="line">          <span class="keyword">let</span> cloenToNode = toNode.cloneNode(<span class="literal">true</span>)</span><br><span class="line">          node.replaceChild(cloneFromNode, toNode)</span><br><span class="line">          node.replaceChild(cloenToNode, fromNode)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>Virtul Dom 算法的实现也是下面三个步骤：</p><ol><li>通过JS 来模拟创建 DOM 对象</li><li>判断两个对象的差异</li><li>渲染差异</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test4 = <span class="keyword">new</span> Element(<span class="string">'div'</span>, &#123; <span class="attr">class</span>: <span class="string">'my-div'</span> &#125;, [<span class="string">'test4'</span>])</span><br><span class="line"><span class="keyword">let</span> test5 = <span class="keyword">new</span> Element(<span class="string">'ul'</span>, &#123; <span class="attr">class</span>: <span class="string">'my-div'</span> &#125;, [<span class="string">'test5'</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test1 = <span class="keyword">new</span> Element(<span class="string">'div'</span>, &#123; <span class="attr">class</span>: <span class="string">'my-div'</span> &#125;, [test4])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test2 = <span class="keyword">new</span> Element(<span class="string">'div'</span>, &#123; <span class="attr">id</span>: <span class="string">'11'</span> &#125;, [test5, test4])</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> root = test1.render()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pathchs = diff(test1, test2)</span><br><span class="line"><span class="built_in">console</span>.log(pathchs)</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'开始更新'</span>)</span><br><span class="line">  patch(root, pathchs)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'结束更新'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><p>涉及的面试题目：前端路由原理，两种实现方式有什么区别？</p><p>前端路由实现起来不难，本质就是监听 URL 的变化，然后匹配路由规则，显示对应的页面，并且无须刷新页面，目前前端使用的路由大概有两种方式：</p><ul><li>hash 模式</li><li>History 模式</li></ul><h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p><code>www.test.com/#/</code> 就是 Hash URL，当 <code>#</code> 后面的哈希值发生变化时，可以通过 <code>hashchange</code> 事件来监听到 URL 的变化，从而进行跳转页面，并且无论哈希值如何变化，服务端接收到的 URL 请求永远是 <code>www.test.com</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'haschange'</span>,()=&gt;&#123;</span><br><span class="line">    <span class="comment">// 具体逻辑...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Hash 模式相对简单，并且兼容性更好</p><h4 id="History"><a href="#History" class="headerlink" title="History"></a>History</h4><p>History 模式 是 HTML5 推出的新功能，主要使用 history.pushState 和 history.replaceState 改变 URL。</p><p>通过 History 模式改变 URL 同样不会引起浏览器的刷新，只会更新浏览器的历史记录</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新增历史记录</span></span><br><span class="line">history.pushState(stateObj,title,URL);</span><br><span class="line"><span class="comment">// 替换当前的历史记录</span></span><br><span class="line">history.replaceState(stateObj,title,URL);</span><br></pre></td></tr></table></figure><p>当用户做出浏览器动作的时候，比如点击后退按钮会触发 popState 事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>,e=&gt;&#123;</span><br><span class="line">    <span class="comment">// e.state 就是 push(stateObject) 中的 stateObject</span></span><br><span class="line">    <span class="built_in">console</span>.log(e.state);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="两种模式对比"><a href="#两种模式对比" class="headerlink" title="两种模式对比"></a>两种模式对比</h4><ul><li>Hash 模式只可以更改 # 号后面的内容。History 模式可以通过 API 设置任意的同源的 URL</li><li>History 模式可以通过 API 添加任意的数据到历史记录中，Hash 模式只能更改哈希值，也就是字符串</li><li>Hash 模式无需后置配置，并且兼容性好。History 模式在用户输入地址或者刷新页面的时候会发起 URL 请求，后端需要配置 index.html 用于匹配不到静态资源的时候</li></ul><h3 id="Vue-常考的基本知识点"><a href="#Vue-常考的基本知识点" class="headerlink" title="Vue 常考的基本知识点"></a>Vue 常考的基本知识点</h3><h4 id="声明周期钩子函数"><a href="#声明周期钩子函数" class="headerlink" title="声明周期钩子函数"></a>声明周期钩子函数</h4><p>在 beforeCreate 钩子函数使用的时候，是获取不到 props 或者 data中的数据的，因为这些数据都在 initState 中</p><p>然后会执行 created 钩子函数，这一步可以访问到之前不能访问到的数据，但是这时候，组件还没有被挂载。</p><p>beforeMount 钩子函数，开始构建 VDOM，最后执行 mounted 钩子函数，并将 VDOM 渲染为真实的 DOM 并且渲染数据。组件中如果有子组件的话，会递归挂载子组件，只有当所有组件全部挂载完毕，才会执行根组件的挂载钩子。</p><p>数据更新时会调用钩子函数 beforeUpdate 和 updated ，分别是在数据更新前后会调用</p><p>keep-alive 独有的生命周期，activated 和 deactivated。用 keep-alive 包裹的组件切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数,命中缓存渲染后会执行 atived 钩子函数</p><p>最后就是销毁组件的钩子函数 beforeDestory 和 destroyed .前者适合移除事件、定时器等等，否则可能会引起内存泄露的问题，然后进行一系列的销操作，如果有子组件的话，也会递归销毁子组件，所有子组件都销毁完毕之后才会执行根组件的 destroyed 钩子函数</p><h4 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h4><p>一般有一下几种情况</p><ul><li>父子组件</li><li>兄弟组件</li><li>跨多层次组件</li><li>任意组件</li></ul><h4 id="父子组件通信"><a href="#父子组件通信" class="headerlink" title="父子组件通信"></a>父子组件通信</h4><p>父组件通过 props 传递给子组件，子组件通过 emit 发送事件传递数据给父组件，这两种方式是常用的父子通信实现方法</p><p>这种父子组件就是典型的单向数据流，父组件通过 props 传递数据，子组件不能直接修改 props,而是必须通过发送事件的方式告知父组件修改数据。</p><p>另外这两种方式还可以使用语法糖 v-model 来直接实现，因为 v-model 会解析成名为  value 的 prop 和 input 的事件。这种语法糖的方式是典型的双向绑定，常用于  UI控件上面，但是根本上还是通过事件的方法来让父组件修改数据。</p><p>还可以通过 \$parent 或者是 \$children 对象来访问组件实例中方法和数据。</p><p>另外使用 Vue2.3 以上的版本还可以使用 \$ listeners 和 .sycn 两个属性</p><p>\$ listeners 属性会将父组件中（不含 .native 修饰器的）v-on 事件监听器传递给子组件，子组件可以通过访问 \$listeners 来自定义监听器</p><p>.sync 属性是语法糖，可以很简单实现子组件和父组件的通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--父组件中---&gt;</span><br><span class="line">&lt;input :value.sync=&quot;value&quot;&gt;</span><br><span class="line">&lt;!--上面写法等同于--&gt;</span><br><span class="line">&lt;input :value=&quot;value&quot; @update:value=&quot;v=&gt;value=v&quot;&gt;&lt;/comp&gt;</span><br><span class="line">&lt;!--子组件中--&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    this.$emit(&apos;update:value&apos;,1)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="兄弟组件通信"><a href="#兄弟组件通信" class="headerlink" title="兄弟组件通信"></a>兄弟组件通信</h4><p>可以通过查找父组件中的子组件的实现，就是 <code>this.$parent.$children</code> 在 <code>$children</code>中可以通过 name 查询到需要的组件实例，然后进行通信</p><h4 id="跨多层组件通信"><a href="#跨多层组件通信" class="headerlink" title="跨多层组件通信"></a>跨多层组件通信</h4><p>可以使用 Vue2.2 新增的 API provide/inject ，虽然在文档中不支持使用在业务中，但是如果用得好的话还是有用的</p><p>假设有父组件 A 然后有一个跨多层级的子组件B</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件A</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    provide:&#123;</span><br><span class="line">        data:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子组件 B</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    inject:[<span class="string">'data'</span>],</span><br><span class="line">    mounted()&#123;</span><br><span class="line">        <span class="comment">// 无论跨几层都能获取到父组件的 data 属性</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.data); <span class="comment">//=&gt;1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="任意组件"><a href="#任意组件" class="headerlink" title="任意组件"></a>任意组件</h4><p>这种方式可以通过 Vuex 或者 Event Bus 解决，另外如果不怕麻烦的话，可以使用这种方式来解决上述的所有通信情况</p><h4 id="extend-能做什么"><a href="#extend-能做什么" class="headerlink" title="extend 能做什么"></a>extend 能做什么</h4><p>作用是扩展㢟生成一个构造器，通常会与 <code>$mount</code>一起使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建组件构造器</span></span><br><span class="line"><span class="keyword">let</span> Component = Vue.extend(&#123;</span><br><span class="line">    template:<span class="string">'&lt;div&gt;test&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 挂载到 #app 上</span></span><br><span class="line"><span class="keyword">new</span>.Component().$mount(<span class="string">'#app'</span>);</span><br><span class="line"><span class="comment">// 除了上面方式还可以来扩展原来的组件</span></span><br><span class="line"><span class="keyword">let</span> SuperComponent = Vue.extend(Component)</span><br><span class="line"><span class="keyword">new</span> SuperComponent(&#123;</span><br><span class="line">    created()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">new</span> SuperComponent().$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><h4 id="mixin-和-mixins-的区别"><a href="#mixin-和-mixins-的区别" class="headerlink" title="mixin 和 mixins 的区别"></a>mixin 和 mixins 的区别</h4><p>mixin 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">    beforeCreate()&#123;</span><br><span class="line">        <span class="comment">// 逻辑，这种方式会影响到所有组件的 beforeCreate 钩子函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>文档不建议直接在应用中使用 mixin ，但是不滥用的话，可以全局混入装好的 ajax 或者一些工具函数等等</p><p>mixins 应该是我们最常使用的扩展组件的方式了，如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混入代码，比如上拉下拉加载数据这种等等。</p><p>另外要注意的是 mixins 混入的钩子函数会先于组件的钩子函数执行，并且在晕倒同名选项的时候也会有选择性的进行合并。</p><h4 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="headerlink" title="computed 和 watch 的区别"></a>computed 和 watch 的区别</h4><p>computed 是计算属性，依赖其他属性来计算，并且 computed 的值有缓存，只有当值变化才会返回内容。</p><p>watch 监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</p><p>所以一般来说需要依赖别的属性来动态获得值的时候就可以使用 computed ，对于监听到值的变化需要做的一些复杂业务逻辑的时候可以使用 watch</p><p>另外这两者都支持对象的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vm.$watch(<span class="string">'obj'</span>,&#123;</span><br><span class="line">    <span class="comment">// 深度遍历</span></span><br><span class="line">    deep:<span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 立即触发</span></span><br><span class="line">    immediate:<span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 执行函数</span></span><br><span class="line">    handler:<span class="function"><span class="keyword">function</span>(<span class="params">val,oldVal</span>)</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    data:&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line">        aPlus:&#123;</span><br><span class="line">            <span class="comment">// this.aPlus 的时候触发</span></span><br><span class="line">            get:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// this.aPlus = 1时触发</span></span><br><span class="line">            set:<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.a = v - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="keep-alive组件的作用"><a href="#keep-alive组件的作用" class="headerlink" title="keep-alive组件的作用"></a>keep-alive组件的作用</h4><p>需要需要在组件切换时，保存一些组件的状态防止多次渲染，可以使用 keep-alive 组件包裹需要保存的组件</p><p>对于 keep-alive 组件来说，它拥有两个独有的声明周期函数，分别是  activated 和 deactivated ，用 keep-alive 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 deactivated 钩子函数，命中缓存渲染后会执行 actived 钩子函数</p><h4 id="v-show-和-v-if-的区别"><a href="#v-show-和-v-if-的区别" class="headerlink" title="v-show 和 v-if 的区别"></a>v-show 和 v-if 的区别</h4><p>v-show 只是在 display：none 和 display：block 之间切换。无论初始条件是什么都会被渲染出来，后面只需要切换 CSS，DOM 还是一直保留的，所以总的来说，v-show 在初始渲染有更高的开销，但是切换开销小，更适合于频繁切换的场景</p><p>v-if 的话就涉及 Vue 底层的编译，当属性初始为 false，组件就不会被渲染，直到条件为 true，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换开销更高，更适合不经常切换的场景，并且基于 v-if 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个页面的初始渲染开销。</p><h4 id="组件中-data-什么时候可以使用对象"><a href="#组件中-data-什么时候可以使用对象" class="headerlink" title="组件中 data 什么时候可以使用对象"></a>组件中 data 什么时候可以使用对象</h4><p>组件复用时所有的实例都会共享 data ，如果data 是对象的话，就会造成一个组件修改 data 之后会影响到其他所有的组件，所以我们需要将 data 写成函数，每次用到就调用一次函数来获得新的数据</p><p>当我们使用 new Vue() 的方式的时候，无论我们将 data 设置为对象还是函数都是可以的，因为 new Vue（） 的方式是生成一个根组件，也就不存在共享 data 的情况了。</p><h4 id="进阶知识点"><a href="#进阶知识点" class="headerlink" title="进阶知识点"></a>进阶知识点</h4><h4 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h4><p>Vue 内部使用了 Object.defineProperty() 来实现数据响应式，通过函数可以监听到 set 和 get 事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">name</span>: <span class="string">'lbh'</span> &#125;</span><br><span class="line">observe(data);</span><br><span class="line"><span class="keyword">let</span> &#123; name &#125; = data;</span><br><span class="line">data.name = <span class="string">'haha'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 判断类型</span></span><br><span class="line">    <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">      defineReactive(obj, key, obj[key])</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  observe(val);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="comment">// 可枚举</span></span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 可配置</span></span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 自定义函数</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get val'</span>);</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'change val'</span>);</span><br><span class="line">      val = newVal;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码简单实现了如何监听数据的 set 和 get 事件，因为自定义函数一开始是不会执行的，只有先执行了依赖收集，才能在属性更新的时候派发更新，所以我们接下来需要先触发依赖收集</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    &#123;&#123;name&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在解析上面的模板代码时候，会遇到 <code></code>就会进行依赖收集</p><p>实现一个 Dep 类，用于解耦属性的依赖收集和派发更新操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加依赖</span></span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 更新</span></span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">      sub.update();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 全局属性，通过该属性配置 watcher</span></span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>当需要收集依赖的时候调用 addSub,当需要派发更新的时候调用 notify()</p><p>下面简单了解 Vue 组件挂载时添加响应式的过程。在组件挂载时，会先对所有需要的属性调用 Object.defineProperty(),然后实例化 Watcher，传入组件更新的回调，在实例化中，会对模板中的属性进行求值，触发依赖收集。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(obj, key, cb) &#123;</span><br><span class="line">    <span class="comment">// 将 Dep.target 指向自己，然后出发属性的 getter 添加监听，最后将 Dep.target 置空</span></span><br><span class="line">    Dep.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb;</span><br><span class="line">    <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = obj[value];</span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="comment">// 获得新值</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.obj[<span class="keyword">this</span>.key];</span><br><span class="line">    <span class="comment">// 调用 update 方法更新 Dom</span></span><br><span class="line">    <span class="keyword">this</span>.cb(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是 Wathcer 的简单实现，在执行构造函数的时候将 Dep.target 指向自身，从而使得收集到了对应的 Watcher,在派发更新的时候取出对应的 Watcher 然后执行 update 函数</p><p>接下来，需要对 defineReactive 函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归子属性</span></span><br><span class="line">  observe(val);</span><br><span class="line">  <span class="keyword">let</span> dp = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="comment">// 可枚举</span></span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 可配置</span></span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// 自定义函数</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'get val'</span>);</span><br><span class="line">      <span class="comment">// 将Watcher 添加到订阅中</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dp.addSub(Dep.target)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'change val'</span>);</span><br><span class="line">      val = newVal;</span><br><span class="line">      <span class="comment">// 执行 watcher 的 update 方法</span></span><br><span class="line">      dp.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码实现了一个简易的数据响应式，核心思路就是手动触发一次属性的 getter 来实现依赖收集。</p><p>测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">name</span>: <span class="string">'lbh'</span> &#125;</span><br><span class="line">observe(data)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">update</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>).innerText = value</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 模拟解析到 `&#123;&#123;name&#125;&#125;` 触发的操作</span></span><br><span class="line"><span class="keyword">new</span> Watcher(data, <span class="string">'name'</span>, update)</span><br><span class="line"><span class="comment">// update Dom innerText</span></span><br><span class="line">data.name = <span class="string">'haha'</span> </span><br><span class="line"><span class="comment">// get val</span></span><br><span class="line"><span class="comment">// change val</span></span><br><span class="line"><span class="comment">// get val</span></span><br></pre></td></tr></table></figure><h4 id="Object-defineProperty-的缺陷"><a href="#Object-defineProperty-的缺陷" class="headerlink" title="Object.defineProperty 的缺陷"></a>Object.defineProperty 的缺陷</h4><p>如果通过下标的方式修改数据或者给对象新增属性并不会触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作，更精确的来说，对于数组来说，大部分操作都是拦截不到的，只是 vue 内部通过重写函数的方式改写了这个问题。</p><p>Vue 提供了一个 API 解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">target: Array&lt;any&gt; | Object, key: any, val: any</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否为数组且下标是否有效</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    <span class="comment">// 调用 splice 函数触发派发更新</span></span><br><span class="line">    <span class="comment">// 该函数已被重写</span></span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">    target.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断 key 是否已经存在</span></span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = (target: any).__ob__</span><br><span class="line">  <span class="comment">// 如果对象不是响应式对象，就赋值返回</span></span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 进行双向绑定</span></span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  <span class="comment">// 手动派发更新</span></span><br><span class="line">  ob.dep.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于数组而言，Vue 内部重写了以下函数实现派发更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得数组原型</span></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"><span class="comment">// 重写以下函数</span></span><br><span class="line"><span class="keyword">const</span> methodsToPatch = [</span><br><span class="line">  <span class="string">'push'</span>,</span><br><span class="line">  <span class="string">'pop'</span>,</span><br><span class="line">  <span class="string">'shift'</span>,</span><br><span class="line">  <span class="string">'unshift'</span>,</span><br><span class="line">  <span class="string">'splice'</span>,</span><br><span class="line">  <span class="string">'sort'</span>,</span><br><span class="line">  <span class="string">'reverse'</span></span><br><span class="line">]</span><br><span class="line">methodsToPatch.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 缓存原生函数</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  <span class="comment">// 重写函数</span></span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 先调用原生函数获得结果</span></span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="keyword">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="keyword">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="comment">// 调用以下几个函数时，监听新数据</span></span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'push'</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'unshift'</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'splice'</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// 手动派发更新</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h4><p>Vue 会通过编译器将模板通过几个阶段最终编成为 render 函数，然后通过执行 render 函数生成 Virtual DOM 最终映射为真实 DOM </p><p>这个阶段分成三部分：</p><ol><li>将模板解析为 AST</li><li>优化 AST</li><li>将 AST 转换为 render 函数</li></ol><p>第一个阶段，通过正则表达式去匹配模板中的内容，然后将内容提取出来做各种逻辑操作，接着会生成一个基本的 AST 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    type：<span class="number">1</span>，</span><br><span class="line">    <span class="comment">// 标签</span></span><br><span class="line">    tag,</span><br><span class="line">    <span class="comment">// 属性列表</span></span><br><span class="line">    attrsList:attrs,</span><br><span class="line">    <span class="comment">// 属性映射</span></span><br><span class="line">    attrsMap:makeAttrsMap（attrs）,</span><br><span class="line">    <span class="comment">// 父节点</span></span><br><span class="line">    parent,</span><br><span class="line">    <span class="comment">// 子节点</span></span><br><span class="line">    children:[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后会根据这个最基本的 AST对象的属性，进一步扩展 AST</p><p>当然在这一阶段中，还会进行其他的一些判断逻辑。比如说对比前后开闭标签是否一致，判断根组件是否只存在一个，判断是否符合 HTML5 <a href="https://link.juejin.im/?target=https%3A%2F%2Fdeveloper.mozilla.org%2Fzh-CN%2Fdocs%2FWeb%2FGuide%2FHTML%2FContent_categories">Content Model</a> 规范等等问题。</p><p>优化 AST 阶段，对节点进行了静态内容提取，将永远不会变动的节点拿出来，实现复用 Virtual DOM,跳过对比算法的功能。</p><p>最后一个阶段，通过 AST 生成 render 函数，主要的目的是遍历整个 AST,根据不同的条件生成不同的代码</p><h4 id="NextTick-原理浅析"><a href="#NextTick-原理浅析" class="headerlink" title="NextTick 原理浅析"></a>NextTick 原理浅析</h4><p>nextTick 可以让我们在下次 DOM 更新循环结束之后执行延迟回调，用于获得更新后的 DOM</p><p>默认使用 microtasks，但是特殊情况下会使用 macrotasks，比如 v-on</p><p>对于实现 macrotasks，会先判断是否能使用 setImmediate，不能的话就降级为 MessageChannel，以上都不行的话就使用 setTimeout</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> MessageChannel !== <span class="string">'undefined'</span> &amp;&amp; (isNative(MessageChannel) || MessageChannel.toString() === <span class="string">'[object MessageChannelConstructor]'</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> channel = <span class="keyword">new</span> MessageChannel();</span><br><span class="line">  <span class="keyword">const</span> port = channel.port2;</span><br><span class="line">  channel.port1.onmessage = flushCallbacks;</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    port.postMessage(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  macroTimerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="React-常考的基本知识点"><a href="#React-常考的基本知识点" class="headerlink" title="React 常考的基本知识点"></a>React 常考的基本知识点</h3><h4 id="声明周期"><a href="#声明周期" class="headerlink" title="声明周期"></a>声明周期</h4><p>v16 版本中引入了 Fiber 机制，这个机制一定程度上影响了部分生命周期函数的调用，也引入了新的两个 API 来解决问题。<a href="http://www.ayqy.net/blog/dive-into-react-fiber/">关于 Fiber</a></p><p>之前版本的 react如果嵌套太多层，会导致调用栈过长，再加上复杂的操作，就可能导致长时间阻塞主线程，带来不好的用户体验。就类似潜水员，只有潜到底才会回到水面。而如果水面这时候发生了其他优先级更高的事情，也要等潜水员潜到底后再重新上来。</p><p>Fiber 就是为了解决这个问题而生的，它本质上是一个虚拟的堆栈帧，新的调度器hi根据优先级自由调用这些帧，从而将之前的同步渲染变成了异步渲染，在不影响体验的情况下去分段计算更新。</p><p>优先级的区别，对于动画这种优先性别很高的东西，16ms 必须渲染一次保证不卡顿的情况下，react 会每 16ms 以内暂停一次更新，返回来继续渲染动画。潜水员不再一直潜到底，而是潜到一定深度后在该点设置一个传送点后浮出水面，然后传回去传送点继续下潜。</p><p>对于异步渲染，有三个阶段：reconcliiation 和 commit ，前者过程是可以打断的，后者不能暂停，会一直更新界面直到完成。</p><p>Reconciliation 阶段</p><ul><li>componentWillMount</li><li>componentWillReceiveProps</li><li>shouldComponentUpdate</li><li>componentWillUpdate</li></ul><p>Commit 阶段</p><ul><li>componentDidMount</li><li>componentDidUpdate</li><li>componentWillUnmount</li></ul><p>因为前者是可以被打断的，所以 Reconciliation  阶段会执行的声明周期函数就可能会出现调用多次的情况，从而引起 bug。因此对于 Reconciliation 阶段调用的几个函数，除了 shouldComponentUpdate 之外，其他都应该避免去使用，并且 V16 中也引入了新的 API 来解决这个问题</p><p>getDerivedStateFromProps 用于替换 componentWillReciveProps，这个函数会在初始化和 update 时候被调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Initialize state in constructor,</span></span><br><span class="line">  <span class="comment">// Or with a property initializer.</span></span><br><span class="line">  state = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prevState.someMirroredValue !== nextProps.someValue) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        derivedData: computeDerivedState(nextProps),</span><br><span class="line">        someMirroredValue: nextProps.someValue</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return null to indicate no change to state.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getSnapshotBeforeUpdate</code> 用于替换 <code>componentWillUpdate</code> ，该函数会在 <code>update</code> 后 DOM 更新前被调用，用于读取最新的 DOM 数据。</p><h4 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h4><p>setState 是异步的，调用这个函数不会马上引起 state 的变化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">handle()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count); <span class="comment">// 0</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>:<span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>:<span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;<span class="attr">count</span>:<span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.count) <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码等同于下面</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(</span><br><span class="line">    &#123;&#125;,</span><br><span class="line">    &#123;<span class="attr">count</span>:<span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">count</span>:<span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">count</span>:<span class="keyword">this</span>.state.count+<span class="number">1</span>&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以通过下面的方式来实现我们原来的目的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handle()&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>)=&gt;</span>(&#123;<span class="attr">count</span>:prevState.state.count+<span class="number">1</span>&#125;));</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>)=&gt;</span>(&#123;<span class="attr">count</span>:prevState.state.count+<span class="number">1</span>&#125;));</span><br><span class="line">    <span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState</span>)=&gt;</span>(&#123;<span class="attr">count</span>:prevState.state.count+<span class="number">1</span>&#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每次 setState 后取得正确的 state，可以这样实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">handle()&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState((prevState)=&gt;(&#123;count:prevState.count+<span class="number">1</span>&#125;),()=&gt;&#123;</span><br><span class="line">        console.log(<span class="keyword">this</span>.state);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p>在 <code>shouldComponentUpdate</code> 函数中我们可以通过返回布尔值来决定当前组件是否需要更新。</p><p>通过 immutable 或者 immer 这些库来生成不可变对象。这类库对于操作大规模的数据来说会提升不错的性能，并且一旦改变数据就会生成一个新的对象，对比前后 <code>state</code> 是否一致也就方便多了。</p><p>单纯的浅比较一下，可以直接使用 <code>PureComponent</code>，底层就是实现了浅比较 <code>state</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">PureComponent</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        PureComponent</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>V16 之后可以使用 React.memo 来实现相同的功能</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Test = React.memo(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        PureComponent</span><br><span class="line">      &lt;<span class="regexp">/div&gt;    </span></span><br><span class="line"><span class="regexp">&#125;)</span></span><br></pre></td></tr></table></figure><p>通过这种方式我们就可以既实现了 <code>shouldComponentUpdate</code> 的浅比较，又能够使用函数组件。</p><h4 id="组件通信-1"><a href="#组件通信-1" class="headerlink" title="组件通信"></a>组件通信</h4><p>同样的情况：</p><ul><li>父子组件</li><li>兄弟组件</li><li>跨多层次组件</li><li>任意组件</li></ul><h4 id="父子组件"><a href="#父子组件" class="headerlink" title="父子组件"></a>父子组件</h4><p>父组件通过 props 传递数据给子组件，子组件通过调用父组件传来函数传递给父组件，这两种方式是最常用的父子通信的方法。</p><p>这种父子通信方式也就是典型的单向数据流，父组件通过 props 传递数据，子组件不能直接修改 props,而是必须通过调用父组件函数的方式来告知父组件修改数据</p><h4 id="兄弟组件"><a href="#兄弟组件" class="headerlink" title="兄弟组件"></a>兄弟组件</h4><p>与这种情况可以通过共同的父组件来管理状态和事件函数。比如其中给一个兄弟组件调用父组件传递过来的事件函数修改父组件中的状态，然后父组件将状态传递给另一个兄弟组件</p><h4 id="跨多层次组件"><a href="#跨多层次组件" class="headerlink" title="跨多层次组件"></a>跨多层次组件</h4><p>使用 Context API</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Context，可以在开始就传入值</span></span><br><span class="line"><span class="keyword">const</span> StateContext = React.createContext();</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</span><br><span class="line">    render()&#123;</span><br><span class="line">        <span class="comment">// value 就是传入 Context 中的值</span></span><br><span class="line">        &lt;StateContext.Provider value=<span class="string">'haha'</span>&gt;</span><br><span class="line">            &lt;Child/&gt;</span><br><span class="line">        &lt;<span class="regexp">/StateContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Child extends React.Component&#123;</span></span><br><span class="line"><span class="regexp">    render()&#123;</span></span><br><span class="line"><span class="regexp">        return(</span></span><br><span class="line"><span class="regexp">            &lt;ThemeContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">                /</span><span class="regexp">/ 取出值</span></span><br><span class="line"><span class="regexp">                &#123;context=&gt;&#123;</span></span><br><span class="line"><span class="regexp">                    name is &#123;context&#125;</span></span><br><span class="line"><span class="regexp">                &#125;&#125;</span></span><br><span class="line"><span class="regexp">            &lt;/</span>ThemeContext.Consumer&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="任意组件-1"><a href="#任意组件-1" class="headerlink" title="任意组件"></a>任意组件</h4><p>这种方式可以通过 Redux、Mobx 等工具 或者 Event Bus 解决。</p><h4 id="HOC-是什么？相比-mixins-有什么优点"><a href="#HOC-是什么？相比-mixins-有什么优点" class="headerlink" title="HOC 是什么？相比 mixins 有什么优点"></a>HOC 是什么？相比 mixins 有什么优点</h4><p>例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给这个 add 函数添加一个输出结果的功能，实现优雅并且可以复用和扩展：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withLog</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">wrapper</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> result = fn(a,b);</span><br><span class="line">        <span class="built_in">console</span>.log(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> wrapper;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> withLogAdd = withLog(add);</span><br><span class="line">withLogAdd();</span><br></pre></td></tr></table></figure><p>这种做法在函数式编程里面被称为高阶函数。高阶组件和高阶函数就是同一个东西，实现一个函数，传入一个组件，然后在函数内部再实现一个函数切扩展传入的组件，最后返回一个新的组件，这就是高阶组件的概念，作用是为了更好的复用代码。</p><p>HOC 和 Vue 中的 mixins 作用是一致的，并且在早期的 React 也是使用 mixins 的方式。但是在使用 class 的方式创建组件以后，mixins 的方式就不能使用了，并且其实 mixins 也是存在一些问题的，比如：</p><ul><li>隐含了一些依赖，多人开发，我写了某个state 并且在 mixins 中使用了，这就存在一个依赖关系。其他人要移除就要去 mixins 里面查找依赖</li><li>多个 mixin 中可能存在同名的函数，会造成函数重写</li><li>雪球效应，一个mixin 被多个组件使用，会由于需求使得 mixin 变得臃肿。</li></ul><p>HOC 解决了这些问题，并且它们达成的效果也是一致的，同时也更加函数式了。</p><h4 id="事件机制-1"><a href="#事件机制-1" class="headerlink" title="事件机制"></a>事件机制</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Test = <span class="function">(<span class="params">&#123;list,handleClick&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    list.map(<span class="function">(<span class="params">item,index</span>)=&gt;</span>(</span><br><span class="line">        &lt;span onClick=&#123;handleClick&#125; key=&#123;index&#125;&gt;&#123;index&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    ))</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p>JSX 上写的事件并没有绑定在对应真实的 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在 document上，这样的方式不仅可以减少内存的损耗，还能在组件挂载时统一订阅和移除事件。</p><p>另外冒泡到  document 上的事件也不是原生的浏览器事件，而是 React自己实现的合成事件（SyntheticEvnet）。因此我们不想要事件冒泡的话，可以使用 event.preventDefault</p><p>合成事件的目的：</p><ul><li>抹平了浏览器之间的兼容问题，另外一个是跨浏览器原生事件包装器，赋予了跨浏览器开发的能力</li><li>对于原生浏览器来说，浏览器会给监听器创建一个事件对象，如果有很多事件监听就要分配很多事件对象会造成高额的内存分配问题。但是对于合成事件来说，有一个事件池专门来管理它们的创建和销毁，当事件需要被使用的时候，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下一次复用事件对象。</li></ul><h2 id="Webpack性能优化"><a href="#Webpack性能优化" class="headerlink" title="Webpack性能优化"></a>Webpack性能优化</h2><h3 id="减少webpack-打包时间"><a href="#减少webpack-打包时间" class="headerlink" title="减少webpack 打包时间"></a>减少webpack 打包时间</h3><h3 id="优化-loader"><a href="#优化-loader" class="headerlink" title="优化 loader"></a>优化 loader</h3><p>影响打包效率第一个必定是 babel，因为 babel hi将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，转换代码越多，效率越低。</p><p>可以优化 loader 的文件搜索范围</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules:&#123;</span><br><span class="line">            <span class="comment">// 只对 js 文件使用 babel</span></span><br><span class="line">            test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">            loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">            <span class="comment">// 只在 src 文件夹下查找</span></span><br><span class="line">            include:[resolve(<span class="string">'src'</span>)],</span><br><span class="line">            exclude:<span class="regexp">/node_module/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以将 babel 编译过的文件缓存起来，下次只需要编译更改过的代码文件就可以了,这样可以大幅度加快打包速度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loader:<span class="string">'babel-loader?cacheDirectory=true'</span></span><br></pre></td></tr></table></figure><h3 id="HappyPack"><a href="#HappyPack" class="headerlink" title="HappyPack"></a>HappyPack</h3><p>受限于 Node 是单线程的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。</p><p>HappyPack 可以将 loader 的同步执行转换为并行的，这样就可以充分利用系统的资源来加快打包效率了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    loaders:[&#123;</span><br><span class="line">        test:<span class="regexp">/\.js$/</span>,</span><br><span class="line">        include:[resolve(<span class="string">'src'</span>)],</span><br><span class="line">        exclude:<span class="regexp">/node_module/</span>,</span><br><span class="line">        <span class="comment">// id 后面的内容对应下面的</span></span><br><span class="line">        loader:<span class="string">'happypack/loader?id=happybabel'</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">plugins:[</span><br><span class="line">    <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">        id:<span class="string">'happybabel'</span></span><br><span class="line">    &#125;),</span><br><span class="line">    loaders:[<span class="string">'babel-loader?cacheDirectory'</span>],</span><br><span class="line">    <span class="comment">// 开启四个线程</span></span><br><span class="line">    threads:<span class="number">4</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="DllPlugin"><a href="#DllPlugin" class="headerlink" title="DllPlugin"></a>DllPlugin</h3><p>DllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要打包，并且也实现了将公告代码抽离出成单独文件的优化方案。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单独配置在一个文件中</span></span><br><span class="line"><span class="comment">// webpack.dll.conf.js</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">    enrty:&#123;</span><br><span class="line">        vendor:[<span class="string">'react'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> webpack.DllPlugin(&#123;</span><br><span class="line">            <span class="comment">// 与 output.library 一致</span></span><br><span class="line">            name:<span class="string">'[name]-[hash]'</span>,</span><br><span class="line">            <span class="comment">// 与 DllReferencePlugin 中一致</span></span><br><span class="line">            context:__dirname,</span><br><span class="line">            path:path.join(__dirname,<span class="string">'dist'</span>,<span class="string">'[name]-mainfest.json'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    ],</span><br><span class="line">    output:&#123;</span><br><span class="line">        path:path.join(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">        filename:<span class="string">'[name].dll.js'</span>,</span><br><span class="line">        library:<span class="string">'[name]-[hash]'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后运行这个配置文件生成依赖文件，使用 DllReferencePlugin 将依赖文件引入项目中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.conf.js</span></span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">    <span class="comment">// 省略其他配置</span></span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="keyword">new</span> webpack.DllReferencePlugin(&#123;</span><br><span class="line">            context:__dirname,</span><br><span class="line">            <span class="comment">// 之前打包出来的 json文件</span></span><br><span class="line">            mainfest:<span class="built_in">require</span>(<span class="string">'./dist/vendor-mainfest.json'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="减少webpack-打包后的体积"><a href="#减少webpack-打包后的体积" class="headerlink" title="减少webpack 打包后的体积"></a>减少webpack 打包后的体积</h3><p><strong>按需加载</strong></p><p>SPA 项目中都会存在十几甚至更多的路由页面。如果我们将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，我们肯定是希望首页能加载的文件体积越小越好，<strong>这时候我们就可以使用按需加载，将每个路由页面单独打包为一个文件</strong>。当然不仅仅路由可以按需加载，对于 <code>loadash</code> 这种大型类库同样可以使用这个功能。</p><p>底层的机制都是当使用的时候再去加载对应的文件，返回一个 Promis ，当 Promise 成功以后去执行回调</p><p><strong>Scope Hoisting</strong></p><p>Scope Hoisting 会分析出来模块之间的依赖关系，尽可能的把打包的模块合并到一个函数中去</p><p>比如打包两个文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;a&#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br></pre></td></tr></table></figure><p>打包出来的代码是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="comment">/* 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 1 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;    </span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>但是如果我们使用 Scope Hoisting 的话，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="comment">/* 0 */</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">module, exports, require</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>在webpack4 中只要启用 optimization.concatenateModules 就可以了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    optimization:&#123;</span><br><span class="line">        concatenateModules:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Tree Shaking</strong></p><p>Tree Shaking 可以实现删除项目中未被引用的代码，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> b = <span class="number">2</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; a &#125; <span class="keyword">from</span> <span class="string">'./test.js'</span></span><br></pre></td></tr></table></figure><p>对于以上情况，<code>test</code> 文件中的变量 <code>b</code> 如果没有在项目中使用到的话，就不会被打包到文件中。</p><p>如果你使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;温故而知新，保持空杯心态.续 &lt;a href=&quot;https://yuchengkai.cn/docs/frontend&quot;&gt;前端面试之道&lt;/a&gt;继续复习浏览器相关内容&lt;/p&gt;
&lt;h2 id=&quot;浏览器基础&quot;&gt;&lt;a href=&quot;#浏览器基础&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="前端面试" scheme="http://laibh.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端面试题" scheme="http://laibh.top/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>前端面试题目汇总摘录（JS 基础篇2）</title>
    <link href="http://laibh.top/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB%E6%91%98%E5%BD%95-JS%20%E5%9F%BA%E7%A1%80%E7%AF%872.html"/>
    <id>http://laibh.top/前端面试题目汇总摘录-JS 基础篇2.html</id>
    <published>2019-04-01T01:30:54.000Z</published>
    <updated>2019-10-15T09:29:49.419Z</updated>
    
    <content type="html"><![CDATA[<p>温故而知新，保持空杯心态,复习到一半的时间，突然发现了 <a href="https://yuchengkai.cn/docs/frontend">前端面试之道</a>，从第二道题目开始按学习这本书的路径来</p><h2 id="JS-基础2"><a href="#JS-基础2" class="headerlink" title="JS 基础2"></a>JS 基础2</h2><h3 id="React-Vue-项目时为什么要在组件中写-key，其作用是什么？"><a href="#React-Vue-项目时为什么要在组件中写-key，其作用是什么？" class="headerlink" title="React/Vue 项目时为什么要在组件中写 key，其作用是什么？"></a>React/Vue 项目时为什么要在组件中写 key，其作用是什么？</h3><blockquote><p>key是给每一个vnode的唯一id,可以<code>依靠key</code>,更<code>准确</code>, 更<code>快</code>的拿到oldVnode中对应的vnode节点。</p></blockquote><p>key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度。</p><p>Vue 和 React 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 中的 diff 函数，交叉对比中，当新节点跟旧节点 <code>头尾交叉对比</code>没有结果的时候，会根据新节点的 key 对比旧节点数组中的 key，从而找到对应旧节点。如果没有找到就认为是一个新增节点。而如果没有 key，那么就会采用遍历查找的方法找到对应的旧节点。。一种一个map 映射，另一种是遍历查找。相比之下，map 映射的速度更快。</p><p>vue 部分源码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// oldCh 是一个旧虚拟节点数组</span></span><br><span class="line"><span class="keyword">if</span>(isUndef(oldKeyToIdx))&#123;</span><br><span class="line">   oldKeyToIdx = createKeyToOldIdx(oldCh,oldStartIdx,oldEndIdx);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isDef(newStartVnode.key))&#123;</span><br><span class="line">   <span class="comment">// map 方式获取</span></span><br><span class="line">   idxInOld = oldKeyToIdx[newStartVnode.key]</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">// 遍历方式获取</span></span><br><span class="line">  idxInOld = findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 map 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createKeyToOldIdx</span>(<span class="params">children,beginIdx,endIdx</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i,key;</span><br><span class="line">    <span class="keyword">const</span> map = &#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span>(i = beginIdx;i &lt;= endIdx,++i)&#123;</span><br><span class="line">        key = children[i].key;</span><br><span class="line"><span class="keyword">if</span>(isDef(key) map[key] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历寻找</span></span><br><span class="line"><span class="comment">// sameVnode 是对比新旧节点是否相同的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findIdxInOld</span>(<span class="params">node,oldCh,start,end</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=start;i&lt;end;i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> c = oldCh[i];</span><br><span class="line">        <span class="keyword">if</span>(isDef(c) &amp;&amp; sameVnode(node,c)) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="“1”-”2”-”3”-map-parseInt-解析"><a href="#“1”-”2”-”3”-map-parseInt-解析" class="headerlink" title="[“1”,”2”,”3”].map(parseInt)解析"></a>[“1”,”2”,”3”].map(parseInt)解析</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>].map(<span class="built_in">parseInt</span>); <span class="comment">// [10,NaN,2,3,4]</span></span><br></pre></td></tr></table></figure><p><code>parseInt(string,radix)</code></p><p>参数：</p><p><code>string</code>:要被解析的值，如果参数不是一个字符串，则将其转换成字符串。字符串开头的空白符会被忽略。</p><p><code>radix</code>:一个介于2 和 36 的整数，表示上述字符串的基数。比如参数10 表示我们通常用的十进制数值系统。始终指定该参数可以消除阅读的困惑并且保证转换结果可预测。当未指定基数时，不同的实现会产生不同的结果，通常将值默认是10.</p><p><code>返回值</code>:返回解析的整数值。如果被解析参数的第一个字符无法被转换为数值类型，则返回 <code>NaN</code></p><p>注意：<code>radix</code>参数为n 会把第一个参数看做是一个数的 n 进制表示，而返回的值是十进制的。</p><ul><li>如果字符串string 是以 ‘0x‘ 或者 ‘0X’开头，则基数是16进制</li><li>如果字符串 string 是以 ’0‘ 开头，基数是8进制或者10进制。ES5 规定用10进制。</li><li>如果字符串string 以其他任何值开头，则默认是十进制</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>,<span class="number">10</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">100</span>,<span class="number">2</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p><code>map</code></p><p>map() 方法会创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数返回的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> new_array = arr.map(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[,index[,array]]</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// return element for new_array;</span></span><br><span class="line">&#125;[,thisArg]);</span><br></pre></td></tr></table></figure><p><code>callback</code>回调函数需要三个参数，我们通常只用了第一个参数（其他两个是可选的）</p><p><code>currentValue</code>:是 callback 数组中正在处理的当前元素。</p><p><code>index</code>:可选，是 callback 数组中正在处理的当前元素的索引</p><p><code>array</code>:可选，是 callback map 方法被调用的数组</p><p>另外还有 <code>thisAry</code>:执行 callback 函数使用的 this 值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>].map(<span class="built_in">parseInt</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">[<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>].map(<span class="function">(<span class="params">item,index</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">parseInt</span>(item,index);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 即是</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>,<span class="number">0</span>); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>,<span class="number">1</span>); <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>,<span class="number">2</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>,<span class="number">3</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'10'</span>,<span class="number">4</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>那么原题目也是同样的道理。</p><p>如果要将字符串数组循环变成数组可使用下面的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>,<span class="string">'10'</span>].map(<span class="built_in">Number</span>);</span><br><span class="line"><span class="comment">// [10,10,10,10,10]</span></span><br></pre></td></tr></table></figure><h3 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h3><p>JS 中分为7种内置类型，内置类型又分为两大类型：基本类型和对象（Object）[Function,Object,Array,Boolean,Number,String,Date,Error,RegExp,全局对象]</p><p>基本类型有：<code>null</code>,<code>undefined</code>,<code>string</code>,<code>number</code>,<code>boolean</code>,<code>symbol</code></p><p>其中 JS 的数字类型是浮点类型，没有整型。<code>NaN</code>也是 <code>number</code>类型，并且 <code>NaN</code>等于自身</p><p>对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会被会转换为对应的类型：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">111</span>; <span class="comment">// 这只是字面量，不是 number 类型</span></span><br><span class="line">a.toString(); <span class="comment">// 使用的时候才会被转换成为对象类型</span></span><br></pre></td></tr></table></figure><p>对象（Object ）是引用类型，在使用过程中会遇到浅拷贝和深拷贝的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">name</span>:<span class="string">'haha'</span>&#125;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">b.name = <span class="string">'haha2'</span></span><br><span class="line">a.name; <span class="comment">// haha2</span></span><br></pre></td></tr></table></figure><h3 id="Typeof"><a href="#Typeof" class="headerlink" title="Typeof"></a>Typeof</h3><p>typeof 对于基本类型，除了 null 都可以显示正确的类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">//'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'1'</span>; <span class="comment">//'string'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">//'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">//'null'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">//'boolean'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>(); <span class="comment">//'symbol'</span></span><br><span class="line"><span class="keyword">typeof</span> b <span class="comment">// b 没有声明，但是还会显示 undefined</span></span><br></pre></td></tr></table></figure><p>typeof 对于对象，除了函数都会显示 Object</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> []; <span class="string">'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="string">'object'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log; <span class="string">'function'</span></span><br></pre></td></tr></table></figure><p>对于 null 来说，虽然它是基本类型。但是会显示 object ，这是一个存在很久的 Bug。在JS 的最初版本，使用的是32位系统，为了性能问题使用低位储存了变量的内部信息，<code>000</code> 开头代表对象，然后 <code>null</code> 表示全为零，所以将它错误的判断为 object 。虽然现在内部类型判断代码已经更改了，但是这个 bug 却是一直流传下来的。</p><p>如果想要获得一个变量的正确类型，可以通过 <code>Object.prototype.call(xx)</code>，这样就可以获得类似 <code>[object type]</code>的字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let a</span><br><span class="line"><span class="comment">// 我们也可以这样判断 undefined</span></span><br><span class="line">a === undefined</span><br><span class="line"><span class="comment">// 但是 undefined 不是保留字，能够在低版本浏览器被赋值</span></span><br><span class="line">let undefined = <span class="number">1</span></span><br><span class="line"><span class="comment">// 这样判断就会出错</span></span><br><span class="line"><span class="comment">// 所以可以用下面的方式来判断，并且代码量更少</span></span><br><span class="line"><span class="comment">// 因为 void 后面随便跟上一个组成表达式</span></span><br><span class="line"><span class="comment">// 返回就是 undefined</span></span><br><span class="line">a === <span class="keyword">void</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h4 id="转Boolean"><a href="#转Boolean" class="headerlink" title="转Boolean"></a><strong>转Boolean</strong></h4><p>在条件判断时，除了 <code>undefined</code>,<code>null</code>,<code>false</code>,<code>NaN</code>,<code>&#39;&#39;</code>,<code>0</code>,<code>-0</code> 其他所有值都转为 true,包括所有对象。</p><h4 id="对象转基本类型"><a href="#对象转基本类型" class="headerlink" title="对象转基本类型"></a><strong>对象转基本类型</strong></h4><p>对象转基本类型时，首先会调用 <code>valueOf</code>然后调用 <code>toString</code>，并且这个两个方法是可以重写的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    valueOf()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以重写 <code>Symbol.toPrimitive</code>，该方法在转基本类型时调用优先级最高</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a =&#123;</span><br><span class="line">    valueOf()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    toString()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'1'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="built_in">Symbol</span>.toPrimitive]()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1</span> + a <span class="comment">// 3</span></span><br><span class="line"><span class="string">'1'</span> + a <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><h4 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a><strong>四则运算符</strong></h4><p>加法运算规则：</p><ol><li>其中一方是字符串类型，另外一方亦然</li><li>其中一方是数字类型，另外一方亦然</li><li>只会触发三种类型转换：值 =&gt; 原始值, =&gt; 数字，=&gt; 字符串</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">'1'</span> <span class="comment">// 11</span></span><br><span class="line"><span class="number">2</span> * <span class="string">'2'</span> <span class="comment">// 4</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>] +[<span class="number">2</span>,<span class="number">1</span>] <span class="comment">// '1,22,1'</span></span><br><span class="line"><span class="comment">// [1,2].toString -&gt; '1,2'</span></span><br><span class="line"><span class="comment">// [2,1].toString -&gt; '2,1'</span></span><br><span class="line"><span class="string">'1,2'</span>+ <span class="string">'2,1'</span> = <span class="string">'1,22,1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于加号要注意表达式 'a'++'b'</span></span><br><span class="line"><span class="string">'a'</span>++ <span class="string">'b'</span> <span class="comment">// 'aNaN'</span></span><br><span class="line"><span class="comment">// 因为 + 'b' 等于 NaN</span></span><br></pre></td></tr></table></figure><h4 id="操作符"><a href="#操作符" class="headerlink" title="== 操作符"></a><strong>== 操作符</strong></h4><p>比较运算 x==y,其中 x 和 y 是值，产生 true 或者 false ，这样的比较按下面的方式进行：</p><ol><li>若Type(x) 和 Type(y)相同，则<ol><li>若 Type(x) 为 undefined,返回 true</li><li>若 Type(x) 为 Null,返回 true</li><li>若 Type(x) 为 Number,则<ol><li>若 x 为 NaN,返回 false</li><li>若 y 为 NaN,返回 false</li><li>若 x 与 y 为相等数值，返回 true</li><li>若 x 为 +0, y 为 -0，返回 true</li><li>若 x 为 -0, y 为 +0，返回 true</li><li>返回 false</li></ol></li><li>若 Type(x) 为 String,则 x 和 y 为完全相同的字符序列（长度相等且相同字符在相同位置）时返回 true,否则，返回 false</li><li>若 Type(x) 为 Boolean,当 x 和 y 同为 true 或者同为 false 时返回 true,否则，返回 false。</li><li>当 x 和 y 为引用同一对象时返回 true,否则返回 false.</li></ol></li><li>若 x 为 null 且 y 为 undefined ，返回 true</li><li>若 x 为 undefined 且 y 为 null ,返回 true</li><li>若 Type(x) 为 Number,且 Type(y) 为 String,返回比较 x == toNumber(y) 的结果</li><li>若 Type(x) 为 String 且 Type(y) 为 Number,返回比较 ToNumber(x) == y 的结果</li><li>若 Type(x) 为 Boolean，返回 比较 ToNumber(x) ==y 的结果</li><li>若 Type(y) 为 Boolean,返回比较 ToNumber(y) ==x 的结果</li><li>若 Type(x) 为 String 或者 Number，且 Type(y) 为 Object,返回比较 x==ToPrimitive(y) 的结果</li><li>若 Type(y) 为 String 或者 Number，且 Type(x) 为 Object,返回比较 y==ToPrimitive(x) 的结果</li><li>返回 false</li></ol><p>toPrimitive 就是对象转基本类型</p><p>对照上面的规则，分析下面的案例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[] == ![] <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 由于 ！优先级大于 ==，所以先运算右边，[] 为 true, ![] 取反为 false，得出</span></span><br><span class="line">[] == <span class="literal">false</span></span><br><span class="line"><span class="comment">// 根据第7条规则 ToNumber(y) ==x ，得出</span></span><br><span class="line">[] == <span class="number">0</span></span><br><span class="line"><span class="comment">// 根据第9条规则， y==ToPrimitive(x)，得出</span></span><br><span class="line">ToPrimitive([]) == <span class="number">0</span></span><br><span class="line"><span class="comment">// 即是</span></span><br><span class="line">[].toString() == <span class="number">0</span></span><br><span class="line"><span class="comment">// 得出</span></span><br><span class="line"><span class="string">''</span> == <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 根据第5条规则，ToNumber(x) == y 得出</span></span><br><span class="line"><span class="number">0</span> == <span class="number">0</span> <span class="comment">// -&gt;true</span></span><br></pre></td></tr></table></figure><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a><strong>比较运算符</strong></h4><ol><li>如果是对象，就通过 toPrimitive 转换对象</li><li>如果是字符串，就通过 unicode 字符索引来比较</li></ol><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p><img src="./images/前端面试题目汇总摘录-JS 基础篇2-原型.png" alt="原型"></p><p>每个函数都有 prototype 属性，除了 Function.prototype.bind() 该属性指向原型。</p><p>每个对象都有 <code>__proto__</code>属性，指向了创建该对象的构造函数的原型，其实这个属性指向了 <code>[[proptotype]]</code>，但是 <code>[[proptotype]]</code>是内部属性，我们并不能访问到，所以使用 <code>__proto__</code>来访问。对象可以通过 <code>__proto__</code>来寻找不属于该对象的属性，<code>__proto__</code>将对象连接起来形成了原型链。</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><ol><li>新生成了一个对象</li><li>链接到原型</li><li>绑定 this</li><li>返回新对象</li></ol><p>在调用 new 的过程会发生上面四种事情，下面是自己实现的一个 new</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="comment">// 获得构造函数</span></span><br><span class="line">    <span class="keyword">let</span> Con = [].shift.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 链接到原型</span></span><br><span class="line">    Obj.__proto__. = Con.prototype;</span><br><span class="line">    <span class="comment">// 绑定 this,执行构造函数</span></span><br><span class="line">    <span class="keyword">let</span> result = Con.apply(obj,<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">// 确保 new 出来的是个对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> result == <span class="string">'Object'</span> ? result : obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于实例对象来说，都是通过 new 产生的，无论是 function Foo(){} 还是 let a = {b:1}</p><p>对于创建一个对象来说，更推荐使用字面量的方式来创建对象（无论是性能上还是可读性）。使用 new Object 方式创建对象需要通过作用域链一层层找到 Object，但是使用字面量就没有这个困扰</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="comment">// function 就是个语法糖，相当于 new Function()</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;<span class="attr">b</span>:<span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// 这个字面量也是使用了 new Object();</span></span><br></pre></td></tr></table></figure><p>对于 new 来说，还需要注意下面的运算符优先级</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Foo.getName(); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure><p>可以看出 new Foo() 优先级大于 new Foo,所以代码可以这样划分执行顺序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> (Foo.getName())</span><br><span class="line">(<span class="keyword">new</span> Foo).getName();</span><br></pre></td></tr></table></figure><p>对于第一个函数来说，先执行了 Foo.getName 所以结果为1，对于后者来说，先 new Foo() 产生了一个实例，然后通过原型链找到了 Foo 上面的 getName 函数，所以结果为 2</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>instanceof 可以正确判断对象的类型，因为内部机制是通过判断对象的原型链是不是能找到类型的 prototype </p><p>我们也可以试着实现:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">instanceof</span>(<span class="params">left,right</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 获得类型的原型</span></span><br><span class="line">    <span class="keyword">let</span> prototype = right.prototype;</span><br><span class="line">    <span class="comment">// 获得对象的原型</span></span><br><span class="line">    left = left.__Proto__;</span><br><span class="line">    <span class="comment">// 判断对象的类型是否等于类型的原型</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left === <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(prototype === left)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        left = left.__proto__</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><p>this 记住几个规则就可以了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">foo();</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">2</span>,</span><br><span class="line">    foo:foo</span><br><span class="line">&#125;</span><br><span class="line">obj.foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面两种情况 this 只依赖调用函数前的对象，优先级是第二个情况大于第一个情况</span></span><br><span class="line"><span class="comment">// 下面的优先级是最高的，this 只会绑定在c 上面，不会被任何方式修改 this 指向</span></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> foo();</span><br><span class="line">c.a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(c.a); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//还有一种情况是利用 call,apply或者 bind 改变 this，这个优先级仅次于 new</span></span><br></pre></td></tr></table></figure><p>箭头函数中的 this </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a()()());</span><br></pre></td></tr></table></figure><p>箭头函数其实是没有 this，这个函数中的 this 只取决于外面的第一个不是箭头函数的函数的this 。在上面的例子中，因为调用 a 符合前面代码的第一种情况，所以 this 是 window，并且一旦 this 绑定上下文了，就不会被任何代码改变。</p><h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>当执行 JS 代码的时候，会产生三种执行上下文</p><ul><li>全局执行上下文</li><li>函数执行上下文</li><li>eval 执行上下文</li></ul><p>每个执行上下文都有三个重要的属性</p><ul><li>变量对象（VO），包含变量、函数声明和函数的形参，该属性只能在全局上下文中访问</li><li>作用域链（JS 采用词法作用域，也就是说变量的作用域是在定义时就决定的）</li><li>this</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>对于上述代码，执行栈中有两个上下文：全局上下文和函数 foo 上下文</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack = [</span><br><span class="line">    globalContext,</span><br><span class="line">    fooContext</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>对于全局上下文来说，VO 大概是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">globalContext.VO === global</span><br><span class="line">globalContext.VO = &#123;</span><br><span class="line">    a:<span class="literal">undefined</span>,</span><br><span class="line">    foo:<span class="xml"><span class="tag">&lt;<span class="name">Function</span>&gt;</span>,</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>对于 函数 foo 来说，VO 不能被访问，只能访问到活动对象（AO）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fooContext.VO === foo.AO</span><br><span class="line">fooContext.AO = &#123;</span><br><span class="line">    i:<span class="literal">undefined</span>,</span><br><span class="line">    b:<span class="literal">undefined</span>,</span><br><span class="line">    <span class="built_in">arguments</span>:<span class="xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// arguments 是函数底油的对象（箭头函数没有），这个对象是一个伪数组，有 length 属性可以通过下标访问元素，该对象的 callee 属性代表函数本身，caller 属性代表函数的调用者</span></span><br></pre></td></tr></table></figure><p>对于作用域链，可以把它理解为包含自身变量对象和上级变量对象的列表，通过 [[Scope]] 属性查找上级变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fooContext.[[Scope]] = [ globalContext.VO ]</span><br><span class="line">fooContext.Scope = fooContext.[[Scope]] + fooContext.VO</span><br><span class="line">fooContext.Scope = [</span><br><span class="line">    fooContext.Vo,</span><br><span class="line">    globalContext.Vo</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>举个例子，var</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b(); <span class="comment">// hehe</span></span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">'haha'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hehe'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的结果是因为函数和变量提升的原因。通常替身的解释是说将生命的代码移到了顶部，这其实没有什么错误，便于理解。但是更准确的解释应该是：在生成执行上下文时，会有两个阶段。第一个阶段是创建的阶段（具体步骤是创建 VO），JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数放入内存中，变量只声明并且赋值为 undefined，所以在第二个阶段，也就是代码的执行阶段，我们可以直接提前使用。</p><p>在提升的过程中，相同的函数会覆盖上一个函数，并且函数优先于变量提升</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">b(); <span class="comment">//2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'haha'</span>;</span><br></pre></td></tr></table></figure><p>var 会产生很多错误，所以现在 ES6 中引入了 let，let 不能在声明前使用，但是这并不是常说的 let 不会提升，let 提升了声明但是没有赋值，因为临时死区导致了并不能在声明前使用</p><p>对于非匿名立即执行函数需要注意下面的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    foo = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">/**ƒ foo() &#123;</span></span><br><span class="line"><span class="comment">    foo = 10</span></span><br><span class="line"><span class="comment">    console.log(foo)</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>因为当 JS 解释器在遇到非匿名的理解执行函数时，会创建一个辅助的特定对象，然后将函数名称作为这个对象的属性，因此函数内部才可以访问到 foo，但是这个值又是只读的，所以对它的赋值并不会生效，所以打印出来的还是这个函数，并且外部的值也没有任何改变。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">specialObject = &#123;&#125;</span><br><span class="line">Scope = specialObject + Scope;</span><br><span class="line">foo = <span class="keyword">new</span> FunctionExpression;</span><br><span class="line">foo.[[Scope]] = Scope;</span><br><span class="line">specialObject.foo = foo; <span class="comment">// &#123;DontDelete&#125;, &#123;ReadOnly&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> Scope[<span class="number">0</span>]; <span class="comment">// remove specialObject from the front of scope chain</span></span><br></pre></td></tr></table></figure><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包的定义很简单：函数 A 返回一个函数 B，并且函数 B 中使用了 函数 A 的变量，函数 B就被称为闭包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数 A 中的变量这时候是存储在堆上的，JS 引擎可以通过逃逸分析辨别哪些变量需要存储在对上，哪些需要存储在栈上。</p><p>循环中使用闭包解决 var 定义函数的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，因为 setTimeout 是异步函数，所以回先把所有U型你换全部执行完毕，这时候 i 就是 6了，所以会输出一堆 6.</p><p>解决的方法有两种，第一种是使用闭包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(j)</span><br><span class="line">        &#125;,j*<span class="number">1000</span>);</span><br><span class="line">    &#125;)(j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种是使用 setTimeout 的第三个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params">j</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;,i*<span class="number">1000</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三种就是使用 let 定义 i</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i)</span><br><span class="line">    &#125;,i*<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为对于 let 来说，会创建一个块级作用域，相当于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 形成块级作用域</span></span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> ii = i;</span><br><span class="line">        setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(ii);</span><br><span class="line">        &#125;,i*<span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> ii = i</span><br><span class="line">    &#125;</span><br><span class="line">    i++</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> ii = i</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = a;</span><br><span class="line">a.age = <span class="number">2</span>;</span><br><span class="line">b.age; <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>从上述例子可以看出，如果给一个变量赋值一个对象，那么两者的值会是同一引用，其中一方改变，另一方也会相应改变。</p><p>通常在开发中，我们不希望出现这样的问题，我们可以使用浅拷贝来解决这个问题。</p><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a><strong>浅拷贝</strong></h4><p>首先可以通过 <code>Object.assign</code> 来解决这个问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;,a);</span><br><span class="line">a.age = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.age); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>也可通过展开运算符（…）来解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">    ...a</span><br><span class="line">&#125;</span><br><span class="line">a.age = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.age); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>通常拷贝能解决大部分问题，但是当我们遇到下面的情况就需要使用深拷贝了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="number">1</span>,</span><br><span class="line">    jobs:&#123;</span><br><span class="line">        first:<span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;</span><br><span class="line">    ...a</span><br><span class="line">&#125;</span><br><span class="line">a.job.first = <span class="string">'native'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first); <span class="comment">// native</span></span><br></pre></td></tr></table></figure><p>浅拷贝只解决了第一层问题，如果接下去的值中还有对象的话，那么两者又享有相同的引用，要解决这个问题，要引入深拷贝。</p><h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a><strong>深拷贝</strong></h4><p>这个问题通常可以通过 <code>JSON.parse(JSON.stringify(object))</code>来解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="number">1</span>,</span><br><span class="line">    jobs:&#123;</span><br><span class="line">        first:<span class="string">'FE'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line">a.jobs.first = <span class="string">'native'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(b.jobs.first); <span class="comment">// 'FE'</span></span><br></pre></td></tr></table></figure><p>但是该方法也是有局限性的：</p><ul><li>会忽略 <code>undefined</code></li><li>会忽略 <code>symbol</code></li><li>不能序列化函数</li><li>不能解决循环引用的对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">        c:<span class="number">2</span>,</span><br><span class="line">        d:<span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.c = obj.b;</span><br><span class="line">obj.e = obj.a;</span><br><span class="line">obj.b.c = obj.c</span><br><span class="line">obj.b.d = obj.b</span><br><span class="line">obj.b.e = obj.b.c</span><br><span class="line"><span class="keyword">let</span> newObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj));</span><br><span class="line"><span class="built_in">console</span>.log(newObj);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Converting circular structure to JSON</span></span><br><span class="line"><span class="comment">//   at JSON.stringify (&lt;anonymous&gt;)</span></span><br><span class="line"><span class="comment">//   at &lt;anonymous&gt;:14:30</span></span><br></pre></td></tr></table></figure><p>在遇到函数、undefined或者 symbol 的时候，该对象也不能正常的序列化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    age:<span class="literal">undefined</span>,</span><br><span class="line">    sex:<span class="built_in">Symbol</span>(<span class="string">'male'</span>),</span><br><span class="line">    jobs:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    name:<span class="string">'haha'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// &#123;name:'haha'&#125;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，该方法会忽略掉函数和 <code>undefined</code></p><p>但是在通常情况下，复杂数据是可以序列化的，所以这个函数可以解决大部分问题，并且该函数是内置函数中处理深拷贝性能最快的。数据中含有以上三种情况下，可以使用 <a href="https://lodash.com/docs##cloneDeep">lodash 的深拷贝函数</a>。</p><p>如果所需要拷贝的对象含有内置类型并且不包括函数的，可以使用 MessageChannel</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">structuralClone</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> &#123;port1,port2&#125; = <span class="keyword">new</span> MessageChannel;</span><br><span class="line">        port2.onmessage = <span class="function"><span class="params">ev</span> =&gt;</span> resolve(ev.data);</span><br><span class="line">        port1.postMessage(obj)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:&#123;</span><br><span class="line">       c:b</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该方法是异步的</span></span><br><span class="line"><span class="comment">// 可以循环处理 undefined 和循环引用对象</span></span><br><span class="line">(<span class="keyword">async</span> ()=&gt;&#123;</span><br><span class="line">    <span class="keyword">const</span> clone = <span class="keyword">await</span> structualClone(obj)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>我们也可以自己创建一个 deepClone 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字 字符串 function 不需要拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCline</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value == <span class="literal">null</span>) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> value !== <span class="string">'object'</span>) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(value);</span><br><span class="line">    <span class="keyword">if</span>(value <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(value)</span><br><span class="line">    <span class="comment">// 判断是数组还是对象</span></span><br><span class="line">    <span class="keyword">let</span> obj = <span class="keyword">new</span> value.constructor;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> ket <span class="keyword">in</span> value)&#123;</span><br><span class="line">        obj[key] = deepClone(value[key])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>在有 Babel 的情况下， 可以直接使用 ES6 的模块化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file a.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file b.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;a,b&#125; <span class="keyword">from</span> <span class="string">'./a.js'</span></span><br><span class="line"><span class="keyword">import</span> XXX <span class="keyword">from</span> <span class="string">'./b.js'</span></span><br></pre></td></tr></table></figure><h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a><strong>CommonJS</strong></h4><p>CommonJS 是 Node 独有的规范，浏览器中使用就需要用到 Broserify 解析</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    a:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span>.a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="built_in">module</span>.a <span class="comment">// -&gt; log 1</span></span><br></pre></td></tr></table></figure><p>在上述代码中，module.export 和 export 很容易混淆，看看大致的内部实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = <span class="built_in">require</span>(<span class="string">'./a.js'</span>);</span><br><span class="line"><span class="built_in">module</span>.a</span><br><span class="line"><span class="comment">// 这里其实就是包装了一层立即执行函数，这样就不会污染全局变量了，重要的是 module 这里，module 是 Node 独有的一个变量</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    a:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 基本实现</span></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">    exports:&#123;&#125; <span class="comment">// exports 就是空对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这也是为什么 exports 和 module.exports 用法相似的原因</span></span><br><span class="line"><span class="keyword">var</span> exports = <span class="built_in">module</span>.exports;</span><br><span class="line"><span class="keyword">var</span> load = <span class="function"><span class="keyword">function</span>(<span class="params">module</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">module</span>.exports = a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>module.exports 和 exports 用法其实是相似的，但是不能对 exports 直接赋值，不会有任何效果。</p><p>对于 CommonJS 和 ES6 的模块化的两者区别是：</p><ul><li>前者支持动态导入，也就是 require(${path}/xx.js),后者不支持，但是已有提案</li><li>前者是同步导入，因为用于服务端，文件都在本地，同步导入即使卡住线程影响也不大。而后者是异步导入，因为用于浏览器，需要下载文件，如果也采用同步导入会对渲染有很大影响</li><li>前者在导出时都是值拷贝，就算导出的值变了，导入的值也不会改变，所以如果想要更新值，必须重新导入一次。但是后者采用实时绑定的方式，导入导出的值都指向同一个内存地址，所以导入值会跟随导出值变化</li><li>后者会编译成 require/exports 来执行</li></ul><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a><strong>AMD</strong></h4><p>AMD 是由 RequireJS 提出的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">define([<span class="string">'./a.js'</span>,<span class="string">'./b.js'</span>],<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">    a.do();</span><br><span class="line">    b.do();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require,exports,module</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line">    a.doSomething();</span><br><span class="line">    <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line">    b.doSomething();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="节流和防抖的理解"><a href="#节流和防抖的理解" class="headerlink" title="节流和防抖的理解"></a>节流和防抖的理解</h3><p>防抖和节流都是防止函数多次调用。区别在于，假设一个用户一直触发这个函数，且每次触发函数的间隔小于 wait，防抖的情况只会调用一次，而节流的情况会隔一定时间（参数wait）调用函数</p><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a><strong>防抖</strong></h4><p>在滚动事件中需要做一个复杂计算或者是实现一个按钮防止第二次点击操作。这些需求都可以通过函数防抖来实现，尤其是第一个需求，如果在频繁的时间回调中做复杂计算，很有可能会导致页面卡顿，不如将多次计算合并为一次计算，只在一个精确点做操作。</p><p>通俗化：如果用手指一直按着弹簧，它将不会弹起知道你松手为止</p><p>袖珍版的防抖：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func 是用户传入需要防抖的函数</span></span><br><span class="line"><span class="comment">// wait 是等待时间</span></span><br><span class="line"><span class="keyword">const</span> debounce = <span class="function">(<span class="params">func,wait = <span class="number">50</span></span>) =&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 缓存一个定时器id</span></span><br><span class="line">    <span class="keyword">let</span> timer = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 返回的函数是每次用户实际调用防抖函数，如果已经设定过定时器就清空上一次的定时器，开始一个新的定时器，延迟用户传入的方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">..args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (timer) clearTimeout(timer);</span><br><span class="line">        timer = setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            func.apply(<span class="keyword">this</span>,args);</span><br><span class="line">        &#125;,wait);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 不难看出来如果用户调用该函数间隔小于 wait 的情况下，上一次时间还未到就被清除了，并不会执行函数。</span></span><br></pre></td></tr></table></figure><p>这是一个简单的防抖，但是有缺陷，在于它只能最后调用。一般的防抖会有 immediate 选项，表示是否立即调用。这两者的区别：</p><ul><li>例如在搜索引擎搜索问题的时候，我们当然希望用户输入完最后一个字才调用查询接口，这个时候用 <code>延迟执行</code> 的防抖函数，它总是在一连串（间隔小于 wait）函数触发之后调用</li><li>例如用户给项目点 star 的时候，我们希望用户点第一下的时候就去调用接口，并成功之后改变 star 按钮的样子，用户就可以立马得到反馈是否 star 成功了，这个情况使用 <code>立即调用</code>的防抖函数，它总在第一次调用，并且下一次调用必须和前一次调用的时间间隔大于 wait 才会触发。</li></ul><p>带有立即执行的防抖函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个用来获取当前时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">now</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 防抖函数，返回函数连续调用，空闲时间必须大于或者等于 wait,func 才会执行</span></span><br><span class="line"><span class="comment">* @param &#123;function&#125; func 回调函数</span></span><br><span class="line"><span class="comment">* @param &#123;number&#125; wait 表示窗口的间隔</span></span><br><span class="line"><span class="comment">* @param &#123;boolean&#125; immediate 设置为 true时，是否立即调用函数</span></span><br><span class="line"><span class="comment">* @return &#123;function&#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func,wait=<span class="number">50</span>,immediate=true</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer,context,args;</span><br><span class="line">    <span class="comment">// 延迟执行函数</span></span><br><span class="line">    <span class="keyword">const</span> later = <span class="function"><span class="params">()</span> =&gt;</span> setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="comment">// 延迟执行函数执行完毕，清除缓存的定时器序号</span></span><br><span class="line">        timer = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 延迟执行的情况下，函数会在延时函数中执行，使用到之前缓存的参数和上下文</span></span><br><span class="line">        <span class="keyword">if</span>(!immediate)&#123;</span><br><span class="line">           func.apply(context,args);</span><br><span class="line">            context = args = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,wait)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里返回的函数是每次实际调用的函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...params</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 如果没有创建样式执行函数（later）,那就创建一个</span></span><br><span class="line">        <span class="keyword">if</span>(!timer)&#123;</span><br><span class="line">           timer = later();</span><br><span class="line">           <span class="comment">// 如果是立即执行，调用函数，否则缓存参数和调用上下文</span></span><br><span class="line">            <span class="keyword">if</span>(immediate)&#123;</span><br><span class="line">               func.apply(<span class="keyword">this</span>,params);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                context = <span class="keyword">this</span>;</span><br><span class="line">                args = params</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 如果已有延迟执行函数（later） ，调用的时候清除原来的并重新设定一个</span></span><br><span class="line">        <span class="comment">// 这样做延迟函数会重新计时</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = later();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总结一下：</p><ul><li>对于按钮点击来说的实现:如果函数是立即执行的，就理解调用，如果函数是延迟执行的，就缓存上下文和参数，放到延迟函数中执行，一旦开始一个定时器，只要定时器还在，每次点击都会重新计时。一旦定时器时间到了，定时器重置为null,就可以再次点击了。</li><li>对于延迟函数来说的实现：清除定时器ID，如果是延迟调用就调用函数</li></ul><h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a><strong>节流</strong></h4><p>防抖和节流本质上是不一样的。防抖是将多次执行变成最后一次执行，节流是将多次执行变成每隔一段时间执行。</p><p>通俗化：如果将水龙头拧紧直到水是以水滴的形式流出，那么你会发现隔一段时间，就会有一滴水溜出来。也就是会预先设定一个执行周期，当调用动作的时刻大于等于执行周期则执行该动作，然后进入下一个周期</p><p>袖珍版实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> throttle = <span class="function">(<span class="params">wait,func</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> curr = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">if</span>(curr - last &gt; wait)&#123;</span><br><span class="line">           func.apply(<span class="keyword">this</span>,args);</span><br><span class="line">            last = curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* underscore 节流函数，返回函数连续调用，func 执行频率是 次/wait</span></span><br><span class="line"><span class="comment">* @param &#123;function&#125; func 回调函数</span></span><br><span class="line"><span class="comment">* @param &#123;number&#125; wait 表示窗口的间隔</span></span><br><span class="line"><span class="comment">* @param &#123;object&#125; options 如果想忽略开始函数的调用，传入&#123;leading:false&#125;,如果想忽略结尾函数则是&#123;trailing:false&#125;,两者不能共存，否则函数不执行。</span></span><br><span class="line"><span class="comment">* @return &#123;function&#125; 返回客户调用的函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">_.throttle = <span class="function"><span class="keyword">function</span>(<span class="params">func,wait,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> context,args,result;</span><br><span class="line">    <span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 之间的时间戳</span></span><br><span class="line">    <span class="keyword">let</span> previous = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果 options 没传则设置为空对象</span></span><br><span class="line">    <span class="keyword">if</span>(!options) options = &#123;&#125;;</span><br><span class="line">    <span class="comment">// 定时器回调函数</span></span><br><span class="line">    <span class="keyword">const</span> later = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 如果设置了 leading,就将 previous 设为0，用于下一个函数的第一个 if 判断</span></span><br><span class="line">        previous = options.length === <span class="literal">false</span> ? <span class="number">0</span> : _.now();</span><br><span class="line">        <span class="comment">// 置空是为了防止内存泄露，也是为了下面定时器的判断</span></span><br><span class="line">        timeout = <span class="literal">null</span>;</span><br><span class="line">        result = func.apply(context,args);</span><br><span class="line">        <span class="keyword">if</span>(!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 获得当前的时间戳</span></span><br><span class="line">        <span class="keyword">const</span> now = _.now;</span><br><span class="line">        <span class="comment">// 首先进入前者肯定要为 true,如果需要第一次不执行函数，就将上次时间戳设定为当前的，就下来的计算中 remaining 的值时会大于0</span></span><br><span class="line">        <span class="keyword">if</span>(previous &amp;&amp; options.leading === <span class="literal">false</span>) previous = now;</span><br><span class="line">        <span class="comment">// 计算剩下的时间</span></span><br><span class="line">        <span class="keyword">const</span> remaining = wait - (now - previous);</span><br><span class="line">        context = <span class="keyword">this</span>;</span><br><span class="line">        args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="comment">// 如果当前调用给意见大于上次时间 + wait，或者用户手动调了事件，如果设置 trailing，只会进入这个条件</span></span><br><span class="line">        <span class="keyword">if</span>(remaining &lt;= <span class="number">0</span> || remaining &gt; wait)&#123;</span><br><span class="line">            <span class="comment">// 如果存在定时器就清理掉否则会调用二次回调</span></span><br><span class="line">            <span class="keyword">if</span>(timeout)&#123;</span><br><span class="line">               clearTimeout(timeout);</span><br><span class="line">                timeout = <span class="literal">null</span>;</span><br><span class="line">             &#125;</span><br><span class="line">            previous = now;</span><br><span class="line">            result = func.apply(context,args);</span><br><span class="line">            <span class="keyword">if</span>(!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!timeout &amp;&amp;options.trailing !== <span class="literal">false</span>)&#123;</span><br><span class="line">            <span class="comment">// 判断是否设置了定时器和 trailing ，没有的话就开启一个定时器，并且不能同时设置 leading 和 trailing</span></span><br><span class="line">            timeout = setTimeout(later,remaining);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在 ES5 中，可以使用下面的方式解决继承的问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Super.prototype.getNumber = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Sub();</span><br><span class="line">Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype,&#123;</span><br><span class="line">    <span class="keyword">constructor</span>:&#123;</span><br><span class="line">        value:Sub,</span><br><span class="line">        enumerable:<span class="literal">false</span>,</span><br><span class="line">        writable:<span class="literal">true</span>,</span><br><span class="line">        configurable:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的继承实现思路就是将子类的原型设置为父类的原型</p><p>在 ES6 中，可以通过 class 语法糖解决这个问题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span> <span class="keyword">extends</span> <span class="title">Date</span></span>&#123;</span><br><span class="line">    test()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myDate = <span class="keyword">new</span> MyDate();</span><br><span class="line">myDate.test();</span><br></pre></td></tr></table></figure><h3 id="call-apply-bind-区别"><a href="#call-apply-bind-区别" class="headerlink" title="call,apply,bind 区别"></a>call,apply,bind 区别</h3><p>call 和 apply 都是为了解决改变 this  的指向，作用都是相同的，只是传参的方式不同，除了第一个参数外，call 可以接受一个参数列表，apply 只接受一个参数数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a =&#123;</span><br><span class="line">    value:<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="built_in">console</span>.log(age);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.value);</span><br><span class="line">&#125;</span><br><span class="line">getValue.call(a,<span class="string">'haha'</span>,<span class="string">'24'</span>);</span><br><span class="line">getValue.apply(a,[<span class="string">'haha'</span>,<span class="string">'24'</span>]);</span><br></pre></td></tr></table></figure><h4 id="模拟实现-call-和-apply"><a href="#模拟实现-call-和-apply" class="headerlink" title="模拟实现 call 和 apply"></a><strong>模拟实现 call 和 apply</strong></h4><p>可以从下面几点来考虑如何实现</p><ul><li>不传入第一个参数，那么默认可以为 window</li><li>改变了 this 指向，让新的对象可以执行该函数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    <span class="comment">// 给 context 添加一个属性</span></span><br><span class="line">    <span class="comment">// getValue.call(a,'haha',24) -&gt; a.fn('haha','24');</span></span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 将 context 后面的参数取出来</span></span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> result = context.fn(...args);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除 fn</span></span><br><span class="line">    <span class="keyword">delete</span> context.fn</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>apply 的实现也是类似的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> context = context || <span class="built_in">window</span>;</span><br><span class="line">    context.fn = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> result;</span><br><span class="line">    <span class="comment">// 判断是否存在第二个参数，如果存在就把第二个参数展开</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>[<span class="number">1</span>])&#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>]);   </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        result = context.fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bind 和其他两个方法作用也是一样的，只是该方法会返回一个函数。并且我们可以通过 bind 实现柯里化</p><p>模拟实现 bind</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span>(<span class="params">context</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'undefined'</span>)&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">var</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 返回一个函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> <span class="keyword">instanceof</span> F)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> _this(..args,...arguments);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _this.apply(context,args.concat(...arguments));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Promise-实现"><a href="#Promise-实现" class="headerlink" title="Promise 实现"></a>Promise 实现</h3><p>Promise 是 ES6 新增的语法，解决了回调地狱的问题。</p><p>可以把 Promise 看成一个状态机。初始状态是 pending 状态，可以通过函数 resolve 和 reject ，将状态转变为 resolved 和 rejected 状态，状态一旦改变就不能再发生变化了。</p><p>then 函数会返回一个 Promise 实例，并且该返回值是一个新的实例而不是之前的实例。因为 Promise 规范规定了 pending 状态，其他状态是不可以改变的，如果返回的是同一个实例的话，多个 then 调用就失去意义了。</p><p>对于 then 来说，本质上可以把它看成 flatMap</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> PENDING = <span class="string">'pending'</span>;</span><br><span class="line">  <span class="keyword">const</span> RESOLVED = <span class="string">'resolved'</span>;</span><br><span class="line">  <span class="keyword">const</span> REJECTED = <span class="string">'rejected'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// promise 接受一个函数参数，该函数会理解执行</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="keyword">this</span>;</span><br><span class="line">    _this.currentState = PENDING;</span><br><span class="line">    _this.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 用于保存 then 中的回调，只有当 promise 状态为 pending 时才会缓存，并且每个实例至多缓存一个</span></span><br><span class="line">    _this.resolvedCallbacks = [];</span><br><span class="line">    _this.rejectedCallbacks = [];</span><br><span class="line">    _this.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">        <span class="comment">// 如果 value 是个 Promise ，递归执行</span></span><br><span class="line">        <span class="keyword">return</span> value.then(_this.resolve, _this.reject);</span><br><span class="line">      &#125;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// 异步执行，保证执行顺序</span></span><br><span class="line">        <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">          _this.currentState = RESOLVED;</span><br><span class="line">          _this.value = value;</span><br><span class="line">          _this.resolvedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    _this.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (_this.currentState === PENDING) &#123;</span><br><span class="line">          _this.currentState = REJECTED;</span><br><span class="line">          _this.value = reason;</span><br><span class="line">          _this.rejectedCallbacks.forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 用于解决下面的问题</span></span><br><span class="line">    <span class="comment">// new Promise(()=&gt; throw Error('error'))</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fn(_this.resolve, _this.reject)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      _this.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// then 函数的作用是为 Promise 实例添加状态改变时的回调函数。then 方法的第一个参数是 resolved 状态的回调函数，第二个参数（可选）是 rejected 状态的回调函数。</span></span><br><span class="line"><span class="comment">// then 方法返回的是一个新的 promise 实例，因此可以采用链式写法，即 then 方法后面再调用另一个 then 方法。</span></span><br><span class="line">  MyPromise.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onResolved, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// then 必须返回一个新的 promise</span></span><br><span class="line">    <span class="keyword">let</span> promise2;</span><br><span class="line">    <span class="comment">// 如果 onResolved 和 onRejected 都为可选参数，如果类型不是函数需要忽略，同时也实现了透传</span></span><br><span class="line">    <span class="comment">// Promise.resolve(4).then().then((value)=&gt;console.log(value))</span></span><br><span class="line">    onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">'function'</span> ? onResolved : <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">r</span> =&gt;</span> &#123; <span class="keyword">throw</span> r &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (self.currentState === RESOLVED) &#123;</span><br><span class="line">      <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onResolve(self.value);</span><br><span class="line">            resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (self.currentState === REJECTED) &#123;</span><br><span class="line">      <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(self.value);</span><br><span class="line">            resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (reason) &#123;</span><br><span class="line">            reject(reason)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (self.currentState === PENDING) &#123;</span><br><span class="line">      <span class="keyword">return</span> (promise2 = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        self.rejectedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onRejected(self.value);</span><br><span class="line">            resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (r) &#123;</span><br><span class="line">            reject(r)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        self.resolvedCallbacks.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> x = onResolved(self.value);</span><br><span class="line">            resolutionProcedure(promise2, x, resolve, reject)</span><br><span class="line">          &#125; <span class="keyword">catch</span> (r) &#123;</span><br><span class="line">            reject(r)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolutionProcedure</span>(<span class="params">promise2, x, resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// x 不能与 promise2 相同，避免循环</span></span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">      <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Error'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 x 为 Promise ，状态为 pending 需要继续等待否则执行</span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">      <span class="keyword">if</span> (x.currentState === PENDING) &#123;</span><br><span class="line">        x.then(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">          <span class="comment">// 再次调用该函数是为了确认 x resolve 的 参数是什么类型，如果是基本类型就再次 resolve，把值传给下一个 then</span></span><br><span class="line">          resolutionProcedure(promise2, x, resolve, reject);</span><br><span class="line">        &#125;, reject);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        x.then(resolve, reject);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reject 或者 resolve 其中一个执行得过的话，忽略其他的</span></span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 判断 x 是否为对象或者是函数</span></span><br><span class="line">    <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">      <span class="comment">// 如果不能取出 then ，就 reject</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> then = x.then;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123;</span><br><span class="line">          then.call(</span><br><span class="line">            x,</span><br><span class="line">            y =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">              called = <span class="literal">true</span>;</span><br><span class="line">              resolutionProcedure(promise2, y, resolve, reject);</span><br><span class="line">            &#125;,</span><br><span class="line">            e =&gt; &#123;</span><br><span class="line">              <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">              called = <span class="literal">true</span>;</span><br><span class="line">              reject(e);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          resolve(x)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        reject(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="Generator-实现"><a href="#Generator-实现" class="headerlink" title="Generator 实现"></a>Generator 实现</h3><p>Generator 是 ES6 中新增的语法，和 Promise 一样，都可以用异步来编程。</p><p>Generator 函数也可以理解成为一个状态机，封装了多个内部状态。</p><p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p><p>形式上，Generator 函数是一个普通函数，但是有两个特征。一个是 function 关键字与函数名之间有一个 星号，二是函数内部使用 yield 表达式，表示不同的内部状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 * 表示这是一个 Generator 函数</span></span><br><span class="line"><span class="comment">// 内部可以使用 yield 暂停代码</span></span><br><span class="line"><span class="comment">// 调用 next 恢复执行</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span>;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = test();</span><br><span class="line">b.next(); <span class="comment">// &#123;value:2,done:false&#125;</span></span><br><span class="line">b.next(); <span class="comment">// &#123;value:3,done:false&#125;</span></span><br><span class="line">b.next(); <span class="comment">// &#123;value:undefined,done:true&#125;</span></span><br></pre></td></tr></table></figure><p>上述代码可以发现，加上 * 的函数执行后拥有了 next 函数，也就是说函数执行后返回了一个对象。每次调用 next 函数可以继续执行被暂停的代码，下面是 Generator 的简单实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cb 也就是编译的 test 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyGerenator</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> object = &#123;</span><br><span class="line">      next: <span class="number">0</span>,</span><br><span class="line">      stop: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> ret = cb(obj);</span><br><span class="line">        <span class="keyword">if</span> (ret === <span class="literal">undefined</span>) <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">          value: ret,</span><br><span class="line">          done: <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 babel 编译后可以发现 test 函数变成了这样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a;</span><br><span class="line">  <span class="keyword">return</span> MyGerenator(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> ((_context.prev = _context.next)) &#123;</span><br><span class="line">        <span class="comment">// 可以发现通过 yield 将代码分成了几块，每次执行 next 函数就执行一块代码，并且表明下次需要执行哪块代码</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">          a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">          _context.next = <span class="number">4</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">          _context.next = <span class="number">6</span>;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'end'</span>:</span><br><span class="line">          <span class="keyword">return</span> _context.stop();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一道题目"><a href="#一道题目" class="headerlink" title="一道题目"></a>一道题目</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">2</span> * (<span class="keyword">yield</span>(x+<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">let</span> z = <span class="keyword">yield</span>(y/<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> (x+y+z)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(it.next())   <span class="comment">// =&gt; &#123;value: 6, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">12</span>)) <span class="comment">// =&gt; &#123;value: 8, done: false&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(it.next(<span class="number">13</span>)) <span class="comment">// =&gt; &#123;value: 42, done: true&#125;</span></span><br></pre></td></tr></table></figure><p>分析：</p><ul><li>首先 <code>Generator</code> 函数调用和普通函数不同，它会返回一个迭代器</li><li>当执行第一次 <code>next</code> 时，传参会被忽略，并且函数暂停在 <code>yield (x + 1)</code> 处，所以返回 <code>5 + 1 = 6</code></li><li>当执行第二次 <code>next</code> 时，传入的参数等于上一个 <code>yield</code> 的返回值，如果你不传参，<code>yield</code> 永远返回 <code>undefined</code>。此时 <code>let y = 2 * 12</code>，所以第二个 <code>yield</code> 等于 <code>2 * 12 / 3 = 8</code></li><li>当执行第三次 <code>next</code> 时，传入的参数会传递给 <code>z</code>，所以 <code>z = 13, x = 5, y = 24</code>，相加等于 <code>42</code></li></ul><h3 id="Map、FlatMap-和-Reduce"><a href="#Map、FlatMap-和-Reduce" class="headerlink" title="Map、FlatMap 和 Reduce"></a>Map、FlatMap 和 Reduce</h3><p>Map 的作用是生成一个数组，遍历原数组，将每个元素拿出来然后做一些变换然后 append 到新的数组中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">v</span>=&gt;</span>v+<span class="number">1</span>);</span><br><span class="line"><span class="comment">// [2,3,4]</span></span><br></pre></td></tr></table></figure><p>Map 有三个参数，分别是当前索引元素，索引，原数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>].map(<span class="built_in">parseInt</span>);</span><br><span class="line"><span class="comment">// parseInt('1',0) -&gt; 1</span></span><br><span class="line"><span class="comment">// parseInt('2',1) -&gt; NaN</span></span><br><span class="line"><span class="comment">// parseInt('3',2) -&gt; NaN</span></span><br></pre></td></tr></table></figure><p>FlatMap 和 map 的作用几乎是相同的，但是对于多维数组来说，会将原数组降维。可以将 FlatMap 看成是 map + flatten ，目前该函数在浏览器中还不支持。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,[<span class="number">2</span>],<span class="number">3</span>].flatMap(v=v+<span class="number">1</span>);</span><br><span class="line"><span class="comment">// [2,3,4]</span></span><br></pre></td></tr></table></figure><p>如果想将一个多维数组彻底的降维，可以这样实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> flattenDeep = <span class="function"><span class="params">arr</span> =&gt;</span> <span class="built_in">Array</span>.isArray(arr) ? arr.reduce(<span class="function">(<span class="params">a,b</span>)=&gt;</span>[...a,...flattenDeep(b)],[]):[arr];</span><br><span class="line">flattenDeep([<span class="number">1</span>,[[<span class="number">2</span>],[<span class="number">3</span>,[<span class="number">4</span>]],<span class="number">5</span>]]);</span><br><span class="line"><span class="comment">// [1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><p>Reduce 作用是数组中的值组合起来，最终得到一个值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">[a,b].reduce(<span class="function">(<span class="params">a,b</span>)=&gt;</span>a(b()));</span><br></pre></td></tr></table></figure><h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h3><p>一个函数如果加上 async,那么该函数就会返回一个 Promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'1'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(test()); <span class="comment">// -&gt; Promise &#123;&lt;resolved&gt;: "1"&#125;</span></span><br></pre></td></tr></table></figure><p>可以把 async 看成函数返回值使用 Promise.resolve() 包裹了下。</p><p>await 只能在 async 函数中使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'finish'</span>);</span><br><span class="line">            resolve(<span class="string">'sleep'</span>);</span><br><span class="line">        &#125;,<span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value = <span class="keyword">await</span> sleep();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'object'</span>);</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>上面代码会先打印 <code>finish</code> 然后再打印 <code>object</code> 。因为 <code>await</code> 会等待 <code>sleep</code> 函数 <code>resolve</code> ，所以即使后面是同步代码，也不会先去执行同步代码再来执行异步代码。</p><p>async 和 await 相比直接使用 Promise 来说，优势在于处理 then 的调用链，能够更清晰准确的写出代码。缺点在于滥用 await 可能会导致性能问题，因为 await 会阻塞代码，也许之后的异步代码并不依赖前者，但仍然需要等待前者完成，导致代码失去了并发性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> b = <span class="keyword">async</span>() =&gt;&#123;</span><br><span class="line">    a = a + <span class="keyword">await</span> <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>,a);</span><br><span class="line">    a = (<span class="keyword">await</span> <span class="number">10</span>) + a;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>,a);</span><br><span class="line">&#125;</span><br><span class="line">b();</span><br><span class="line">a++</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>,a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// VM3859:10 1 1</span></span><br><span class="line"><span class="comment">// VM3859:4 2 10</span></span><br><span class="line"><span class="comment">// VM3859:6 3 20</span></span><br></pre></td></tr></table></figure><ul><li>首先函数 b 执行，在执行到了 await 10 之前 a 的变量还是 0，因为在 await 内部实现了generators ,generators 会保留堆栈中东西，a=0 被保存下来。</li><li>因为 await 是异步操作，遇到 await 会立即返回一个 pending 状态的 promise 对象，暂时返回执行代码的控制权，使得函数外的代码得以继续执行，所以会先执行 同步代码 console.log(‘1’,a);</li><li>同步代码之后就是异步代码，将保存下来的值拿出来用，这时候 a = 10</li><li>后面就是常规的执行代码了</li></ul><h3 id="常用的定时器函数"><a href="#常用的定时器函数" class="headerlink" title="常用的定时器函数"></a>常用的定时器函数</h3><p>相关面试题：setTimeout、setInterval、requestAnimationFrame 各有什么特点？</p><h4 id="requestAnimationFrame"><a href="#requestAnimationFrame" class="headerlink" title="requestAnimationFrame"></a><strong>requestAnimationFrame</strong></h4><p>请求动画帧。屏幕刷新频率，也就是屏幕上的图像每秒钟出现的次数，它的单位是赫兹（HZ）。当对着电脑屏幕什么也不做的情况下，显示器也会以每秒60次的频率在不断更新屏幕上的图像。我们之所以感觉不到变化的原因是因为人的眼睛有视觉停留效应，画之间间隔时间只有16.7ms（1000/60)，所以我们会觉得屏幕上的图像是静止不动的。</p><p>动画的本质就是要让人眼看到图像被刷新而引起的变化的视觉效果，这个变化要以连贯的平滑的方式过渡。</p><p>我们在每次刷新前，将图像的位置移动一个像素，这样一来，屏幕每次刷新出来的图像位置都比前一个要差一个像素。因为你会看到图像在移动，由于人眼的视觉停留效应，当前位置的图像停留在大脑的影响还没有消失，紧接着图像又被移到了下一个位置，因为你会看到图像在流畅地移动，这就是视觉效果上形成的动画。</p><p>requestAnimationFrame最大的优势就是系统决定的回调函数的执行时机，大概的意思就是回调函数会随着屏幕刷新的频率的变化而产生对应的变化。它能保证回调函数在屏幕每一次的刷新间隔中只执行一次，这样就不会引起丢帧现象，也不会导致动画出现卡顿的问题。</p><p>简单的调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> progress = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    progress +=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(progress&lt;<span class="number">100</span>)&#123;</span><br><span class="line">        <span class="built_in">window</span>.requestAnimationFrame(render)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一帧渲染</span></span><br><span class="line"><span class="built_in">window</span>.requestAnimationFrame(render);</span><br></pre></td></tr></table></figure><p>另外它还有两个优势：</p><ul><li>Cpu节能：使用 setTimeout 实现的动画，当页面被隐藏到最小化时，仍然会在后台执行动画人物，由于此时页面处于不可见或者不可用状态，刷新画面也是没有意义的，完全是浪费资源。而 requestAnimationFrame 则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新人物也会被系统暂停，有效节省CPU 开销</li><li>函数节流：在高频率（resize,scroll）中吗，为了防止在一个刷新间隔内发生多出函数执行，使用 requestAnimationFrame 可以保证每个刷新的间隔内，函数只被执行一次，这样既可以保证流畅性，也能更好的节省函数执行的开销。一个刷新间隔内函数执行多次是没有意义的，因为显示器刷新的频率是一定的，多次绘制不会在屏幕上体现出来。</li></ul><p>由于浏览器兼容问题，需要优雅降级做兼容，具体代码,摘自 <a href="https://github.com/darius/requestAnimationFrame/blob/master/requestAnimationFrame.js">requestAnimationFrame</a>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!<span class="built_in">Date</span>.now) &#123;</span><br><span class="line">  <span class="built_in">Date</span>.now = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> vendors = [<span class="string">'webkit'</span>, <span class="string">'moz'</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; vendors.length &amp;&amp; !<span class="built_in">window</span>.requestAnimationFrame; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> vp = vendors[i];</span><br><span class="line">    <span class="built_in">window</span>.requestAnimationFrame = <span class="built_in">window</span>[vp + <span class="string">'RequestAnimationFrame'</span>];</span><br><span class="line">    <span class="built_in">window</span>.cancelAnimationFrame = <span class="built_in">window</span>[vp + <span class="string">'CancelAnimationFrame'</span>] || <span class="built_in">window</span>[vp + <span class="string">'CancelRequestAnimationFrame'</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/iP(ad|hone|od).*OS 6/</span>.test(<span class="built_in">window</span>.navigator.userAgent) || !<span class="built_in">window</span>.requestAnimationFrame || !<span class="built_in">window</span>.cancelAnimationFrame) &#123;</span><br><span class="line">      <span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">window</span>.requestAnimationFrame = <span class="function"><span class="keyword">function</span> (<span class="params">cb</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> now = <span class="built_in">Date</span>.now();</span><br><span class="line">        <span class="keyword">var</span> nextTime = <span class="built_in">Math</span>.max(lastTime + <span class="number">16</span>, now);</span><br><span class="line">        <span class="keyword">return</span> setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          cb(lastTime = nextTime)</span><br><span class="line">        &#125;, nextTime - now)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">window</span>.cancelAnimationFrame = clearTimeout;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h4 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a><strong>setTimeout</strong></h4><p>设置某个时间后执行某个动作，表示延时执行某个动作</p><h4 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a><strong>setInterval</strong></h4><p>设置每隔多久执行某个动作，循环的。setInterval 将注册函数植入 Event Queue,如果前面的任务耗能太久，那么就需要等待。</p><p>因为JS 单线程的问题，setTimeout 可能不会按期执行，可以通过代码去修正 setTimeout ，从而使定时器相对准确</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> period = <span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> end = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime + period;</span><br><span class="line"><span class="keyword">let</span> interval = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">let</span> currentInterval = interval;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  count++;</span><br><span class="line">  <span class="comment">// 代码执行所消耗的时间</span></span><br><span class="line">  <span class="keyword">let</span> offset = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - (startTime + count * interval);</span><br><span class="line">  <span class="keyword">let</span> diff = end - <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="keyword">let</span> h = <span class="built_in">Math</span>.floor(diff / (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>))</span><br><span class="line">  <span class="keyword">let</span> hdiff = diff % (<span class="number">60</span> * <span class="number">1000</span> * <span class="number">60</span>);</span><br><span class="line">  <span class="keyword">let</span> m = <span class="built_in">Math</span>.floor(hdiff / (<span class="number">60</span> * <span class="number">1000</span>));</span><br><span class="line">  <span class="keyword">let</span> mdiff = hdiff % (<span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">let</span> s = mdiff / (<span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">let</span> sCeil = <span class="built_in">Math</span>.ceil(s);</span><br><span class="line">  <span class="keyword">let</span> sFloor = <span class="built_in">Math</span>.floor(s);</span><br><span class="line">  <span class="comment">// 得出下一次循环所消耗的时间</span></span><br><span class="line">  currentInterval = interval - offset;</span><br><span class="line">  setTimeout(loop, currentInterval);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'时：'</span> + h, <span class="string">'分：'</span> + m, <span class="string">'毫秒：'</span> + s, <span class="string">'秒向上取整：'</span> + sCeil, <span class="string">'代码执行时间：'</span> + offset, <span class="string">'下次循环间隔'</span> + currentInterval)</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(loop, currentInterval)</span><br></pre></td></tr></table></figure><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>Proxy 是 ES6 中新增的功能，可以用来自定义对象中的操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target,handler)</span><br><span class="line"><span class="comment">// target 代表需要添加代理的对象</span></span><br><span class="line"><span class="comment">// Handler 用来自定义对象中的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以很方便使用 Proxy 来实现一个数据的绑定和监听</span></span><br><span class="line"><span class="keyword">let</span> onWatch = <span class="function">(<span class="params">obj,setBind,getLogger</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> handler = &#123;</span><br><span class="line">        get(target,property,receiver)&#123;</span><br><span class="line">            getLogger(target,property)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target,property,receiver);</span><br><span class="line">        &#125;,</span><br><span class="line">        set(target,property,value,receiver)&#123;</span><br><span class="line">            setBind(value);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target,property,value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj,handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> value;</span><br><span class="line"><span class="keyword">let</span> pw = onWatch(obj,(v)=&gt;&#123;</span><br><span class="line">    value = v</span><br><span class="line">&#125;,(target,property)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Get <span class="subst">$&#123;property&#125;</span> = <span class="subst">$&#123;target[property]&#125;</span>`</span>);</span><br><span class="line">&#125;)</span><br><span class="line">pw.a = <span class="number">2</span>; <span class="comment">// bind value to 2</span></span><br><span class="line">pw.a <span class="comment">// get a = 2</span></span><br></pre></td></tr></table></figure><h3 id="为什么-0-1-0-2-0-3"><a href="#为什么-0-1-0-2-0-3" class="headerlink" title="为什么 0.1 + 0.2 != 0.3"></a>为什么 0.1 + 0.2 != 0.3</h3><p>因为 JS 采用 IEEE 754 双精度版本（64位）,并且只要采用 IEEE 754 的语言都有该问题</p><p>原生解决方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>((<span class="number">0.1</span>+<span class="number">0.2</span>).toFixed(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h4><table><thead><tr><th>元字符</th><th>作用</th></tr></thead><tbody><tr><td>.</td><td>匹配任意字符除了换行符和回车符</td></tr><tr><td>[]</td><td>匹配方括号内的任意字符。比如 [0-9] 就可以用来匹配任意数字</td></tr><tr><td>^</td><td>^9 这样使用匹配以 9 开头，[^9] 这样使用代表不匹配方括号内除了9的字符</td></tr><tr><td>{1,2}</td><td>匹配1到2位字符</td></tr><tr><td>(yck)</td><td>只匹配 yck 相同字符串</td></tr><tr><td>\</td><td></td><td>匹配 \</td><td>前后任意字符</td></tr><tr><td>\</td><td>转义</td></tr><tr><td>*</td><td>只匹配出现0次及以上 *前的字符</td></tr><tr><td>+</td><td>只匹配出现1次及以上 +前的字符</td></tr><tr><td>?</td><td>？ 之前字符可选</td></tr></tbody></table><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><table><thead><tr><th>修饰语</th><th>作用</th></tr></thead><tbody><tr><td>i</td><td>忽略大小写</td></tr><tr><td>g</td><td>全局搜索</td></tr><tr><td>m</td><td>多行</td></tr></tbody></table><h4 id="字符简写"><a href="#字符简写" class="headerlink" title="字符简写"></a>字符简写</h4><table><thead><tr><th>简写</th><th>作用</th></tr></thead><tbody><tr><td>\w</td><td>匹配字母数字或下划线</td></tr><tr><td>\W</td><td>与上面相反</td></tr><tr><td>\s</td><td>匹配任意的空白符</td></tr><tr><td>\S</td><td>与上面相反</td></tr><tr><td>\d</td><td>匹配数字</td></tr><tr><td>\D</td><td>与上面相反</td></tr><tr><td>\b</td><td>匹配单词的开始或结束</td></tr><tr><td>\B</td><td>与上面相反</td></tr></tbody></table><h3 id="V8下的垃圾回收机制"><a href="#V8下的垃圾回收机制" class="headerlink" title="V8下的垃圾回收机制"></a>V8下的垃圾回收机制</h3><p>V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为了新生代和老生代两部分</p><h4 id="新生代算法"><a href="#新生代算法" class="headerlink" title="新生代算法"></a>新生代算法</h4><p>新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。</p><p>在新生代空间中，内存空间分为了两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满的时候，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成将 From 空间和 To 空间互换，这样 GC 就结束了。</p><h4 id="老生代算法"><a href="#老生代算法" class="headerlink" title="老生代算法"></a>老生代算法</h4><p>老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。</p><p>什么情况下对象会出现在老生代空间中：</p><ul><li>新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。</li><li>To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中</li></ul><p>老生代中的空间很复杂，有如下几个空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">enum AllocationSpace &#123;</span><br><span class="line">  // TODO(v8:7464): Actually map this space's memory as read-only.</span><br><span class="line">  RO_SPACE,    // 不变的对象空间</span><br><span class="line">  NEW_SPACE,   // 新生代用于 GC 复制算法的空间</span><br><span class="line">  OLD_SPACE,   // 老生代常驻对象空间</span><br><span class="line">  CODE_SPACE,  // 老生代代码对象空间</span><br><span class="line">  MAP_SPACE,   // 老生代 map 对象</span><br><span class="line">  LO_SPACE,    // 老生代大空间对象</span><br><span class="line">  NEW_LO_SPACE,  // 新生代大空间对象</span><br><span class="line"></span><br><span class="line">  FIRST_SPACE = RO_SPACE,</span><br><span class="line">  LAST_SPACE = NEW_LO_SPACE,</span><br><span class="line">  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,</span><br><span class="line">  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在老生代中，以下情况会先启动标记清除算法：</p><ul><li>某一个空间没有分块的时候</li><li>空间中被对象超过一定限制</li><li>空间不能保证新生代中的对象移动到老生代中</li></ul><p>在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行，你可以点击 <a href="https://v8project.blogspot.com/2018/06/concurrent-marking.html">该博客</a> 详细阅读。</p><p>清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象像一端移动，直到所有对象都移动完成然后清理掉不需要的内存。</p><h3 id="Event-Loop"><a href="#Event-Loop" class="headerlink" title="Event Loop"></a>Event Loop</h3><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p>两个名词都是 CPU 工作时间片的一个描述。</p><p>进程描述了 CPU 在运行指令以及记载和保存上下文所需的时间，放在应用上来说就代表了一个程序。</p><p>线程是进程中更小的单位，描述了一段指令所需要的时间。</p><p>在浏览器中，打开一个 Tab 页面，就是创建了一个进程，一个进程里面可以有多个线程，例如渲染线程，JS 引擎线程，HTTP 请求线程。当发起一个请求时，就是在创建一个线程，当请求结束的时候，该线程就可能会被销毁掉。</p><p>众所周知，JS 运行时会阻止 UI 渲染，这两个线程是互斥的，因为 JS 可以修改 Dom ，如果在 JS 执行的时候 Ui 线程还在工作，就可能会导致不能正常安全渲染 UI。这也是单线程的一个好处，得益于 JS 是单线程与很像的，可以达到节省呢欧村，节约上下文切换时间，没有锁的问题的好处。</p><h4 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h4><p>可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则</p><h4 id="浏览器中的-Event-Loop"><a href="#浏览器中的-Event-Loop" class="headerlink" title="浏览器中的 Event Loop"></a>浏览器中的 Event Loop</h4><p>当遇到异步代码的时候，会被挂起并在需要执行的时候加入到 Task  队列中。一旦执行栈为空，Event Loop 就会从 Task 队列中拿出需要你执行的代码并放入执行栈中执行，所以本质上 JS 中的异步还是同步行为。</p><p>不同的任务源会被分配到不同的 Task 队列中，任务源可以分成 微任务（mocrotask） 和 宏任务（macrotask)。在 ES6 规范中，macrotask 被称为 task,microtask 被称为 jobs 。下面举个例子看看代码的执行顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2 end'</span>)</span><br><span class="line">&#125;</span><br><span class="line">async1()</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Promise'</span>)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>)</span><br></pre></td></tr></table></figure><p>当我们调用 async1 函数的时候，会马上输出 async2 end,并且函数返回一个 Promise，接下来在遇到 await 的时候就让出线程开始执行 async1 外的代码，可以完全把 await 看成是让出线程的标志。</p><p>然后当同步代码全部执行完毕以后，就会执行所有的异步代码，那么就会又回到 await 的位置执行返回的 Promise 的 resolve 函数，这又会把 resolve 丢到微任务队列中，接下来执行 then 中的回调，当两个 then 中的回调全部执行完毕后，回到 await 的位置处理返回值，这时候可以看成 <code>Promise.resolve(返回值).then()</code>，然后 await 后的代码全部被包裹进了 then 的回调中，所以 <code>console.log(&#39;async1 end&#39;)</code> 会优先执行于 <code>setTimeout</code>。</p><p>微任务包括 <code>process.nextTick</code> ，<code>promise</code> ，<code>MutationObserver</code>。</p><p>宏任务包括 <code>script</code> ， <code>setTimeout</code> ，<code>setInterval</code> ，<code>setImmediate</code> ，<code>I/O</code> ，<code>UI rendering</code>。</p><p>Event Loop 执行顺序如下所示：</p><ul><li>首先执行同步代码，这属于宏任务</li><li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li><li>执行所有微任务</li><li>当执行完所有微任务后，如有必要会渲染页面</li><li>然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 <code>setTimeout</code> 中的回调函数</li></ul><p>Node 中的 Event Loop</p><p>涉及的面试题：Node 中 Event Loop 和 浏览器的有什么不同？process.nextTick 执行顺序</p><p>Node 中的 Event Loop 分成6个阶段，它们会按照顺序反复运行，每当进入某一个阶段的时候，都会从对应的回调队列取出函数去执行。当队列为空或者执行的回调函数数量达到系统设定的阈值，就会进入下一个阶段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">┌──────────────────────────┐</span><br><span class="line">┌─&gt;│        timers         │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     I/O callbacks     │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">│  │     idle, prepare     │</span><br><span class="line">│  └──────────┬────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌──────────┴────────────┐      │   incoming:   │</span><br><span class="line">│  │         poll          │&lt;──connections───     │</span><br><span class="line">│  └──────────┬────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌──────────┴────────────┐      └───────────────┘</span><br><span class="line">│  │        check          │</span><br><span class="line">│  └──────────┬────────────┘</span><br><span class="line">│  ┌──────────┴────────────┐</span><br><span class="line">└──┤    close callbacks    │</span><br><span class="line">   └───────────────────────┘</span><br></pre></td></tr></table></figure><p><strong>timer</strong></p><p>timer 阶段会执行 setTimeout 和 setInerval 回调，并是由 poll 阶段控制的</p><p> 同样，在 Node 中定时器指定的时间也不是准确的时间，只是尽快执行。</p><p><strong>I/O</strong></p><p>I/O 阶段会处理上一轮循环中少数未执行的的 I/O 回调</p><p><strong>dle,prepare</strong></p><p>idle,prepare 阶段内部实现</p><p><strong>poll</strong></p><p>poll 阶段很重要，在这一阶段中，系统会做两件事情</p><ol><li>执行到点的定时器</li><li>执行 poll 队列中的事件</li></ol><p>并且当 poll 中没有定时器的情况下，会发现以下两件事情</p><ul><li>如果poll队列不为空，会遍历回调队列并同步执行，直到队列为空或者系统限制</li><li>如果poll队列为空,会发生两件事情<ul><li>如果有 setImmediate 需要执行的时候，poll 阶段会停止并且进入到 check 阶段执行 setImmediate</li><li>如果没有 setImmediate 需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</li></ul></li></ul><p>当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</p><p><strong>check</strong></p><p>check 阶段执行 <code>setImmediate</code></p><p><strong>close callbacks</strong></p><p>close callbacks 阶段执行了 close 事件。</p><p>首先在有些情况下，定时器的执行顺序其实是<strong>随机</strong>的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;setTimeout&apos;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">setImmediate(() =&gt; &#123;</span><br><span class="line">    console.log(&apos;setImmediate&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于以上代码来说，<code>setTimeout</code> 可能执行在前，也可能执行在后</p><ul><li>首先 <code>setTimeout(fn, 0) === setTimeout(fn, 1)</code>，这是由源码决定的</li><li>进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 <code>setTimeout</code> 回调</li><li>那么如果准备时间花费小于 1ms，那么就是 <code>setImmediate</code> 回调先执行了</li></ul><p>当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：</p><p>当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const fs = require(&apos;fs&apos;)</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, () =&gt; &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;timeout&apos;);</span><br><span class="line">    &#125;, 0)</span><br><span class="line">    setImmediate(() =&gt; &#123;</span><br><span class="line">        console.log(&apos;immediate&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>setImmediate</code> 永远<strong>先执行</strong>。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 <code>setImmediate</code> 回调，所以就直接跳转到 check 阶段去执行回调了。</p><p><strong>process.nextTick</strong></p><p>这个函数是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成之后，如果存在 nextTick 阶段，就会清空队列中的所有回调函数，并优于其他 microtask 执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'timer1'</span>)</span><br><span class="line"></span><br><span class="line"> <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'promise1'</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line"> process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">   process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">     process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'nextTick'</span>)</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// nextTick</span></span><br><span class="line"><span class="comment">// nextTick</span></span><br><span class="line"><span class="comment">// nextTick</span></span><br><span class="line"><span class="comment">// nextTick</span></span><br><span class="line"><span class="comment">// timer1</span></span><br><span class="line"><span class="comment">// promise1</span></span><br></pre></td></tr></table></figure><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/blob/master/datum/summary.md">前端面试题目已经答案汇总</a></p><p><a href="https://yuchengkai.cn/docs/frontend/#%E9%98%B2%E6%8A%96">防抖</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;温故而知新，保持空杯心态,复习到一半的时间，突然发现了 &lt;a href=&quot;https://yuchengkai.cn/docs/frontend&quot;&gt;前端面试之道&lt;/a&gt;，从第二道题目开始按学习这本书的路径来&lt;/p&gt;
&lt;h2 id=&quot;JS-基础2&quot;&gt;&lt;a href=&quot;#JS-
      
    
    </summary>
    
      <category term="前端面试" scheme="http://laibh.top/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="前端面试题" scheme="http://laibh.top/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Mongoose</title>
    <link href="http://laibh.top/2019-03-26-mongoose.html"/>
    <id>http://laibh.top/2019-03-26-mongoose.html</id>
    <published>2019-03-26T08:30:00.000Z</published>
    <updated>2019-10-15T09:29:49.415Z</updated>
    
    <content type="html"><![CDATA[<p>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。</p><p>Mongoose是在node.js环境下对mongodb进行便捷操作的对象模型工具</p><p><a href="https://cn.mongoosedoc.top/docs/guide.html">学习链接</a></p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p><em>请先安装 MongoDB 和 Node.js。</em></p><p>下一步，<code>npm</code>安装Mongoose:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mongoose</span><br></pre></td></tr></table></figure><p>连接数据库test</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line">mongoose.connect(<span class="string">'mongodb://localhost/test'</span>);</span><br></pre></td></tr></table></figure><p><code>connect()</code>返回一个状态待定（pending）的连接，接着我们加上成功和失败的提醒：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db = mongoose.connection;</span><br><span class="line">db.on(<span class="string">'error'</span>,<span class="built_in">console</span>.error.bind(<span class="built_in">console</span>,<span class="string">'connection error:'</span>));</span><br><span class="line">db.once(<span class="string">'open'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// .. </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>连接成功的时候，回调函数会被调用，假设下面所有函数都在这个回调函数里面。</p><p>Mongoose 里面一切始于 Schema。看一个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> KittySchema = mongoose.Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们得到了一个带有 <code>String</code>类型的 <code>name</code> 属性的 schema,接着把这个 schema 编译成一个 Model:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Kitten = mongoose.model(<span class="string">'Kitten'</span>,kittySchema);</span><br></pre></td></tr></table></figure><p>model 是我们创造的 document 的 Class。在例子中，每个 document 都是一个实例，它的属性和行为都会被声明在 schema 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> felyne = <span class="keyword">new</span> Kitten(&#123;<span class="attr">name</span>:<span class="string">'Felyne'</span>&#125;);</span><br><span class="line">felyne.name <span class="comment">// 'Felyne';</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 document 加一个 speak 方法</span></span><br><span class="line">KittySchema.methods.speak = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> greeting = <span class="keyword">this</span>.name ?  <span class="string">"Meow name is "</span> + <span class="keyword">this</span>.name: <span class="string">"I don't have a name"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(greeting);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Kitten = mongoose.model(<span class="string">'Kitten'</span>,kittySchema);</span><br></pre></td></tr></table></figure><p>加在 schema 的 <code>methods</code> 属性的函数会编译到 <code>Model</code> 的prototype,也会暴露搭配每个 document 实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Kitten(&#123;<span class="attr">name</span>:<span class="string">'A'</span>&#125;);</span><br><span class="line">a.speak(); <span class="comment">// Meow name is A</span></span><br></pre></td></tr></table></figure><p>每个 document 会在调用它的 save 方法后保存到数据库中，注意回调函数的第一个参数永远是 error</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A.save(<span class="function"><span class="keyword">function</span>(<span class="params">err,A</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    A.speak();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果有很多个实例，可以用下面的方法来获取 model 里面的所有数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Kitten.find(<span class="function"><span class="keyword">function</span>(<span class="params">err,kittens</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> <span class="built_in">console</span>.error(err);</span><br><span class="line">    <span class="built_in">console</span>.log(kittens);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="模式（Schemas）"><a href="#模式（Schemas）" class="headerlink" title="模式（Schemas）"></a>模式（Schemas）</h2><h4 id="定义一个schema"><a href="#定义一个schema" class="headerlink" title="定义一个schema"></a>定义一个schema</h4><p>Mongoose 的一切始于 Schema,每个 schama 都会映射到一个 MongoDB collection，并定义这个 collection 里面的文档的构成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema;</span><br><span class="line"><span class="keyword">const</span> blog = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    title:<span class="built_in">String</span>,</span><br><span class="line">    author:<span class="built_in">String</span>,</span><br><span class="line">    body:<span class="built_in">String</span>,</span><br><span class="line">    comments:[&#123;<span class="attr">body</span>:<span class="built_in">String</span>,<span class="attr">date</span>:<span class="built_in">Date</span>&#125;],</span><br><span class="line">    date:&#123;</span><br><span class="line">        type:<span class="built_in">Date</span>,</span><br><span class="line">        defalut:<span class="built_in">Date</span>.now</span><br><span class="line">    &#125;,</span><br><span class="line">    hidden:<span class="built_in">Boolean</span>,</span><br><span class="line">    meta:&#123;</span><br><span class="line">        votes:<span class="built_in">Number</span>,</span><br><span class="line">        favs:<span class="built_in">Number</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>document 里面的每个属性都会被转换成在 blogSchema 里面对应的 SchemaType。例如 <code>title</code> 属性会被转换成为 SchemaType String,而 <code>date</code>属性会被转换成为 SchemaType Date。还可以像 <code>meta</code>属性一样，更加详细地指定嵌套在里面的属性类型。</p><p>运行使用的 SchemaTypes 有：</p><ul><li>String</li><li>Number</li><li>Boolean</li><li>Date</li><li>Buffer</li><li>Mixed</li><li>ObjectId</li><li>Array</li></ul><p>Schema 的功能不只是定义文档结构和属性类型，还可以定义</p><ul><li>document 的 instance methods</li><li>model 的 static Model methods</li><li>复合索引</li><li>文档的生命周期钩子，也称为中间件</li></ul><h4 id="创建一个-model"><a href="#创建一个-model" class="headerlink" title="创建一个 model"></a>创建一个 model</h4><p><code>mongoose.model(modelName,schema)</code> 函数把 schema 转换为一个 Model:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Blog = mongoose.model(<span class="string">'Blob'</span>,blogSchema);</span><br></pre></td></tr></table></figure><h4 id="实例方法（method）"><a href="#实例方法（method）" class="headerlink" title="实例方法（method）"></a>实例方法（method）</h4><p>document 是 Models 的实例。Document 有很多自带的实例方法，当然也可以自定义我们自己的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个 schema</span></span><br><span class="line"><span class="keyword">const</span> animalSchema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>,<span class="attr">type</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line"></span><br><span class="line">animalSchema.methods.findSimilarTypes = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.model(<span class="string">'Animal'</span>).find(&#123;<span class="attr">type</span>:<span class="keyword">this</span>.type&#125;,cb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在所有的 <code>animal</code> 实例都有 <code>findSimilarTypes</code> 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Animal = mongoose.model(<span class="string">'Animal'</span>,animalSchema);</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> Animal(&#123;type：<span class="string">'dog'</span>&#125;);</span><br><span class="line"></span><br><span class="line">dog.findSimilarTypes(<span class="function"><span class="keyword">function</span>(<span class="params">err,dogs</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(dogs); <span class="comment">// woof</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>重写 mongoose 的默认方法会造成无法预料的结果</li><li>不要在自定义方法中使用 ES6 箭头函数，会造成 this 指向错误</li></ul><h4 id="静态方法（static）"><a href="#静态方法（static）" class="headerlink" title="静态方法（static）"></a>静态方法（static）</h4><p>添加 <code>Model</code> 的静态方法也十分简单，继续使用 <code>animalSchema</code> 举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">animalSchema.statics.findByName = <span class="function"><span class="keyword">function</span>(<span class="params">name,cb</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.find(&#123;<span class="attr">name</span>:<span class="keyword">new</span> <span class="built_in">RegExp</span>(name,<span class="string">'i'</span>)&#125;,cb)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Animal = mongoose.model(<span class="string">'Animal'</span>,animalSchema);</span><br><span class="line">Animal.findByName(<span class="string">'fido'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,animals</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animals);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>同样注意的是不要在静态方法中使用 ES6 的箭头函数</p><h4 id="查询助手（query-helper）"><a href="#查询助手（query-helper）" class="headerlink" title="查询助手（query helper）"></a>查询助手（query helper）</h4><p>查询助手作用于 query 实例，方便自定义扩展链式查询</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">animalSchema.query.byName = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.find(&#123;<span class="attr">name</span>:<span class="keyword">new</span> <span class="built_in">RegExp</span>(name,<span class="string">'i'</span>)&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Animal = mongoose.model(<span class="string">'Animal'</span>,animalSchema);</span><br><span class="line">Animal.find().byName(<span class="string">'fido'</span>).exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,animal</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(animals);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="索引（index）"><a href="#索引（index）" class="headerlink" title="索引（index）"></a>索引（index）</h4><p>MongoDB 支持 secondary indexes。在 mongoose 中，我们在 Schema 定义索引。索引分字段级别和 schema 级别，复合索引需要在 schema 级别定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> animalSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    type:<span class="built_in">String</span>,</span><br><span class="line">    tags:&#123;</span><br><span class="line">        type:[<span class="built_in">String</span>],</span><br><span class="line">        index:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">animalSchema.index(&#123;<span class="attr">name</span>:<span class="number">1</span>,<span class="attr">type</span>:<span class="number">-1</span>&#125;);</span><br></pre></td></tr></table></figure><p>应用启动的时候，Mongoose 会自动调用 <code>createIndex</code> 初始化定义的索引。Mongoose 顺序处理每一个 createIndex，然后在 model 触发 ‘index’ 事件。在生产中建议禁止这种行为，因为创建索引会对性能造成重大影响。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://user:pass@localhost:port/database'</span>,&#123;<span class="attr">autoIndex</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">mongoose.createConnection(<span class="string">'mongodb://user:pass@localhost:port/database'</span>,&#123;<span class="attr">autoIndex</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">autoIndex</span>:<span class="literal">false</span>&#125;);</span><br></pre></td></tr></table></figure><p>索引创建完成或者失败，Mongoose 会触发 index 事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Will cause an error because mongodb has an _id index by default that is not sparse</span></span><br><span class="line">animalSchema.index(&#123;<span class="attr">_id</span>:<span class="number">1</span>&#125;,&#123;<span class="attr">sparse</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Animal = mongoose.model(<span class="string">'Animal'</span>,animalSchema);</span><br><span class="line">Animal.on(<span class="string">'index'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// _id index cannot be sparse</span></span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="虚拟值（Virtual）"><a href="#虚拟值（Virtual）" class="headerlink" title="虚拟值（Virtual）"></a>虚拟值（Virtual）</h4><p>Virtual 是 document 的属性，但是不会被保存到 MongoDB.getter 可以用于格式化和组合字段数据，setter 可以很方便地分解一个值到多个字段。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> personSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        first:<span class="built_in">String</span>,</span><br><span class="line">        last:<span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Person = mongoose.model(<span class="string">'Person'</span>,personSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> axl = <span class="keyword">new</span> Person(&#123;</span><br><span class="line">    name:&#123;<span class="attr">first</span>:<span class="string">'Axl'</span>,<span class="attr">last</span>:<span class="string">'Rose'</span>&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(axl.name.first + <span class="string">' '</span> + axl.name.last); <span class="comment">//Axl Rose</span></span><br></pre></td></tr></table></figure><p>但是每次都要这样拼接就太麻烦了，使用 virtual property getter 这个方法允许定义一个 fullName 属性，但不必保存到数据库。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">personSchema.virtual(<span class="string">'fullName'</span>).get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name.first + <span class="string">' '</span> + <span class="keyword">this</span>.name.last</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(axl.fullName); <span class="comment">// Axl Rose</span></span><br></pre></td></tr></table></figure><p>如果对 document 使用 <code>toJSON（）</code> 或 <code>toObject()</code> 默认不包括虚拟值，需要额外向 toObject 或者 toJSON 传入参数 <code>{virtuals:true}</code></p><p>也可以设定虚拟值的 setter，下面的例子中，当赋值到虚拟值的时候，会自动拆分到其他属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">personSchema.virtual(<span class="string">'fullName'</span>).get(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name.first + <span class="string">' '</span> + <span class="keyword">this</span>.name.last</span><br><span class="line">&#125;).set(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name.first = v.substr(<span class="number">0</span>,v.indexOf(<span class="string">' '</span>));</span><br><span class="line">    <span class="keyword">this</span>.name.last = v.substr(v.indexOf(<span class="string">' '</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line">axl.fullName = <span class="string">'William Rose'</span> <span class="comment">// Now `axl.name.first` is "William"</span></span><br></pre></td></tr></table></figure><p>需要注意的是，虚拟值不能用于查询和字段选择，因为虚拟值不存储在 MongoDB</p><h4 id="别名（Alias）"><a href="#别名（Alias）" class="headerlink" title="别名（Alias）"></a>别名（Alias）</h4><p>Aliase 是一种特殊的虚拟值，它的getter 和 setter 会无缝链接到另一个值，这是一个节省带宽的做法，可以存储一个更短的属性名到数据库，同时在调用的时候保持可读性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> personSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    n:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        alias:<span class="string">'name'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(&#123;<span class="attr">name</span>:<span class="string">'Val'</span>&#125;);</span><br><span class="line">person <span class="comment">//&#123;n:'Val'&#125;</span></span><br><span class="line">person.toObject(&#123;<span class="attr">virtuals</span>:<span class="literal">true</span>&#125;) <span class="comment">//&#123;n:'Val',name:'Val'&#125;</span></span><br><span class="line">person.name <span class="comment">// Val</span></span><br><span class="line">person.name = <span class="string">'Not Val'</span>;</span><br><span class="line">person <span class="comment">// &#123;n:'Not Val'&#125;</span></span><br></pre></td></tr></table></figure><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><p>Schema 有很多可配置选项，可以在构造时传入或者直接 set</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Schema(&#123;...&#125;,options);</span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;...&#125;);</span><br><span class="line"></span><br><span class="line">schema.set(option,value);</span><br></pre></td></tr></table></figure><p>有效的选项：</p><ul><li>autoIndex</li><li>bufferCommands</li><li>capped</li><li>collection</li><li>id</li><li>_id</li><li>minimize</li><li>read</li><li>shardKey</li><li>strict</li><li>strictQuery</li><li>toJSON</li><li>toObject</li><li>typekey</li><li>validateBeforeSave</li><li>versionKey</li><li>skipVersioning</li><li>timestamps</li><li>useNestedStrict</li></ul><p><strong>option：autoIndex</strong></p><p>应用启动的时候，Mongoose 自动发送 <code>createIndex</code> 指令，schema 里面的每个 index 都会被创建，如果需要关闭自动创建功能或者需要在创建后进行一系列操作，可以把 <code>autoIndex</code> 设为 <code>false</code>，然后对 model 调用 ensureIndexes：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">autoIndex</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Clock = mongoose.model(<span class="string">'Clock'</span>,schema);</span><br><span class="line">Clock.ensureIndexes(callback);</span><br></pre></td></tr></table></figure><p><strong>option：bufferCommands</strong></p><p>默认情况下，mongoose buffers会在连接中断时发出命令，直到驱动程序重新连接为止。若要禁用缓冲，请将bufferCommands设置为false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">bufferCommands</span>:<span class="literal">false</span>&#125;);</span><br></pre></td></tr></table></figure><p>schema 的bufferCommands 会重写全局的 bufferCommands 选项。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mongoose.set(<span class="string">'bufferCommands'</span>,<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">bufferCommands</span>:<span class="literal">false</span>&#125;);</span><br></pre></td></tr></table></figure><p><strong>option：capped</strong></p><p>Mongoose 支持 MongoDB 的 capped collections ，要从底层把 collection 设定为 capped(封顶)，可以把collection 的最大容量设定到 <code>capped</code> 选项（单位 bytes）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">capped</span>:<span class="number">1024</span>&#125;);</span><br></pre></td></tr></table></figure><p>如果要传递多个选项，capped 也可以作为对象传递.这个试试需要显式传入必要值 <code>size</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">size</span>:<span class="number">1024</span>,<span class="attr">max</span>:<span class="number">1000</span>,<span class="attr">autoIndexId</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p><strong>option：collection</strong></p><p>Mongoose 通过 utils.toCollectionName 方法，默认生成 collection 的名称（生成 model 名称的复数形式）。设置这个选项可以自定义名称</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dataSchema = <span class="keyword">new</span> Schema(&#123;..&#125;,&#123;<span class="attr">collection</span>:<span class="string">'data'</span>&#125;);</span><br></pre></td></tr></table></figure><p><strong>option：id</strong></p><p>Mongoose 会默认生成一个虚拟值 <code>id</code>，指向文档的 <code>_id</code>字段。如果你不需要 <code>id</code> 虚拟值，可以通过这个选项禁用此功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认行为</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Page = mongoose.model(<span class="string">'Page'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Page(&#123;<span class="attr">name</span>:<span class="string">'mongodb.org'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p.id); <span class="comment">// 50341373e894ad16347efe01</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//禁止 id</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;,&#123;<span class="attr">id</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Page = mongoose.model(<span class="string">'Page'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Page(&#123;<span class="attr">name</span>:<span class="string">'mongodb.org'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p.id); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p><strong>option：_id</strong></p><p>Mongoose 默认给你的 Schema 赋值一个 <code>_id</code>，这个值的类型是 ObjectId，这与 MongoDB 的默认表现一致。如果需要，可以禁止</p><p>此选项<strong>只能</strong>用于 subdocument。 Mongoose 不能保存没有id的文档，如果硬是要这么做，会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认行为</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Page = mongoose.model(<span class="string">'Page'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Page(&#123;<span class="attr">name</span>:<span class="string">'mongodb.org'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// &#123; _id: '50341373e894ad16347efe01', name: 'mongodb.org' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 禁止 _id</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;,&#123;<span class="attr">_id</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Page = mongoose.model(<span class="string">'Page'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Page(&#123;<span class="attr">name</span>:<span class="string">'mongodb.org'</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// &#123; name: 'mongodb.org' &#125;</span></span><br></pre></td></tr></table></figure><p><strong>option：minimize</strong></p><p>Mongoose 默认不保存空对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>,<span class="attr">inventory</span>:&#123;&#125;&#125;);</span><br><span class="line"><span class="keyword">const</span> Character = mongoose.model(<span class="string">'Character'</span>,schema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> frodo = <span class="keyword">new</span> Character(&#123;<span class="attr">name</span>:<span class="string">'Frodo'</span>,<span class="attr">inventory</span>:&#123;<span class="attr">ringOfPower</span>:<span class="number">1</span>&#125;&#125;);</span><br><span class="line">Character.findOne(&#123;<span class="attr">name</span>:<span class="string">'Frodo'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,character</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(character); <span class="comment">// &#123;name: 'Frodo', inventory: &#123; ringOfPower: 1 &#125;&#125;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Sam = <span class="keyword">new</span> Character(&#123;<span class="attr">name</span>:<span class="string">'Sam'</span>,<span class="attr">inventory</span>:&#123;&#125;&#125;);</span><br><span class="line">Character.findOne(&#123;<span class="attr">name</span>:<span class="string">'Sam'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,character</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(character); <span class="comment">// &#123;name: 'Sam'&#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果把 minimize 设定为 false,Mongoose 将保存空对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sam = <span class="keyword">new</span> Character(&#123;<span class="attr">name</span>:<span class="string">'Sam'</span>,<span class="attr">inventory</span>:&#123;&#125;&#125;,&#123;<span class="attr">minimize</span>:<span class="literal">false</span>&#125;);</span><br><span class="line">Character.findOne(&#123;<span class="attr">name</span>:<span class="string">'Sam'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,character</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(character); <span class="comment">// &#123;name: 'Sam',inventory:&#123;&#125;&#125;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>option：read</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">read</span>: <span class="string">'primary'</span> &#125;);<span class="comment">// also aliased as 'p'</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">read</span>: <span class="string">'primaryPreferred'</span> &#125;);<span class="comment">// aliased as 'pp'</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">read</span>: <span class="string">'secondary'</span> &#125;);<span class="comment">// aliased as 's'</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">read</span>: <span class="string">'secondaryPreferred'</span> &#125;);<span class="comment">// aliased as 'sp'</span></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">read</span>: <span class="string">'nearest'</span> &#125;);<span class="comment">// aliased as 'n'</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123; <span class="attr">replset</span>: &#123; <span class="attr">strategy</span>: <span class="string">'ping'</span> &#125;&#125;;</span><br><span class="line">mongoose.connect(uri, options);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">read</span>: [<span class="string">'nearest'</span>, &#123; <span class="attr">disk</span>: <span class="string">'ssd'</span> &#125;] &#125;);</span><br><span class="line">mongoose.model(<span class="string">'JellyBean'</span>, schema);</span><br></pre></td></tr></table></figure><p><strong>option：shardKey</strong></p><p>分片相关.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Schema(&#123; .. &#125;, &#123; <span class="attr">shardKey</span>: &#123; <span class="attr">tag</span>: <span class="number">1</span>, <span class="attr">name</span>: <span class="number">1</span> &#125;&#125;)</span><br></pre></td></tr></table></figure><p><strong>option：strict</strong></p><p>Strict 选项默认为 true，这意味着你不能 <code>save</code> schema 里没有声明的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thingSchema = <span class="keyword">new</span> Schema(&#123;..&#125;)</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, thingSchema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(&#123; <span class="attr">iAmNotInTheSchema</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">thing.save(); <span class="comment">// iAmNotInTheSchema is not saved to the db</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// set to false..</span></span><br><span class="line"><span class="keyword">const</span> thingSchema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">strict</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(&#123; <span class="attr">iAmNotInTheSchema</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">thing.save(); <span class="comment">// iAmNotInTheSchema is now saved to the db!!</span></span><br></pre></td></tr></table></figure><p><code>doc.set()</code> 也受该选项影响：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thingSchema = <span class="keyword">new</span> Schema(&#123;..&#125;)</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, thingSchema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing;</span><br><span class="line">thing.set(<span class="string">'iAmNotInTheSchema'</span>, <span class="literal">true</span>);</span><br><span class="line">thing.save(); <span class="comment">// iAmNotInTheSchema is not saved to the db</span></span><br></pre></td></tr></table></figure><p>这个值可以在 model 级别重写，在第二个参数值传入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(doc, <span class="literal">true</span>);  <span class="comment">// enables strict mode</span></span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(doc, <span class="literal">false</span>); <span class="comment">// disables strict mode</span></span><br></pre></td></tr></table></figure><p>还可以将strict选项设置为“throw”，这将导致产生错误，而不是删除坏数据。</p><p>注意:在 schema 中不存在的实例上设置的任何键/值总是被忽略，不管模式选项是什么。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thingSchema = <span class="keyword">new</span> Schema(&#123;..&#125;)</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, thingSchema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing;</span><br><span class="line">thing.iAmNotInTheSchema = <span class="literal">true</span>;</span><br><span class="line">thing.save(); <span class="comment">// iAmNotInTheSchema is never saved to the db</span></span><br></pre></td></tr></table></figure><p><strong>option：strictQuery</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">field</span>: <span class="built_in">Number</span> &#125;, &#123; <span class="attr">strict</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> MyModel = mongoose.model(<span class="string">'Test'</span>, mySchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mongoose will **not** filter out `notInSchema: 1`, despite `strict: true`</span></span><br><span class="line">MyModel.find(&#123; <span class="attr">notInSchema</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure><p>严格的选择适用于更新</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Mongoose will strip out `notInSchema` from the update if `strict` is not `false`</span></span><br><span class="line">MyModel.updateMany(&#123;&#125;, &#123; <span class="attr">$set</span>: &#123; <span class="attr">notInSchema</span>: <span class="number">1</span> &#125; &#125;);</span><br></pre></td></tr></table></figure><p>Mongoose 有一个单独的 strictQuery 选项，用于将过滤器参数的strict模式切换到查询。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">field</span>: <span class="built_in">Number</span> &#125;, &#123;</span><br><span class="line">  strict: <span class="literal">true</span>,</span><br><span class="line">  strictQuery: <span class="literal">true</span> <span class="comment">// Turn on strict mode for query filters</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> MyModel = mongoose.model(<span class="string">'Test'</span>, mySchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mongoose will strip out `notInSchema: 1` because `strictQuery` is `true`</span></span><br><span class="line">MyModel.find(&#123; <span class="attr">notInSchema</span>: <span class="number">1</span> &#125;);</span><br></pre></td></tr></table></figure><p><strong>option：toJSON</strong></p><p>与toObject选项完全相同，但仅在调用documents toJSON方法时才适用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line">schema.path(<span class="string">'name'</span>).get(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v +<span class="string">' is my name'</span>;</span><br><span class="line">&#125;);</span><br><span class="line">schema.set(<span class="string">'toJSON'</span>,&#123;<span class="attr">getters</span>:<span class="literal">true</span>,<span class="attr">virituals</span>:<span class="literal">false</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> M = mongoose.model(<span class="string">'Person'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> M(&#123;<span class="attr">name</span>:<span class="string">'Max Headroom'</span>&#125;);     </span><br><span class="line">m.toObject(); <span class="comment">// &#123;_id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom' &#125;</span></span><br><span class="line">m.toJSON(); <span class="comment">//  &#123;_id: 504e0cd7dd992d9be2f20b6f, name: 'Max Headroom is my name' &#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.stringfy(m); <span class="comment">// &#123; "_id": "504e0cd7dd992d9be2f20b6f", "name": "Max Headroom is my name" &#125;</span></span><br></pre></td></tr></table></figure><p><strong>option：toObject</strong></p><p>Documents 的 toObject 方法可以把文档转换成一个 plain javascript object （也就是去掉里面的方法）。 这是一个可以接收多个参数的方法，我们可以在 schemas 定义这些参数。</p><p>例如要打印出虚拟值，可以向 <code>toObject</code> 传入 <code>{ getters: true }</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line">schema.path(<span class="string">'name'</span>).get(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v + <span class="string">'is my name'</span></span><br><span class="line">&#125;);</span><br><span class="line">schema.set(<span class="string">'toObject'</span>,&#123;<span class="attr">getters</span>:<span class="literal">true</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> M = mongoose.model(<span class="string">'Person'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> M(&#123;<span class="attr">name</span>:<span class="string">'HAHA'</span>&#125;);</span><br><span class="line">m <span class="comment">// &#123; _id: 504e0cd7dd992d9be2f20b6f, name: 'HAHA is my name' &#125;</span></span><br></pre></td></tr></table></figure><p><strong>option：typekey</strong></p><p>类型声明</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">loc</span>:&#123;<span class="attr">type</span>:<span class="built_in">String</span>,<span class="attr">coordinates</span>:[<span class="built_in">Number</span>]&#125;&#125;);</span><br></pre></td></tr></table></figure><p>对于像geoJSON这样的应用程序，“type”属性非常重要。控制使用哪个键mongoose来查找类型声明，要设置“typeKey”模式选项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    loc:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        coordinates:[<span class="built_in">Number</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    name:&#123;</span><br><span class="line">        $type:<span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;,&#123;<span class="attr">typeKey</span>:<span class="string">'$type'</span>&#125;);</span><br></pre></td></tr></table></figure><p><strong>option：validateBeforeSave</strong></p><p>默认情况下，文档在保存到数据库之前会自动验证。这是为了防止保存无效的文档。如果希望手动处理验证，并能够保存没有通过验证的对象，可以将validatebeforeave设置为false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123; <span class="attr">name</span>: <span class="built_in">String</span> &#125;);</span><br><span class="line">schema.set(<span class="string">'validateBeforeSave'</span>, <span class="literal">false</span>);</span><br><span class="line">schema.path(<span class="string">'name'</span>).validate(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> v != <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> M = mongoose.model(<span class="string">'Person'</span>, schema);</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> M(&#123; <span class="attr">name</span>: <span class="literal">null</span> &#125;);</span><br><span class="line">m.validate(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err); <span class="comment">// Will tell you that null is not allowed.</span></span><br><span class="line">&#125;);</span><br><span class="line">m.save(); <span class="comment">// Succeeds despite being invalid</span></span><br></pre></td></tr></table></figure><p><strong>option：versionKey</strong></p><p><code>versionKey</code> 是 Mongoose 在文件创建时自动设定的。 这个值包含文件的内部<a href="http://aaronheckmann.tumblr.com/post/48943525537/mongoose-v3-part-1-versioning">修订号</a>。 <code>versionKey</code> 是一个字符串，代表版本号的属性名， 默认值为 <code>__v</code>。如果这个值与你的计划冲突，你可以设定为其他名称：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123; <span class="attr">name</span>: <span class="string">'string'</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, schema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(&#123; <span class="attr">name</span>: <span class="string">'mongoose v3'</span> &#125;);</span><br><span class="line">thing.save(); <span class="comment">// &#123; __v: 0, name: 'mongoose v3' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// customized versionKey</span></span><br><span class="line"><span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">versionKey</span>: <span class="string">'_somethingElse'</span> &#125;)</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, schema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(&#123; <span class="attr">name</span>: <span class="string">'mongoose v3'</span> &#125;);</span><br><span class="line">thing.save(); <span class="comment">// &#123; _somethingElse: 0, name: 'mongoose v3' &#125;</span></span><br></pre></td></tr></table></figure><p>你也可以赋值为 <code>false</code> 禁用 <code>versionKey</code>。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Schema(&#123;..&#125;, &#123; <span class="attr">versionKey</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, schema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing(&#123; <span class="attr">name</span>: <span class="string">'no versioning please'</span> &#125;);</span><br><span class="line">thing.save(); <span class="comment">// &#123; name: 'no versioning please' &#125;</span></span><br></pre></td></tr></table></figure><p><strong>option：collation</strong></p><p>为 查询（query）和 聚合（aggregation）设置 collation</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">    collaction:&#123;</span><br><span class="line">        locale:<span class="string">'en_US'</span>,</span><br><span class="line">        strength:<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyModel = db.model(<span class="string">'MyModel'</span>,schema);</span><br><span class="line">myModel.create([&#123;<span class="attr">name</span>:<span class="string">'val'</span>,&#123;<span class="attr">name</span>:<span class="string">'Val'</span>&#125;]).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> MyModel.find(&#123;<span class="attr">name</span>:<span class="string">'Val'</span>&#125;);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">docs</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// docs 里面会包含上面两个值，因为 strength：1 代表着忽略大小写</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>option：skipVersioning</strong></p><p>跳过版本控制允许从版本控制中排除路径(例如。，即使更新了这些路径，也不会增加内部修订)。除非你知道你在做什么，否则不要这样做。对于子文档，使用完全限定路径将其包含在父文档中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">skipVersioning</span>: &#123; <span class="attr">dontVersionMe</span>: <span class="literal">true</span> &#125; &#125;);</span><br><span class="line">thing.dontVersionMe.push(<span class="string">'hey'</span>);</span><br><span class="line">thing.save(); <span class="comment">// version is not incremented</span></span><br></pre></td></tr></table></figure><p><strong>option：timestamps</strong></p><p>如果设置了 <code>timestamps</code> 选项, mongoose 会在你的 schema 自动添加 <code>createdAt</code> 和 <code>updatedAt</code> 字段， 其类型为Date。这两个字段的默认名称是 <code>createAt</code>和 <code>updateAt</code>，你可以通过设定 <code>timestamps.createAt</code> 和 <code>timestamps.updateAt</code> 自定义名称。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thingSchema = <span class="keyword">new</span> Schema(&#123;..&#125;, &#123; <span class="attr">timestamps</span>: &#123; <span class="attr">createdAt</span>: <span class="string">'created_at'</span> &#125; &#125;);</span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>, thingSchema);</span><br><span class="line"><span class="keyword">const</span> thing = <span class="keyword">new</span> Thing();</span><br><span class="line">thing.save(); <span class="comment">// `created_at` &amp; `updatedAt` will be included</span></span><br></pre></td></tr></table></figure><p><strong>option：useNestedStrict</strong></p><p>在 mongoose4 中，<code>update()</code> 和 <code>findOneAndUpdate()</code>只检查顶层 schema 的严格模式设定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childSchema = <span class="keyword">new</span> Schema(&#123;&#125;, &#123; <span class="attr">strict</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> parentSchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">child</span>: childSchema &#125;, &#123; <span class="attr">strict</span>: <span class="string">'throw'</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> Parent = mongoose.model(<span class="string">'Parent'</span>, parentSchema);</span><br><span class="line">Parent.update(&#123;&#125;, &#123; <span class="string">'child.name'</span>: <span class="string">'Luke Skywalker'</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 报错！原因是父Schema设定为`strict: throw`，但是因为只检查顶层，导致</span></span><br><span class="line">  <span class="comment">// 子Schema的 `strict: false` 遭到无情忽视</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> update = &#123; <span class="string">'child.name'</span>: <span class="string">'Luke Skywalker'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> opts = &#123; <span class="attr">strict</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">Parent.update(&#123;&#125;, update, opts, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这样可以，因为重写了父Schema的 strict 选项</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果你把 <code>useNestedStrict</code> 设为 true，mongoose 就不会忽略嵌套的 strict 设定。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childSchema = <span class="keyword">new</span> Schema(&#123;&#125;, &#123; <span class="attr">strict</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> parentSchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">child</span>: childSchema &#125;,</span><br><span class="line">  &#123; <span class="attr">strict</span>: <span class="string">'throw'</span>, <span class="attr">useNestedStrict</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> Parent = mongoose.model(<span class="string">'Parent'</span>, parentSchema);</span><br><span class="line">Parent.update(&#123;&#125;, &#123; <span class="string">'child.name'</span>: <span class="string">'Luke Skywalker'</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Works!</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="模式类型（SchemaTypes）"><a href="#模式类型（SchemaTypes）" class="headerlink" title="模式类型（SchemaTypes）"></a>模式类型（SchemaTypes）</h3><p>SchemaTypes 是处理字段路径各种属性的定义（默认值、验证、getter、setter、查询的字段选择默认值，以及字符串和数字的其他一般特性）</p><p>下面是合法的 SchemaTypes：</p><ul><li>String</li><li>Number</li><li>Date</li><li>Buffer</li><li>Boolean</li><li>Mixed</li><li>ObjectId</li><li>Array</li><li>Decimal128</li></ul><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    binary:Buffer,</span><br><span class="line">    living:<span class="built_in">Boolean</span>,</span><br><span class="line">    updated:&#123;</span><br><span class="line">        type:<span class="built_in">Date</span>,</span><br><span class="line">        <span class="keyword">default</span>:<span class="built_in">Date</span>.now</span><br><span class="line">    &#125;,</span><br><span class="line">    age:&#123;</span><br><span class="line">        type:<span class="built_in">Number</span>,</span><br><span class="line">        min:<span class="number">18</span>,</span><br><span class="line">        max:<span class="number">65</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mixed:Schema.Types.Mixed,</span><br><span class="line">    _someId:Schema.Types.ObjectId,</span><br><span class="line">    decimal:Schema.Types.Decimal128,</span><br><span class="line">    array:[],</span><br><span class="line">    ofString:[<span class="built_in">String</span>],</span><br><span class="line">    ofNumber:[<span class="built_in">Number</span>],</span><br><span class="line">    ofDates:[<span class="built_in">Date</span>],</span><br><span class="line">    ofBuffer:[Buffer],</span><br><span class="line">    ofBoolean:[<span class="built_in">Boolean</span>],</span><br><span class="line">    ofMixed:[Schema.Types.Mixed],</span><br><span class="line">    ofObjectId:[Schema.Types.ObjectId],</span><br><span class="line">    ofArrays:[[]],</span><br><span class="line">    ofArrayOfNumbers:[[<span class="built_in">Number</span>]],</span><br><span class="line">    nested:&#123;</span><br><span class="line">        stuff:&#123;</span><br><span class="line">            type:<span class="built_in">String</span>,</span><br><span class="line">            lowercase:<span class="literal">true</span>,</span><br><span class="line">            trim:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Thing = mongoose.model(<span class="string">'Thing'</span>,schema);</span><br><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> Thing;</span><br><span class="line">m.name = <span class="string">'haha'</span>;</span><br><span class="line">m.age = <span class="number">125</span>;</span><br><span class="line">m.updated = <span class="keyword">new</span> <span class="built_in">Date</span>;</span><br><span class="line">m.binary = <span class="keyword">new</span> Buffer(<span class="number">0</span>);</span><br><span class="line">m.mixed = &#123;</span><br><span class="line">    any:&#123;</span><br><span class="line">        thing:<span class="string">'i want'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">m.markModified(<span class="string">'mixed'</span>);</span><br><span class="line">m._someId = <span class="keyword">new</span> mongoose.Typed.ObjectId;</span><br><span class="line">m.array.push(<span class="number">1</span>);</span><br><span class="line">m.ofString.push(<span class="string">'strings!'</span>);</span><br><span class="line">m.ofNumber.unshift(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">m.ofDates.addToSet(<span class="keyword">new</span> <span class="built_in">Date</span>);</span><br><span class="line">m.ofBuffer.pop();</span><br><span class="line">m.ofMixed = [<span class="number">1</span>,[],<span class="string">'three'</span>,&#123;<span class="attr">four</span>:<span class="number">5</span>&#125;]</span><br><span class="line">m.nested.stuff = <span class="string">'good'</span>;</span><br><span class="line">m.save(callback);</span><br></pre></td></tr></table></figure><h4 id="SchemaType-选项"><a href="#SchemaType-选项" class="headerlink" title="SchemaType 选项"></a>SchemaType 选项</h4><p>可以直接声明 schema type 为某一种 type，或者赋值一个含有 type 属性的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    test:<span class="built_in">String</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> schema2 = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    test:&#123;</span><br><span class="line">        type:<span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>除了 type 属性，还可以对这个字段路径指定其他属性，如果要在保存之前把字母都改成小写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema2 = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    test:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        lowercase:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>lowercase</code> 属性只作用于字符串。以下有一些全部type 可用的选项和一些限定部分 type 使用的选项。</p><p><strong>全部可用</strong></p><ul><li><code>required</code>：布尔值或者函数，如果值为真，为此属性添加 required 验证器</li><li><code>default</code>：任何值或者函数设置此路径默认值，如果是函数，函数返回值为默认值</li><li><code>select</code>：布尔值执行query 默认 projections</li><li><code>validate</code>：属性验证函数</li><li><code>get</code>：函数 使用 <code>Object.defineProperty()</code> 定义自定义 getter</li><li><code>set</code>：函数 使用 <code>Object.defineProperty()</code> 定义自定义 setter</li><li><code>alias</code>：字符串 仅mongoose &gt;= 4.10.0。 为该字段路径定义虚拟值 gets/sets</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numberSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    integerOnly:&#123;</span><br><span class="line">        type:<span class="built_in">Number</span>,</span><br><span class="line">        get:<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">Math</span>.round(v),</span><br><span class="line">        set:<span class="function"><span class="params">v</span> =&gt;</span> <span class="built_in">Math</span>.round(v),</span><br><span class="line">        alias:<span class="string">'i'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">Number</span> = mongoose.model(<span class="string">'Number'</span>,numberSchema);</span><br><span class="line"><span class="keyword">const</span> doc = <span class="keyword">new</span> <span class="built_in">Number</span>();</span><br><span class="line">doc.integerOnly = <span class="number">2.001</span>;</span><br><span class="line">doc.integerOnly <span class="comment">// 2</span></span><br><span class="line">doc.i <span class="comment">// 2</span></span><br><span class="line">doc.i = <span class="number">3.001</span>;</span><br><span class="line">doc.integerOnly <span class="comment">//3</span></span><br><span class="line">doc.i <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p><strong>索引相关</strong></p><p>可以使用 schema type 选项定义 MongoDB  indexex</p><ul><li><code>index</code>:布尔值 是否对这个属性创建索引</li><li><code>unique</code>:布尔值 是否对这个属性创建唯一索引</li><li><code>sparse</code>:布尔值 是否对这个属性创建稀疏索引</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    test:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        index:<span class="literal">true</span>,</span><br><span class="line">        unique:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>String</p><ul><li><code>lowercase</code>: 布尔值 是否保存前对此值调用 <code>.toLowerCase()</code></li><li><code>uppercase</code>: 布尔值 是否保存前对此值调用 <code>.toUpperCase()</code></li><li><code>trim</code>: 布尔值 是否在保存前对此值调用  <code>trim()</code></li><li><code>match</code>:正则表达式 创建验证器检查这个值是否匹配给定正则表达式</li><li><code>enum</code>:数组 创建验证器检查这个值是否包含于给定数组</li></ul><p>Number </p><ul><li><code>min</code>:数值 创建验证器检查属性是否大于或者等于该值</li><li><code>max</code>:数值 创建验证器检查属性是否小于或者等于该值</li></ul><p>Date</p><ul><li><code>min</code>:Date</li><li><code>max</code>:Date</li></ul><h4 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a><strong>使用注意</strong></h4><p><strong>Dates</strong></p><p>内建的 Date 方法不会触发 mongoose 修改跟踪逻辑，如果使用 <code>setMonth()</code> 修改文档里面的 <code>Date</code>,mongoose 在 <code>doc.save()</code> 的时候是察觉不到这个文档发生了变化的，因此保存不到数据库中。如果一定要用内建的 Date 方法，需要手动调用 <code>doc.markModified(&#39;pathToYourDate&#39;)</code>告诉 mongoose 修改了数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Assignment = mongoose.model(<span class="string">'Assignment'</span>,&#123;<span class="attr">dueDate</span>:<span class="built_in">Date</span>&#125;);</span><br><span class="line">Assignment.findOne(<span class="function"><span class="keyword">function</span>(<span class="params">err,doc</span>)</span>&#123;</span><br><span class="line">    doc.dueDate.setMonth(<span class="number">3</span>);</span><br><span class="line">    doc.save(callback); <span class="comment">// 这个不会保存你的修改</span></span><br><span class="line">    doc.markModified(<span class="string">'dueDate'</span>);</span><br><span class="line">    doc.save(callback);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>Mixed</strong></p><p>一个什么都可以放的 SchemaType,虽然遍历，但是也会让数据难以维护。Mixed 可以通过 Schema.Types.Mixed 或者传入 一个空对象定义。下面三种方法效果是一致的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Any = <span class="keyword">new</span> Schema(&#123;<span class="attr">any</span>:&#123;&#125;&#125;);</span><br><span class="line"><span class="keyword">const</span> Any = <span class="keyword">new</span> Schema(&#123;<span class="attr">any</span>:<span class="built_in">Object</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Any = <span class="keyword">new</span> Schema(&#123;<span class="attr">any</span>:Schema.Types.Mixed&#125;);</span><br></pre></td></tr></table></figure><p>因为这是个 schema-less type，所以可以赋值为任意类型，但是 mongoose 无法自动检测并保存修改。要告诉它修改了 Mixed type 的值，调用文档的 <code>.markModified(path)</code> 方法，传入你的 Mixed 字段路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person.anything = &#123;<span class="attr">x</span>:[<span class="number">3</span>,<span class="number">4</span>,&#123;<span class="attr">y</span>:<span class="string">'changed'</span>&#125;]&#125;</span><br><span class="line">person.markModified(<span class="string">'anything'</span>);</span><br><span class="line">person.save(); <span class="comment">// anything will now get changed</span></span><br></pre></td></tr></table></figure><p><strong>ObjectIds</strong></p><p>要指定类型为 ObjectId，在声明中使用 <code>Schema.Types.ObjectId</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> ObjectId = mongoose.Schema.Types.ObjectId;</span><br><span class="line"><span class="keyword">const</span> Car = <span class="keyword">new</span> Schema(&#123;<span class="attr">driver</span>:ObjectId&#125;);</span><br></pre></td></tr></table></figure><p><strong>Arrays</strong></p><p>创造 SchemaTypes 或者子文档数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ToySchema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> ToyBox = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    toys:[ToySchema],</span><br><span class="line">    buffers:[Buffer],</span><br><span class="line">    string:[<span class="built_in">String</span>]，</span><br><span class="line">    number:[<span class="built_in">Number</span>]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意：指定空数组相当于  <code>Mixed</code>,下面的操作相当于创建 <code>Mixed</code>数组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Empty1 = <span class="keyword">new</span> Schema(&#123;<span class="attr">ary</span>:&#123;]&#125;&#125;);</span><br><span class="line"><span class="keyword">const</span> Empty2 = <span class="keyword">new</span> Schema(&#123;<span class="attr">any</span>:<span class="built_in">Array</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Empty3 = <span class="keyword">new</span> Schema(&#123;<span class="attr">any</span>:[Schema.Types.Mixed]&#125;);</span><br><span class="line"><span class="keyword">const</span> Empty4 = <span class="keyword">new</span> Schema(&#123;<span class="attr">any</span>:[&#123;&#125;]&#125;);</span><br></pre></td></tr></table></figure><p>数组的默认值是 <code>[]</code>（空数组）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Toy = mongoose.model(<span class="string">'Test'</span>,toySchema);</span><br><span class="line"><span class="keyword">new</span> Toy().toys <span class="comment">// []</span></span><br></pre></td></tr></table></figure><p>要手动把默认值设置为 <code>undefined</code>，从而覆盖 <code>[]</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ToySchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    toys:&#123;</span><br><span class="line">        type:[ToySchema],</span><br><span class="line">        defalut:<span class="literal">undefined</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="创建自定义-Type"><a href="#创建自定义-Type" class="headerlink" title="创建自定义 Type"></a><strong>创建自定义 Type</strong></h4><p>Mongoose 可以扩展自定义 SchemaType.</p><p><strong><code>schema.path()</code>函数</strong></p><p>这个函数为给定字段路径返回实例化 schema type</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sampleSchema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:&#123;<span class="attr">type</span>:<span class="built_in">String</span>,<span class="attr">require</span>:<span class="literal">true</span>&#125;&#125;);</span><br><span class="line">sampleSchema.path(<span class="string">'name'</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* SchemaString &#123;</span></span><br><span class="line"><span class="comment"> *   enumValues: [],</span></span><br><span class="line"><span class="comment"> *   regExp: null,</span></span><br><span class="line"><span class="comment"> *   path: 'name',</span></span><br><span class="line"><span class="comment"> *   instance: 'String',</span></span><br><span class="line"><span class="comment"> *   validators: ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>这个函数可以检查给定字段路径的检查器和类型等信息。</p><h3 id="连接（Connections）"><a href="#连接（Connections）" class="headerlink" title="连接（Connections）"></a>连接（Connections）</h3><p>可以使用 <code>mongoose.connect()</code>方法连接 MongoDB</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://localhost/myapp'</span>);</span><br></pre></td></tr></table></figure><p>这是连接本地 <code>myapp</code>数据库默认接口（27017）的最小配置。本地连接失败可以尝试 127.0.0.1.local hostname 被修改有时候会引起问题。</p><p>可以在 url 中指定多个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://username:password@host:port/database?options'</span>);</span><br></pre></td></tr></table></figure><h4 id="操作缓存"><a href="#操作缓存" class="headerlink" title="操作缓存"></a><strong>操作缓存</strong></h4><p>不必等等连接建立成功就可以使用 Mongoose models</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://localhost/myapp'</span>);</span><br><span class="line"><span class="keyword">const</span> MyModel = mongoose.model(<span class="string">'Test'</span>,<span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;));</span><br><span class="line">MyModel.findOne(<span class="function"><span class="keyword">function</span>(<span class="params">err,res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Mongoose 会缓存 model 操作。这个操作很方便，但也会引起一些疑惑，因为如果没有连上的话，Mongoose 不会抛错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyModel = mongoose.model(<span class="string">'Test'</span>,<span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>&#125;));</span><br><span class="line">MyModel.findOne(<span class="function"><span class="keyword">function</span>(<span class="params">err,res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ..</span></span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    mongoose.connect(<span class="string">'mongodb://localhost/xxx'</span>);</span><br><span class="line">&#125;,<span class="number">6000</span>);</span><br></pre></td></tr></table></figure><p>要禁用缓存，修改 bufferCommands 配置。如果打开了这个选项连接被挂起，尝试关闭 bufferCommands 检查是否正确打开连接，也可以全局禁用 bufferCommands:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.set(<span class="string">'bufferCommands'</span>,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h4 id="选项-1"><a href="#选项-1" class="headerlink" title="选项"></a><strong>选项</strong></h4><p><code>connect</code> 方法也接受 <code>options</code> 参数，这些参数会传入底层 MongoDB 驱动</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(uri,options);</span><br></pre></td></tr></table></figure><p>Mongoose 会不做修改直接把选项传到驱动，以下有一点例外</p><ul><li><code>bufferCommands</code> 是 mongoose 特有的选项，</li><li><code>user/pass</code>  用于认证的用户名和密码。mongoose 特有的，等价于 MongoDB 驱动的 <code>auth.user</code> 和 <code>auth.password</code>选项</li><li><code>autoIndex</code> 理想情况下，mongoose 在连接时会自动建立 schema 索引。这有利于开发，但是在大型生产环境中不是很理想，因为会导致性能下降。</li><li><code>dbName</code> 指定要连接的数据库名称（覆盖连接字符串）</li></ul><p>下面是一些重要的选项</p><ul><li><code>autoReconnect</code> 底层 MongoDB 驱动在连接后将自动重连。除非是管理连接池的高手，不然不建议设置为 false</li><li><code>bufferMaxEntries</code> MongoDB 驱动同样有自己的离线缓存机制。如果希望连接错误时终止数据库操作，可以设这个值为 0 以及把 bufferCommands 设为 false.</li><li><code>promiseLibrary</code> 设置底层 promise 库</li><li><code>poolSize</code> MongoDB 保持的最大 socket 连接数。默认是5.MongoDB 3.4 之前，只允许每个 socket 同时进行一个操作，所以如果有几个缓慢请求卡着后面快的请求，可以尝试增加连接数。</li></ul><p>举例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">    useMongoClient:<span class="literal">true</span>,</span><br><span class="line">    autoIndex:<span class="literal">false</span>, <span class="comment">// 不要创建索引</span></span><br><span class="line">    reconnectTries:<span class="built_in">Number</span>.MAX_VALUE, <span class="comment">// 不要停止重连</span></span><br><span class="line">    reconnectInterval:<span class="number">500</span>, <span class="comment">// 每500毫秒重连</span></span><br><span class="line">    poolSize:<span class="number">10</span>, <span class="comment">// 维护最多10个socket</span></span><br><span class="line">    bufferMaxEntries:<span class="number">0</span> <span class="comment">// 如果没有连接，则立即返回错误，而不是等待重新连接</span></span><br><span class="line">&#125;</span><br><span class="line">mongoose.connect(uri,options);</span><br></pre></td></tr></table></figure><h4 id="回调"><a href="#回调" class="headerlink" title="回调"></a><strong>回调</strong></h4><p><code>connect</code> 函数接受回调函数，或者返回一个 promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(uri,options,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;);</span><br><span class="line">mongoose.connect(uri,options).then(</span><br><span class="line">    ()=&gt;&#123;<span class="comment">/** ready to use. The `mongoose.connect()` promise resolves to undefined. */</span> &#125;</span><br><span class="line">    err=&gt;&#123;<span class="comment">/** handle initial connection error */</span>&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="连接字符串（Connectng-String）选项"><a href="#连接字符串（Connectng-String）选项" class="headerlink" title="连接字符串（Connectng String）选项"></a><strong>连接字符串（Connectng String）选项</strong></h4><p>可以在连接字符串填写驱动选项，这只适用于 MongoDB 驱动使用的选项，所以类似 bufferCommands 的 Mongoose 专用选项不能在连接字符串使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://localhost:27017/test?connectTimeoutMS=1000&amp;bufferCommands=false'</span>);</span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">mongoose.connect(<span class="string">'mongodb://localhost:27017/test'</span>, &#123;</span><br><span class="line">  connectTimeoutMS: <span class="number">1000</span></span><br><span class="line">  <span class="comment">// Note that mongoose will **not** pull `bufferCommands` from the query string</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>把选项放在连接字符串的劣势是不便阅读。优势是简短。最佳实践是把区分生产环境和开发环境的选项，<code>socketTimeoutMS</code> 、 <code>connectTimeoutMS</code> 放在 uri ， 把通用的常量如 <code>connectTimeoutMS</code> 、 <code>poolSize</code> 放在选项对象里。</p><h4 id="keepAlive注意事项"><a href="#keepAlive注意事项" class="headerlink" title="keepAlive注意事项"></a><strong>keepAlive注意事项</strong></h4><p>对于长期运行的后台引用，启用毫秒级 <code>keepAlive</code>是一个精明的操作。不这么做偶尔会经常收到看似没有什么原因的 <code>connection closed</code> 错误</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(uri,&#123;<span class="attr">keepAlive</span>:<span class="number">120</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="副本集（Replica-Set）连接"><a href="#副本集（Replica-Set）连接" class="headerlink" title="副本集（Replica Set）连接"></a><strong>副本集（Replica Set）连接</strong></h4><p>要连接到副本集，可以使用逗号分隔开，传入多个地址：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]'</span> [, options]);</span><br></pre></td></tr></table></figure><p>连接到单节点副本集，需要指定 <code>relicaSet</code> 选项</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'mongodb://host1:port1/?replicaSet=rsName'</span>);</span><br></pre></td></tr></table></figure><h4 id="多-mongos-支持"><a href="#多-mongos-支持" class="headerlink" title="多 mongos 支持"></a><strong>多 mongos 支持</strong></h4><p>使用高性能分片集群，需要连接<a href="https://docs.mongodb.com/manual/reference/program/mongos/">多个 mongos（MongoDB Shard） 实例</a>。 在 mongoose 5.x 中， 你在连接多个 mongos 时<a href="http://mongodb.github.io/node-mongodb-native/3.0/tutorials/connect/#connect-to-sharded-cluster">不需要传入任何特殊选项</a>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Connect to 2 mongos servers</span></span><br><span class="line">mongoose.connect(<span class="string">'mongodb://mongosA:27501,mongosB:27501'</span>, cb);</span><br></pre></td></tr></table></figure><h4 id="多个连接"><a href="#多个连接" class="headerlink" title="多个连接"></a><strong>多个连接</strong></h4><p>之前我们了解如何使用 Mongoose 默认连接方法连接到 MongoDB。但有时候我们需要权限不同的多个连接， 或是连接到不同数据库。这个情况下我们可以使用 <code>mongoose.createConnection()</code>， 它接受之前提到的所有参数，给你返回一个新的连接。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> conn = mongoose.createConnection(<span class="string">'mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]'</span>, options);</span><br></pre></td></tr></table></figure><p>connection对象后续用于创建和检索models。 models 的范围总是局限于单个连接。</p><p>调用 <code>mongoose.connect()</code> 时，Mongoose 会自动创建<strong>默认连接</strong>。 你可以使用 <code>mongoose.connection</code> 访问默认连接。</p><h4 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a><strong>连接池</strong></h4><p>无论是使用 <code>mongoose.connect</code> 或是 <code>mongoose.createConnection</code> 创建的连接， 都被纳入默认最大为 5 的连接池，可以通过 poolSize 选项调整：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// With object options</span></span><br><span class="line">mongoose.createConnection(uri, &#123; <span class="attr">poolSize</span>: <span class="number">4</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uri = <span class="string">'mongodb://localhost/test?poolSize=4'</span>;</span><br><span class="line">mongoose.createConnection(uri);</span><br></pre></td></tr></table></figure><h3 id="模型（Models）"><a href="#模型（Models）" class="headerlink" title="模型（Models）"></a>模型（Models）</h3><p>Models 是从 Schema 编译来的构造函数，它们的实例就代表着可以从数据保存和读取 documents，从数据创建和读取 document 的所有操作都是通过 model 进行的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="string">'string'</span>,<span class="attr">size</span>:<span class="string">'string'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> Tank = mongoose.model(<span class="string">'Tank'</span>,schema);</span><br></pre></td></tr></table></figure><p>第一个参数是跟 model 对应的集合（collection） 名字的单数形式。Mongoose 会自动找到名称是 model 名字复数形式的 collection。对于上例，Tank 这个model 就对应 数据库中 tanks 这个 collection.<code>.model()</code> 这个函数是对 <code>schema</code> 做了拷贝（生成了model）。要确保在调用 <code>.model()</code> 之前把所有需要的东西都加进去 <code>schema</code>里面。</p><h4 id="构造-documents"><a href="#构造-documents" class="headerlink" title="构造 documents"></a><strong>构造 documents</strong></h4><p>Documents 是 model 的实例，创建它们并保存到数据库非常简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Tank = mongoose.model(<span class="string">'Tank'</span>,yourSchema);</span><br><span class="line"><span class="keyword">const</span> small = <span class="keyword">new</span> Tank(&#123;<span class="attr">size</span>:<span class="string">'small'</span>&#125;);</span><br><span class="line">small.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Tank.create(&#123;<span class="attr">size</span>:<span class="string">'small'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,small</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>要注意，知道 model 使用的数据连接（connection）被打开，tanks 才会被创建/删除，每个 model 都有一个绑定的连接。如果model 是通过调用 <code>mongoose.model()</code> 生成的，它将使用 mongoose 的默认连接。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongoose.connect(<span class="string">'localhost'</span>,<span class="string">'gettingstarted'</span>)</span><br></pre></td></tr></table></figure><p>如果自行创建了连接，就需要使用 connection 的 <code>model</code>函数代替 mongoose 的 <code>model</code>函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> connection = mongoose.createConnection(<span class="string">'mongodb://localhost:27017/test'</span>);</span><br><span class="line"><span class="keyword">const</span> Tank = connection.model(<span class="string">'Tank'</span>,yourSchema);</span><br></pre></td></tr></table></figure><h4 id="查询"><a href="#查询" class="headerlink" title="查询"></a><strong>查询</strong></h4><p>用 mongoose 查询文档相当容易，它支持 mongoDB的高级查询语法（rich），查询文档可以使用 <code>model</code>的 find,findById,findOne,where 这些静态方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tank.find(&#123;<span class="attr">size</span>:<span class="string">'small'</span>&#125;).where(<span class="string">'createDate'</span>).gt(oneYearAgo).exec(callback);</span><br></pre></td></tr></table></figure><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a><strong>删除</strong></h4><p><code>model</code>的 <code>remove</code>方法可以删除所有匹配查询条件的文档</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tank.remove(&#123;<span class="attr">size</span>:<span class="string">'large'</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a><strong>更新</strong></h4><p><code>model</code>的 <code>update</code>方法可以修改数据库中的文档，不过不会把文档返回给应用层。</p><p>如果想更新单独一条文档并且返回给应用层，可以使用 findOneAndIUpdate 方法</p><h3 id="文档（Documents）"><a href="#文档（Documents）" class="headerlink" title="文档（Documents）"></a>文档（Documents）</h3><p>Mongoose documents代表着MongoDB 文档的一对一映射，每个 document 都是他的 Model 实例。</p><h4 id="检索"><a href="#检索" class="headerlink" title="检索"></a><strong>检索</strong></h4><p>MongoDB  有很多检索数据的方法。</p><h4 id="更新-1"><a href="#更新-1" class="headerlink" title="更新"></a><strong>更新</strong></h4><p>Document 更新的方法同样也有很多,最基本的 findById</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Tank.findById(id,<span class="function"><span class="keyword">function</span>(<span class="params">err,tank</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    tank.size = <span class="string">'large'</span>;</span><br><span class="line">    tank.save(<span class="function"><span class="keyword">function</span>(<span class="params">err,updateTank</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">        res.send(updateTank);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>也可以用 <code>.set()</code> 修改 document 。在底层，<code>tank.size = &#39;large&#39;</code>，用 <code>tank.set({size:&#39;large&#39;})</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Tank.findById(id,<span class="function"><span class="keyword">function</span>(<span class="params">err,tank</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    tank.set(&#123;<span class="attr">size</span>:<span class="string">'large'</span>&#125;);</span><br><span class="line">    tank.save(<span class="function"><span class="keyword">function</span>(<span class="params">err,updateTank</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">        res.send(updateTank);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个方法先检索了数据，接着更新（使用了<code>save</code>）。如果我们仅仅需要更新而不是获取该数据，<code>model#update</code>就很适合我们：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tank.update(&#123;<span class="attr">_id</span>:id&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="attr">size</span>:<span class="string">'large'</span>&#125;&#125;,callback);</span><br></pre></td></tr></table></figure><p>如果我们确实需要返回文档，下面的方法更加适合：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Tank.findByIdAndUpdate(id,&#123;<span class="attr">$set</span>:&#123;<span class="attr">size</span>:<span class="string">'large'</span>&#125;&#125;,&#123;<span class="attr">new</span>:<span class="literal">true</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,tank</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    res.send(tank);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>findAndUpdate/Remove</code>系列静态方法查找并返回最多1个文档，模式的方法有不少。</p><p>注意：<code>findAndUpdata/Remove</code>不会修改数据库时执行任何钩子或者验证。可以使用 <code>runValidators</code> 选项获取一个验证的限制子集。但是需要钩子和全文档验证的，还是先query 在save </p><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a><strong>验证</strong></h4><p>Document 会在被保存之前验证。</p><h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a><strong>覆盖</strong></h4><p>可以用 <code>.set()</code> 覆盖整个文档。如果要修改在中间件中被保存的文档，这样就很方便了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Tank.findById(id,<span class="function"><span class="keyword">function</span>(<span class="params">err,tank</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError();</span><br><span class="line">    <span class="comment">// otherTank 是 tank 的副本</span></span><br><span class="line">    otherTank.set(tank)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="子文档（Subdocuments）"><a href="#子文档（Subdocuments）" class="headerlink" title="子文档（Subdocuments）"></a>子文档（Subdocuments）</h3><p>子文档是指嵌套在另一个文档中的文档。在 Mongoose 中，这意味着可以在 里面嵌套一个 schema 。Mongoose 子文档有两种不同的概念：子文档数组和单个嵌套子文档。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childSchema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="string">'string'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> parentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    children:[childSchema],</span><br><span class="line">    <span class="comment">// Single nested subdocuments. Caveat: single nested subdocs only work in mongoose &gt;= 4.2.0</span></span><br><span class="line">    child:childSchema</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>子文档和普通 docuemnt 类似。嵌套 schema 可以有自己的中间件，自定义检索逻辑、虚拟值已经其他顶层 schemas 可用的特性，两者主要的不同点是子文档不能单独保存，他们会在他们的顶级文档保存时保存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Parent = mongoose.model(<span class="string">'Parent'</span>,parentSchema);</span><br><span class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> Parent([children:[&#123;<span class="attr">name</span>:<span class="string">'Matt'</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'Sarah'</span>&#125;]]);</span><br><span class="line">parent.children[<span class="number">0</span>].name = <span class="string">'HaHa'</span>;</span><br><span class="line"><span class="comment">// parent.children[0].save() 无操作，虽然他触发了中间件，但是没有保存文档，需要 save 他的文档、</span></span><br><span class="line">parent.save(callback);</span><br></pre></td></tr></table></figure><p>子文档跟普通文档一样有 save 和 validate 中间件，调用福文档的 save 会触发所有子文档的 save 中间件， validate 中间件同理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">childSchema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="string">'invalid'</span> == <span class="keyword">this</span>.name)&#123;</span><br><span class="line">       <span class="keyword">return</span> next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'#sadpanda'</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> Parent(&#123;<span class="attr">children</span>:[&#123;<span class="attr">name</span>:<span class="string">'invalid'</span>&#125;]&#125;);</span><br><span class="line">parent.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.message); <span class="comment">//#sadpanda</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>子文档的 <code>pre(&#39;save&#39;)</code> 和 <code>pre(&#39;validate&#39;)</code>中间件执行于顶层 document <code>pre(&#39;save&#39;)</code> 之前，顶层 document 的 <code>pre(&#39;validate&#39;)</code>之后。因为 <code>save()</code>前的验证就是一个中间件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> childSchema = <span class="keyword">new</span> mongoose.Schema(&#123;<span class="attr">name</span>:<span class="string">'string'</span>&#125;);</span><br><span class="line">childSchema.pre(<span class="string">'validate'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">childSchema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> parentSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">    child:childSchema</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">parentSchema.pre(<span class="string">'validate'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line">parentSchema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1 2 3 4</span></span><br></pre></td></tr></table></figure><h4 id="查找子文档"><a href="#查找子文档" class="headerlink" title="查找子文档"></a><strong>查找子文档</strong></h4><p>每个子文档都有一个默认 <code>_id</code>，Mongoose document 数组有一个特别的 id 方法，这个方法只要传入 <code>_id</code>就能返回文档数组中特定文档。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doc = parent.children.id(_id);</span><br></pre></td></tr></table></figure><h4 id="添加子文档到数组"><a href="#添加子文档到数组" class="headerlink" title="添加子文档到数组"></a><strong>添加子文档到数组</strong></h4><p>Mongoose 数组方法有 push、unshift、addToSet 等等：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Parent = mongoose.model(<span class="string">'Parent'</span>);</span><br><span class="line"><span class="keyword">const</span> parent = <span class="keyword">new</span> Parent;</span><br><span class="line"></span><br><span class="line">parent.children.push(&#123;<span class="attr">name</span>:<span class="string">'Haha'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> subdoc = parent.children[<span class="number">0</span>];</span><br><span class="line">subdoc; <span class="comment">//  _id: '501d86090d371bab2c0341c5', name: 'Haha' &#125;</span></span><br><span class="line">subdoc.isNew; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">parent.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Success'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>create 方法可以新建文档但是不加入数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newdoc = parent.children.create(&#123;<span class="attr">name</span>:<span class="string">'Haha'</span>&#125;);</span><br></pre></td></tr></table></figure><h4 id="删除子文档"><a href="#删除子文档" class="headerlink" title="删除子文档"></a><strong>删除子文档</strong></h4><p>每个子文档都有 remove 方法，另外，对于子文档数组，有一个等效的方法<code>.pull()</code>。对于单个嵌套子文档，remove 与把这个文档的值设为 null 等效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 等效 parent.children.pull(_id)</span></span><br><span class="line">parent.children.id(_id).remove()</span><br><span class="line"><span class="comment">// 或者 parent.child = null</span></span><br><span class="line">parent.child.remove();</span><br><span class="line">parent.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'the subdocs were removed'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>代替声明语法的写法</strong></p><p>如果用对象的数组创建 schema,mongoose 会自动把对象转成 schema：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> parentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    children:[&#123;<span class="attr">name</span>:<span class="string">'string'</span>&#125;]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">const</span> parentSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    children:[<span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="string">'string'</span>&#125;)]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="查询（queries）"><a href="#查询（queries）" class="headerlink" title="查询（queries）"></a>查询（queries）</h3><p>Model 的多个静态辅助方法都可以查询文档。</p><p>Model 的方法中包含查询条件参数的（find findById count update）都可以按照下面两种方式执行：</p><ol><li>传入 callback 参数，操作会被立即执行，查询结果被传给回调函数（callback）</li><li>不传 callback 参数，Query 的一个实例（一个 query对象）被返回，这个 query 提供了 构建查询器的特殊接口。</li></ol><p>Query 实例有一个 <code>.then()</code>函数，用法类似 promise</p><p>如果执行查询时传入 callback,就需要用 JSON 文档的格式指定查询条件，JSON 文档的语法跟 MongoDB shell  一致。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Parent = mongoose.model(<span class="string">'Person'</span>,mySchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询 last name 是 haha 的 person,选中 name 和 occupation 字段</span></span><br><span class="line">Person.findOne(&#123;<span class="string">'name.last'</span>:<span class="string">'haha'</span>&#125;,<span class="string">'name occupation'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err,person</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(person.name.first,person.name.last,person.occupation);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的查询被立即执行，查询结果被传入回调函数。Mongoose 中所有的调用函数都是用 <code>callback(error,result)</code>这种模式。如果查询发生错误，<code>error</code>参数即是错误文档，<code>result</code>参数会是 null。如果查询成功，<code>error</code>参数是 null，<code>result</code>即是查询结果。</p><p>查询结果的格式取决于做什么操作：findOne() 是单个文档（或者null），find() 是文档列表，count() 是文档数量， update() 是被修改的文档数量。</p><p>下面看看不传入 callback 这个参数会是怎么样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找每个  last name 是 haha 的 person</span></span><br><span class="line"><span class="keyword">const</span> query = Person.findOne(&#123;<span class="string">'name.last'</span>:<span class="string">'haha'</span>&#125;);</span><br><span class="line"><span class="comment">// 选择 name 和 occupation 字段</span></span><br><span class="line">query.select(<span class="string">'name occupation'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后执行查询</span></span><br><span class="line">query.exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,person</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(person.name.first,person.name.last,person.occupation);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码中，query 是 Query 类型的变量，Query 能够用链式语法构建查询器，无需要执行 JSON 对象。下面2个实例等效：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Person.find(&#123;</span><br><span class="line">    occupation:<span class="regexp">/host/</span>,</span><br><span class="line">    <span class="string">'name.last'</span>:<span class="string">'haha'</span>,</span><br><span class="line">    age:&#123;<span class="attr">$gt</span>:<span class="number">17</span>,<span class="attr">$lt</span>:<span class="number">66</span>&#125;,</span><br><span class="line">    likes:&#123;<span class="attr">$in</span>:[<span class="string">'vaporizing'</span>,<span class="string">'talking'</span>]&#125;</span><br><span class="line">&#125;).limit(<span class="number">10</span>).sort(&#123;<span class="attr">occupation</span>:<span class="number">-1</span>&#125;).</span><br><span class="line">select(&#123;<span class="attr">name</span>:<span class="number">1</span>,<span class="attr">ouccupation</span>:<span class="number">1</span>&#125;).</span><br><span class="line">exec(callback);</span><br><span class="line"></span><br><span class="line">Person.find(&#123;<span class="attr">occupation</span>:<span class="regexp">/host/</span>&#125;).</span><br><span class="line">where(<span class="string">'name.last'</span>).equals(<span class="string">'haha'</span>).</span><br><span class="line">where(<span class="string">'age'</span>).gt(<span class="number">17</span>).lt(<span class="number">66</span>).</span><br><span class="line">where(<span class="string">'likes'</span>).in([<span class="string">'vaporizing'</span>,<span class="string">'talking'</span>]).</span><br><span class="line">limit(<span class="number">10</span>).</span><br><span class="line">sort(<span class="string">'-occupation'</span>).</span><br><span class="line">select(<span class="string">'name occupation'</span>).</span><br><span class="line">exec(callback)</span><br></pre></td></tr></table></figure><h4 id="引用其他文档"><a href="#引用其他文档" class="headerlink" title="引用其他文档"></a><strong>引用其他文档</strong></h4><p>MongoDB 中没有表连接，但引用其他结合的文档有时候也会需要。population 就是这样当升的。</p><p><strong>Streaming</strong></p><p>可以用 流式处理 MongoDB 的查询结果，需要调用 Query.cursor() 函数获得 QueryCursor 的一个实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cursor = Person.find(&#123;<span class="attr">occupation</span>:<span class="regexp">/host/</span>&#125;).cursor();</span><br><span class="line"></span><br><span class="line">cursor.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">doc</span>)</span>&#123;<span class="comment">/**Called once for every document*/</span>&#125;);</span><br><span class="line">cursor.on(<span class="string">'close'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">/**Called when done*/</span>&#125;);</span><br></pre></td></tr></table></figure><h3 id="验证（validation）"><a href="#验证（validation）" class="headerlink" title="验证（validation）"></a>验证（validation）</h3><p>需要先注意下面几点：</p><ul><li>验证定义于 SchemaType</li><li>验证是一个中间件，它默认作为 <code>pre(save)</code>钩子注册在 schema 上</li><li>可以使用 <code>doc.validate(callback)</code>或者 <code>doc.validateSync()</code>手动验证</li><li>验证器不对未定义的值进行验证，唯一例外就是 require 验证器</li><li>验证是异步递归的。当调用 Model#save,子文档也会执行，出错的话 Model#save 回调会接受错误</li><li>验证是可以定制的。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="built_in">require</span>:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> Cat = db.model(<span class="string">'Cat'</span>,schema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cat = <span class="keyword">new</span> Cat();</span><br><span class="line">cat.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    assert.equal(error.errors[<span class="string">'name'</span>].message,<span class="string">'Path `name` is required.'</span>);</span><br><span class="line">    error = cat.validateSync();</span><br><span class="line">    assert.equal(error.errors[<span class="string">'name'</span>].message,<span class="string">'Path `name` is required.'</span>)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="内建-Validators"><a href="#内建-Validators" class="headerlink" title="内建 Validators"></a><strong>内建 Validators</strong></h4><p>Mongoose 有一些内建验证器</p><ul><li>所有 SchemaTypes 都有内建的 required 验证器。required 验证器使用 <code>checkRequired（）</code>函数判定这个值是否满足 required 验证器</li><li>Numbers 有 min 和 max 验证器</li><li>String 有 enum、match、maxlength 和 minlength 验证器</li></ul><p>上面的链接提供了使用和错误处理相关的详细信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> breakfastSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    eggs:&#123;</span><br><span class="line">        type:<span class="built_in">Number</span>,</span><br><span class="line">        min:[<span class="number">6</span>,<span class="string">'Too few eggs'</span>],</span><br><span class="line">        max:<span class="number">12</span></span><br><span class="line">    &#125;,</span><br><span class="line">    bacon:&#123;</span><br><span class="line">        type:<span class="built_in">Number</span>,</span><br><span class="line">        required:[<span class="literal">true</span>,<span class="string">'Why no bacon'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line">    drink:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        enum:[<span class="string">'Coffee'</span>,<span class="string">'Tea'</span>],</span><br><span class="line">        required:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.bacon &gt; <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> Breakfast = db.model(<span class="string">'Breakfast'</span>,breakfastSchema);</span><br><span class="line"><span class="keyword">const</span> badBreakfast = <span class="keyword">new</span> Breakfast(&#123;</span><br><span class="line">    eggs:<span class="number">2</span>,</span><br><span class="line">    bacon:<span class="number">0</span>,</span><br><span class="line">    drink:<span class="string">'Milk'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> error = badBreakfast.validateSync();</span><br><span class="line">assert.equal(error.errors[<span class="string">'eggs'</span>].message,<span class="string">'Too few eggs'</span>);</span><br><span class="line">assert.ok(!error.errors[<span class="string">'bacon'</span>]);</span><br><span class="line">assert.equal(error.errors[<span class="string">'drink'</span>].message,<span class="string">'`Milk` is not a valid enum value for path `drink`'</span>);</span><br><span class="line">badBreakfast.bacon = <span class="number">5</span>;</span><br><span class="line">badBreakfast.drink = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">error = badBreakfast.validateSync();</span><br><span class="line">assert.equal(error.errors[<span class="string">'drink'</span>].message,<span class="string">'Path `drink` is required'</span>);</span><br><span class="line"></span><br><span class="line">badBreakfast.bacon = <span class="literal">null</span>;</span><br><span class="line">error = badBreakfast.validateSync();</span><br><span class="line">assert.equal(error.errors[<span class="string">'bacon'</span>].message,<span class="string">'Why no bacon'</span>);</span><br></pre></td></tr></table></figure><h4 id="unique不是验证器"><a href="#unique不是验证器" class="headerlink" title="unique不是验证器"></a><strong><code>unique</code>不是验证器</strong></h4><p>它是构建  MongoDB unique indexes 的辅助函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uniqueUsernameSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    username:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        unique:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> U1 = db.model(<span class="string">'U1'</span>,uniqueUsernameSchema);</span><br><span class="line"><span class="keyword">const</span> U2 = db.model(<span class="string">'U2'</span>,uniqueUsernameSchema);</span><br><span class="line"><span class="keyword">const</span> dup = [&#123;<span class="attr">username</span>:<span class="string">'Val'</span>&#125;,&#123;<span class="attr">username</span>:<span class="string">'val'</span>&#125;]</span><br><span class="line"></span><br><span class="line">U1.create(dup,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在保存之前需要等待索引完成构建，否则可能会违反惟一的约束。</span></span><br><span class="line">U2.once(<span class="string">'index'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    assert.ifError(err);</span><br><span class="line">    U2.create(dup,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 重复键错误</span></span><br><span class="line">        assert.ok(err);</span><br><span class="line">        assert.ok(!err.errors);</span><br><span class="line">        assert.ok(error.message.indexOf(<span class="string">'duplicate key error'</span>) != <span class="number">-1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">U2.init().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    U2.create(dup,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 重复键错误</span></span><br><span class="line">        assert.ok(err);</span><br><span class="line">        assert.ok(!err.errors);</span><br><span class="line">        assert.ok(error.message.indexOf(<span class="string">'duplicate key error'</span>) != <span class="number">-1</span>);</span><br><span class="line">    &#125;);   </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="自定义验证器"><a href="#自定义验证器" class="headerlink" title="自定义验证器"></a><strong>自定义验证器</strong></h4><p>如果内建检验器不够用了，可以定义满足自己需要的验证器</p><p>自定义验证器通过传入一个验证函数来定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    phone:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        validate:&#123;</span><br><span class="line">            validator:<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="regexp">/\d&#123;3&#125;-d&#123;3&#125;-d&#123;4&#125;/</span>.test(v);</span><br><span class="line">            &#125;,</span><br><span class="line">            message:<span class="string">'&#123;VALUE&#125; is not a valid phone number!'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        required:[<span class="literal">true</span>,<span class="string">'User phone number required'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = db.model(<span class="string">'user'</span>,userSchema);</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="keyword">let</span> error;</span><br><span class="line"></span><br><span class="line">user.phone = <span class="string">'555.0123'</span>;</span><br><span class="line">error = user.validateSync();</span><br><span class="line">assert.equal(error.errors[<span class="string">'phone'</span>].message,<span class="string">'555.0123 is not a valid phone number!'</span>);</span><br><span class="line"></span><br><span class="line">user.phone = <span class="string">''</span>;</span><br><span class="line">rror = user.validateSync();</span><br><span class="line">assert.equal(error.errors[<span class="string">'phone'</span>].message,<span class="string">'User phonse number required!'</span>);</span><br><span class="line"></span><br><span class="line">user.phone = <span class="string">'201-555-0123'</span>;</span><br><span class="line">rror = user.validateSync();</span><br><span class="line">assert.equal(error,<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h4 id="异步自定义验证器"><a href="#异步自定义验证器" class="headerlink" title="异步自定义验证器"></a><strong>异步自定义验证器</strong></h4><p>自定义验证器可以是异步的，如果检验函数返回 promise (像 <code>async</code>函数)，mongoose 将会等待该 promise 完成。如果更喜欢使用回调函数，设置 <code>isAsync</code>选项，mongoose 会将回调函数作为验证函数的第二个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">// 可以通过返回一个promise使验证器异步。如果返回一个promise，不要指定' isAsync '选项。</span></span><br><span class="line">        validate:<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                   resolve(<span class="literal">false</span>) </span><br><span class="line">                &#125;,<span class="number">5</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    phone:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        validate:&#123;</span><br><span class="line">            isAsync:<span class="literal">true</span>,</span><br><span class="line">            validator:<span class="function"><span class="keyword">function</span>(<span class="params">v,cb</span>)</span>&#123;</span><br><span class="line">                setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                   <span class="keyword">const</span> phoneRegex = <span class="regexp">/\d&#123;3&#125;-d&#123;3&#125;-d&#123;4&#125;/</span>;</span><br><span class="line">                   <span class="keyword">const</span> msg = v + <span class="string">'is not a valid phone number!'</span>;</span><br><span class="line">                    <span class="comment">// 第一个参数是布尔值代表验证结果</span></span><br><span class="line">                    <span class="comment">// 第二个参数是报错信息</span></span><br><span class="line">                    cb(phoneRegex.test(v),msg);</span><br><span class="line">                &#125;,<span class="number">5</span>);</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="comment">// 默认报错信息会被 cb 的第二个参数覆盖</span></span><br><span class="line">            message:<span class="string">'Default error message'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        required:[<span class="literal">true</span>,<span class="string">'User phone number required'</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = db.model(<span class="string">'User'</span>,userSchema);</span><br><span class="line"><span class="keyword">const</span> user = <span class="keyword">new</span> User();</span><br><span class="line"><span class="keyword">let</span> error;</span><br><span class="line">user.phone = <span class="string">'555.0123'</span>;</span><br><span class="line">user.name = <span class="string">'test'</span>;</span><br><span class="line">user.validate(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    assert.ok(error);</span><br><span class="line">assert.equal(error.errors[<span class="string">'phone'</span>].message,<span class="string">'555.0123 is not a valid phone number!'</span>);</span><br><span class="line">    assert.equal(error.errors[<span class="string">'name'</span>].message,<span class="string">'Validator failed for path `name` with value `test`'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="验证错误"><a href="#验证错误" class="headerlink" title="验证错误"></a><strong>验证错误</strong></h4><p>验证失败返回 的err 包含一个 <code>ValidatorError</code>对象。每一个 ValidatorError 都有 kind、path、value 和 message 属性。ValidatorError 也有可能有 reason 属性如果验证器抛出错误，这个属性会包含该错误原因。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toySchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    color:<span class="built_in">String</span>,</span><br><span class="line">    name:<span class="built_in">String</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> validator = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="regexp">/red|white|gold/i</span>.test(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">toySchema.path(<span class="string">'color'</span>）.validate(validator,<span class="string">'Color `&#123;VALUE&#125;` not valid'</span>,<span class="string">'Invalid color'</span>);</span><br><span class="line">toySchema.path(<span class="string">'name'</span>).validate(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v !== <span class="string">'Turbo Man'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Need to get a Turbo Man for Christmas'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ture;</span><br><span class="line">&#125;,<span class="string">'Name `&#123;VALUE&#125;` is not valid'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Toy = db.model(<span class="string">'Toy'</span>,toySchema);</span><br><span class="line"><span class="keyword">const</span> toy = <span class="keyword">new</span> Toy(&#123;<span class="attr">color</span>:<span class="string">'Green'</span>,<span class="attr">name</span>:<span class="string">'Power Ranger'</span>&#125;);</span><br><span class="line">toy.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    assert.equal(err.errors.color.message, <span class="string">'Color `Green` not valid'</span>);</span><br><span class="line">    assert.equal(err.errors.color.kind, <span class="string">'Invalid color'</span>);</span><br><span class="line">    assert.equal(err.errors.color.path, <span class="string">'color'</span>);</span><br><span class="line">    assert.equal(err.errors.color.value, <span class="string">'Green'</span>);</span><br><span class="line">    assert.equal(err.errors.name.message,<span class="string">'Need to get a Turbo Man for Christmas'</span>);</span><br><span class="line">    assert.equal(err.errors.name.value, <span class="string">'Power Ranger'</span>);</span><br><span class="line">assert.equal(err.errors.name.reason.message,<span class="string">'Need to get a Turbo Man for Christmas'</span>);</span><br><span class="line">    assert.equal(err.name, <span class="string">'ValidationError'</span>);    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="嵌套对象中的-Required-验证器"><a href="#嵌套对象中的-Required-验证器" class="headerlink" title="嵌套对象中的 Required 验证器"></a><strong>嵌套对象中的 Required 验证器</strong></h4><p>定义嵌套对象的验证器需要特别注意</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        first:<span class="built_in">String</span>,</span><br><span class="line">        last:<span class="built_in">String</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">assert.throws(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 这里会报错，因为 name 不是完整路径</span></span><br><span class="line">    personSchema.path(<span class="string">'name'</span>).required(<span class="literal">true</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要让嵌套对象 required 要使用单独的嵌套 schema</span></span><br><span class="line"><span class="keyword">const</span> nameSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:nameSchema,</span><br><span class="line">        required:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">personSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:nameSchema,</span><br><span class="line">        required:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = db.model(<span class="string">'Person'</span>,personSchema);</span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">const</span> error = person.validateSync();</span><br><span class="line">assert.ok(error.errors[<span class="string">'name'</span>]);</span><br></pre></td></tr></table></figure><h4 id="Update-验证器"><a href="#Update-验证器" class="headerlink" title="Update 验证器"></a><strong>Update 验证器</strong></h4><p>Mongoose 还支持验证 update() 和 findOneAndUpdate() 操作，Update 验证器默认关闭，如果需要打开，需要配置 runValidators</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toySchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">      color: <span class="built_in">String</span>,</span><br><span class="line">      name: <span class="built_in">String</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Toy = db.model(<span class="string">'Toys'</span>, toySchema);</span><br><span class="line"></span><br><span class="line">Toy.schema.path(<span class="string">'color'</span>).validate(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/blue|green|white|red|orange|periwinkle/i</span>.test(value);</span><br><span class="line">&#125;, <span class="string">'Invalid color'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> opts = &#123; <span class="attr">runValidators</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">Toy.update(&#123;&#125;, &#123; <span class="attr">color</span>: <span class="string">'bacon'</span> &#125;, opts, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  assert.equal(err.errors.color.message,<span class="string">'Invalid color'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Update-验证器-与-this"><a href="#Update-验证器-与-this" class="headerlink" title="Update 验证器 与 this"></a><strong>Update 验证器 与 <code>this</code></strong></h4><p>update 验证器和 document 验证器有很多不同。上面的颜色验证函数，this 指向验证中的 document，然后update 验证器运行时，被更新文档不一定存在于服务器内存，所以 this 值未定义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toySchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  color: <span class="built_in">String</span>,</span><br><span class="line">  name: <span class="built_in">String</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">toySchema.path(<span class="string">'color'</span>).validate(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在运行“validate()”或“validateSync()”时</span></span><br><span class="line">  <span class="comment">// 验证器可以使用“this”访问文档。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.name.toLowerCase().indexOf(<span class="string">'red'</span>) !== <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value !== <span class="string">'red'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Toy = db.model(<span class="string">'ActionFigure'</span>, toySchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> toy = <span class="keyword">new</span> Toy(&#123; <span class="attr">color</span>: <span class="string">'red'</span>, <span class="attr">name</span>: <span class="string">'Red Power Ranger'</span> &#125;);</span><br><span class="line"><span class="keyword">const</span> error = toy.validateSync();</span><br><span class="line">assert.ok(error.errors[<span class="string">'color'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> update = &#123; <span class="attr">color</span>: <span class="string">'red'</span>, <span class="attr">name</span>: <span class="string">'Red Power Ranger'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> opts = &#123; <span class="attr">runValidators</span>: <span class="literal">true</span> &#125;;</span><br><span class="line"></span><br><span class="line">Toy.update(&#123;&#125;, update, opts, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// The update validator throws an error:</span></span><br><span class="line">  <span class="comment">// "TypeError: Cannot read property 'toLowerCase' of undefined",</span></span><br><span class="line">  <span class="comment">// because `this` is **not** the document being updated when using</span></span><br><span class="line">  <span class="comment">// update validators</span></span><br><span class="line">  assert.ok(error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="context选项"><a href="#context选项" class="headerlink" title="context选项"></a><strong><code>context</code>选项</strong></h4><p>context 选项运行把 update 验证器的 this 设定为 query</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">toySchema.path(<span class="string">'color'</span>).validate(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// When running update validators with the `context` option set to</span></span><br><span class="line">    <span class="comment">// 'query', `this` refers to the query object.</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.getUpdate().$set.name.toLowerCase().indexOf(<span class="string">'red'</span>) !== <span class="number">-1</span>)&#123;</span><br><span class="line">       <span class="keyword">return</span> value == <span class="string">'red'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Toy = db.model(<span class="string">'Figure'</span>,toySchema);</span><br><span class="line"><span class="keyword">const</span> update = &#123;<span class="attr">color</span>:<span class="string">'blue'</span>,<span class="attr">name</span>:<span class="string">'haha'</span>&#125;</span><br><span class="line"><span class="comment">// Note the context option</span></span><br><span class="line"><span class="keyword">const</span> opts = &#123;<span class="attr">runValidators</span>:<span class="literal">true</span>,<span class="attr">context</span>:<span class="string">'query'</span>&#125;</span><br><span class="line">Toy.update(&#123;&#125;,update,opts,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    assert.ok(error.errors[<span class="string">'color'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Update-验证器字段路径"><a href="#Update-验证器字段路径" class="headerlink" title="Update 验证器字段路径"></a><strong>Update 验证器字段路径</strong></h4><p>另一个关键不同点是 update 验证器只运行于更新的字段。 下例中，因为 ‘name’ 在更新操作未被指定，所以此次更新操作成功。</p><p>使用 update 验证器的时候， <code>required</code> 验证器<strong>只会</strong>在你对某个字段显式使用 <code>$unset</code> 才会触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> kittenSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  name: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">  age: <span class="built_in">Number</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Kitten = db.model(<span class="string">'Kitten'</span>, kittenSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> update = &#123; <span class="attr">color</span>: <span class="string">'blue'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> opts = &#123; <span class="attr">runValidators</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">Kitten.update(&#123;&#125;, update, opts, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 即使 'name' 没有指定也操作成功了</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> unset = &#123; <span class="attr">$unset</span>: &#123; <span class="attr">name</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line">Kitten.update(&#123;&#125;, unset, opts, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 'name' required， 操作失败</span></span><br><span class="line">  assert.ok(err);</span><br><span class="line">  assert.ok(err.errors[<span class="string">'name'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Update-验证器只运行于指定字段路径"><a href="#Update-验证器只运行于指定字段路径" class="headerlink" title="Update 验证器只运行于指定字段路径"></a><strong>Update 验证器只运行于指定字段路径</strong></h4><p>最后要注意的是：update 验证器<strong>只</strong>运行于下列更新操作：</p><ul><li><code>$set</code></li><li><code>$unset</code></li><li><code>$push</code> (&gt;= 4.8.0)</li><li><code>$addToSet</code> (&gt;= 4.8.0)</li><li><code>$pull</code> (&gt;= 4.12.0)</li><li><code>$pullAll</code> (&gt;= 4.12.0)</li></ul><p>例如，以下 update 成功执行，不管 <code>number</code> 的值，因为 update 验证器 无视 <code>$inc</code> 。同样， <code>$push</code>、<code>$addToSet</code>、 <code>$pull</code>和 <code>$pullAll</code> 验证器 不会对数组自身验证，只会对数组中的元素验证。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  number: &#123; <span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">max</span>: <span class="number">0</span> &#125;,</span><br><span class="line">  arr: [&#123; <span class="attr">message</span>: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">maxlength</span>: <span class="number">10</span> &#125; &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Update 验证器不会作检查，所以你再仍然可以 `$push` 两个元素到数组 </span></span><br><span class="line"><span class="comment">// 只要他们的 `message` 没有超长</span></span><br><span class="line">testSchema.path(<span class="string">'arr'</span>).validate(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v.length &lt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Test = db.model(<span class="string">'Test'</span>, testSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> update = &#123; <span class="attr">$inc</span>: &#123; <span class="attr">number</span>: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> opts = &#123; <span class="attr">runValidators</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">Test.update(&#123;&#125;, update, opts, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这里不会报错</span></span><br><span class="line">  update = &#123; <span class="attr">$push</span>: [&#123; <span class="attr">message</span>: <span class="string">'hello'</span> &#125;, &#123; <span class="attr">message</span>: <span class="string">'world'</span> &#125;] &#125;;</span><br><span class="line">  Test.update(&#123;&#125;, update, opts, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里也不会报错</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="push-和-addToSet"><a href="#push-和-addToSet" class="headerlink" title="\$push 和 \$addToSet"></a><strong>\$push 和 \$addToSet</strong></h4><p>4.8.0 新特性： update 验证器也运行于 <code>$push</code> 和 <code>$addToSet</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> testSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  numbers: [&#123; <span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">max</span>: <span class="number">0</span> &#125;],</span><br><span class="line">  docs: [&#123;</span><br><span class="line">    name: &#123; <span class="attr">type</span>: <span class="built_in">String</span>, <span class="attr">required</span>: <span class="literal">true</span> &#125;</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Test = db.model(<span class="string">'TestPush'</span>, testSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> update = &#123;</span><br><span class="line">  $push: &#123;</span><br><span class="line">    numbers: <span class="number">1</span>,</span><br><span class="line">    docs: &#123; <span class="attr">name</span>: <span class="literal">null</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> opts = &#123; <span class="attr">runValidators</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">Test.update(&#123;&#125;, update, opts, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  assert.ok(error.errors[<span class="string">'numbers'</span>]);</span><br><span class="line">  assert.ok(error.errors[<span class="string">'docs'</span>]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="中间件（middleware）"><a href="#中间件（middleware）" class="headerlink" title="中间件（middleware）"></a>中间件（middleware）</h3><p>中间件（pre 和 post）是在异步函数执行时函数传入的控制函数。中间件在 Schema 上指定，在写插件时很有用。Mongoose 4.x 有四种中间件：document、model、aggregate、query 中间件。对于 document 中间件，this 指向当前的 document，Document 中间件支持下面的 document 操作：</p><ul><li>init</li><li>validate</li><li>save</li><li>remove</li></ul><p>对于 query中间件，this 指向 query。Query 中间件支持一下 Model 和 Query 操作：</p><ul><li>count</li><li>find</li><li>findOne</li><li>findOneAndRemove</li><li>findOneAndUpdate</li><li>update</li></ul><p>Aggregate 中间件作用于 MyModel.aggregat(),它会在对 aggregate 对象调用 exec() 时执行。对于 aggregate 中间件，this 也是指向 aggregation 对象。</p><ul><li>aggregate</li></ul><p>对于 model 中间件来说，this 是指向当前的model.Model 中间件支持下面的操作：</p><ul><li>insertMany</li></ul><p>所有的中间件支持 pre 和 post 钩子，下面解释这两个钩子的细节。</p><p>注意：Query 是没有 remove 钩子的，只有 document有，如果设定了 remove 钩子，将会在调用 myDoc.remove()而不是MyModel.remove 的时候触发。只有 create() 函数会触发 save() 钩子。</p><h4 id="Pre"><a href="#Pre" class="headerlink" title="Pre"></a><strong>Pre</strong></h4><p>pre 钩子分为串行和并行两种。</p><p><strong>串行</strong></p><p>串行中间件一个接一个地执行，具体来说，上一个中间件调用 next 函数的时候，下一个执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;);</span><br><span class="line"></span><br><span class="line">schema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 5.x 版本中，除了手动调用 next ，可以返回一个 promise ，甚至是 async/await。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">schema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doStuff().then(<span class="function"><span class="params">()</span>=&gt;</span>doMoreStuff())</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 或者 Node.js &gt;= 7.6.0:</span></span><br><span class="line">schema.pre(<span class="string">'save'</span>,<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> doStuff();</span><br><span class="line">    <span class="keyword">await</span> doMoreStuff();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>next() 不会阻止剩余代码的运行，可以使用提前 return 模式来阻止 next () 后面的代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;);</span><br><span class="line">schema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(foo())&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="string">'calling next'</span>);</span><br><span class="line">       <span class="comment">// `return next();` will make sure the rest of this function doesn't run</span></span><br><span class="line">       next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Unless you comment out the `return` above, 'after next' will print</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'after next'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>并行</strong></p><p>并行中间件提供细粒度流控制</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;..&#125;);</span><br><span class="line"><span class="comment">// true 代表这是一个并行中间件，如果要使用并行中间件，必须指定 true 为第二个参数</span></span><br><span class="line">schema.pre(<span class="string">'save'</span>,<span class="literal">true</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next,done</span>)</span>&#123;</span><br><span class="line">    next();</span><br><span class="line">    setTimeout(done,<span class="number">100</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述的例子中，save 方法将在所有中间件都调用了 done 的时候才会执行。</p><p>使用场景：</p><p>中间件对原子化模型逻辑很有帮助，这里有一些其他建议：</p><ul><li>复杂的数据校验</li><li>删除依赖文档（删除用户后删除其他所有文章）</li><li>某个操作触发的异步任务</li></ul><p>错误处理：</p><p>如果 pre 钩子出错，momgoose 将不会执行后面的函数。Mongoose 会向回调函数传入 err 参数，或者 reject 返回的 promise 。下面是几个错误的处理的方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">schema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> err = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'something went gone'</span>);</span><br><span class="line">    next(err);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">schema.pre(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'something went gone'</span>))</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">schema.pre(<span class="string">'save'</span>,<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'something went gone'</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">myDoc.save(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.message);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>多次调用 next 是无效的，如果调用 next 带有错误参数 err1 ，然后再抛出一个 err2，mongoose 只会传递 err1</p><h4 id="Post中间件"><a href="#Post中间件" class="headerlink" title="Post中间件"></a><strong>Post中间件</strong></h4><p>post 中间件在方法执行之后调用，这个时候每个 pre 中间件都已经完成了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">schema.post(<span class="string">'init'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'%s has been initialized from the db'</span>, doc._id);</span><br><span class="line">&#125;);</span><br><span class="line">schema.post(<span class="string">'validate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'%s has been validated (but not saved yet)'</span>, doc._id);</span><br><span class="line">&#125;);</span><br><span class="line">schema.post(<span class="string">'save'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'%s has been saved'</span>, doc._id);</span><br><span class="line">&#125;);</span><br><span class="line">schema.post(<span class="string">'remove'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'%s has been removed'</span>, doc._id);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="异步-Post-钩子"><a href="#异步-Post-钩子" class="headerlink" title="异步 Post 钩子"></a><strong>异步 Post 钩子</strong></h4><p>如果给回调函数传入两个参数，mongoose 会认为第二个参数 next 函数，可以通过 next 触发下一个中间件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">schema.post(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">doc,next</span>)</span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'post1'</span>);</span><br><span class="line">        next();</span><br><span class="line">    &#125;,<span class="number">10</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 直到第一个中间件执行 next() 才会执行</span></span><br><span class="line">schema.post(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">doc,next</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'post2'</span>);</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Save-Validate钩子"><a href="#Save-Validate钩子" class="headerlink" title="Save/Validate钩子"></a><strong>Save/Validate钩子</strong></h4><p>save() 函数触发 validate 钩子，mongoose validate() 其实就是 pre(‘save’)钩子，这意味着所有 pre(‘validate’) 和 post(‘validate’)都会在 pre(‘save’)钩子之前调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">schema.pre(<span class="string">'validate'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this gets printed first'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">schema.post(<span class="string">'validate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this gets printed second'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">schema.pre(<span class="string">'save'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this gets printed third'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">schema.post(<span class="string">'save'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this gets printed fourth'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="finAndUpdate-与-Query-中间件使用注意"><a href="#finAndUpdate-与-Query-中间件使用注意" class="headerlink" title="finAndUpdate() 与 Query 中间件使用注意"></a><strong>finAndUpdate() 与 Query 中间件使用注意</strong></h4><p>pre 和 post save() 钩子都不执行于 update ,findOneAndUpdate 等情况。Mongoose4.0 为这些函数制定了新钩子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">schema.pre(<span class="string">'find'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span> <span class="keyword">instanceof</span> mongoose.Query); <span class="comment">// true</span></span><br><span class="line">    <span class="keyword">this</span>.start = <span class="built_in">Date</span>.now()</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">schema.post(<span class="string">'find'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="keyword">this</span> <span class="keyword">instanceof</span> mongoose.Query); <span class="comment">// true</span></span><br><span class="line">  <span class="comment">// prints returned documents</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'find() returned '</span> + <span class="built_in">JSON</span>.stringify(result));</span><br><span class="line">  <span class="comment">// prints number of milliseconds the query took</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'find() took '</span> + (<span class="built_in">Date</span>.now() - <span class="keyword">this</span>.start) + <span class="string">' millis'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Query 中间件不同于 document 中间件，document 中间件中，this 指向被更新 document,query 中间件中，this 指向query 对象而不是被更新 document</p><p>例如，如果要每次 update 之前更新 updateAt 时间戳，可以使用 pre 钩子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">schema.pre(<span class="string">'update'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.update(&#123;&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="attr">updateAt</span>:<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="错误处理中间件"><a href="#错误处理中间件" class="headerlink" title="错误处理中间件"></a><strong>错误处理中间件</strong></h4><p>错误处理中间件比普通中间件多一个 <code>error</code> 参数，并且 <code>err</code> 作为第一个参数传入。 而后错误处理中间件可以让你自由地做错误的后续处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> schema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        type:<span class="built_in">String</span>,</span><br><span class="line">        <span class="comment">// // Will trigger a MongoError with code 11000 when you save a duplicate</span></span><br><span class="line">        unique:<span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理函数必须传入3个参数：发生的错误，返回文件，以及 next 函数</span></span><br><span class="line">schema.post(<span class="string">'save'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error,doc,next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(error.name === <span class="string">'MongoError'</span> &amp;&amp; error.code === <span class="number">11000</span>)&#123;</span><br><span class="line">        next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'There was a duplicate key error'</span>))</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Will trigger the `post('save')` error handler</span></span><br><span class="line">Person.create([&#123;<span class="attr">name</span>:<span class="string">'Axl Rose'</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'Axl Rose'</span>&#125;]);</span><br></pre></td></tr></table></figure><p>对于query 中间件也可以使用错误处理，可以定义一个 post update 钩子，它可以捕获 MongoDB 重复 key 错误。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">schema.post(<span class="string">'update'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">error,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(error.name === <span class="string">'MongoError'</span> &amp;&amp; error.code === <span class="number">11000</span>)&#123;</span><br><span class="line">        next(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'There was a duplicate key error'</span>))</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> people = [&#123;<span class="attr">name</span>:<span class="string">'Axl Rose'</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">'Axl Rose'</span>&#125;];</span><br><span class="line">Person.create(people,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    Person.update(&#123;<span class="attr">name</span>:<span class="string">'haha'</span>&#125;,&#123;<span class="attr">$set</span>:&#123;<span class="attr">name</span>:<span class="string">'Axl Rose'</span>&#125;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">        <span class="comment">// error.message` will be "There was a duplicate key error"</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="填充（Populate）"><a href="#填充（Populate）" class="headerlink" title="填充（Populate）"></a>填充（Populate）</h3><p>像sql 里面的 join 的聚合操作，populate 可以让你在别的 collection 中引用 document</p><p>Population 可以自动替换 document 中的指定字段，替换内容从其他 collection 获取。我们可以填充单个或者每个 document、单个或者多个纯对象，甚至是 query 返回的一切对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">'mongoose'</span>);</span><br><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema;</span><br><span class="line"><span class="keyword">const</span> personSchema = Schema(&#123;</span><br><span class="line">    _id:Schema.Types.ObjectId,</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    age:<span class="built_in">Number</span>,</span><br><span class="line">    stories:[&#123;<span class="attr">type</span>:Schema.Types.ObjectId,<span class="attr">ref</span>:<span class="string">'Story'</span>&#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> storySchema = Schema(&#123;</span><br><span class="line">    author:&#123;</span><br><span class="line">        type:Schema.Types.ObjectId,</span><br><span class="line">        ref:<span class="string">'Person'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    title:<span class="built_in">String</span>,</span><br><span class="line">    fans:[&#123;</span><br><span class="line">        type:Schema.Types.ObjectId,</span><br><span class="line">        ref:<span class="string">'Person'</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Story = mongoose.model(<span class="string">'Story'</span>,storySchema);</span><br><span class="line"><span class="keyword">const</span> Person = mongoose.model(<span class="string">'Person'</span>,personSchema);</span><br></pre></td></tr></table></figure><p>上面创建了两个 Model，Person model 的 stories 字段设为 ObjectId 数组。ref 选项告诉 Mongoose 在填充的时候使用哪个 model，上例中为 Story 的 model.所有存储在此的 _id 必须是 Story model 中的 document 的 _id。</p><p>注意：ObjectId、Number、String 以及 Buffer 都可以作为 refs 使用。但是最好还是用 ObjectId</p><h4 id="保存-refs"><a href="#保存-refs" class="headerlink" title="保存 refs"></a><strong>保存 refs</strong></h4><p>保存 refs 与保存普通属性一样，把 _id 的值赋给它就好了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> author = <span class="keyword">new</span> Person(&#123;</span><br><span class="line">  _id: <span class="keyword">new</span> mongoose.Types.ObjectId(),</span><br><span class="line">  name: <span class="string">'Ian Fleming'</span>,</span><br><span class="line">  age: <span class="number">50</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">author.save(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> story1 = <span class="keyword">new</span> Story(&#123;</span><br><span class="line">    title: <span class="string">'Casino Royale'</span>,</span><br><span class="line">    author: author._id    <span class="comment">// assign the _id from the person</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  story1.save(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="comment">// thats it!</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Population"><a href="#Population" class="headerlink" title="Population"></a><strong>Population</strong></h4><p>我们做的东西还是跟平时差不多，只是创建了 <code>Person</code> 和 <code>Story</code>。现在试试对query 填充 story 的 author。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Story.findOne(&#123;</span><br><span class="line">    title:<span class="string">'haha'</span></span><br><span class="line">&#125;).population(<span class="string">'author'</span>).exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,story</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The author is %s'</span>, story.author.name);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>被填充的字段已经不再是原来的 _id，而是被指定的 document 替代，这个 document 由另一条 query 从数据库返回。refs 数组的原理也是相似的。对 query 对象调用 populate 方法，就能返回装载对应 _id 的 document 数组。</p><h4 id="设置被填充字段"><a href="#设置被填充字段" class="headerlink" title="设置被填充字段"></a><strong>设置被填充字段</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Story.findOne(&#123; <span class="attr">title</span>: <span class="string">'Casino Royale'</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error, story</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="keyword">return</span> handleError(error);</span><br><span class="line">  &#125;</span><br><span class="line">  story.author = author;</span><br><span class="line">  <span class="built_in">console</span>.log(story.author.name); <span class="comment">// prints "Ian Fleming"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="字段选择"><a href="#字段选择" class="headerlink" title="字段选择"></a><strong>字段选择</strong></h4><p>如果我们只需要填充 document 其中一部分字段，第二个参数传入 field name syntax 就可以实现。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Story.</span><br><span class="line">findOne(&#123;<span class="attr">title</span>:<span class="regexp">/casino royale/i</span>&#125;).</span><br><span class="line">populate(<span class="string">'author'</span>,<span class="string">'name'</span>).<span class="comment">// only return the Persons name</span></span><br><span class="line">exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,story</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'The author is %s'</span>, story.author.name); <span class="comment">// The author is Ian Fleming</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'The author is %s'</span>, story.author.age); <span class="comment">// The authors age is null</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="填充多个字段"><a href="#填充多个字段" class="headerlink" title="填充多个字段"></a><strong>填充多个字段</strong></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Story.</span><br><span class="line">  find(...).</span><br><span class="line">  populate(<span class="string">'fans'</span>).</span><br><span class="line">  populate(<span class="string">'author'</span>).</span><br><span class="line">  exec();</span><br></pre></td></tr></table></figure><p>如果对同一路径 populate 两次，只有最后一次生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二个会覆盖第一个的</span></span><br><span class="line">Story.</span><br><span class="line">  find().</span><br><span class="line">  populate(&#123; <span class="attr">path</span>: <span class="string">'fans'</span>, <span class="attr">select</span>: <span class="string">'name'</span> &#125;).</span><br><span class="line">  populate(&#123; <span class="attr">path</span>: <span class="string">'fans'</span>, <span class="attr">select</span>: <span class="string">'email'</span> &#125;);</span><br><span class="line"><span class="comment">// The above is equivalent to:</span></span><br><span class="line">Story.find().populate(&#123; <span class="attr">path</span>: <span class="string">'fans'</span>, <span class="attr">select</span>: <span class="string">'email'</span> &#125;);</span><br></pre></td></tr></table></figure><h4 id="Query-条件与其他选项"><a href="#Query-条件与其他选项" class="headerlink" title="Query 条件与其他选项"></a><strong>Query 条件与其他选项</strong></h4><p>如果要根据年龄来填充，只填充 name,并且值返回最多5个数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Story.</span><br><span class="line">  find(...).</span><br><span class="line">  populate(&#123;</span><br><span class="line">    path: <span class="string">'fans'</span>,</span><br><span class="line">    match: &#123; <span class="attr">age</span>: &#123; <span class="attr">$gte</span>: <span class="number">21</span> &#125;&#125;,</span><br><span class="line">    <span class="comment">// Explicitly exclude `_id`, see http://bit.ly/2aEfTdB</span></span><br><span class="line">    select: <span class="string">'name -_id'</span>,</span><br><span class="line">    options: &#123; <span class="attr">limit</span>: <span class="number">5</span> &#125;</span><br><span class="line">  &#125;).</span><br><span class="line">  exec();</span><br></pre></td></tr></table></figure><h4 id="Refs-到-children"><a href="#Refs-到-children" class="headerlink" title="Refs 到 children"></a><strong>Refs 到 children</strong></h4><p>我们发现，用 author 对象没有办法获取 story 列表，因为 author.stories 没有被 pushed 任何 story 对象</p><p>我们希望 author 知道哪些 story 属于他们，通常，schema 应该通过在 多 的一方使用指向它们的父节点（parent pointer）解决一对多关系问题。另一方面，如果有充分理由得到指向子节点的数组，可以像下面代码一样把 document push() 到数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">author.stories.push(story1);</span><br><span class="line">author.save(callback);</span><br></pre></td></tr></table></figure><p>然后我们就能 find 和 populate 了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person.findOne(&#123;<span class="attr">name</span>:<span class="string">'Ian Fleming'</span>&#125;).</span><br><span class="line">populate(<span class="string">'stories'</span>).</span><br><span class="line">exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,person</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="keyword">throw</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(person);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果父子节点互相指向，数据可能会在某一时刻失去同步。为此我们可以不使用填充，直接 <code>find()</code>我们需要的 story</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Story.find(&#123;<span class="attr">author</span>:author._id&#125;).</span><br><span class="line">exec(<span class="function"><span class="keyword">function</span>(<span class="params">err, stories</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">return</span> handleError(err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The stories are an array: '</span>, stories);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>query 填充后返回的 document 功能齐全，除非设置 lean 选项，否则它就是可 remove，可 save 的。调用 remove 不单是从数组中删除也是从数据库中删除它们。</p><h4 id="填充现有-document"><a href="#填充现有-document" class="headerlink" title="填充现有 document"></a><strong>填充现有 document</strong></h4><p>document#populate()</p><h4 id="填充多个现有-document"><a href="#填充多个现有-document" class="headerlink" title="填充多个现有 document"></a><strong>填充多个现有 document</strong></h4><p>如果需要填充一个或者多个 document 对象，我们可以使用 Model.populate 方法。</p><h4 id="多级填充"><a href="#多级填充" class="headerlink" title="多级填充"></a><strong>多级填充</strong></h4><p>假设 user schema 记录了 user 的 friends</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    friends:[&#123;</span><br><span class="line">        type:ObjectId,</span><br><span class="line">        ref:<span class="string">'User'</span></span><br><span class="line">    &#125;]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当然可以填充得到用户的 friends 列表，但是如果要在获得他们朋友的朋友呢？指定 <code>populate</code>选项就可以了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User.findOne(&#123;<span class="attr">name</span>:<span class="string">'Val'</span>&#125;).</span><br><span class="line">populate(&#123;</span><br><span class="line">    path:<span class="string">'friends'</span>,</span><br><span class="line">    populate:&#123;</span><br><span class="line">        path:<span class="string">'friends'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="跨数据库填充"><a href="#跨数据库填充" class="headerlink" title="跨数据库填充"></a><strong>跨数据库填充</strong></h4><p>假设现在有 event schema 和 conversation schema,每个 event 对应一个 conversation 线程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    conversation:ObjectId</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> conversationSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    numMessage:<span class="built_in">Number</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>并且，event 和 conversation 保存在不同的 MongoDB 实例中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> db1 = mongoose.createConnection(<span class="string">'localhost:27000/db1'</span>);</span><br><span class="line"><span class="keyword">const</span> db2 = mongoose.createConnection(<span class="string">'localhost:27001/db2'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Event = db1.model(<span class="string">'Event'</span>, eventSchema);</span><br><span class="line"><span class="keyword">const</span> Conversation = db2.model(<span class="string">'Conversation'</span>, conversationSchema);</span><br></pre></td></tr></table></figure><p>这个情况就<strong>不能</strong>直接使用 <code>populate()</code> 了，因为 <code>populate()</code> 不知道应该使用什么填充。 可以显式指定一个 model</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Event.find().population(&#123;<span class="attr">path</span>:<span class="string">'conversation'</span>,<span class="attr">model</span>:Conversation&#125;).</span><br><span class="line">exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,docs</span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure><h4 id="动态引用"><a href="#动态引用" class="headerlink" title="动态引用"></a><strong>动态引用</strong></h4><p>Mongoose 也可以从多个 collection 填充。假设 user schema 有一系列 connection，一个 user 可以连接到其他 user 或者组织。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> userSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">    name:<span class="built_in">String</span>,</span><br><span class="line">    connection:[&#123;</span><br><span class="line">        kind:<span class="built_in">String</span>,</span><br><span class="line">        item:&#123;</span><br><span class="line">            type:ObjectId,</span><br><span class="line">            refPath:<span class="string">'connections.kind'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> organizationSchema = <span class="keyword">new</span> Schema(&#123;<span class="attr">name</span>:<span class="built_in">String</span>,<span class="attr">kind</span>:<span class="built_in">String</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> User = mongoose.model(<span class="string">'User,userSchema'</span>);</span><br><span class="line"><span class="keyword">const</span> Organization = mongoose.model(<span class="string">'Organization'</span>,organizationSchema);</span><br></pre></td></tr></table></figure><p>上面的 <code>refPath</code> 属性意味着 mongoose 会查找 <code>connections.kind</code> 路径， 以此确定 <code>populate()</code> 使用的 model。换句话说，<code>refPath</code> 属性可以让你动态寻找 <code>ref</code>。</p><h3 id="鉴别器（Discriminators）"><a href="#鉴别器（Discriminators）" class="headerlink" title="鉴别器（Discriminators）"></a>鉴别器（Discriminators）</h3><p>Discriminator 是一种 schema 继承机制。它允许在相同的底层 MongoDB  collection 上使用部分重叠的 schema 建立多个 model。</p><p>假设要在单个 collection 中记录多种 event ，每个 event 都有时间戳字段，但是 click 事件还有 URL 字段，可以用 model.discriminator 实现上面的要求。这个函数需要两个参数，model 名称和 discriminator  schema,返回 model 结合原 model 的 schema 和 discriminator schema.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123; <span class="attr">discriminatorKey</span>:<span class="string">'kind'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> eventSchema = <span class="keyword">new</span> mongoose.Schema(&#123;<span class="attr">tiem</span>:<span class="built_in">Date</span>&#125;,options);</span><br><span class="line"><span class="keyword">const</span> Event = mongoose.model(<span class="string">'Event'</span>.eventSchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClickedLinkEvent 是一个有 URL 的特别 event</span></span><br><span class="line"><span class="keyword">const</span> ClickedLinkEvent = Event.discriminator(<span class="string">'ClickedLink'</span>,</span><br><span class="line">  <span class="keyword">new</span> mongoose.Schema(&#123;<span class="attr">url</span>: <span class="built_in">String</span>&#125;, options));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当你创建通用 event，他将没有 URL 字段...</span></span><br><span class="line"><span class="keyword">const</span> genericEvent = <span class="keyword">new</span> Event(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">url</span>: <span class="string">'google.com'</span>&#125;);</span><br><span class="line">assert.ok(!genericEvent.url);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是 ClickedLinkEvent 可以有</span></span><br><span class="line"><span class="keyword">const</span> clickedEvent =</span><br><span class="line">  <span class="keyword">new</span> ClickedLinkEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">url</span>: <span class="string">'google.com'</span>&#125;);</span><br><span class="line">assert.ok(clickedEvent.url);</span><br></pre></td></tr></table></figure><h4 id="Discriminator-储存在-Event-model-的-collection"><a href="#Discriminator-储存在-Event-model-的-collection" class="headerlink" title="Discriminator 储存在 Event model 的 collection"></a><strong>Discriminator 储存在 Event model 的 collection</strong></h4><p>现在假设你要创建另一个 discriminator，记录用户注册 event。 <code>SignedUpEvent</code> 实例将跟 通用 events 和 <code>ClickedLinkEvent</code> 实例 一样储存在同一个 collection。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event1 = <span class="keyword">new</span> Event(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now()&#125;);</span><br><span class="line"><span class="keyword">const</span> event2 = <span class="keyword">new</span> ClickedLinkEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">url</span>: <span class="string">'google.com'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> event3 = <span class="keyword">new</span> SignedUpEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">user</span>: <span class="string">'testuser'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> save = <span class="function"><span class="keyword">function</span> (<span class="params">doc, callback</span>) </span>&#123;</span><br><span class="line">  doc.save(<span class="function"><span class="keyword">function</span> (<span class="params">error, doc</span>) </span>&#123;</span><br><span class="line">    callback(error, doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>.map([event1, event2, event3], save, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  Event.count(&#123;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error, count</span>) </span>&#123;</span><br><span class="line">    assert.equal(count, <span class="number">3</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Discriminator-keys"><a href="#Discriminator-keys" class="headerlink" title="Discriminator keys"></a><strong>Discriminator keys</strong></h4><p>Mongoose 通过 ‘discriminator key’ 识别两个不同的 discriminator， 这个值默认是 <code>__t</code> 。Mongoose 自动在你的 schema 添加 <code>__t</code> 字段， 记录你的 document 是哪个 discriminator 的实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event1 = <span class="keyword">new</span> Event(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now()&#125;);</span><br><span class="line"><span class="keyword">const</span> event2 = <span class="keyword">new</span> ClickedLinkEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">url</span>: <span class="string">'google.com'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> event3 = <span class="keyword">new</span> SignedUpEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">user</span>: <span class="string">'testuser'</span>&#125;);</span><br><span class="line"></span><br><span class="line">assert.ok(!event1.__t);</span><br><span class="line">assert.equal(event2.__t, <span class="string">'ClickedLink'</span>);</span><br><span class="line">assert.equal(event3.__t, <span class="string">'SignedUp'</span>);</span><br></pre></td></tr></table></figure><h4 id="Discriminator-在查询中添加-discriminator-key"><a href="#Discriminator-在查询中添加-discriminator-key" class="headerlink" title="Discriminator 在查询中添加 discriminator key"></a><strong>Discriminator 在查询中添加 discriminator key</strong></h4><p>Discriminator model 的特别之处在于：他们会把 discriminator key 附到 query 上。换句话说，<code>find()</code>, <code>count()</code>, <code>aggregate()</code> 等方法 都能适配 discriminators。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> event1 = <span class="keyword">new</span> Event(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now()&#125;);</span><br><span class="line"><span class="keyword">const</span> event2 = <span class="keyword">new</span> ClickedLinkEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">url</span>: <span class="string">'google.com'</span>&#125;);</span><br><span class="line"><span class="keyword">const</span> event3 = <span class="keyword">new</span> SignedUpEvent(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>.now(), <span class="attr">user</span>: <span class="string">'testuser'</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> save = <span class="function"><span class="keyword">function</span> (<span class="params">doc, callback</span>) </span>&#123;</span><br><span class="line">  doc.save(<span class="function"><span class="keyword">function</span> (<span class="params">error, doc</span>) </span>&#123;</span><br><span class="line">    callback(error, doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span>.map([event1, event2, event3], save, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  ClickedLinkEvent.find(&#123;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error, docs</span>) </span>&#123;</span><br><span class="line">    assert.equal(docs.length, <span class="number">1</span>);</span><br><span class="line">    assert.equal(docs[<span class="number">0</span>]._id.toString(), event2._id.toString());</span><br><span class="line">    assert.equal(docs[<span class="number">0</span>].url, <span class="string">'google.com'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="Discriminator-复制-pre-post-钩子"><a href="#Discriminator-复制-pre-post-钩子" class="headerlink" title="Discriminator 复制 pre / post 钩子"></a><strong>Discriminator 复制 pre / post 钩子</strong></h4><p>Discriminator 会继承他的基础 schema 的 pre 和 post 中间件。 不过，你也可以为 discriminator 添加中间件，这不回影响到基础 schema。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;<span class="attr">discriminatorKey</span>: <span class="string">'kind'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventSchema = <span class="keyword">new</span> mongoose.Schema(&#123;<span class="attr">time</span>: <span class="built_in">Date</span>&#125;, options);</span><br><span class="line"><span class="keyword">const</span> eventSchemaCalls = <span class="number">0</span>;</span><br><span class="line">eventSchema.pre(<span class="string">'validate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">  ++eventSchemaCalls;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> Event = mongoose.model(<span class="string">'GenericEvent'</span>, eventSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clickedLinkSchema = <span class="keyword">new</span> mongoose.Schema(&#123;<span class="attr">url</span>: <span class="built_in">String</span>&#125;, options);</span><br><span class="line"><span class="keyword">const</span> clickedSchemaCalls = <span class="number">0</span>;</span><br><span class="line">clickedLinkSchema.pre(<span class="string">'validate'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">next</span>) </span>&#123;</span><br><span class="line">  ++clickedSchemaCalls;</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> ClickedLinkEvent = Event.discriminator(<span class="string">'ClickedLinkEvent'</span>,</span><br><span class="line">  clickedLinkSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event1 = <span class="keyword">new</span> ClickedLinkEvent();</span><br><span class="line">event1.validate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  assert.equal(eventSchemaCalls, <span class="number">1</span>);</span><br><span class="line">  assert.equal(clickedSchemaCalls, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> generic = <span class="keyword">new</span> Event();</span><br><span class="line">  generic.validate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    assert.equal(eventSchemaCalls, <span class="number">2</span>);</span><br><span class="line">    assert.equal(clickedSchemaCalls, <span class="number">1</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="处理自定义-id-字段"><a href="#处理自定义-id-字段" class="headerlink" title="处理自定义 _id 字段"></a><strong>处理自定义 _id 字段</strong></h4><p>Discriminator 的字段是基础 schema 加 discriminator schema ， 并且以 discriminator schema 的字段优先。 但有一个例外，<code>_id</code> 字段。</p><p>You can work around this by setting the <code>_id</code> option to false in the discriminator schema as shown below.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> options = &#123;<span class="attr">discriminatorKey</span>: <span class="string">'kind'</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基础 schema 有字符串格式的 `_id` 字段和 Data 格式的 `time` 字段...</span></span><br><span class="line"><span class="keyword">const</span> eventSchema = <span class="keyword">new</span> mongoose.Schema(&#123;<span class="attr">_id</span>: <span class="built_in">String</span>, <span class="attr">time</span>: <span class="built_in">Date</span>&#125;,</span><br><span class="line">  options);</span><br><span class="line"><span class="keyword">const</span> Event = mongoose.model(<span class="string">'BaseEvent'</span>, eventSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> clickedLinkSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</span><br><span class="line">  url: <span class="built_in">String</span>,</span><br><span class="line">  time: <span class="built_in">String</span></span><br><span class="line">&#125;, options);</span><br><span class="line"><span class="comment">// 但是 Discriminator schema 有字符串格式的 `time`，并且有</span></span><br><span class="line"><span class="comment">// 隐式添加的 ObjectId 格式的 `_id`</span></span><br><span class="line">assert.ok(clickedLinkSchema.path(<span class="string">'_id'</span>));</span><br><span class="line">assert.equal(clickedLinkSchema.path(<span class="string">'_id'</span>).instance, <span class="string">'ObjectID'</span>);</span><br><span class="line"><span class="keyword">const</span> ClickedLinkEvent = Event.discriminator(<span class="string">'ChildEventBad'</span>,</span><br><span class="line">  clickedLinkSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> event1 = <span class="keyword">new</span> ClickedLinkEvent(&#123; <span class="attr">_id</span>: <span class="string">'custom id'</span>, <span class="attr">time</span>: <span class="string">'4pm'</span> &#125;);</span><br><span class="line"><span class="comment">// 问题来了，clickedLinkSchema 重写了 `time` 路径，但是**没有**</span></span><br><span class="line"><span class="comment">// 重写 `_id` 路径，因为已经隐式添加（没看懂）</span></span><br><span class="line">assert.ok(<span class="keyword">typeof</span> event1._id === <span class="string">'string'</span>);</span><br><span class="line">assert.ok(<span class="keyword">typeof</span> event1.time === <span class="string">'string'</span>);</span><br></pre></td></tr></table></figure><h4 id="discriminator-与-Model-create"><a href="#discriminator-与-Model-create" class="headerlink" title="discriminator 与 Model.create()"></a><strong>discriminator 与 <code>Model.create()</code></strong></h4><p>当你使用 <code>Model.create()</code>，Mongoose 会自动帮你适配 discriminator key ~</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Schema = mongoose.Schema;</span><br><span class="line"><span class="keyword">const</span> shapeSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  name: <span class="built_in">String</span></span><br><span class="line">&#125;, &#123; <span class="attr">discriminatorKey</span>: <span class="string">'kind'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Shape = db.model(<span class="string">'Shape'</span>, shapeSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Circle = Shape.discriminator(<span class="string">'Circle'</span>,</span><br><span class="line">  <span class="keyword">new</span> Schema(&#123; <span class="attr">radius</span>: <span class="built_in">Number</span> &#125;));</span><br><span class="line"><span class="keyword">const</span> Square = Shape.discriminator(<span class="string">'Square'</span>,</span><br><span class="line">  <span class="keyword">new</span> Schema(&#123; <span class="attr">side</span>: <span class="built_in">Number</span> &#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shapes = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">'Test'</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">kind</span>: <span class="string">'Circle'</span>, <span class="attr">radius</span>: <span class="number">5</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">kind</span>: <span class="string">'Square'</span>, <span class="attr">side</span>: <span class="number">10</span> &#125;</span><br><span class="line">];</span><br><span class="line">Shape.create(shapes, <span class="function"><span class="keyword">function</span>(<span class="params">error, shapes</span>) </span>&#123;</span><br><span class="line">  assert.ifError(error);</span><br><span class="line">  <span class="comment">// 重点看这里</span></span><br><span class="line">  assert.ok(shapes[<span class="number">0</span>] <span class="keyword">instanceof</span> Shape);</span><br><span class="line">  assert.ok(shapes[<span class="number">1</span>] <span class="keyword">instanceof</span> Circle);</span><br><span class="line">  assert.equal(shapes[<span class="number">1</span>].radius, <span class="number">5</span>);</span><br><span class="line">  assert.ok(shapes[<span class="number">2</span>] <span class="keyword">instanceof</span> Square);</span><br><span class="line">  assert.equal(shapes[<span class="number">2</span>].side, <span class="number">10</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="数组中的嵌套-discriminator"><a href="#数组中的嵌套-discriminator" class="headerlink" title="数组中的嵌套 discriminator"></a><strong>数组中的嵌套 discriminator</strong></h4><p>你也可以为嵌套文档数组定义 discriminator。 嵌套 discriminator 的特点是：不同 discriminator 类型储存在相同的文档而不是同一个 mongoDB collection。 换句话说，嵌套 discriminator 让你 在同一个数组储存符合不同 schema 的子文档。</p><p>最佳实践：确保你声明了钩子再使用他们。 你<strong>不应当</strong>在调用 <code>discriminator()</code> 之后调用 <code>pre()</code> 或 <code>post()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> eventSchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">message</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">discriminatorKey</span>: <span class="string">'kind'</span>, <span class="attr">_id</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> batchSchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">events</span>: [eventSchema] &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// `batchSchema.path('events')` gets the mongoose `DocumentArray`</span></span><br><span class="line"><span class="keyword">const</span> docArray = batchSchema.path(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个 `events` 数组可以包含 2 种不同的 event 类型，</span></span><br><span class="line"><span class="comment">// 'clicked' event that requires an element id that was clicked...</span></span><br><span class="line"><span class="keyword">const</span> clickedSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  element: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    required: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123; <span class="attr">_id</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"><span class="comment">// 确定在调用 `discriminator()` **之前**</span></span><br><span class="line"><span class="comment">// 对 `eventSchema` 和 `clickedSchema` 赋予钩子</span></span><br><span class="line"><span class="keyword">const</span> Clicked = docArray.discriminator(<span class="string">'Clicked'</span>, clickedSchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... and a 'purchased' event that requires the product that was purchased.</span></span><br><span class="line"><span class="keyword">const</span> Purchased = docArray.discriminator(<span class="string">'Purchased'</span>, <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  product: &#123;</span><br><span class="line">    type: <span class="built_in">String</span>,</span><br><span class="line">    required: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123; <span class="attr">_id</span>: <span class="literal">false</span> &#125;));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Batch = db.model(<span class="string">'EventBatch'</span>, batchSchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new batch of events with different kinds</span></span><br><span class="line"><span class="keyword">const</span> batch = &#123;</span><br><span class="line">  events: [</span><br><span class="line">    &#123; <span class="attr">kind</span>: <span class="string">'Clicked'</span>, <span class="attr">element</span>: <span class="string">'#hero'</span>, <span class="attr">message</span>: <span class="string">'hello'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">kind</span>: <span class="string">'Purchased'</span>, <span class="attr">product</span>: <span class="string">'action-figure-1'</span>, <span class="attr">message</span>: <span class="string">'world'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Batch.create(batch).</span><br><span class="line">  then(<span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    assert.equal(doc.events.length, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    assert.equal(doc.events[<span class="number">0</span>].element, <span class="string">'#hero'</span>);</span><br><span class="line">    assert.equal(doc.events[<span class="number">0</span>].message, <span class="string">'hello'</span>);</span><br><span class="line">    assert.ok(doc.events[<span class="number">0</span>] <span class="keyword">instanceof</span> Clicked);</span><br><span class="line"></span><br><span class="line">    assert.equal(doc.events[<span class="number">1</span>].product, <span class="string">'action-figure-1'</span>);</span><br><span class="line">    assert.equal(doc.events[<span class="number">1</span>].message, <span class="string">'world'</span>);</span><br><span class="line">    assert.ok(doc.events[<span class="number">1</span>] <span class="keyword">instanceof</span> Purchased);</span><br><span class="line"></span><br><span class="line">    doc.events.push(&#123; <span class="attr">kind</span>: <span class="string">'Purchased'</span>, <span class="attr">product</span>: <span class="string">'action-figure-2'</span> &#125;);</span><br><span class="line">    <span class="keyword">return</span> doc.save();</span><br><span class="line">  &#125;).</span><br><span class="line">  then(<span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    assert.equal(doc.events.length, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    assert.equal(doc.events[<span class="number">2</span>].product, <span class="string">'action-figure-2'</span>);</span><br><span class="line">    assert.ok(doc.events[<span class="number">2</span>] <span class="keyword">instanceof</span> Purchased);</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line">  &#125;).</span><br><span class="line">  <span class="keyword">catch</span>(done);</span><br></pre></td></tr></table></figure><h4 id="检索数组中的嵌套-discriminator"><a href="#检索数组中的嵌套-discriminator" class="headerlink" title="检索数组中的嵌套 discriminator"></a><strong>检索数组中的嵌套 discriminator</strong></h4><p>检索嵌套 discriminator</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> singleEventSchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">message</span>: <span class="built_in">String</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">discriminatorKey</span>: <span class="string">'kind'</span>, <span class="attr">_id</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> eventListSchema = <span class="keyword">new</span> Schema(&#123; <span class="attr">events</span>: [singleEventSchema] &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> subEventSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">   sub_events: [singleEventSchema]</span><br><span class="line">&#125;, &#123; <span class="attr">_id</span>: <span class="literal">false</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> SubEvent = subEventSchema.path(<span class="string">'sub_events'</span>).discriminator(<span class="string">'SubEvent'</span>, subEventSchema)</span><br><span class="line">eventListSchema.path(<span class="string">'events'</span>).discriminator(<span class="string">'SubEvent'</span>, subEventSchema);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Eventlist = db.model(<span class="string">'EventList'</span>, eventListSchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a new batch of events with different kinds</span></span><br><span class="line"><span class="keyword">const</span> list = &#123;</span><br><span class="line">  events: [</span><br><span class="line">    &#123; <span class="attr">kind</span>: <span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>: [&#123;<span class="attr">kind</span>:<span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>:[], <span class="attr">message</span>:<span class="string">'test1'</span>&#125;], <span class="attr">message</span>: <span class="string">'hello'</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">kind</span>: <span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>: [&#123;<span class="attr">kind</span>:<span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>:[&#123;<span class="attr">kind</span>:<span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>:[], <span class="attr">message</span>:<span class="string">'test3'</span>&#125;], <span class="attr">message</span>:<span class="string">'test2'</span>&#125;], <span class="attr">message</span>: <span class="string">'world'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Eventlist.create(list).</span><br><span class="line">  then(<span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    assert.equal(doc.events.length, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    assert.equal(doc.events[<span class="number">0</span>].sub_events[<span class="number">0</span>].message, <span class="string">'test1'</span>);</span><br><span class="line">    assert.equal(doc.events[<span class="number">0</span>].message, <span class="string">'hello'</span>);</span><br><span class="line">    assert.ok(doc.events[<span class="number">0</span>].sub_events[<span class="number">0</span>] <span class="keyword">instanceof</span> SubEvent);</span><br><span class="line"></span><br><span class="line">    assert.equal(doc.events[<span class="number">1</span>].sub_events[<span class="number">0</span>].sub_events[<span class="number">0</span>].message, <span class="string">'test3'</span>);</span><br><span class="line">    assert.equal(doc.events[<span class="number">1</span>].message, <span class="string">'world'</span>);</span><br><span class="line">    assert.ok(doc.events[<span class="number">1</span>].sub_events[<span class="number">0</span>].sub_events[<span class="number">0</span>] <span class="keyword">instanceof</span> SubEvent);</span><br><span class="line"></span><br><span class="line">    doc.events.push(&#123;<span class="attr">kind</span>:<span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>:[&#123;<span class="attr">kind</span>:<span class="string">'SubEvent'</span>, <span class="attr">sub_events</span>:[], <span class="attr">message</span>:<span class="string">'test4'</span>&#125;], <span class="attr">message</span>:<span class="string">'pushed'</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> doc.save();</span><br><span class="line">  &#125;).</span><br><span class="line">  then(<span class="function"><span class="keyword">function</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    assert.equal(doc.events.length, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    assert.equal(doc.events[<span class="number">2</span>].message, <span class="string">'pushed'</span>);</span><br><span class="line">    assert.ok(doc.events[<span class="number">2</span>].sub_events[<span class="number">0</span>] <span class="keyword">instanceof</span> SubEvent);</span><br><span class="line"></span><br><span class="line">    done();</span><br><span class="line">  &#125;).</span><br><span class="line">  <span class="keyword">catch</span>(done);</span><br></pre></td></tr></table></figure><p>### </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。它支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是它支持的查询语言非常强大，其语法有点类似于面向对象的查询
      
    
    </summary>
    
      <category term="数据库相关" scheme="http://laibh.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="数据库相关" scheme="http://laibh.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式——适配器模式</title>
    <link href="http://laibh.top/2019-03-22-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://laibh.top/2019-03-22-JavaScript设计模式——适配器模式.html</id>
    <published>2019-03-22T08:30:00.000Z</published>
    <updated>2019-10-15T09:29:49.415Z</updated>
    
    <content type="html"><![CDATA[<p>学习曾探的 《JavaScript设计模式与开发实践》并做记录。</p><p><a href="http://www.ituring.com.cn/book/1632/">书籍的购买链接</a></p><p>设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。</p><p>通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。</p><h1 id="JavaScript设计模式——适配器模式"><a href="#JavaScript设计模式——适配器模式" class="headerlink" title="JavaScript设计模式——适配器模式"></a>JavaScript设计模式——适配器模式</h1><p>适配器模式的作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作。</p><p>适配器的别名是包装器，这是一个相对简单的模式。在程序开发中有许多这样的场景，当我们试图调用模块或者对象的某个接口的时候，却发现这个接口的格式并不符合目前的需求。这时候有两个解决方法，第一种是修改原来的接口，但是如果原来的模块很复杂，后者我们拿到的模块是别人编写压缩的代码，修改原来的接口就不太现实了。第二种方法是创建一个适配器，将原来的接口装换为客户希望的另一个接口，客户只需要和适配器打交道。</p><h2 id="现实中的适配器"><a href="#现实中的适配器" class="headerlink" title="现实中的适配器"></a>现实中的适配器</h2><p>适配器在现实生活的应用非常广泛，接下来我们来看几个现实生活中的适配器模式。</p><p><strong>1.港式插头转换器</strong><br>港式的电器插头比大陆的电器插头体积要大一些。如果从香港买了一个 Mac book，我们会发现充电器无法插在家里的插座上，为此而改造家里的插座显然不方便，所以我们需要一个适配器。</p><p><strong>2.电源适配器</strong></p><p>Mac book 电池支持的电压是 20V，我们日常生活中的交流电压一般是 220V。除了我们了解的 220V 交流电压，日本和韩国的交流电压大多是 100V，而英国和澳大利亚的是 240V。笔记本电脑的电源适配器就承担了转换电压的作用，电源适配器使笔记本电脑在 100V~240V 的电压之内都能正常工作，这也是它为什么被称为电源“适配器”的原因。</p><p><strong>3.USB 转接口</strong></p><p>在以前的电脑上，PS2 接口是连接鼠标、键盘等其他外部设备的标准接口。但随着技术的发展，越来越多的电脑开始放弃了 PS2 接口，转而仅支持 USB 接口。所以那些过去生产出来的只拥有 PS2 接口的鼠标、键盘、游戏手柄等，需要一个 USB 转接口才能继续正常工作，这是 PS2-USB适配器诞生的原因</p><h2 id="适配器模式应用"><a href="#适配器模式应用" class="headerlink" title="适配器模式应用"></a>适配器模式应用</h2><p>在 JSON 格式流行之前，很多 cgi 返回的都是 XML 格式的数据，如果今天仍然想继续使用这些接口，显然我们可以创造一个XML-JSON 的适配器。</p><p>当我们向 googleMap 和 baiduMap 都发出“显示”请求时，googleMap和 baiduMap 分别以各自的方式在页面中展现了地图：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> googleMap = &#123;</span><br><span class="line">    show:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> baiduMap = &#123;</span><br><span class="line">    show:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> renderMap = <span class="function"><span class="keyword">function</span>(<span class="params">map</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(map.show <span class="keyword">instanceof</span> <span class="built_in">Function</span>)&#123;</span><br><span class="line">       map.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">renderMap(googleMap);</span><br><span class="line">renderMap(baiduMap);</span><br></pre></td></tr></table></figure><p>这段程序得以顺利运行的关键是 googleMap 和 baiduMap 提供了一致的 show 方法，但第三方的接口方法并不在我们自己的控制范围之内，假如 baiduMap 提供的显示地图的方法不叫 show 而叫display 呢？</p><p>baiduMap 这个对象来源于第三方，正常情况下我们都不应该去改动它。此时我们可以通过增加 baiduMapAdapter 来解决问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> googleMap = &#123;</span><br><span class="line">    show:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> baiduMap = &#123;</span><br><span class="line">    display::<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> baiduMapAdapter = &#123;</span><br><span class="line">    show:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baiduMap.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> renderMap = <span class="function"><span class="keyword">function</span>(<span class="params">map</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(map.show <span class="keyword">instanceof</span> <span class="built_in">Function</span>)&#123;</span><br><span class="line">       map.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">renderMap(googleMap);</span><br><span class="line">renderMap(baiduMapAdapter);</span><br></pre></td></tr></table></figure><p>再来看看另外一个例子。假设我们正在编写一个渲染广东省地图的页面。目前从第三方资源里获得了广东省的所有城市以及它们所对应的 ID，并且成功地渲染到页面中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getGuangdongCity = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> guangdongCity = [&#123;</span><br><span class="line">        name:<span class="string">'shenzhen'</span>,</span><br><span class="line">        id:<span class="number">11</span>,</span><br><span class="line">    &#125;,&#123;</span><br><span class="line">        name:<span class="string">'guangzhou'</span>,</span><br><span class="line">        id:<span class="number">12</span>,</span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="keyword">return</span> guangdongCity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> render = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">''</span>);</span><br><span class="line">    <span class="built_in">document</span>.write(<span class="built_in">JSON</span>.stringfy(fn()));</span><br><span class="line">&#125;</span><br><span class="line">render(getGuangdongCity);</span><br></pre></td></tr></table></figure><p>利用这些数据，我们编写完成了整个页面，并且在线上稳定地运行了一段时间。但后来发现这些数据不太可靠，里面还缺少很多城市。于是我们又在网上找到了另外一些数据资源，这次的数据更加全面，但遗憾的是，数据结构和正运行在项目中的并不一致。新的数据结构如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> guangdongCity = &#123;</span><br><span class="line">    shenzhen:<span class="number">11</span>,</span><br><span class="line">    guangzhou:<span class="number">12</span>,</span><br><span class="line">    zhuhai:<span class="number">13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了大动干戈地改写渲染页面的前端代码之外，另外一种更轻便的解决方式就是新增一个数据格式转换的适配器:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> addressAdapter = <span class="function"><span class="keyword">function</span>(<span class="params">oldAddressfn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> address = &#123;&#125;,</span><br><span class="line">          oldAddressfn = oldAddressfn();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,c;c = oldAddress[i++];)&#123;</span><br><span class="line">        address[c.name] = c.id</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">render(addressAdapter(getGuangdongCity));</span><br></pre></td></tr></table></figure><p>那么接下来需要做的，就是把代码中调用 getGuangdongCity 的地方，用经过 addressAdapter适配器转换之后的新函数来代替。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>适配器模式是一种相对比较简单的模式。装饰者模式、代理模式和外观模式其实都挺相似的，都是由一个对象来包装另一个对象。区别它们的关键仍然是模式的意图。</p><p>适配器模式主要用来解决两个已有的接口之间不匹配的问题，它不考虑这些接口是怎么样实现的，也不考虑它们将来可能会如何演变，适配器模式不需要改变已有的接口，就能够使它们协同作用。</p><p>装饰者模式和代理模式也不会改变原来对象的接口，但装饰者模式的作用是为了给对象增加功能。装饰者模式常常形成一条很长的装饰链，而是适配器模式通常只包装一次。代理模式是为了控制对对象的访问，通常也只包装一次。</p><p>外观模式的作用倒是和适配器模式比较相似的，有人把外观模式看成一组对象的适配器，但外观模式最显著的特点是定义了一个新的接口。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习曾探的 《JavaScript设计模式与开发实践》并做记录。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ituring.com.cn/book/1632/&quot;&gt;书籍的购买链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而
      
    
    </summary>
    
      <category term="JavaScript设计模式" scheme="http://laibh.top/categories/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="JavaScript设计模式" scheme="http://laibh.top/tags/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript设计原则和编程技巧——开放-封闭原则</title>
    <link href="http://laibh.top/2019-03-22-JavaScript%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%92%8C%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94%E6%9C%80%E5%B0%91%E7%9F%A5%E8%AF%86%E5%8E%9F%E5%88%99.html"/>
    <id>http://laibh.top/2019-03-22-JavaScript设计原则和编程技巧——最少知识原则.html</id>
    <published>2019-03-22T08:30:00.000Z</published>
    <updated>2019-10-15T09:29:49.415Z</updated>
    
    <content type="html"><![CDATA[<p>学习曾探的 《JavaScript设计模式与开发实践》并做记录。</p><p><a href="http://www.ituring.com.cn/book/1632/">书籍的购买链接</a></p><p>设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。</p><p>通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。</p><p>说每种设计模式都是为了让代码迎合其中一个或多个原则而出现的，它们本身已经融入了设计模式之中，给面向对象编程指明了方向。</p><p>前辈总结的这些设计原则通常指的是单一职责原则、里氏替换原则、依赖倒置原则、接口隔离原则、合成复用原则和最少知识原则 </p><h1 id="JavaScript设计原则和编程技巧——开放-封闭原则"><a href="#JavaScript设计原则和编程技巧——开放-封闭原则" class="headerlink" title="JavaScript设计原则和编程技巧——开放-封闭原则"></a>JavaScript设计原则和编程技巧——开放-封闭原则</h1><p>在面向对象的程序设计中，开放封闭原则（OCP）是最重要的一条原则。很多时候，一个程序具有良好的设计，往往说明它是符合开放-封闭原则的</p><p><strong>软件实体（类、模块、函数）等应该是可以扩展的，但是不可修改</strong></p><h2 id="扩展-window-onload-函数"><a href="#扩展-window-onload-函数" class="headerlink" title="扩展 window.onload 函数"></a>扩展 window.onload 函数</h2><p>假设我们是一个大型 Web 项目的维护人员，在接手这个项目时，发现它已经拥有 10 万行以上的 JavaScript 代码和数百个 JS 文件。</p><p>不久后接到了一个新的需求，即在 window.onload 函数中打印出页面中的所有节点数量。这当然难不倒我们了。于是我们打开文本编辑器，搜索出 window.onload 函数在文件中的位置，在函数内部添加以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"> <span class="comment">// 原有代码略</span></span><br><span class="line"> <span class="built_in">console</span>.log( <span class="built_in">document</span>.getElementsByTagName( <span class="string">'*'</span> ).length ); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在项目需求变迁的过程中，我们经常会找到相关代码，然后改写它们。这似乎是理所当然的事情，不改动代码怎么满足新的需求呢？想要扩展一个模块，最常用的方式当然是修改它的源代码。如果一个模块不允许修改，那么它的行为常常是固定的。然而，改动代码是一种危险的行为，也许我们都遇到过 bug 越改越多的场景。刚刚改好了一个 bug，但是又在不知不觉中引发了其他的 bug。</p><p>那么，有没有办法在不修改代码的情况下，就能满足新需求呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params">afterfn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> ret = self.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        afterfn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.onload = (<span class="built_in">window</span>.onload || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;).after(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(xxx);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过动态装饰函数的方式，我们完全不用理会从前 window.onload 函数的内部实现，无论它的实现优雅或是丑陋。就算我们作为维护者，拿到的是一份混淆压缩过的代码也没有关系。只要它从前是个稳定运行的函数，那么以后也不会因为我们的新增需求而产生错误。新增的代码和原有的代码可以井水不犯河水。 </p><h2 id="开发和封闭"><a href="#开发和封闭" class="headerlink" title="开发和封闭"></a>开发和封闭</h2><p>上一节为 window.onload 函数扩展功能时，用到了两种方式。一种是修改原有的代码，另一种是增加一段新的代码。使用哪种方式效果更好，已经不言而喻。</p><p>封闭-开发原则的思想：当需要改变一个程序的功能或者给这个程序增加新的功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。</p><p>在现实生活中，我们也能找到一些跟开放封闭原则相关的故事。下面这个故事人尽皆知，且跟肥皂相关</p><blockquote><p>有一家生产肥皂的大企业，从欧洲花巨资引入了一条生产线。这条生产线可以自动完成从原材料加工到包装成箱的整个流程，但美中不足的是，生产出来的肥皂有一定的空盒几率。于是老板又从欧洲找来一支专家团队，花费数百万元改造这一生产线，终于解决了生产出空盒肥皂的问题。</p><p>另一家企业也引入了这条生产线，他们同样遇到了空盒肥皂的问题。但他们的解决办法很简单：用一个大风扇在生产线旁边吹，空盒肥皂就会被吹走。</p></blockquote><p>这个故事告诉我们，相比修改源程序，如果通过增加几行代码就能解决问题，那这显然更加简单和优雅，而且增加代码并不会影响原系统的稳定。讲述这个故事，我们的目的不在于说明风扇的成本有多低，而是想说明，如果使用风扇这样简单的方式可以解决问题，根本没有必要去大动干戈地改造原有的生产线。</p><h2 id="用对象的多态性消除条件分支"><a href="#用对象的多态性消除条件分支" class="headerlink" title="用对象的多态性消除条件分支"></a>用对象的多态性消除条件分支</h2><p>过多的条件分支语句是造成程序违反开放-封闭原则的一个常见原因。每当需要增加一个新的 if 语句时，都要被迫改动原函数。把 if 换成 switch-case 是没有用的，这是一种换汤不换药的做法。实际上，每当我们看到一大片的 if 或者 swtich-case 语句时，第一时间就应该考虑，能否利用对象的多态性来重构它们。</p><p>利用对象的多态性来让程序遵守开放-封闭原则，是一个常用的技巧。用让动物发出叫声的例子。下面先提供一段不符合开放-封闭原则的代码。每当我们增加一种新的动物时，都需要改动makeSound 函数的内部实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 改动前</span></span><br><span class="line"><span class="keyword">var</span> makeSound = <span class="function"><span class="keyword">function</span>(<span class="params"> animal </span>)</span>&#123; </span><br><span class="line"> <span class="keyword">if</span> ( animal <span class="keyword">instanceof</span> Duck )&#123; </span><br><span class="line"> <span class="built_in">console</span>.log( <span class="string">'嘎嘎嘎'</span> ); </span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( animal <span class="keyword">instanceof</span> Chicken )&#123; </span><br><span class="line"> <span class="built_in">console</span>.log( <span class="string">'咯咯咯'</span> ); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">var</span> Duck = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; </span><br><span class="line"><span class="keyword">var</span> Chicken = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; </span><br><span class="line">makeSound( <span class="keyword">new</span> Duck() ); <span class="comment">// 输出：嘎嘎嘎</span></span><br><span class="line">makeSound( <span class="keyword">new</span> Chicken() ); <span class="comment">// 输出：咯咯咯</span></span><br><span class="line"><span class="comment">// 动物世界里增加一只狗之后，makeSound 函数必须改成：</span></span><br><span class="line"><span class="keyword">var</span> makeSound = <span class="function"><span class="keyword">function</span>(<span class="params"> animal </span>)</span>&#123; </span><br><span class="line"> <span class="keyword">if</span> ( animal <span class="keyword">instanceof</span> Duck )&#123; </span><br><span class="line"> <span class="built_in">console</span>.log( <span class="string">'嘎嘎嘎'</span> ); </span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( animal <span class="keyword">instanceof</span> Chicken )&#123; </span><br><span class="line"> <span class="built_in">console</span>.log( <span class="string">'咯咯咯'</span> ); </span><br><span class="line"> &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( animal <span class="keyword">instanceof</span> Dog )&#123; <span class="comment">// 增加跟狗叫声相关的代码</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'汪汪汪'</span> ); </span><br><span class="line"> &#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">var</span> Dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; </span><br><span class="line">makeSound( <span class="keyword">new</span> Dog() ); <span class="comment">// 增加一只狗</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改动后</span></span><br><span class="line"><span class="keyword">const</span> makeSound = <span class="function"><span class="keyword">function</span>(<span class="params">animal</span>)</span>&#123;</span><br><span class="line">    animal.sound();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> Duck = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; </span><br><span class="line">Duck.prototype.sound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log( <span class="string">'嘎嘎嘎'</span> ); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">const</span> Chicken = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; </span><br><span class="line">Chicken.prototype.sound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log( <span class="string">'咯咯咯'</span> ); </span><br><span class="line">&#125;; </span><br><span class="line">makeSound( <span class="keyword">new</span> Duck() ); <span class="comment">// 嘎嘎嘎</span></span><br><span class="line">makeSound( <span class="keyword">new</span> Chicken() ); <span class="comment">// 咯咯咯</span></span><br><span class="line"><span class="comment">/********* 增加动物狗，不用改动原有的 makeSound 函数 ****************/</span> </span><br><span class="line"><span class="keyword">var</span> Dog = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; </span><br><span class="line">Dog.prototype.sound = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log( <span class="string">'汪汪汪'</span> ); </span><br><span class="line">&#125;; </span><br><span class="line">makeSound( <span class="keyword">new</span> Dog() ); <span class="comment">// 汪汪汪</span></span><br></pre></td></tr></table></figure><h2 id="找出变化的地方"><a href="#找出变化的地方" class="headerlink" title="找出变化的地方"></a>找出变化的地方</h2><p>开放封闭原则是一个看起来比较虚幻的原则，并没有实际的模板教导我们怎样亦步亦趋地实现它。但我们还是能找到一些让程序尽量遵守开放-封闭原则的规律，最明显的就是找出程序中将要发生变化的地方，然后把变化封装起来</p><p>通过封装变化的方式，可以把系统中稳定不变的部分和容易变化的部分隔离开来。在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经被封装好的，那么替换起来也相对容易。而变化部分之外的就是稳定的部分。在系统的演变过程中，稳定的部分是不需要改变的。</p><p>除了利用对象的多态性之外，还有其他方式可以帮助我们编写遵守开放-封闭原则的代码，下面将详细介绍。</p><p><strong>1.放置倒钩</strong></p><p>放置挂钩（hook）也是分离变化的一种方式。我们在程序有可能发生变化的地方放置一个挂钩，挂钩的返回结果决定了程序的下一步走向。这样一来，原本的代码执行路径上就出现了一个分叉路口，程序未来的执行方向被预埋下多种可能性。</p><p>由于子类的数量是无限制的，总会有一些“个性化”的子类迫使我们不得不去改变已经封装好的算法骨架。于是我们可以在父类中的某个容易变化的地方放置挂钩，挂钩的返回结果由具体子类决定。这样一来，程序就拥有了变化的可能</p><p><strong>2.使用回调函数</strong></p><p>回调函数是一种特殊的挂钩。我们可以把一部分易于变化的逻辑封装在回调函数里，然后把回调函数当作参数传入一个稳定和封闭的函数中。当回调函数被执行的时候，程序就可以因为回调函数的内部逻辑不同，而产生不同的结果。</p><h2 id="设计模式中的开发-封闭原则"><a href="#设计模式中的开发-封闭原则" class="headerlink" title="设计模式中的开发-封闭原则"></a>设计模式中的开发-封闭原则</h2><p>有一种说法是，设计模式就是给做的好的设计取个名字。几乎所有的设计模式都是遵守开放-封闭原则的，我们见到的好设计，通常都经得起开放-封闭原则的考验。不管是具体的各种设计模式，还是更抽象的面向对象设计原则，比如单一职责原则、最少知识原则、依赖倒置原则等都是为了让程序遵守开放-封闭原则而出现的。可以这样说，开放-封闭原则是编写一个好程序的目标，其他设计原则都是达到这个目标的过程。</p><p><strong>1.发布-订阅模式</strong></p><p>模式用来降低多个对象之间的依赖关系，它可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。当有新的订阅者出现时，发布者的代码不需要进行任何修改；同样当发布者需要改变时，也不会影响到之前的订阅者。</p><p><strong>2.模板方法模式</strong></p><p>是一种典型的通过封装变化来提高系统扩展性的设计模式。在一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽出来放到父类的模板方法里面；而子类的方法具体怎么实现则是可变的，于是把这部分变化的逻辑封装到子类中。通过增加新的子类，便能给系统增加新的功能，并不需要改动抽象父类以及其他的子类，这也是符合开放-封闭原则的。 </p><p><strong>3.策略模式</strong></p><p>策略模式和模板方法模式是一对竞争者。在大多数情况下，它们可以相互替换使用。模板方法模式基于继承的思想，而策略模式则偏重于组合和委托。</p><p>策略模式将各种算法都封装成单独的策略类，这些策略类可以被交换使用。策略和使用策略的客户代码可以分别独立进行修改而互不影响。我们增加一个新的策略类也非常方便，完全不用修改之前的代码</p><p><strong>4.代理模式</strong></p><p><strong>5.职责链模式</strong></p><h2 id="接受第一次愚弄"><a href="#接受第一次愚弄" class="headerlink" title="接受第一次愚弄"></a>接受第一次愚弄</h2><p>让程序一开始就尽量遵守开放-封闭原则，并不是一件很容易的事情。一方面，我们需要尽快知道程序在哪些地方会发生变化，这要求我们有一些“未卜先知”的能力。另一方面，留给程序员的需求排期并不是无限的，所以我们可以说服自己去接受不合理的代码带来的第一次愚弄。在最初编写代码的时候，先假设变化永远不会发生，这有利于我们迅速完成需求。当变化发生并且对我们接下来的工作造成影响的时候，可以再回过头来封装这些变化的地方。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习曾探的 《JavaScript设计模式与开发实践》并做记录。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ituring.com.cn/book/1632/&quot;&gt;书籍的购买链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而
      
    
    </summary>
    
      <category term="JavaScript设计模式" scheme="http://laibh.top/categories/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="JavaScript设计模式" scheme="http://laibh.top/tags/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript设计原则和编程技巧——单一职责原则</title>
    <link href="http://laibh.top/2019-03-22-JavaScript%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E5%92%8C%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7%E2%80%94%E2%80%94%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99.html"/>
    <id>http://laibh.top/2019-03-22-JavaScript设计原则和编程技巧——单一职责原则.html</id>
    <published>2019-03-22T08:30:00.000Z</published>
    <updated>2019-10-15T09:29:49.415Z</updated>
    
    <content type="html"><![CDATA[<p>学习曾探的 《JavaScript设计模式与开发实践》并做记录。</p><p><a href="http://www.ituring.com.cn/book/1632/">书籍的购买链接</a></p><p>设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。</p><p>通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。</p><p>说每种设计模式都是为了让代码迎合其中一个或多个原则而出现的，它们本身已经融入了设计模式之中，给面向对象编程指明了方向。</p><p>前辈总结的这些设计原则通常指的是单一职责原则、里氏替换原则、依赖倒置原则、接口隔离原则、合成复用原则和最少知识原则 </p><h1 id="JavaScript设计原则和编程技巧——单一职责原则"><a href="#JavaScript设计原则和编程技巧——单一职责原则" class="headerlink" title="JavaScript设计原则和编程技巧——单一职责原则"></a>JavaScript设计原则和编程技巧——单一职责原则</h1><p>就一个类而言，应该仅有一个引起它变化的原因，在JavaScript 中，需要用到的类的场景并不太多，单一职责原则则是更多地运用在对象或者方法级别上面。</p><p>单一职责原则（SRP）的职责被定义为引起变化的原因。如果我们有两个动机去改写一个方法，那么这个方法就具有两个职责。每个职责都是变化的一个轴线。如果一个方法承担了过多的职责，那么杂需求的变迁中，需要改写这个方法的可能性就越大。</p><p>因此，SRP原则体现为：一个对象（方法）只做一件事情。</p><h2 id="设计模式中的SRP原则"><a href="#设计模式中的SRP原则" class="headerlink" title="设计模式中的SRP原则"></a>设计模式中的SRP原则</h2><p>SRP原则在很多设计模式中都有着很广泛的应用，例如代理模式，迭代器模式、单例模式和装饰者模式。</p><p><strong>1.代理模式</strong></p><p>图片预加载，通过增加虚拟代理的方式，把预加载图片的职责放到代理对象中，而本体仅仅是负责往页面中添加 img 标签，这也是它最原始的职责。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myImage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> imgNode = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(imgNode);</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        setSrc:<span class="function"><span class="keyword">function</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">            imgNode.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proxyImage 负责预加载图片，并在预加载完成之后把请求交给本体 myImage:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proxyImage  = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> img = <span class="keyword">new</span> Image;</span><br><span class="line">    img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        myImage.setSrc(<span class="keyword">this</span>.src);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        setSrc:<span class="function"><span class="keyword">function</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">            myImage.setSrc(<span class="string">'xxx.jpg'</span>);</span><br><span class="line">            img.src = src;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>把添加 img 标签的功能和预加载图片的职责分开放到两个对象中，这两个对象各自都只有一个被修改的动机。在它们各自发生改变的时候，也不会影响另外的对象</p><p><strong>2.迭代器模式</strong></p><p>我们有这样一段代码，先遍历一个集合，然后往页面中添加一些 div，这些 div 的 innerHTML分别对应集合里的元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> appendDiv = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,l=data.length;i&lt;l;i++)&#123;</span><br><span class="line">        <span class="keyword">const</span> div = <span class="built_in">document</span>.createElememt(<span class="string">'div'</span>);</span><br><span class="line">        div.innerHTML = data[i];</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">appendDiv( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ] );</span><br></pre></td></tr></table></figure><p>这其实是一段很常见的代码，经常用于 ajax 请求之后，在回调函数中遍历 ajax 请求返回的数据，然后在页面中渲染节点。</p><p>appendDiv 函数本来只是负责渲染数据，但是在这里它还承担了遍历聚合对象 data 的职责。我们想象一下，如果有一天 cgi 返回的 data 数据格式从 array 变成了 object，那我们遍历 data 的代码就会出现问题，必须改成 for ( var i in data )的方式，这时候必须去修改 appendDiv 里的代码，否则因为遍历方式的改变，导致不能顺利往页面中添加 div 节点.</p><p>我们有必要把遍历 data 的职责提取出来，这正是迭代器模式的意义，迭代器模式提供了一种方法来访问聚合对象，而不用暴露这个对象的内部表示</p><p>当把迭代聚合对象的职责单独封装在 each 函数中后，即使以后还要增加新的迭代方式，我们只需要修改 each 函数即可，appendDiv 函数不会受到牵连，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> each = <span class="function"><span class="keyword">function</span>(<span class="params">obj,callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> value,</span><br><span class="line">          i = <span class="number">0</span>,</span><br><span class="line">          length = obj.length,</span><br><span class="line">          isArray = isArraylike(obj);</span><br><span class="line">    <span class="keyword">if</span>(isArray)&#123;</span><br><span class="line">        <span class="keyword">for</span>(;i&lt;length;i++)&#123;</span><br><span class="line">            callback.call(obj[i],i,obj[i]);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>( i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">            value = callback.call(obj[i],i,obj[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> appendDiv = <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    each(data,<span class="function"><span class="keyword">function</span>(<span class="params">i,n</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> div = <span class="built_in">document</span>.createElememt(<span class="string">'div'</span>);</span><br><span class="line">        div.innerHTML = n;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line">appendDiv( [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> ] ); </span><br><span class="line">appendDiv(&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>,<span class="attr">c</span>:<span class="number">3</span>,<span class="attr">d</span>:<span class="number">4</span>&#125; );</span><br></pre></td></tr></table></figure><p><strong>3.单例模式</strong></p><p>惰性单例，最开始的代码是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> createLogin = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> div;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!div)&#123;</span><br><span class="line">            div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">            div.innerHTML = <span class="string">'我是登录浮窗'</span>;</span><br><span class="line">            div.style.display = <span class="string">'none'</span>;</span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> div;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>现在我们把管理单例的职责和创建登录浮窗的职责分别封装在两个方法里，这两个方法可以独立变化而互不影响，当它们连接在一起的时候，就完成了创建唯一登录浮窗的功能，下面的代码显然是更好的做法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getSingle = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line">    <span class="keyword">return</span> functiion()&#123;</span><br><span class="line">        <span class="keyword">return</span> result || (result = fn.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> createLogin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    div.innerHTML = <span class="string">'我是登录浮窗'</span>;</span><br><span class="line">    div.style.display = <span class="string">'none'</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> createSingleLogin = getSingle(createLogin);</span><br><span class="line"><span class="keyword">const</span> l1 = createSingleLogin();</span><br><span class="line"><span class="keyword">const</span> l2 = createSingleLogin();</span><br><span class="line">l1 === l2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>4.装饰者模式</strong></p><p>使用装饰者模式的时候，我们通常让类或者对象一开始只具有一些基础的职责，更多的职责在代码运行时被动态装饰到对象上面。装饰者模式可以为对象动态增加职责，从另一个角度来看，这也是分离职责的一种方式</p><p>我们把数据上报的功能单独放在一个函数里，然后把这个函数动态装饰到业务函数上面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.after = <span class="function"><span class="keyword">function</span>(<span class="params"> afterfn </span>)</span>&#123; </span><br><span class="line"><span class="keyword">const</span> __self = <span class="keyword">this</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">var</span> ret = __self.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> ); </span><br><span class="line">        afterfn.apply( <span class="keyword">this</span>, <span class="built_in">arguments</span> ); </span><br><span class="line">    <span class="keyword">return</span> ret; </span><br><span class="line">&#125; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">const</span> showLogin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log( <span class="string">'打开登录浮层'</span> ); </span><br><span class="line">&#125;; </span><br><span class="line"><span class="keyword">const</span> log = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"> <span class="built_in">console</span>.log( <span class="string">'上报标签为: '</span> + <span class="keyword">this</span>.getAttribute( <span class="string">'tag'</span> ) ); </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById( <span class="string">'button'</span> ).onclick = showLogin.after( log );</span><br></pre></td></tr></table></figure><h2 id="何时应该分离职责"><a href="#何时应该分离职责" class="headerlink" title="何时应该分离职责"></a>何时应该分离职责</h2><p>SRP  原则是所有原则中最简单也是最难正确运用的原则之一。</p><p>一方面，随着需求的变化，有两个原则总是同时变化，那么就不必分离它们，比如在 ajax 请求的时候，创建 xhr 对象和发送 xhr 对象几乎总是在一起的，那么创建 xhr 对象的职责和发送 xhr 请求的职责就没有必要分开。</p><p>另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦合在一起，但它们还没有发生改变的征兆，那么也许就没有必须要分离它们。在代码重构的时候再分离也不迟。</p><h2 id="违反SRP原则"><a href="#违反SRP原则" class="headerlink" title="违反SRP原则"></a>违反SRP原则</h2><p>在人的常规思维中，总是习惯性地把一组相关的行为放到一起，如何正确地分离职责不是一件容易的事情。</p><p>我们也许从来没有考虑过如何分离职责，但这并不妨碍我们编写代码完成需求。对于 SRP原则，许多专家委婉地表示“This is sometimes hard to see.”。</p><p>一方面，我们受设计原则的指导，另一方面，我们未必要在任何时候都一成不变地遵守原则。在实际开发中，因为种种原因违反 SRP 的情况并不少见。比如 jQuery 的 attr 等方法，就是明显违反 SRP 原则的做法。jQuery 的 attr 是个非常庞大的方法，既负责赋值，又负责取值，这对于jQuery 的维护者来说，会带来一些困难，但对于 jQuery 的用户来说，却简化了用户的使用。</p><p>在方便性与稳定性之间要有一些取舍。具体是选择方便性还是稳定性，并没有标准答案，而是要取决于具体的应用环境。比如如果一个电视机内置了 DVD 机，当电视机坏了的时候，DVD机也没法正常使用，那么一个 DVD 发烧友通常不会选择这样的电视机。但如果我们的客厅本来就小得夸张，或者更在意 DVD 在使用上的方便，那让电视机和 DVD 机耦合在一起就是更好的选择</p><h2 id="SRP原则的优缺点"><a href="#SRP原则的优缺点" class="headerlink" title="SRP原则的优缺点"></a>SRP原则的优缺点</h2><p>优点是降低单个类或者对象的复杂度，按照职责把对象分解成为更加小的粒度，这有助于代码的复用，也有利于单元测试，当一个职责需要变更的时候，不会影响到其他的职责。</p><p>缺点是会增加代码的复杂度，当我们按照职责将对象分解成更小的粒度之后，实际上也增大了这些对象之间互相联系的难度。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习曾探的 《JavaScript设计模式与开发实践》并做记录。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ituring.com.cn/book/1632/&quot;&gt;书籍的购买链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而
      
    
    </summary>
    
      <category term="JavaScript设计模式" scheme="http://laibh.top/categories/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="JavaScript设计模式" scheme="http://laibh.top/tags/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式——模板方法模式</title>
    <link href="http://laibh.top/2019-03-21-JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://laibh.top/2019-03-21-JavaScript设计模式——模板方法模式.html</id>
    <published>2019-03-21T03:30:00.000Z</published>
    <updated>2019-10-15T09:29:49.415Z</updated>
    
    <content type="html"><![CDATA[<p>学习曾探的 《JavaScript设计模式与开发实践》并做记录。</p><p><a href="http://www.ituring.com.cn/book/1632/">书籍的购买链接</a></p><p>设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。</p><p>通俗一点，设计模式是在某种场合下对某个问题的一种解决方案。是给面向对象软件开发中的一些好的设计取个名字。</p><h1 id="JavaScript设计模式——模板方法模式"><a href="#JavaScript设计模式——模板方法模式" class="headerlink" title="JavaScript设计模式——模板方法模式"></a>JavaScript设计模式——模板方法模式</h1><p>在 JavaScript 开发中用到继承的场景其实不是很多，很多时候我们都喜欢用 mix-in 的方式给对象扩展属性。但这部代表继承在 JavaScript 中没有用武之地，虽然没有真正的类和继承机制，但是我们可以通过原型 prototype 来变相地继承。</p><p>本章讨论一种基于继承的设计模式——模板方法（Template Method）模式</p><h2 id="定义和组成"><a href="#定义和组成" class="headerlink" title="定义和组成"></a>定义和组成</h2><p>模板方法模式只是一种需要使用继承就可以实现的非常简单的模式。</p><p>模板方法模式由两个部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共的方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。</p><p>假如我们有一些平行的子类，各个子类之间有一些相同的行为，也有一些不同的行为。如果相同和不同的行为都混合在各个子类的实现中，说明这些相同的行为会在各个子类中重复出现。但实际上，相同的行为可以被搬移到另外一个单一的地方，模板方法模式就是为了解决这个问题而生的。在模板方法模式中，子类实现的相同部分被上移到了父类中，而将不同的部分留待子类类实现。也很好地体现了泛化的思想。</p><h2 id="Coffee-or-Tea"><a href="#Coffee-or-Tea" class="headerlink" title="Coffee or Tea"></a>Coffee or Tea</h2><p>咖啡和茶是一个经典的例子。</p><h3 id="先泡一杯咖啡"><a href="#先泡一杯咖啡" class="headerlink" title="先泡一杯咖啡"></a>先泡一杯咖啡</h3><p>首先，我们来泡一杯咖啡，如果没有什么太多个性化的需求，一般的步骤如下：</p><ol><li>把水煮沸</li><li>用沸水冲泡咖啡</li><li>把咖啡倒进杯子</li><li>加糖和牛奶</li></ol><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Coffee = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Coffee.prototype.boilWater = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'把水煮沸'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Coffee.prototype.brewCoffeeGriends  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用沸水冲泡咖啡'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Coffee.prototype.pourInCup  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'把咖啡倒进杯子'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Coffee.prototype.addSugarAndMilk  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'加糖和牛奶'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Coffee.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.boilWater()</span><br><span class="line">    <span class="keyword">this</span>.brewCoffeeGriends()</span><br><span class="line">    <span class="keyword">this</span>.pourInCup()</span><br><span class="line">    <span class="keyword">this</span>.addSugarAndMilk()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line">coffee.init();</span><br></pre></td></tr></table></figure><h3 id="泡一壶茶"><a href="#泡一壶茶" class="headerlink" title="泡一壶茶"></a>泡一壶茶</h3><p>开始准备我们的茶，步骤差不多：</p><ol><li>把水煮沸</li><li>用沸水浸泡茶叶</li><li>把茶水倒进杯子</li><li>加柠檬</li></ol><p>代码实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Tea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Tea.prototype.boilWater = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'把水煮沸'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Tea.prototype.steepTeaBag   = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用沸水浸泡茶叶'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Tea.prototype.pourInCup  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'把茶水倒进杯子'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Tea.prototype.addLemon  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'加柠檬'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Tea.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.boilWater()</span><br><span class="line">    <span class="keyword">this</span>.steepTeaBag()</span><br><span class="line">    <span class="keyword">this</span>.pourInCup()</span><br><span class="line">    <span class="keyword">this</span>.addLemon()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> tea = <span class="keyword">new</span> Tea();</span><br><span class="line">tea.init();</span><br></pre></td></tr></table></figure><h3 id="分离出共同点"><a href="#分离出共同点" class="headerlink" title="分离出共同点"></a>分离出共同点</h3><p>我们可以发现其实两个步骤是大同小异的。</p><p>主要体现为：</p><ul><li>原料不同。一个是咖啡，一个是茶，但我们都可以统称之为饮料</li><li>泡的方式不同。咖啡是冲泡，而茶叶是浸泡，但是都可以抽象为“泡”</li><li>加入的调料不同。一个是糖和牛奶，一个是柠檬，但是都可以抽象为 “调料”</li></ul><p>不管是茶还是咖啡都可以整理为下面四步：</p><ol><li>把水煮沸</li><li>用沸水浸泡饮料</li><li>把饮料倒进杯子</li><li>加调料(condiments)</li></ol><p>现在可以创建一个抽象父类来表示泡(brew)一杯饮料(Beverage)的整个过程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Beverage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Beverage.prototype.boilWater = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'把水煮沸'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 空方法，应该由子类重写</span></span><br><span class="line">Beverage.prototype.brew  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Beverage.prototype.pourInCup  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Beverage.prototype.addCondiments  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Beverage.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.boilWater()</span><br><span class="line">    <span class="keyword">this</span>.brew()</span><br><span class="line">    <span class="keyword">this</span>.pourInCup()</span><br><span class="line">    <span class="keyword">this</span>.addCondiments()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建-Coffee-子类和-Tea-子类"><a href="#创建-Coffee-子类和-Tea-子类" class="headerlink" title="创建 Coffee 子类和 Tea 子类"></a>创建 Coffee 子类和 Tea 子类</h3><p>继承饮料类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Coffee = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Coffee.prototype = <span class="keyword">new</span> Beverage();</span><br><span class="line"><span class="comment">// 重写抽象父类中的一些方法，把只有把水煮沸这个行为可以使用父类中的 boilWater 方法，其他都需要在 Coffee 子类中重写</span></span><br><span class="line">Coffee.prototype.brew  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用沸水冲泡咖啡'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Coffee.prototype.pourInCup  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'把咖啡倒进杯子'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Coffee.prototype.addCondiments  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'加糖和牛奶'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line">coffee.init();</span><br></pre></td></tr></table></figure><p>当调用 coffee 对象的 init 方法时候，由于 coffee 对象和 Coffee 构造器的原型 prototype 上没有这个方法，所以该请求会顺着原型链，被委托给 Coffee 的父类 Beverage 原型上的 init 方法。而这个方法已经规定好了泡饮料的顺序，所以我们成功地泡出了一杯咖啡。</p><p>Tea 类：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Tea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Tea.prototype = <span class="keyword">new</span> Beverage();</span><br><span class="line">Tea.prototype.brew  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用沸水浸泡茶叶'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Tea.prototype.pourInCup  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'把茶水倒进杯子'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Tea.prototype.addCondiments  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'加柠檬'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> tea = <span class="keyword">new</span> Tea();</span><br><span class="line">tea.init();</span><br></pre></td></tr></table></figure><p><code>Beverage.prototype.init</code> 就是模板方法，该方法中封装了子类的算法框架，他作为一个算法的模板，指导子类以何种顺序去执行哪些方法。在这个方法中，算法内的每一步骤都清楚地展示在我们面前。</p><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>在 Java 中，类分成两种，一种是具体类，另一种就是抽象类。具体类可以被实例化，抽象类不能被实例化。</p><p>由于抽象类不能被实例化，如果有人编写了一个抽象类，那么这个抽象类一定是用来被某些具体类继承的。</p><p>抽象类和接口一样可以用于向上转型，在静态类型语言中，编译器对类型检查总是一个绕不开的话题与困扰。虽然类型检查可以提供程序的安全性，但繁琐而严格的类型检查也时常会让程序员觉得麻烦。把对象的真正类型隐藏在抽象类或者接口之后，这些对象才可以被互相替换使用。这可以让我们 Java 程序尽量避免依赖倒置原则。</p><p>除了用于向上转型，抽象类也可以表示一种契约。继承了这个抽象类的所有子类都将拥有跟抽象类一致的接口方法，抽象类的主要作用就是为它的子类定义这些公共接口。如果我们在子类中删除了这些方法中的某一个，那么将不能通过编译器的检查，这在某些场景下是非常有用的。例如，Coffee 子类中没有实现对应的 brew 方法，那么我们百分之百得不到一杯咖啡。既然父类规定了子类的方法和执行这些方法的顺序，子类就应该拥有这些方法，并且提供正确的实现。</p><h3 id="抽象方法和具体方法"><a href="#抽象方法和具体方法" class="headerlink" title="抽象方法和具体方法"></a>抽象方法和具体方法</h3><p>抽象方法被声明在抽象类中，抽象方法并没有具体的实现过程，都是一些 “哑” 方法。比如 Beverage 类中的 brew 方法、pourInCup 方法和 addCondiments 方法，都被声明为抽象方法。当子类继承了这个抽象类时，必须重写父类的抽象方法。</p><p>除了抽象方法之外，如果每个子类中都有一些同样的具体实现方法，那这些方法也可以选择放在抽象类中，这可以节省代码以达到复用的效果，这些方法叫做具体方法。当代码需要改变的时候，我们需要改动抽象类里的具体方法就可以了。</p><h3 id="用-Java-实现-Coffee-or-Tea"><a href="#用-Java-实现-Coffee-or-Tea" class="headerlink" title="用 Java 实现 Coffee or Tea"></a>用 Java 实现 Coffee or Tea</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Beverage</span></span>&#123; <span class="comment">// 抽象类饮料</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123; <span class="comment">// 模板方法</span></span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">'把水煮沸'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抽象类方法</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">pourInCup</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>&#123; <span class="comment">// Coffee 类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>&#123; <span class="comment">// 子类中重写 brew 方法</span></span><br><span class="line">        System.out.println(<span class="string">'用沸水冲泡咖啡'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pourInCup</span><span class="params">()</span></span>&#123; <span class="comment">// 子类中重写 pourInCup 方法</span></span><br><span class="line">        System.out.println(<span class="string">'把咖啡倒进杯子'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>&#123; <span class="comment">// 子类中重写 addCondiments 方法</span></span><br><span class="line">        System.out.println(<span class="string">'加糖和牛奶'</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tea</span> <span class="keyword">extends</span> <span class="title">Beverage</span></span>&#123; <span class="comment">// Coffee 类</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>&#123; <span class="comment">// 子类中重写 brew 方法</span></span><br><span class="line">        System.out.println(<span class="string">'用沸水浸泡茶叶'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pourInCup</span><span class="params">()</span></span>&#123; <span class="comment">// 子类中重写 pourInCup 方法</span></span><br><span class="line">        System.out.println(<span class="string">'把茶倒进杯子'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>&#123; <span class="comment">// 子类中重写 addCondiments 方法</span></span><br><span class="line">        System.out.println(<span class="string">'加柠檬'</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareRecipe</span><span class="params">(Beverage beverage)</span></span>&#123;</span><br><span class="line">        beverage.init();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        Beverage coffee = <span class="keyword">new</span> Coffee(); <span class="comment">// 创建 coffee 对象</span></span><br><span class="line">        prepareRecipe(coffee); <span class="comment">// 开始泡咖啡</span></span><br><span class="line">         <span class="comment">// 把水煮沸</span></span><br><span class="line">         <span class="comment">// 用沸水冲泡咖啡</span></span><br><span class="line">         <span class="comment">// 把咖啡倒进杯子</span></span><br><span class="line">         <span class="comment">// 加糖和牛奶        </span></span><br><span class="line">        Beverage tea = <span class="keyword">new</span> Tea(); <span class="comment">// 创建 tea 对象</span></span><br><span class="line">        prepareRecipe(tea); <span class="comment">// 开始泡茶</span></span><br><span class="line">         <span class="comment">// 把水煮沸</span></span><br><span class="line">         <span class="comment">// 用沸水浸泡茶叶</span></span><br><span class="line">         <span class="comment">// 把茶倒进杯子</span></span><br><span class="line">         <span class="comment">// 加柠檬         </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JavaScript-没有抽象类的缺点和解决方案"><a href="#JavaScript-没有抽象类的缺点和解决方案" class="headerlink" title="JavaScript 没有抽象类的缺点和解决方案"></a>JavaScript 没有抽象类的缺点和解决方案</h3><p>JavaScript 并没有从语法层面提供对抽象类的支持。抽象类的第一个作用是隐藏对象的具体类型，由于 JavaScript 是一门 “类型模糊” 的语言，所以隐藏对象的类型在 JavaScript 中并不重要。</p><p>另一方面，当我们在 JavaScript 中使用原型继承模拟传统的类式继承时，并没有编译器帮助我们进行任何形式的检查，我们也没有办法保证子类会重写父类中的 “抽象方法”。</p><p>我们知道，<code>Beverage.prototype.init</code> 作为模仿方法，已经规定了子类的算法框架，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Beverage.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"> <span class="keyword">this</span>.boilWater(); </span><br><span class="line"> <span class="keyword">this</span>.brew(); </span><br><span class="line"> <span class="keyword">this</span>.pourInCup(); </span><br><span class="line"> <span class="keyword">this</span>.addCondiments(); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们的 Coffee 类或者 Tea 类忘记实现这 4 个方法中的一个呢？拿 brew 方法举例，如果我们忘记编写 Coffee.prototype.brew 方法，那么当请求 coffee 对象的 brew 时，请求会顺着原型链找到 Beverage“父类”对应的 Beverage.prototype.brew 方法，而 Beverage.prototype.brew 方到目前为止是一个空方法，这显然是不能符合我们需要的。</p><p>在 Java 中编译器会保证子类会重写父类中的抽象方法，但在 JavaScript 中却没有进行这些检查工作。我们在编写代码的时候得不到任何形式的警告，完全寄托于程序员的记忆力和自觉性是很危险的，特别是当我们使用模板方法模式这种完全依赖继承而实现的设计模式时。</p><p>下面提供两种变通的解决方案。</p><ul><li>第 1 种方案是用鸭子类型来模拟接口检查，以便确保子类中确实重写了父类的方法。但模拟接口检查会带来不必要的复杂性，而且要求程序员主动进行这些接口检查，这就要求我们在业务代码中添加一些跟业务逻辑无关的代码。</li><li>第 2 种方案是让 Beverage.prototype.brew 等方法直接抛出一个异常，如果因为粗心忘记编<br>写 Coffee.prototype.brew 方法，那么至少我们会在程序运行时得到一个错误。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Beverage.prototype.brew = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">'子类必须重写 brew 方法'</span> ); </span><br><span class="line">&#125;; </span><br><span class="line">Beverage.prototype.pourInCup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">'子类必须重写 pourInCup 方法'</span> ); </span><br><span class="line">&#125;; </span><br><span class="line">Beverage.prototype.addCondiments = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line"> <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>( <span class="string">'子类必须重写 addCondiments 方法'</span> ); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第 2 种解决方案的优点是实现简单，付出的额外代价很少；缺点是我们得到错误信息的时间点太靠后</p><p>我们一共有 3 次机会得到这个错误信息，第 1 次是在编写代码的时候，通过编译器的检查来得到错误信息；第 2 次是在创建对象的时候用鸭子类型来进行“接口检查”；而目前我们不得不利用最后一次机会，在程序运行过程中才知道哪里发生了错误。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>从大的方面来讲，模板方法模式常被架构师用于构建项目的框架，架构师订好了框架的骨架，程序员继承架构的结构后，负责往里面填空，比如 Java 程序员大多使用过的 HttpServlet 技术来开发项目。</p><p>一个基于 HttpServlet 的程序包含 7 个 生命周期，这 7 个周期分别对应一个 do 方法。</p><ul><li>doGet()</li><li>doHead()</li><li>doPut()</li><li>doDelete()</li><li>doOption()</li><li>doTrace()</li></ul><p>HttpServlet 类还提供了一个 service 方法，它就是这里的模板方法，service 规定了这些 do 方法的执行顺序，而这些 do 方法的具体实现则需要 HttpServlet 的子类来提供。</p><p>在 Web 开发中也能找打很多模板方法模式适用的场景，比如我们在构建一系列的 UI 组件，这些组件的构建过程一般如下所示：</p><ol><li>初始化一个 div 容器</li><li>通过 ajax 请求拉取相应的数据</li><li>把数据渲染到 div 容器里面，完成组件的构造</li><li>通知用户组件渲染完毕</li></ol><p>我们可以看到，任何组件的构建都遵循上面的四部，其中第一步和最后一步是相同的，第二步不同的地方是请求 ajax 的远程地址，第三步不同地方是渲染数据的方式。</p><h2 id="钩子方法"><a href="#钩子方法" class="headerlink" title="钩子方法"></a>钩子方法</h2><p>通过模板方法模式，我们在父类中封装了子类的算法框架。这些算法框架在正常状态下是适用于多数子类的，但如果有一些特别“个性”的子类呢？比如我们在 饮料类 Beverage 中封装了饮料冲泡顺序：</p><ol><li>把水煮沸</li><li>用沸水冲泡饮料</li><li>把饮料倒入杯中</li><li>加调料</li></ol><p>在我们的饮料店中，根据这四个步骤制作出来的咖啡和茶，一直顺利地提供给绝大多数客人享用。但有一些客人喝咖啡是不加调料的。既然 Beverage 作为父类，已经规定好了冲泡饮料的四个步骤，那么有什么方法可以让子类不受这个约束？</p><p>钩子方法（hook） 可以用来解决这个问题，放置钩子是隔离变化的一种常见的手段，我们在父类中容易变化的地方放置钩子，钩子可以有一个默认的实现，究竟要不要 “挂钩”，这由子类自行决定。钩子方法的返回结果决定了模板方法后面部分的执行步骤，也就是程序接下来的走向，这样一来，程序就拥有了变化的可能。</p><p>在这个例子里面，我们把挂钩的名为定位 customWantsCondiments，接下来将挂钩放入 Beverage 类，看看我们如何得到一杯不需要 糖和牛奶的咖啡，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Beverage = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Beverage.prototype.boilWater = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'把水煮沸'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Beverage.prototype.brew  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'子类必须重写 brew 方法'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Beverage.prototype.pourInCup  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'子类必须重写 pourInCup 方法'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Beverage.prototype.addCondiments  = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'子类必须重写 addCondiments 方法'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Beverage.prototype.customerWantsCondiments   = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 默认需要调料</span></span><br><span class="line">&#125;</span><br><span class="line">Beverage.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.boilWater()</span><br><span class="line">    <span class="keyword">this</span>.brew()</span><br><span class="line">    <span class="keyword">this</span>.pourInCup()</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.customerWantsCondiments())&#123;</span><br><span class="line">        <span class="keyword">this</span>.addCondiments()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> CoffeeWithHook = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">CoffeeWithHook.prototype = <span class="keyword">new</span> Beverage();</span><br><span class="line">CoffeeWithHook.prototype.brew = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用沸水冲泡咖啡'</span>);</span><br><span class="line">&#125;</span><br><span class="line">CoffeeWithHook.prototype.pourInCup = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'把咖啡倒进杯子'</span>);</span><br><span class="line">&#125;</span><br><span class="line">CoffeeWithHook.prototype.addCondiments = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'加糖和牛奶'</span>);</span><br><span class="line">&#125;</span><br><span class="line">CoffeeWithHook.prototype.customerWantsCondiments = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.confirm(<span class="string">'请问需要调料吗？'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> coffeeWithHook = <span class="keyword">new</span> CoffeeWithHook();</span><br><span class="line">coffeeWithHook.init();</span><br></pre></td></tr></table></figure><h2 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h2><p>好莱坞无疑是演员的天堂，但好莱坞也有很多找不到工作的新人演员，许多新人演员在好莱坞把简历递给演艺公司之后就只有回家等待电话。有时候该演员等得不耐烦了，给演艺公司打电话询问情况，演艺公司往往这样回答：“不要来找我，我会给你打电话。”</p><p>在设计中，这样的规则就是好莱坞原则。在这一原则的指导下，我们运行底层组件将自己挂钩到高层组件中，而高层组件决定什么时候、以何种方式去使用这些底层组件，高层组件对待底层组件的方式，跟演艺公司对待新人演员一样，都是 “别调用我们，我们会调用你”。</p><p>模板方法模式是好莱坞原则的一个典型使用场景，它与好莱坞原则的联系非常明显，当我们用模板方法模式编写一个程序的时候，这意味着子类放弃了对自己的控制权，而是改成父类通知子类，哪些方法应该在什么时候被调用，作为子类，只负责提供一些设计上的细节。</p><p>除此之外，好莱坞原则还常常应用于其他模式和场景，例如发布-订阅模式和回调函数。</p><ul><li><p>发布-订阅模式</p><p>发布者会把消息推送给订阅者，这取代了原先不断去 fetch 消息的形式。例如假设我们乘坐出租车去一个不了解的地方，除了每过 5 秒钟问司机 “是否达到了目的地”之外，还可以在车上美美地睡一觉，然后跟司机说好，等目的地到了就叫醒你。这也相当于好莱坞原则中的 “别调用我们，我们会调用你”</p></li><li><p>回调函数</p><p>在 ajax 异步请求中，由于不知道请求返回的具体时间，而通过轮询去判断是否返回数据，这项显然是不理智的行为。所以我们通常会把接下来的操作放在回调函数中，传入发起 ajax 异步请求的函数。当数据返回之后，这个回调函数才被执行，这也是好莱坞原则的一种体现。把需要执行的操作封装在回调函数里面，然后把主动权交给另一个函数。至于回调函数什么时候被调用，则是另外一个函数控制的。</p></li></ul><h2 id="真的需要-“继承”-吗"><a href="#真的需要-“继承”-吗" class="headerlink" title="真的需要 “继承” 吗"></a>真的需要 “继承” 吗</h2><p>模板方法模式是基于继承的一种设计模式，父类封装了子类的算法框架和方法的执行顺序，子类继承父类之后，父类通知子类执行这些方法，好莱坞原则很好地诠释了这种设计技巧，即高层组件调用底层组件。</p><p>上面的例子中，我们编写了一个 Coffee or Tea 的例子。模板方法模式是为数不多的基于继承的设计模式，但 JavaScript 语言实际上没有提供真正的类式继承模式，继承是通过对象与对象之间的委托来实现的。也就是说，虽然我们在形式上借鉴了提供类式继承的语言，但本章学习到的模板方法模式并不十分正宗。</p><p>在好莱坞原则的指导下，下面的这段代码可以达到和继承一样的效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Beverage = <span class="function"><span class="keyword">function</span>(<span class="params">param</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> boilWater = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'把水煮沸'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> brew = param.brew || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须传递 brew 方法'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> pourInCup = param.pourInCup || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须传递 pourInCup 方法'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> addCondiments = param.addCondiments || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'必须传递 addCondiments 方法'</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    F.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brew();</span><br><span class="line">        pourInCup();</span><br><span class="line">        addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Coffee = Beverage(&#123;</span><br><span class="line">    brew:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'用沸水冲泡咖啡'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    pourInCup:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'把咖啡倒进杯子'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    addCondiments:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'加糖和牛奶'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Tea = Beverage(&#123; </span><br><span class="line">    brew: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'用沸水浸泡茶叶'</span> ); </span><br><span class="line">    &#125;, </span><br><span class="line">    pourInCup: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'把茶倒进杯子'</span> ); </span><br><span class="line">    &#125;, </span><br><span class="line">    addCondiments: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'加柠檬'</span> ); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> coffee = <span class="keyword">new</span> Coffee();</span><br><span class="line">coffee.init();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tea = <span class="keyword">new</span> Tea();</span><br><span class="line">tea.init();</span><br></pre></td></tr></table></figure><p>在这段代码中，我们把 brew、pourInCup、addCondiments 这些方法依次传入 Beverage 函数，Beverage 函数被调用之后返回构造器 F。F 类中包含了“模板方法”F.prototype.init。跟继承得到的效果一样，该“模板方法”里依然封装了饮料子类的算法框架</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>模板方法模式是一种典型的通过封装变化提高系统扩展性的设计模式。在传统的面向对象语言中，一个运用模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以我们把这部分逻辑抽象到父类的模板方法里面。而子类的方法具体怎么实现则是可变的，于是我们把这部分变化的逻辑封装到子类中。通过增加新的子类，我们便能对系统增加新的功能，并不需要改动抽象已经其他子类，这也是符合开发-封闭的原则。</p><p>但在 JavaScript 中，我们很多时候并不需要这样去实现一个模板方法模式，高阶函数是更好的选择。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习曾探的 《JavaScript设计模式与开发实践》并做记录。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ituring.com.cn/book/1632/&quot;&gt;书籍的购买链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;设计模式的定义是：在面向对象软件设计过程中针对特定问题的简洁而
      
    
    </summary>
    
      <category term="JavaScript设计模式" scheme="http://laibh.top/categories/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="JavaScript设计模式" scheme="http://laibh.top/tags/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
