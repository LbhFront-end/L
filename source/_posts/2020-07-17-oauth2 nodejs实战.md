---
title: oauth2 nodejs实战
date: 2020-07-17 11:17:40
tags: docker
categories: 
	- nodejs实战
---



# oauth2 nodejs实战

## 第一章：OAuth2.0是什么

### 是什么

OAuth2.0是一个授权协议，允许软件应用代表资源拥有者去访问资源拥有者的资源。应用向资源拥有者请求授权，然后取得令牌token并用它来访问资源。这一切都不需要应用去充当资源拥有者的身份，因为令牌明确表示了被授予的访问权，限制客户端只能执行资源拥有者授权的操作，或者OAuth2.0是一个安全协议，能让第三方应用以有限的权限访问HTTP服务，可以通过构建资源拥有者与HTTP服务间的许可交互机制，让第三方应用代表资源拥有者访问服务，或者通过授权权限给第三方应用，让其代表自己访问服务。

作为一个授权框架，OAuth关注的是如何让一个系统组件获取对另一个系统㢟的访问权限，最常见的情形是客户端应用代表资源拥有者（通常是最终用户）访问受保护资源。三个角色：

- 资源拥有者有权访问API,并将API访问权限委托出去。资源拥有者一般是能够使用浏览器的人

- 受保护资源是资源拥有者有限权限访问的组件。这样的组件有多种形式，一般是某种形式的Web API，资源听起来像是某种能下载的东西，但其实这些API支持读、写和其他操作。

- 客户端是代表资源拥有者访问受保护资源的软件。在OAuth中，只要软件使用了受保护的资源的API,就是客户端。

例子：假设度假拍的照片上传到了照片存储网站，现在想将它们打印出来。照片存储网络的API就是资源，打印服务则是那个API的客户端。作为资源拥有者，需要将一部分权利委托给照片打印服务，让它能读取照片。但你不想让打印服务读取所有照片也不想它有删除或者上传的权限。

### 旧时代：凭证共享与凭证盗用

#### 复制凭证

之前流行的做法是复制用户的凭证并用它登录另一个服务。就是照片打印服务假设用户在照片存储服务商使用的凭证与在打印服务上的相同。当用户登录照片打印服务后，该服务使用用户的用户名和密码登录照片存储网络，获取用户的账号访问权，假装用户。

这种情况下，用户需要使用某种凭证与客户端进行身份认证，这些凭证通常是被集中控制的，并受客户端和受保护资源一致认可。客户端先得到用户的用户名和密码或者会话cookie，然后用它们访问受保护资源，假装是用户。受保护资源将客户端视为用户并直接通过身份认证，而实际上与受保护资源建立连接的是客户端。

这种方法要求用户在客户端和受保护资源端使用相同的凭据，使得这种凭据盗用技术只能在同一安全域内使用。也就是说，如果是一个公司控制着客户端、授权服务器和受保护资源，并且这些组件都使用相同的策略和网络控制下运作，这种方法才行得通。如果打印服务和存储服务是由同一个公司提供的，就能采用这种方法，因为用户可以在两个服务使用相同的账户凭据。

这一技术还会将用户的密码暴露给客户端应用，即使在单一安全域使用同一组凭据，这也基本上无法避免。但无论如何，客户端是在扮演用户，受保护资源无法区分资源拥有者和扮演资源拥有者的客户端，因此两者都用相同的用户名和密码。

#### 索取并复制密码

如果两个服务处于不同的安全域中，如照片打印例子中的情况，不能复制用户提供的用于登录当前应用的密码了，因为这个密码对于另一个应用来说是无效的。对于这个问题可以采取另一种老套的手段来获取密码：向用户索取。

打印服务想要获取用户的照片，可以提示用户输入照片存储网络上的用户名和密码，打印服务用这些凭据访问受保护资源，扮演用户。在这种情况下，用户用于登录客户端的凭据和用于访问受保护资源的凭据可以不同。很多用户在实际中会运行这样的要求，特别是当使用受保护资源的是一个很有用的服务时。

因此这仍然是当前移动应用通过用户账号访问后端服务的最常见的方法之一：移动应用让用户输入用户名和密码，然后直接将这些凭证通过网络发送给后端API。为了可以持续访问API,客户端应用会保存用户的凭据，以便在必要的时候访问受保护资源，这种做法很危险，一旦任何一个正在使用中的客户端被攻破，这意味着用户在所有系统的账号都被攻破。

#### 开发者密钥

复制用户密码并不是一个好方法，如果授予打印服务全局的访问权限，使它能代表由它指定的任何用户并访问存储服务上的所有照片，常见的方式是为客户端颁发一个开发者密钥，让客户端使用该密钥直接调用受保护资源。

开发者密钥是一种全局的密钥，客户端可以用它来充当任意一个由其指定的用户，用户的指定很可能通过一个API参数来完成。这样做的好处是避免了向客户端暴露用户凭据，但代价是要向客户端提供功能强大的开发者密钥。有了这种密钥，打印服务随时都能任意地打印所有用户的所有照片，因此它实际上拥有了自由访问受保护资源的权利。这在一定程度上是可行，但前提是受保护资源充分了解并信任客户端。但是这样的关系几乎不可能存在于两个组织之间，例如照片打印例子中的两个服务。此外，如果客户端的密钥被盗，将对受保护资源造成灾难性损害，因为存储服务的所有用户都将受到影响，无论他们是否使用打印服务。

#### 特殊密码

给用户一个特殊密码，此密码仅用于透露给第三方服务。用户自己不会使用这个密码来登录，只是将它粘贴到所使用的第三方应用里。用户不再需要想客户端透露登录密码，受保护资源也不在需要相信客户端都能代表所有用户执行正确的操作。但是这种系统的可用性不好。要求用户除了管理自己的主密码之外，还要创建、分发、管理特殊凭据。因为需要用户来管理这些凭据，一般来说，客户端与凭据本身并没有对应关系，这使得撤销某个应用的访问权限变得很困难。

#### 更好的方法

如果能为每个客户端和每个用户的组合分别颁发这种受保护资源具有受限访问的凭据，就可以将受限访问分别与受限凭据绑定。如果有一个基于网络的协议，能够部署到整个互联网上，跨安全边界地生成安全分发这些首先呢的凭据，同时具有良好的用户体验。



### 授权访问

OAuth协议的设计目的是：让最终用户通过OAuth将他们在受保护资源上的部分权限委托给客户端应用，使客户端应用代表他们执行操作。为实现这一点，OAuth在系统中引入了另外一个组件：授权服务器。

受保护资源依赖授权服务器向客户端颁发专用的安全凭据——OAuth访问令牌。为了获取令牌，客户端首先将资源拥有者引导至授权服务器，请求资源拥有者为其授权。授权服务器先对资源拥有者进行身份认证，然后一般会让资源拥有者选择是否对客户端授权。客户端可以请求授权功能或权限范围的子集，该子集可能会被资源拥有者进一步缩小。一旦授权请求被许可，客户端就可以向授权服务器请求访问令牌。按照资源拥有者的许可，客户端可以使用该令牌对受保护资源上的API进行访问。

在这个过程中，没有讲资源拥有者的凭据暴露给客户端：资源拥有者向授权服务器进去身份认证的过程中所用的信息是独立于客户端交互的。客户端没有功能强大的开发者密钥，无法随意访问任何资源，而是必须在得到有效的资源拥有者的授权之后才能访问受保护资源。虽然大多数OAuth客户端可以向授权服务器进行身份认证，但仍然需要得到授权后才能访问资源。

用户通常不必查看或者直接处理访问令牌，OAuth不需要由用户生成令牌并粘贴到客户端，而是简化了这一过程：客户端请求令牌，用户对客户端授权，然后由客户端管理令牌，用户管理客户端应用。

#### 超越HTTP基本认证协议和密码共享反模式

上面很多传统方法都是密码反模式的案例，通过共享机密信息（密码）来直接代表当事方（用户）。用户通过与应用共享密码，使应用能够访问受保护的API，然而这种方式非常不安全。

HTTP API最开始是如何引入密码保护功能的呢？可以从 HTTP 协议的历史及其安全手段入手，HTTP 协议制定了一个机制，用户可以凭借该机制在浏览器中使用用户名和密码向一个网页进行身份认证，这就是所谓的 HTTP 基本认证协议 （HTTP basic auth）。还有一种更安全的认证协议，叫做 HTTP 摘要认证（HTTP digest auth）。它们都假设用户在场，并且要求 HTTP 服务器呈现用户的用户名和密码，此外由于 HTTP 是一个无状态的协议，因此每一个 HTTP 事务都要呈现这些凭据。

HTTP不会区分一个事务是由用户通过浏览器发起的，还是通过其他软件发起的，这种基本的灵活性是HTTP协议得到普及的关键原因。这样有一个问题是除了面向用户的网页或服务之外，当 HTTP 用于直接访问 API时，现有的安全机制顺理成章被沿用到新的应用场景，为API和网页服务不断呈现 密码。虽然浏览器可以使用cookie技术或其他会话管理技术，但是访问Web API的HTTP客户端没有这样的机制可用。

OAuth从一开始就被设计成一个可用的API协议，其中主要的交互过程都是在浏览器之外进行的。OAuth的整个流程通常是由最终用户在浏览器中启动的，实际上这也正是委托模式的灵活性和优势所在。但是最终接收令牌、使用令牌访问受保护资源的步骤对用户是不可见的。实际上，OAuth的一些主要事务过程都是发生在用户不在场的情况下，客户端仍然能够代表用户执行操作。OAuth让我们摒弃HTTP基本协议中的观念和假设，将一种功能强大、安全的方式引入现如今的API体系

#### 授权委托：重要性及应用

委托概念是OAuth强大功能的根基，虽然OAuth经常被称作授权协议，但它也是一个委托协议。通常，被委托的是用户权限的子集，但是OAuth本身并不承载或者传递权限。相反，它提供一种方法，让客户端可以请求用户将部分权限委托给自己，然后用户可以批准这个委托请求，被批准后，客户端就可以去执行那些操作了。

以照片打印为例子，照片打印服务可以询问用户：是否在这个存储服务存放了照片？如果是我可以帮打印出来。然后用户被引导至照片存储服务，存储服务也会问：打印服务想要获取照片，同意吗？用户可以决定是否同意，即决定是否将访问权限委托给打印服务。

委托协议和授权协议的区别很重要，因为OAuth令牌中携带的授权信息对系统中的大部分组件是不透明的。只有受保护资源需要了解授权信息，只要它能从令牌得知授权信息（既可以直接从令牌中获取，也可以通过某种服务来获取），就可以按照要求提供API服务

#### 用户主导的安全与用户的选择

由于OAuth的委托过程需要资源拥有者的参与，因此它提供了一种在很多其他安全模型中不存在的可能性：重要的安全决策可以由最终用户来做。传统上，安全决策一直由集权机构负责。由集权机构决定谁可以使用服务、使用什么客户端以及以何种目的使用。OAuth则允许集权机构将某些决策权交到最终使用软件的用户手中。

OAuth系统常遵循TOFU原则：首次使用时信任（trust on first use）。在TOFU模型中，需要用户在第一次运行时进行安全决策，而且并不为安全决策预设任何先决条件或者配置，仅提示用户做出决策。这个过程可以简单到只是询问用户“要连接新的应用吗”。很多实现运行在这个步骤中进行更多控制。无论用户遇到的是哪种情况，只要具有对应的权限，就能做出安全决策。系统会记住用户的决策，以便以后使用。只要首次建立了授权关系，系统就会在后续的处理过程中继续信任用户的决策：首次使用时信任。

### OAuth2.0：优点、缺点和丑陋方面

OAuth2.0非常善于获取用户的委托决策，并通过网络传递出去。运行多方参与安全决策过程，尤其是在运行期间让最终用户参与决策。由多个可移动的组件构成的协议，但是在很多方面都比其他方案更简单、更安全。

OAuth2.0设计中有一个重要的阶段，就是不受控的客户端总是比授权服务器或者受保护资源多出好几个数量级。因为单个授权服务器可以很轻松地保护多个资源服务器，并且很可能有许多不同类型的客户端想要访问特定的API。一台授权服务器甚至可以有多个不同的客户端信任等级。这样的架构决策导致的结果就是， 尽可能将复杂性从客户端转移到服务端。这对于客户端开发人员来说是好事，因为客户端成了系统最简单的部分。客户端人员不再需要像在先前的安全协议中，处理签名规范化以及解析复杂的安全策略文档，也不需要担心处理敏感的用户凭据。OAuth令牌提供了一种比密码略复杂的机制，如果使用得当，其安全性比密码高很多。

另一方面，授权服务和受保护资源要承担更多复杂性和安全性方面的责任。客户端只要保护好自身的客户端凭据和用户的令牌即可，单个客户端被攻破会造成损害，但只有该客户端的用户会受到影响。被攻破的客户端也不会泄露资源拥有者的凭据，因此客户端根本没有机会接触这些凭据。然而，授权服务器则需要管理和保护系统中所有客户端和用户的凭证和令牌。虽然这确实使它更容易称为攻击目标，但是保护单个授权服务器要比保护上千台由不同开发人员开发的客户端容易得多。

OAuth2.0的可拓展性和模块化是其最大的优势之一，因为这使得该协议适用于各种环境。然而正是这种灵活性导致不同的实现之间存在基本的兼容性问题。当开发人员想在不同的系统上实现OAuth时，它提供的众多自定义选项更让人困惑。

### OAuth2.0不能做什么

#### 没有定义HTTP协议之外的情形

由于使用bearer令牌的OAuth2.0并不提供消息签名，因此不应该脱离HTTPS使用。机密信息需要在网络上传播，所以OAuth需要TLS这样的传输机制来保护这些信息。

#### 不是身份认证协议

OAuth本身并不透露关于用户的信息，本质上是一个部件，能用于在更宏大的技术方案中提供其他功能，另外OAuth 在多个地方用到了身份认证，最典型的就是资源拥有者和客户端软件要向授权服务器进行身份认证。但这种内嵌身份认证的行为并不会使OAuth自身成为身份认证协议

#### 没有定义用户对用户的授权机制

尽管它在根本上是一个用户向软件授权的协议。OAuth假设资源拥有者能够控制客户端。要使资源拥有者向另一个用户授权，仅适用OAuth是不行的。但这种授权并不罕见，User Managed Access协议就是为此而生，规定了如何使用OAuth 构建一个支持用户对用户授权的系统。

#### 没有定义授权处理机制

提供了一种传达授权委托已发生这一事实，但是它并不定义授权的内容。相反，由服务API定义使用权限范围、令牌之类的OAuth组件来定义一个给定的令牌适用于哪些操作

#### 没有定义令牌格式

明确声明了令牌的内容对客户端是完全不透明的。颁发令牌的授权服务器和接收令牌的受保护资源需要理解令牌。这个层面的互操作性要求催发了 JSON Web Token(JWT)格式和令牌内省协议。虽然令牌本身对客户端还是不透明的，但现在它的格式能被其他组件理解。

#### 没有定义加密方法

没有新的加密机制，而是允许借用通用的加密机制，这些加密机制不止适用于OAuth。这种有意的遗漏催生了JSON对象签名和加密（JOSE）规范套件，该套件提供了一系列通用的加密机制，可以配合OAuth使用，也可以脱离OAuth使用。

#### 不是单体协议

规范被分成了多个定义和流程，每个定义和流程都有各自适用的场景。在某种程度上，可以将OAuth2.0视为一个安全协议生成器，因为它可用于许多不同的应用场景设计安全架构。

### 小结

OAuth是一个应用广泛的安全标准，提供了一种安全访问受保护资源的方式，特别适用于Web API

- 关注的是如何获取令牌和如何使用令牌
- 是一个委托协议，提供跨系统授权的方案
- 用可用性和安全性更高的委托协议取代了密码共享反模式
- 专注于很好地解决小问题集，因而是整个安全系统中一颗很合用的螺丝钉

## 第二章：协议与组件