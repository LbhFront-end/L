<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="NodeJs," />





  <link rel="alternate" href="/atom.xml" title="赖同学" type="application/atom+xml" />






<meta name="description" content="NodeJS模块与文件require 的加载机制模块的分类系统模块  C/C++模块，也叫build-in内建模块，一般用于native模块嗲用，在require出去 native模块，在开发中使用的Node.js 的 http/buffer/fs等，底层也是调用的内建模块（C/C++）  第三方模块： 非Node.js自带的模块被称为第三方模块，会分成路径形式的文件模块（以.、..、/开头的）和">
<meta name="keywords" content="NodeJs">
<meta property="og:type" content="article">
<meta property="og:title" content="NodeJs回顾">
<meta property="og:url" content="http://laibh.top/2020-06-19-NodeJS回顾.html">
<meta property="og:site_name" content="赖同学">
<meta property="og:description" content="NodeJS模块与文件require 的加载机制模块的分类系统模块  C/C++模块，也叫build-in内建模块，一般用于native模块嗲用，在require出去 native模块，在开发中使用的Node.js 的 http/buffer/fs等，底层也是调用的内建模块（C/C++）  第三方模块： 非Node.js自带的模块被称为第三方模块，会分成路径形式的文件模块（以.、..、/开头的）和">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-06-30T09:27:05.295Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="NodeJs回顾">
<meta name="twitter:description" content="NodeJS模块与文件require 的加载机制模块的分类系统模块  C/C++模块，也叫build-in内建模块，一般用于native模块嗲用，在require出去 native模块，在开发中使用的Node.js 的 http/buffer/fs等，底层也是调用的内建模块（C/C++）  第三方模块： 非Node.js自带的模块被称为第三方模块，会分成路径形式的文件模块（以.、..、/开头的）和">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '1YNH8Y3MP9',
      apiKey: '61c189facf700193dfcbb902369ce227',
      indexName: 'MyBlog',
      hits: {"per_page":10},
      labels: {"input_placeholder":"想要找些什么呢","hits_empty":"${query} 没有被找到，再试试","hits_stats":"在 ${time} ms 查找了${hits}个结果"}
    }
  };
</script>



  <link rel="canonical" href="http://laibh.top/2020-06-19-NodeJS回顾.html"/>





  <title>NodeJs回顾 | 赖同学</title>
  








</head>
<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">赖同学</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      
        
        <li class="menu-item menu-item-guestbook">
          <a href="/guestbook" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-comment"></i> <br />
            
            留言
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://laibh.top/2020-06-19-NodeJS回顾.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="赖彬鸿">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/myPhoto.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="赖同学">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">NodeJs回顾</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-19T16:46:38+08:00">
                2020-06-19
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-06-30T17:27:05+08:00">
                2020-06-30
              </time>
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/NodeJs/" itemprop="url" rel="index">
                    <span itemprop="name">NodeJs</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2020-06-19-NodeJS回顾.html" class="leancloud_visitors" data-flag-title="NodeJs回顾">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  21,368
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h1><h2 id="模块与文件"><a href="#模块与文件" class="headerlink" title="模块与文件"></a>模块与文件</h2><h3 id="require-的加载机制"><a href="#require-的加载机制" class="headerlink" title="require 的加载机制"></a>require 的加载机制</h3><h4 id="模块的分类"><a href="#模块的分类" class="headerlink" title="模块的分类"></a>模块的分类</h4><p>系统模块</p>
<ul>
<li>C/C++模块，也叫build-in内建模块，一般用于native模块嗲用，在require出去</li>
<li>native模块，在开发中使用的Node.js 的 http/buffer/fs等，底层也是调用的内建模块（C/C++）</li>
</ul>
<p>第三方模块：</p>
<p>非Node.js自带的模块被称为第三方模块，会分成路径形式的文件模块（以<code>.</code>、<code>..</code>、<code>/</code>开头的）和自定义的模块（比如express/koa/moment.js等）</p>
<p>在 Node.JS 中模块加载一般会经历3个步骤：路径分析、文件定位、编译执行</p>
<p>按照模块的分类，按照以下的顺序进行优先加载：</p>
<ul>
<li>系统缓存：模块被执行之后会进行缓存，首先是先进行缓存加载，判断换粗中是否有值。</li>
<li>系统模块：也就是原生模块，优先级次于系统缓存，部分核心模块已经被编译成二进制，省略了路径分析、文件定位，直接加载在内存中，系统模块定义在 Node.js 源码的lib目录下。</li>
<li>文件模块：优先加载 <code>.</code>、<code>..</code>、<code>/</code>开头的，如果文件没有加上拓展名，会依次按照<code>.js</code>、<code>.json</code>、<code>.node</code>尝试进行拓展名补足。（在尝试过程中也是以<strong>同步阻塞模式</strong>来判断文件是否存在的，从性能优化角度来看，<code>.json</code>、<code>node</code>最好还是加上文件的拓展名）</li>
<li>目录作为模块：文件模块加载过程中没有找到，但发现这是一个目录，这个适合就会把这个目录当做一个包来处理，Node采用了commonjs规范，会先在项目的根目录查找package.json文件，取出文件中定义的main属性描述的入口文件进行加载，也没有加载到，则会抛出默认错误：Error：Cannot find module ‘lib/hello.js’</li>
<li>node_modules目录加载：对于系统模块，路径文件模块都找不到，Nodejs会从当前模块的父目录进行查找，直到系统的根目录</li>
</ul>
<h3 id="module-exports-与-exports-的区别"><a href="#module-exports-与-exports-的区别" class="headerlink" title="module.exports 与 exports 的区别"></a>module.exports 与 exports 的区别</h3><p>exports相当于 module.exports 的快捷方式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> exports = <span class="built_in">module</span>.exports</span><br></pre></td></tr></table></figure>
<p>但是不能改变 exports 的指向，我们可以通过 <code>exports.test = &#39;a&#39;</code>，这样来导出一个对象，但是不能通过下面的例子直接赋值，这样会改变 exports 的指向</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法，将会得到 undefined</span></span><br><span class="line">exports = &#123;</span><br><span class="line">   <span class="string">'a'</span>:<span class="number">1</span>,</span><br><span class="line">   <span class="string">'b'</span>:<span class="number">2</span> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line">modules.exports =&#123;</span><br><span class="line">   <span class="string">'a'</span>:<span class="number">1</span>,</span><br><span class="line">   <span class="string">'b'</span>:<span class="number">2</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模块循环引用问题"><a href="#模块循环引用问题" class="headerlink" title="模块循环引用问题"></a>模块循环引用问题</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a模块start'</span>);</span><br><span class="line">exports.test = <span class="number">1</span>;</span><br><span class="line">undeclaredVariable = <span class="string">'a模块为声明变量'</span></span><br><span class="line"><span class="keyword">const</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a模块加载完毕：b.test值'</span>,b.test);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b模块start'</span>);</span><br><span class="line">exports.test = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'undeclaredVariable:'</span>,undeclaredVariable)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b模块加载完毕：a.test值：'</span>,a.test)</span><br></pre></td></tr></table></figure>
<p>执行 <code>node a.js</code>,结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a模块start</span><br><span class="line">b模块start</span><br><span class="line">undeclaredVariable:a模块未声明变量</span><br><span class="line">b模块加载完毕：a.test值：1</span><br><span class="line">a模块加载完毕：b.test值：2</span><br></pre></td></tr></table></figure>
<p>启动a.js会加载b.js，那么在b.js中又加载到了a.js，但是此时a.js模块hi阿咩有执行完，返回的是一个a.js模块的exports对象未完成的副本给到b.js模块（因此不会陷入死循环），然后b.js完成加载之后将exports 对象退供给a.js模块</p>
<h4 id="a-模块中的-undeclaredVariable-变量在-b-js-是否会打印？"><a href="#a-模块中的-undeclaredVariable-变量在-b-js-是否会打印？" class="headerlink" title="a 模块中的 undeclaredVariable 变量在 b.js 是否会打印？"></a>a 模块中的 undeclaredVariable 变量在 b.js 是否会打印？</h4><p>undeclaredVariable 是一个未声明的变量，也就是一个挂在全局的变量，那么在其他地方是可以拿得到的</p>
<h4 id="假设有-a-js、b-js-两个模块相互引用，会有什么问题，会不会陷入死循环？"><a href="#假设有-a-js、b-js-两个模块相互引用，会有什么问题，会不会陷入死循环？" class="headerlink" title="假设有 a.js、b.js 两个模块相互引用，会有什么问题，会不会陷入死循环？"></a>假设有 a.js、b.js 两个模块相互引用，会有什么问题，会不会陷入死循环？</h4><p>不会陷入死循环</p>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><h3 id="Buffer与Cache的区别"><a href="#Buffer与Cache的区别" class="headerlink" title="Buffer与Cache的区别"></a>Buffer与Cache的区别</h3><h4 id="缓冲（Buffer）"><a href="#缓冲（Buffer）" class="headerlink" title="缓冲（Buffer）"></a>缓冲（Buffer）</h4><p>缓冲是用于处理二进制流数据，将数据存储起来，它是临时性的，对于流式数据来说，会采用缓冲区将数据临时存储起来，等缓冲到一定大小的时候存入硬盘中。视频播放器就是一个经典例子。</p>
<h4 id="缓存（Cache）"><a href="#缓存（Cache）" class="headerlink" title="缓存（Cache）"></a>缓存（Cache）</h4><p>缓存可以看做一个中间层，可以是永久性的将热点数据进行缓存，使得访问速度更快。例如我们通过对 memory、Redis等将数据从硬盘或者第三方接口中请求过来进行缓存，目的就是将数据存于内存的缓存区中，这样对同一个资源进行访问，速度会更快，也就是性能优化的一个重要点。</p>
<h2 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h2><h4 id="什么是进程（Process）和线程（Thread），之间的区别"><a href="#什么是进程（Process）和线程（Thread），之间的区别" class="headerlink" title="什么是进程（Process）和线程（Thread），之间的区别"></a>什么是进程（Process）和线程（Thread），之间的区别</h4><h5 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h5><p>进程是计算中程序关于数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器。启动一个服务，运行一个实例，就是开一个服务进程。多进程就是进程的复制（fork），fork出来的每个进程都有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了IPC通信，进程之间才可以数据共享。</p>
<h5 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h5><p>线程是操作系统能够进行运算调度的最小单位，线程是隶属进程的，被包含与进程之中的。一个线程只能隶属一个进程，但是一个进程是可以拥有多个线程的。</p>
<p>同一个代码，可以根据系统CPU核心数启动多个进程，每个进程都有属于自己的独立运行空间，进程之间是不互相影响的。同一进程中的多条线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述和信号处理等。但 同一进程中的多个线程有各自的调用栈，自己的寄存器环境，自己的线程本地存储。</p>
<h3 id="什么是孤儿进程"><a href="#什么是孤儿进程" class="headerlink" title="什么是孤儿进程"></a>什么是孤儿进程</h3><p>父进程创建子进程之后，父进程退出了，但是父进程对应的一个或者多个子进程还在运行，这些子进程会被系统的init进程收养，对应的程序ppid为1，这就是孤儿进程。</p>
<h3 id="创建多进程时，代码里有app-listen-port-在进行fork时，为什么没有报端口被占用"><a href="#创建多进程时，代码里有app-listen-port-在进行fork时，为什么没有报端口被占用" class="headerlink" title="创建多进程时，代码里有app.listen(port)在进行fork时，为什么没有报端口被占用"></a>创建多进程时，代码里有<code>app.listen(port)</code>在进行fork时，为什么没有报端口被占用</h3><p>端口被占用的情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.js</span></span><br><span class="line"><span class="keyword">const</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</span><br><span class="line"><span class="keyword">const</span> cups = <span class="built_in">require</span>(<span class="string">'os'</span>).cups();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;cups.length;i++)&#123;</span><br><span class="line">    <span class="keyword">const</span> worker = fork(<span class="string">'worker.js'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'worker process created, pid: %s ppid: %s'</span>, worker.pid, process.pid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line">http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.send(<span class="string">'I am worker,pid:'</span>+process.pid+<span class="string">', ppid: '</span>+process.pid)</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 控制台执行node master.js只有一个worker 可以监听 3000 端口，其余会抛出 Error:listen EADDRINUSE :::3000错误</span></span><br></pre></td></tr></table></figure>
<p>多进程模式可通过句柄传递不会有端口占用的问题。</p>
<p>当父子进程之间建立IPC通道之后，通过子进程对象的send方法发送消息，第二个参数sendHandle就是句柄，可以是TCP套接字，TCP服务器、UDP套接字等，为了解决上面多进程端口占用问题，将主进程的socket传递到子进程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.js</span></span><br><span class="line"><span class="keyword">const</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</span><br><span class="line"><span class="keyword">const</span> cups = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus();</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer();</span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br><span class="line">process.title = <span class="string">'node-master'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;cpus.length;i++)&#123;</span><br><span class="line">    <span class="keyword">const</span> worker = fork(<span class="string">'worker.js'</span>)</span><br><span class="line">    worker.send(<span class="string">'server'</span>,server);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'worker process created, pid: %s ppid: %s'</span>, worker.pid, process.pid);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(i+<span class="number">1</span> === cpus.length)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'serve close'</span>);</span><br><span class="line">        server.close(); <span class="comment">// 关闭服务器监听，交由子进程处理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req,res</span>)=&gt;</span>&#123;</span><br><span class="line">    res.end(<span class="string">'I am worker, pid: '</span> + process.pid + <span class="string">', ppid: '</span> + process.ppid);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">let</span> worker;</span><br><span class="line">process.title = <span class="string">'node-worker'</span>;</span><br><span class="line">process.on(<span class="string">'message'</span>,(message,sendHandle)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(message === <span class="string">'server'</span>)&#123;</span><br><span class="line">        worker = sendHandle;</span><br><span class="line">        worker.on(<span class="string">'connection'</span>,(socket)=&gt;&#123;</span><br><span class="line">            server.emit(<span class="string">'connection'</span>,socket)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="什么是IPC通信，如何建立，什么场景下会使用"><a href="#什么是IPC通信，如何建立，什么场景下会使用" class="headerlink" title="什么是IPC通信，如何建立，什么场景下会使用"></a>什么是IPC通信，如何建立，什么场景下会使用</h3><p>IPC(inter-process communication)，即进程间通信技术，由于每个进程创建之后都有自己的独立地址空间，实现IPC的目的就是进程之间的资源共享访问，实现IPC的方式有多种：管道、消息队列、信号量、Domain Socket，Nodejs通过pipe来实现。</p>
<p>未使用IPC的情况：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pipe.js</span></span><br><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;</span><br><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">'node'</span>,[<span class="string">'worker.js'</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(process.pid,child.pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'I am worker,PID:'</span>,process.pid)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行 node pipe.js，输出主线程的id，子线程的id，但是子线程worker.js的信息没有在控制台打印，原因是新创建的子进程有自己的 stdio流</span></span><br></pre></td></tr></table></figure>
<p>创建一个父进程和子进程之间传递消息的IPC通道实现输出信息</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改pipe.js让子进程的stdio和当前进程的stdio之间建立管道链接，还可以通过spawn方法的stdio选项建立IPC机制</span></span><br><span class="line"><span class="comment">// pipe.js</span></span><br><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;</span><br><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">'node'</span>,[<span class="string">'worker.js'</span>]);</span><br><span class="line">child.stdout.pipe(process.stdout);</span><br><span class="line"><span class="built_in">console</span>.log(process.pid,child.pid);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父进程与子进程的通信</span></span><br><span class="line"><span class="comment">// 父进程在创建子进程之前会先去创建IPC通道并一直监听该通道，之后开始创建子进程并通过环境变量（NODE_CHANNEL_FD）的方式将IPC频道的文件描述符传递给子进程，子进程启动时根据传递的文件描述符去链接IPC通道，从而建立父子进程之间的通信机制。</span></span><br></pre></td></tr></table></figure>
<h3 id="Node-js是单线程还是多线程，为什么会单线程"><a href="#Node-js是单线程还是多线程，为什么会单线程" class="headerlink" title="Node.js是单线程还是多线程，为什么会单线程"></a>Node.js是单线程还是多线程，为什么会单线程</h3><p>javascript是单线程，在服务端运行环境的nodejs不是单线程。</p>
<p>浏览器环境中对于DOM的操作是单线程的，避免DOM渲染冲突，在浏览器中UI渲染线程和JS执行引擎是互斥的，一方在执行式都会导致另一方被挂起，这是由JS引擎所决定的。</p>
<h3 id="关于守护进程，是什么，为什么，怎么编写？"><a href="#关于守护进程，是什么，为什么，怎么编写？" class="headerlink" title="关于守护进程，是什么，为什么，怎么编写？"></a>关于守护进程，是什么，为什么，怎么编写？</h3><p>守护进程运行在后台不受终端影响。</p>
<h4 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h4><ol>
<li>创建子进程</li>
<li>在子进程中创建新会话（调用系统函数setsid）</li>
<li>改变子进程工作目录（如：’/‘或者’/usr/‘等）</li>
<li>父进程终止</li>
</ol>
<h3 id="编写demo"><a href="#编写demo" class="headerlink" title="编写demo"></a>编写demo</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js文件的处理逻辑使用 spawn创建子进程完成第一步，设置options.detached为true可以使得子进程在父进程退出后继续运行（系统层会调用setsid方法），这是第二步。options.cwd指定当前子进程工作目录不做设置默认继承当前工作目录，这是第三步。运行daemon.unref()退出父进程，第四步。</span></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startDaemon</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> daemon = spawn(<span class="string">'node'</span>,[<span class="string">'daemon.js'</span>],&#123;</span><br><span class="line">        cwd:<span class="string">'/usr'</span>,</span><br><span class="line">        datached:<span class="literal">true</span>,</span><br><span class="line">        stdio:<span class="string">'ignore'</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'守护进程开启 父进程 pid: %s, 守护进程 pid: %s'</span>, process.pid, daemon.pid);</span><br><span class="line">    daemon.unref();</span><br><span class="line">&#125;</span><br><span class="line">startDaemon();</span><br><span class="line"></span><br><span class="line"><span class="comment">// daemon.js文件哩逻辑开启一个定时器每10秒运行一次，使得这个资源不会退出，同时写入日志到子进程当前的工作目录下</span></span><br><span class="line"><span class="comment">// /usr/daemon.js</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;Console&#125; = <span class="built_in">require</span>(<span class="string">'console'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Console(fs.createWriteStream(<span class="string">'./stdout.log'</span>),fs.createWriteStream(<span class="string">'./stderr.log'</span>));</span><br><span class="line"></span><br><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    logger.log(<span class="string">'daemon pid:'</span>,process.pid,<span class="string">'ppid: '</span>,process.ppid)</span><br><span class="line">&#125;,<span class="number">1000</span>*<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>实际工作中守护进程很多，例如PM2,Egg-Cluster等，实际工作上对于守护进程的健壮性要求还是很高的，例如：进程的异常监听，工作进程管理调度，进程挂掉之后重启等等。</p>
<h3 id="实现一个简单的命令行交互程序"><a href="#实现一个简单的命令行交互程序" class="headerlink" title="实现一个简单的命令行交互程序"></a>实现一个简单的命令行交互程序</h3><p>采用子进程 child_process的spawn方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> spawn = <span class="built_in">require</span>(<span class="string">'child_process'</span>).spawn;</span><br><span class="line"><span class="keyword">const</span> child = spawn(<span class="string">'echo'</span>,[<span class="string">'简单的命令行交互'</span>]);</span><br><span class="line">child.stdout.pipe(process.stdout) <span class="comment">// 将子进程的输出作为当前进程的输入，打印在控制台</span></span><br></pre></td></tr></table></figure>
<h3 id="进程的当前工作目录是什么，有什么用"><a href="#进程的当前工作目录是什么，有什么用" class="headerlink" title="进程的当前工作目录是什么，有什么用"></a>进程的当前工作目录是什么，有什么用</h3><p>进程的当前工作目录可以通过process.cwd()命令获取，默认为当前启动的目录，如果是创建子进程则继承于父进程的目录，可以通过process.chdir()命令重置，例如通过spawn命令创建的子进程可以指定cwd选项设置子进程的工作目录。</p>
<p>有什么用，例如fs读取文件，如果设置为相对路径则是相当于当前进程启动的目录进行查找，所以，启动目的设置有误的情况下将无法得到正确的结果。还有一种情况程序里引用第三方模块也是根据当前进程启动的目录来进行查找的</p>
<h3 id="多进程或者多个Web服务之间的状态共享问题"><a href="#多进程或者多个Web服务之间的状态共享问题" class="headerlink" title="多进程或者多个Web服务之间的状态共享问题"></a>多进程或者多个Web服务之间的状态共享问题</h3><p>多进程模式下各个进程之间是相互独立的，例如用户登录之后seesion的保存，如果保存在服务进程里，那么如果我有4个工作进程，每个进程都要保存一份这是没有必要的。假设服务重启了数据也会丢失。多个Web服务也是一样的，还会出现在A机器创建了Session，当负载均衡分到B机器上之后还需要再创建一份，一般的做法是通过Redis或者数据库来做数据共享</p>
<h3 id="什么是僵尸进程"><a href="#什么是僵尸进程" class="headerlink" title="什么是僵尸进程"></a>什么是僵尸进程</h3><p>使用fork可以创建子进程，正常情况进程退出，内核要释放进程所占用的资源：打开的文件、占用的内存等，但是进程的PID、退出状态、运行时间等会进行保留，知道父进程调用wait/waitpid来获取子进程的状态信息时，这些资源才会释放。</p>
<p>如果子进程退出之后，父进程没有调用wait/waitpid来获取子进程的状态，那么保留的进程号将会一直被占用，且占用系统资源，称为僵死或僵尸进程。</p>
<p>元凶是其父进程，我们把元凶kill掉之后，僵尸进程会变为孤儿进程被系统的 init 进程pid=1的进程所收养，init进程会对这些孤儿进程进行管理（调用wait/waitpid）释放其占用资源。</p>
<h2 id="Console"><a href="#Console" class="headerlink" title="Console"></a>Console</h2><h3 id="console是异步还是同步的"><a href="#console是异步还是同步的" class="headerlink" title="console是异步还是同步的"></a>console是异步还是同步的</h3><p>console既不是总是同步的，也不总是异步的，是否为同步取决于链接是什么流以及操作系统是Window还是Posix</p>
<p>同步写将会阻塞实践循环直到写完成。</p>
<ul>
<li>文件（Files）：Windows和POSIX平台都是同步</li>
<li>终端（TTYS）：Windows平台下同步，在POSIX平台下异步</li>
<li>管道（Pipes）：Windows平台下同步，POSIX平台下异步</li>
</ul>
<h3 id="如何实现一个console-log"><a href="#如何实现一个console-log" class="headerlink" title="如何实现一个console.log"></a>如何实现一个console.log</h3><p>可利用 process.stdout将输入流数据输出到输出流（即输出到终端）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">process.stdout.write(<span class="string">'xxx'</span>+<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="为什么console-log-执行完就退出"><a href="#为什么console-log-执行完就退出" class="headerlink" title="为什么console.log()执行完就退出"></a>为什么console.log()执行完就退出</h3><p>一旦产生事件循环，就会长产生一个While(true)的死循环，例如定时器，console.log则没有产生watch/handlers，在事件循环一次就退出了。</p>
<p>Nodejs进程退出会等待异步处理完成，常见的运维过程中会碰到需要进程优雅退出的场景，Nodejs自然退出是最好的，process.exit是比较粗暴的。</p>
<p>常见的异步请求：</p>
<ul>
<li>http请求，数据库请求等IO请求操作</li>
<li>net.Server.listen()或者http.Server.listen等端口监听</li>
<li>fs.write()类型的文件IO操作</li>
<li>console.log()输出日志</li>
<li>setTimeout()/setInterval等定时器操作</li>
<li>process.send()等异步请求发送</li>
</ul>
<h2 id="Net模块"><a href="#Net模块" class="headerlink" title="Net模块"></a>Net模块</h2><table>
<thead>
<tr>
<th>OSI七层模型</th>
<th>TCP/IP五层模型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>应</td>
<td>构建于传输层之上常用的HTTP、FTP文件传输协议、SMTP邮件传输协议等</td>
</tr>
<tr>
<td>表示层</td>
<td>用</td>
<td>构建于传输层之上常用的HTTP、FTP文件传输协议、SMTP邮件传输协议等</td>
</tr>
<tr>
<td>会话层</td>
<td>层</td>
<td>构建于传输层之上常用的HTTP、FTP文件传输协议、SMTP邮件传输协议等</td>
</tr>
<tr>
<td>传输层</td>
<td>传输层</td>
<td>向用户提供可靠的端到端服务TCP、UDP</td>
</tr>
<tr>
<td>网络层</td>
<td>网络层</td>
<td>IPV4、IPV6</td>
</tr>
<tr>
<td>数据链路层</td>
<td>数据链路层</td>
<td>设备驱动和硬件</td>
</tr>
<tr>
<td>物理层</td>
<td>物理层</td>
<td>设备驱动和硬件</td>
</tr>
</tbody>
</table>
<h3 id="什么是TCP协议，什么时候会选择TCP协议"><a href="#什么是TCP协议，什么时候会选择TCP协议" class="headerlink" title="什么是TCP协议，什么时候会选择TCP协议"></a>什么是TCP协议，什么时候会选择TCP协议</h3><p>IP协议是无连接通信协议，IP协议不会占用两个设备之间通信的线路，IP实际上主要负责将每个数据包路由至目的地，但是IP协议没有能确保数据包是否到达，传过去的数据是否按照顺序排列，所以IP数据包是不可靠的。而解决数据不可靠的问题就是由TCP协议来完成。</p>
<p>TCP（Transmission Control Protocol）是可靠的传输控制协议，三个特点：</p>
<ul>
<li>面向链接：需要对方主机在线，并建立链接</li>
<li>面向字节流：发送多少字节自己说了算，每次选出一段字节发送的时候，都会带上一个序号，这个序号就是发送的这段字节中编号最小的字节的编号。</li>
<li>可靠：保证数据有序的到达对方主机，每发送一个数据就会期待收到对方的回复，在指定时间内收到了ACK回复，就确认数据到达，如果超过一定的时间没有收到对方的回复，就认为对方没有收到，再重新发送一次。</li>
</ul>
<p>TCP报文</p>
<table>
<thead>
<tr>
<th>源端口（16）</th>
<th>目的端口（16）</th>
</tr>
</thead>
<tbody>
<tr>
<td>TCP序号（32）</td>
<td>TCP序号（32）</td>
</tr>
<tr>
<td>捎带的确认（32）</td>
<td>捎带的确认（32）</td>
</tr>
<tr>
<td>首部长度（4）保留（6）Flag（6：URG、ACK、PSH、RST、SYN、FIN）</td>
<td>窗口尺寸（16）</td>
</tr>
<tr>
<td>TCP校验和（16）</td>
<td>紧急指针（16）</td>
</tr>
<tr>
<td>数据包内容</td>
<td>数据包内容</td>
</tr>
</tbody>
</table>
<p>6个标志位：</p>
<ul>
<li>URG,紧急指针标志，当为1时表示紧急指针有效，为0时则忽略紧急指针</li>
<li>ACK,确认序号标志，为1表示确认有效，为0表示报文不含有确认信息，确认号无误</li>
<li>PSH,push标志，当为1时就是让接收方收到该TCP报文的时候不进入缓冲区排队而是快速发送给应用程序</li>
<li>RST,重置连接标志，当连接出现错误的时可以重置，或者用于拒绝非法的报文段和连接请求</li>
<li>SYN,同步序号，用于建立连接过程</li>
<li>FIN,finish标志，用于释放连接</li>
</ul>
<p>3次握手协议：</p>
<ol>
<li>第一次握手，当客户端需要去建立连接时，客户端就会发送SYN包（seq=x）到服务器，然后客户端进入SYN_SEND的状态，代表已经发SYN包过去，并且在等待服务器确认。此时，ACK=0,SYN=1。</li>
<li>第二次握手，服务器收到SYN包，会进行确认，由上面的标志知道SYN是表示同步序号，这时候会使得 确认号=序号+1，即ack等于x+1,然后服务器也会像客户端发送一个SYN包（seq=y),也就是服务器会发送SYN+ACK包，来表示确认到了客户端的一次握手并且二次握手建立，此时服务器进入SYN_RECV状态。此时，ACK=1,SYN=1。</li>
<li>第三次握手，客户端收到服务器的SYN+ACK包，然后就会向服务器发送确认包ACK(ack=y+1)和SYN(seq=x+1),等到这个包发送完毕之后客户端和服务器就会进入ESTABLISHED状态，完成三次握手，就可以在服务器与客户端之间传输数据了。</li>
</ol>
<p>SYN是同步序号，当SYN=1而ACK=0时表明这是一个连接请求报文，对方若同意连接，那应在报文中使SYN=1和ACK=1，因此SYN置1表示这是一个连接请求或者连接接受报文。而ACK状态是用来确认是否同意连接。也就是传了SYN,证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要ACK信号来验证</p>
<p>当在传送完数据之后，客户端与服务器端之间有四次握手协议：</p>
<ol>
<li>第一次握手：客户端发送一个FIN和序号过去（seq=u）用来表示客户端和服务端之间有关闭的请求，同时关闭客户端的数据传送，客户端就进入FIN_WAIT_1的状态</li>
<li>第二次握手：服务端收到FIN=1的标志位，就会发送一个ACK标志位表示确认，然后确认序号就变成了收到的序号+1,即ack=u+1(FIN和SYN在这点相同，但是作用不一样)这时候服务端进入CLOSE_WAIT状态，这是一个半关闭状态。只能服务端给客户端发送数据而客户端不能给服务端发送数据</li>
<li>第三次握手：这次握手还是服务端发起的。这是服务端在传完最后的数据（没有就不传）就会发送一个FIN=1和ACK=1,且序号seq会改变（没有传数据则不变），而ack不变，这时候服务端就会进入LAST_ACK状态，表示最后再确认一次。</li>
<li>第四次握手：客户端在接收到FIN之后，就会进入TIME_WAIT状态，接着发送一个ACK和seq=u+1,ack=w+1给服务端，这时候服务端就会进入CLOSED状态。而客户端进入TIME_WAIT状态的时候必须要等待2MSL的时间才会关闭</li>
</ol>
<p>TIME_WAIT状态的作用？（MSL：网络中数据报文存在的最大时间）</p>
<ol>
<li>TIME_WAIT状态可以确保有足够的时间让对方接收到ACK包，如果ACK没有到达，在传输过程丢失了或者一些其他原因，这样就可以让客户端重发ACK包，如果客户端直接关闭了，那么就有可能导致服务端在一些情况下没有接受到ACK包而无法与客户端断开连接。这样客户端发送ACK包到服务端，服务端请求重发，一来一回就刚好是2MSL</li>
<li>保证迟来的TCP报文段有足够的时间被识别并丢弃，linux中一个TCPort不能打开两次或者两次以上。当client处于time_wait状态时无法使用此port建立新连接，假设不存在time_wait状态，新连接可能会受到旧连接的数据</li>
</ol>
<h3 id="TCP粘包是什么-该怎么办"><a href="#TCP粘包是什么-该怎么办" class="headerlink" title="TCP粘包是什么,该怎么办"></a>TCP粘包是什么,该怎么办</h3><p>客户端（发送一端）在发送之前会将短时间有多个发送的数据块缓冲到一起（发送缓冲区），形成了一个大的数据块一并发送，同样接收端也有一个接收缓冲区，收到的数据先存放在接收端缓冲区，然后程序从这里读取部分数据进行消费，这样做也是为了减少I/O消耗达到性能优化。</p>
<p>数据达到缓冲区什么时间开发发送这个取决于TCP拥塞控制，是任何时刻内确定能被发送出去的字节数的控制因素之一，是阻止发送方至接收方之间的链路变得拥塞的手段</p>
<p>TCP粘包解决方案：</p>
<ol>
<li><p>延迟发送：设置延迟发送，sleep休眠一段时间。简单但是传输效率大大降低，只适用于交互频率低的情况</p>
</li>
<li><p>关闭nagle算法。nagle算法是一种改善网络传输效率的算法，避免网络中充斥着大量小的数据块，它所期望的是尽可能发送大的数据块，因此在每次请求一个数据块给TCP发送时，TCP并不会立即执行发送，而是等待一小段时间进行发送。</p>
<p>当网络中充斥着大量小的数据块时，Nagle算法能将小的数据块集合起来一起发送减少了网络拥堵，但并不是所有场景都需要这样。例如，REPL终端交互，当用户输入单个字符以获取响应，所以在nodejs中可以设置 socket.setNoDelay方法来关闭Nagle算法。<code>const server = net.createServer(); server.on(&#39;connection&#39;,socket=&gt;{socket.setNoDelay(true)})</code></p>
</li>
<li><p>封包/拆包。使用长度编码的方式，通信双方约定好格式，将消息分为定长的消息头（Header）和不定长的消息体（Body），在解析时读取消息头获取到内容的占用的长度，之后读取到的消息体内容字节数等于字节头的字节数时，认为它是一个完整的包。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>消息头序号（Header）</th>
<th>消息体长度（Header）</th>
<th>消息体（Body）</th>
</tr>
</thead>
<tbody>
<tr>
<td>SerialNumber</td>
<td>bodyLength</td>
<td>body</td>
</tr>
<tr>
<td>2字节</td>
<td>2字节</td>
<td>N字节</td>
</tr>
</tbody>
</table>
<p>Buffer的几个api：</p>
<ul>
<li>Buffer.alloc(size[,fill[,encoding]]),初始化一个size大小的Buffer空间，默认填充0，也可以指定fill进行自动以填充</li>
<li>Buffer.writeInt16BE(value[,offset]),value为要写入的Buffer值，offset为偏移量从哪个位置开始写入</li>
<li>Buffer.writeInt32BE(value[,offset]),value为要写入的Buffer值，不同的是writeInt16BE表示高位优先写入一个16位整型，这个是32位</li>
<li>Buffer.readInt16BE([offset])，高位优先读取16位整型，offset为读取之前要跳过的字节数</li>
<li>Buffer.readInt32BE([offset])，高位优先读取32位整型，offset为读取之前要跳过的字节数</li>
</ul>
<h4 id="编码-解码的实现"><a href="#编码-解码的实现" class="headerlink" title="编码/解码的实现"></a>编码/解码的实现</h4><p>TCP顶层是基于二进制数据，应用层通常是易于表达的字符串、数字等，需要先将数据通过Buffer转换为二进制，取出的时候同样需要解码操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transcoder.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transcoder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.packageHeaderLen = <span class="number">4</span>; <span class="comment">// 包头长度</span></span><br><span class="line">    <span class="keyword">this</span>.serialNumber = <span class="number">0</span>; <span class="comment">// 定义包序号</span></span><br><span class="line">    <span class="keyword">this</span>.packageSerialNumberLen = <span class="number">2</span>; <span class="comment">// 包序列号所占用的字节</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 编码</span></span><br><span class="line"><span class="comment">   * @param &#123;Object&#125; data Buffer 对象数据</span></span><br><span class="line"><span class="comment">   * @param &#123;Int&#125; serialNumber 包序号，客户端编码时自动生成，服务器解码之后在编码时需要传入解码的包序号</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  encode(data, serialNumber) &#123;</span><br><span class="line">    <span class="keyword">const</span> body = Buffer.from(data);</span><br><span class="line">    <span class="keyword">const</span> header = Buffer.alloc(<span class="keyword">this</span>.packageHeaderLen);</span><br><span class="line">    header.writeInt16BE(serialNumber || <span class="keyword">this</span>.serialNumber);</span><br><span class="line">    header.writeInt16BE(body.length, <span class="keyword">this</span>.packageSerialNumberLen); <span class="comment">// 跳过包序号的前两位</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (serialNumber === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.serialNumber++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Buffer.concat([header, body])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 解码</span></span><br><span class="line"><span class="comment">   * @param &#123;Object&#125; buffer</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  decode(buffer) &#123;</span><br><span class="line">    <span class="keyword">const</span> header = buffer.slice(<span class="number">0</span>, <span class="keyword">this</span>.packageHeader); <span class="comment">// 获取包头</span></span><br><span class="line">    <span class="keyword">const</span> body = buffer.slice(<span class="keyword">this</span>.packageHeaderLen); <span class="comment">// 获取包尾部</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      serialNumber: header.readInt16BE(),</span><br><span class="line">      bodyLength: header.readInt16BE(<span class="keyword">this</span>.packageSerialNumberLen), <span class="comment">// 因为编码阶段跳过两位，所以解码也需要跳过</span></span><br><span class="line">      body: body.toString(),</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取包长度两种情况</span></span><br><span class="line"><span class="comment">   * 1. 如果当前buffer长度数据小于包头，肯定不是一个完整的数据包，因此直接返回0不做处理（可能数据还没有接收完）</span></span><br><span class="line"><span class="comment">   * 2. 否则返回这个完整的数据包长度</span></span><br><span class="line"><span class="comment">   * @param &#123;*&#125; buffer</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  getPackageLength(buffer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer.length &lt; <span class="keyword">this</span>.packageHeaderLen) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.packageHeaderLen + buffer.readInt16BE(<span class="keyword">this</span>.packageSerialNumberLen)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Transcoder;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> Transcoder = <span class="built_in">require</span>(<span class="string">'./transcoder'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> transcoder = <span class="keyword">new</span> Transcoder();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> client = net.createConnection(&#123;</span><br><span class="line">  host: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">  port: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> overageBuffer = <span class="literal">null</span>; <span class="comment">//上一次Buffer剩下的数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client.on(<span class="string">'data'</span>, buffer =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (overageBuffer) &#123;</span><br><span class="line">    buffer = Buffer.concat([overageBuffer, buffer])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> packageLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// eslint-disable-next-line no-cond-assign</span></span><br><span class="line">  <span class="keyword">while</span> (packageLength = transcoder.getPackageLength(buffer)) &#123;</span><br><span class="line">    <span class="keyword">const</span> packageData = buffer.slice(<span class="number">0</span>, packageLength); <span class="comment">// 取出整个数据包</span></span><br><span class="line">    buffer = buffer.slice(packageLength); <span class="comment">// 删除已经取出的数据包，这里采用的方法是把缓冲区（buffer）已取出的包给截掉</span></span><br><span class="line">    <span class="keyword">const</span> result = transcoder.decode(packageData); <span class="comment">// 解码</span></span><br><span class="line">    <span class="built_in">console</span>.log(result)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  overageBuffer = buffer; <span class="comment">// 记录剩余不完整的包</span></span><br><span class="line">&#125;).on(<span class="string">'error'</span>, err =&gt; &#123; <span class="comment">// 监听一个未开启的端口就会报 ECONNREFUSED错误</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`服务器异常: <span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">&#125;).on(<span class="string">'close'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`客户链接断开！， <span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">client.write(transcoder.encode(<span class="string">'Nodejs 技术栈'</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  <span class="string">'1 JavaScript '</span>,</span><br><span class="line">  <span class="string">'2 TypeScript '</span>,</span><br><span class="line">  <span class="string">'3 Python '</span>,</span><br><span class="line">  <span class="string">'4 Java '</span>,</span><br><span class="line">  <span class="string">'5 C '</span>,</span><br><span class="line">  <span class="string">'6 PHP '</span>,</span><br><span class="line">  <span class="string">'7 ASP.NET '</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">    client.write(transcoder.encode(arr[i]))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>服务端</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">const</span> Transcoder = <span class="built_in">require</span>(<span class="string">'./transcoder'</span>);</span><br><span class="line"><span class="keyword">const</span> transcoder = <span class="keyword">new</span> Transcoder();</span><br><span class="line"><span class="keyword">const</span> HOST = <span class="string">'127.0.0.1'</span>;</span><br><span class="line"><span class="keyword">const</span> PORT = <span class="number">3000</span>;</span><br><span class="line"><span class="keyword">let</span> overageBuffer = <span class="literal">null</span>; <span class="comment">// 上一次善剩余数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个TCP服务实例</span></span><br><span class="line"><span class="keyword">const</span> server = net.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听端口</span></span><br><span class="line">server.listen(PORT, HOST)</span><br><span class="line"></span><br><span class="line">server.on(<span class="string">'listening'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`服务已经开启在<span class="subst">$&#123;HOST&#125;</span>:<span class="subst">$&#123;PORT&#125;</span>`</span>)</span><br><span class="line">&#125;).on(<span class="string">'connection'</span>, socket =&gt; &#123;</span><br><span class="line">  <span class="comment">// data事件就是读取数据</span></span><br><span class="line">  socket.on(<span class="string">'data'</span>, buffer =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (overageBuffer) &#123;</span><br><span class="line">      buffer = Buffer.concat([overageBuffer, buffer])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> packageLength = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// eslint-disable-next-line no-cond-assign</span></span><br><span class="line">    <span class="keyword">while</span> (packageLength = transcoder.getPackageLength(buffer)) &#123;</span><br><span class="line">      <span class="keyword">const</span> packageData = buffer.slice(<span class="number">0</span>, packageLength); <span class="comment">//取出整个数据包</span></span><br><span class="line">      buffer = buffer.slice(packageLength); <span class="comment">// 删除取出的数据包，这里采用的方法是把缓冲区buffer已取出的包截掉</span></span><br><span class="line">      <span class="keyword">const</span> result = transcoder.decode(packageData); <span class="comment">// 解码</span></span><br><span class="line">      <span class="built_in">console</span>.log(result);</span><br><span class="line">      socket.write(transcoder.encode(result.body, result.serialNumber))</span><br><span class="line">    &#125;</span><br><span class="line">    overageBuffer = buffer; <span class="comment">// 记录不完整的包  </span></span><br><span class="line">  &#125;).on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'socket end'</span>)</span><br><span class="line">  &#125;).on(<span class="string">'error'</span>, error =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'socket error'</span>, error)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).on(<span class="string">'close'</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Server Close!'</span>)</span><br><span class="line">&#125;).on(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err.code === <span class="string">'EADDRINUSE'</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'地址正被使用，重试中......'</span>)</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      server.close();</span><br><span class="line">      server.listen(PORT.HOST)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`服务器异常: <span class="subst">$&#123;err&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><p>DNS模块是基于UDP协议来实现的，在Nodejs中可以通过<code>require(&#39;dns&#39;)</code>实现域名的解析查询，Nodejs DNS模块分成两大类：</p>
<ol>
<li>底层操作系统工具进行域名解析</li>
<li>链接到一个DNS网络服务器执行域名解析</li>
</ol>
<h3 id="底层操作工具域名解析"><a href="#底层操作工具域名解析" class="headerlink" title="底层操作工具域名解析"></a>底层操作工具域名解析</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Nodejs DNS模块的 dns.lookup()方法使用底层操作系统进行域名解析，是不需要经过网络通信的</span></span><br><span class="line"><span class="keyword">const</span> dns = <span class="built_in">require</span>(<span class="string">'dns'</span>);</span><br><span class="line"></span><br><span class="line">dns.lookup(<span class="string">'laibh.top'</span>,(err,address,family)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`地址: <span class="subst">$&#123;address&#125;</span>,地址族：<span class="subst">$&#123;family&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="链接到DNS服务器执行域名解析"><a href="#链接到DNS服务器执行域名解析" class="headerlink" title="链接到DNS服务器执行域名解析"></a>链接到DNS服务器执行域名解析</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dns 模块除了 dns.lookup之外的函数，都会连接到实际DNS服务器以执行名称解析并始终使用网络执行DNS查询</span></span><br><span class="line"><span class="keyword">const</span> dns = <span class="built_in">require</span>(<span class="string">'dns'</span>);</span><br><span class="line">dns.lookup(<span class="string">'laibh.top'</span>,(err,records)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(records)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>dns.lookup与dns.resolve</code>不同</p>
<p>虽然用异步的角度来使用dns.lookup，但是内部的libuv底层线程池中确实同步的调用 getaddrinfo(3)，所以可能有由于一些不确定的因素造成Node进程阻塞</p>
<p>与dns.lookup不同的是dns.resolve没有使用getaddrinfo(3)，而通过网络执行的DNS查询，始终保持异步不会对其他进程产生负面影响</p>
<h3 id="DNS域名解析过程"><a href="#DNS域名解析过程" class="headerlink" title="DNS域名解析过程"></a>DNS域名解析过程</h3><ol>
<li>浏览器DNS缓存。访问一个URL优先查找浏览器的DNS缓存，命中就返回。未命中就继续下一步，查找操作系统的缓存。当修改了本地hosts域名指向发现浏览器缓存没有变化是因为每个浏览器有一个固定值。</li>
<li>系统（OS）缓存。查看操作系统中是否有域名对应的IP,位于操作系统的hosts文件。</li>
<li>路由器缓存。当浏览器DNS与系统OS缓存均没有映射的时候，则请求会发送到路由器缓存中检查</li>
<li>ISP DNS缓存。ISP为互联网服务提供商。</li>
</ol>
<p>DNS本地解析指的是系统缓存这一阶段，在浏览器缓存没有命中的情况下， 会从本地系统的一个hosts文件中寻找对应的IP</p>
<h2 id="Cluster-（集群）"><a href="#Cluster-（集群）" class="headerlink" title="Cluster （集群）"></a>Cluster （集群）</h2><p>在PM2的配置文件中可以设置<code>exec_model:&#39;cluster</code>和<code>instance</code>两个属性来设置开启多个进程，PM2其实就是利用Nodejs Cluster这个模块来实现的，还有eggJs中的egg-cluster模块在启用Worker进程也是用到这个模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> numCPUs = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus().length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (cluster.isMaster) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Master 进程 <span class="subst">$&#123;process.pid&#125;</span> 正在运行`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numCPUs; i++) &#123;</span><br><span class="line">    cluster.fork();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  cluster.on(<span class="string">'exit'</span>, (worker, code, signal) =&gt; &#123; <span class="built_in">console</span>.log(<span class="string">`Worker <span class="subst">$&#123;worker.process.pid&#125;</span> 已退出`</span>) &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">`你好，哈哈哈 <span class="subst">$&#123;process.pid&#125;</span>`</span>)</span><br><span class="line">  &#125;).listen(<span class="number">8000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Worker 进程 <span class="subst">$&#123;process.pid&#125;</span> 已启用`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="采用了哪种集群方式"><a href="#采用了哪种集群方式" class="headerlink" title="采用了哪种集群方式"></a>采用了哪种集群方式</h3><p>集群模式通常实现有两种：</p>
<ol>
<li>1个Node实例开启多个端口，通过反向代理服务器向各端口服务进行转发</li>
<li>1个Node实例开启多个进程监听同一个端口，通过负载均衡技术分配请求（Master-&gt;Worker）</li>
</ol>
<p>第一个方案存在的一个问题就是占用多个端口，造成资源浪费，由于多个实例是独立运行的，进程间通信不太好做。好处是稳定性高，各实例之间没有影响。</p>
<p>第二个方案多个Node进程去监听同一个端口，好处是进程间通信相对简单，减少了端口的资源浪费，但是这个时候需要保证服务进程的稳定性，特别是对Master进程稳定性要求会更高，编码也会复杂。</p>
<p>Nodejs中自带的Cluster模块正是采用了第二种方案。</p>
<h3 id="多个进程为什么可以监听同一个端口"><a href="#多个进程为什么可以监听同一个端口" class="headerlink" title="多个进程为什么可以监听同一个端口"></a>多个进程为什么可以监听同一个端口</h3><p>端口不是被所有的进程全部监听，仅仅受到Master进程的监听。Master进程创建一个Socket并绑定监听到目标端口，通过子进程之间建立IPC通道之后，通过调用子进程的send方法，将Socket（链接句柄）传递过去。（Master通过cluster.fork方法创建的，本质上还是使用了child_process.fork这个方法）</p>
<p>使用 child_process.fork()创建的子进程，进行Socket传递的示例</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// master.js</span></span><br><span class="line"><span class="keyword">const</span> fork = <span class="built_in">require</span>(<span class="string">'child_process'</span>).fork;</span><br><span class="line"><span class="keyword">const</span> cpus = <span class="built_in">require</span>(<span class="string">'os'</span>).cpus();</span><br><span class="line"><span class="keyword">const</span> server = <span class="built_in">require</span>(<span class="string">'net'</span>).createServer().listen(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;cpus.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> worker = fork(<span class="string">'worker.js'</span>);</span><br><span class="line">      <span class="comment">// 将 Master 的 server 传递给子进程</span></span><br><span class="line">    worker.send(<span class="string">'server'</span>, server);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'worker process created, pid: %s ppid: %s'</span>, worker.pid, process.pid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// worker.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.end(<span class="string">'I am worker, pid: '</span> + process.pid + <span class="string">', ppid: '</span> + process.ppid);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> worker;</span><br><span class="line"><span class="comment">// 第二个参数 sendHandle 就是句柄，可以是 TCP套接字、TCP服务器、UDP套接字等</span></span><br><span class="line">process.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">message, sendHandle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (message === <span class="string">'server'</span>) &#123;</span><br><span class="line">        worker = sendHandle;</span><br><span class="line">        worker.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">socket</span>) </span>&#123;</span><br><span class="line">            server.emit(<span class="string">'connection'</span>, socket);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>端口会被主进程绑定监听一次，但是主进程和子进程在建立IPC通信之后，发送Socket到子进程实现端口共享，在之后Master接受到新的客户端链接后，通过负载均衡技术再转发到各Worker进程。</p>
<h3 id="多个进程之间如何通信"><a href="#多个进程之间如何通信" class="headerlink" title="多个进程之间如何通信"></a>多个进程之间如何通信</h3><p>由于cluster.fork本质上还是使用child_process.fork()这个方法来创建子进程，进程间通信无非几种：pipe（管道）、消息队列、信号量、Domain Socket。Nodejs中是通过pipe(管道)实现的，pipe作用于之间有血缘关系的进程，通过fork传递，其本身也是一个进程，将一个进程的输出作为另外一个进程的输入。</p>
<h3 id="如何对多个Worker进行请求转发"><a href="#如何对多个Worker进行请求转发" class="headerlink" title="如何对多个Worker进行请求转发"></a>如何对多个Worker进行请求转发</h3><p>在Nodejs中使用了RoundRobin负载均衡策略，简称RP,它的实现原理是一种无状态的轮询策略，假定每台服务器的硬件资源、处理性能都是相同的，根据进程的数量，依次分配，直到所有进程处理完了，再开始重新计算分配。优点是实现起来简洁也易用，缺点是如果出现某个请求占用的时间较长，就会导致负载不会太均衡。</p>
<p>RP这种负载均衡技术适用于同一组服务器拥有相同的软硬件配置且平均的服务请求响应</p>
<p>RP是一种常见的复杂均衡技术，Nginx中也有使用，另外在RP的基础上还衍生了一个Weighted Round-Robin权重负载均衡轮询算法，简称WRR,同样也是使用轮询的技术，但是在基础上考虑了服务器的处理能力，实现时为服务器加上权重，这种负载均衡算法能够确保高性能的服务器得到更多的使用率，避免低性能的服务器负载过重。</p>
<h3 id="Nodejs负载均衡策略设置"><a href="#Nodejs负载均衡策略设置" class="headerlink" title="Nodejs负载均衡策略设置"></a>Nodejs负载均衡策略设置</h3><ul>
<li>RoundRobin,RR。设置时要使用cluster.SCHED_RR,如果通过环境变量设置要使用rr,如果用cluster对象获取 schedulingPolicy数字表示为2</li>
<li>Shared Socket，SS,设置时要用cluster.SCHED_NONE，如果通过环境变量设置要用node,如果用cluster对象获取schedulingPolicy数字表示为1</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cluster对象的schedulingPolicy属性设置</span></span><br><span class="line"><span class="keyword">const</span> cluster = <span class="built_in">require</span>(<span class="string">'cluster'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略一：一种轮询的策略，默认值</span></span><br><span class="line">cluster.schedulingPolicy = cluster.SHCED_RR;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略二:由操作系统调度的策略</span></span><br><span class="line">cluster.schedulingPolicy = cluster.SCHED_NONE;</span><br><span class="line"></span><br><span class="line">cluster.fork();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者通过环境变量 NODE_CLUSTER_SCHED_POLICY设置：</span></span><br><span class="line">env NODE_CLUSTER_SCHED_POLICY = <span class="string">'none'</span> node app.js</span><br></pre></td></tr></table></figure>
<h2 id="基于Stream实现多文件合并"><a href="#基于Stream实现多文件合并" class="headerlink" title="基于Stream实现多文件合并"></a>基于Stream实现多文件合并</h2><h3 id="一个简单的Stream操作"><a href="#一个简单的Stream操作" class="headerlink" title="一个简单的Stream操作"></a>一个简单的Stream操作</h3><p>创建一个可读流readable一个可写流writeable，通过管道pipe将可写流绑到可读流，一个简单的Stream操作就可以完成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> readable = fs.createReadStream(<span class="string">'./log/read.txt'</span>);</span><br><span class="line"><span class="keyword">const</span> writeable = fs.createWriteStream(<span class="string">'./log/write.txt'</span>);</span><br><span class="line"></span><br><span class="line">readable.pipe(writeable)</span><br><span class="line"></span><br><span class="line"><span class="comment">// readable.pip(destionation[,option])</span></span><br><span class="line"><span class="comment">// destionation：是一个可写流对象，也就是一个数据写入的目标对象</span></span><br><span class="line"><span class="comment">// options:end,读取结束时终止写入流，默认值是true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认情况下不需要手动调用写入流的end方法关闭的，更改end为false写入的目标将会处于一直打开状态，此时就需要监听可读流的end时间，结束之后手动调用可写流的end事件。</span></span><br><span class="line"></span><br><span class="line">readable.pipe(writeable,&#123;</span><br><span class="line">    end:<span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readable.on(<span class="string">'end'</span>,()=&gt;&#123;</span><br><span class="line">    writeable.end(<span class="string">'结束'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>如果可读流期间发什么什么错误，则写入的目标流将不会关闭，所以需要监听错误事件，手动关闭可写流，防止内存泄露。</p>
<h3 id="多个文件通过Stream合并成一个文件"><a href="#多个文件通过Stream合并成一个文件" class="headerlink" title="多个文件通过Stream合并成一个文件"></a>多个文件通过Stream合并成一个文件</h3><p>设置可读流的end为false可以保持写入流一直处于打开状态，通过这种方式，一开始可写流处于打开状态，知道所有的可读流结束，我们再将可写流关闭。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stream 合并</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; sourceFiles 源文件目录名</span></span><br><span class="line"><span class="comment"> * @param &#123;String&#125; targetFile 目标文件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">streamMerge</span>(<span class="params">sourceFiles, targetFile</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> scripts = fs.readdirSync(path.resolve(__dirname, sourceFiles)); <span class="comment">// 获取源文件目录下的所有文件</span></span><br><span class="line">  <span class="keyword">const</span> fileWriteStream = fs.createWriteStream(path.resolve(__dirname, targetFile)); <span class="comment">// 创建一个可写流</span></span><br><span class="line">  streamMergeRecursive(scripts, fileWriteStream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Stream 合并的递归调用</span></span><br><span class="line"><span class="comment"> * @param &#123;Array&#125; scripts</span></span><br><span class="line"><span class="comment"> * @param &#123;Stream&#125; fileWriteStream</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">streamMergeRecursive</span>(<span class="params">scripts = [], fileWriteStream</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 递归到尾 的情况判断</span></span><br><span class="line">  <span class="keyword">if</span> (!scripts.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> fileWriteStream.end(<span class="string">"console.log('Stream 合并完成')"</span>) <span class="comment">// 最后关闭可写流，防止内存泄露</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> currentFile = path.resolve(__dirname, <span class="string">'scripts/'</span>, scripts.shift());</span><br><span class="line">  <span class="keyword">const</span> currentReadStream = fs.createReadStream(currentFile); <span class="comment">// 获取当前的可读流</span></span><br><span class="line"></span><br><span class="line">  currentReadStream.pipe(fileWriteStream, &#123; <span class="attr">end</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  currentReadStream.on(<span class="string">'end'</span>, () =&gt; &#123;</span><br><span class="line">    streamMergeRecursive(scripts, fileWriteStream)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  currentReadStream.on(<span class="string">'error'</span>, (error) =&gt; &#123; <span class="comment">// 监听错误事件，关闭可读流，防止内存泄露</span></span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">    fileWriteStream.close()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">streamMerge(<span class="string">'./scripts'</span>, <span class="string">'./script.js'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="Stream-pipe的使用与实现原理"><a href="#Stream-pipe的使用与实现原理" class="headerlink" title="Stream pipe的使用与实现原理"></a>Stream pipe的使用与实现原理</h2><p>通过流我们可以将一大块数据拆分称为一小部分一点一点的流动起来，不需要一次性全部读入，在Linux下可以通过<code>|</code>符号实现，类似的在Nodejs的Stream模块中同样也为我们提供了 pipe方法来实现</p>
<h3 id="未使用Stream-pipe的情况"><a href="#未使用Stream-pipe的情况" class="headerlink" title="未使用Stream pipe的情况"></a>未使用Stream pipe的情况</h3><p>在Nodejs中I/O操作都是异步的，先用util模块的promiseify方法将fs.readFile的callback形式转换为Promise形式</p>
<p>，它将数据一次性读入内存然后再进行返回，当数据文件很大的时候也是对内存的一种消耗，不推荐</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// koa 的例子</span></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="keyword">const</span> &#123;promisify&#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123;resolve&#125; = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> readFile = promisify(fs.readFile);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> ctx=&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        ctx.body = <span class="keyword">await</span> readFile(resolve(__dirname,<span class="string">'test.json'</span>)))</span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        ctx.body = err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).listen(<span class="number">3000</span>)</span><br></pre></td></tr></table></figure>
<h3 id="使用Steam-pipe"><a href="#使用Steam-pipe" class="headerlink" title="使用Steam pipe"></a>使用Steam pipe</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="keyword">async</span> ctx=&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> readable = fs.createReadStream(resolve(__dirname,<span class="string">'test.json'</span>));</span><br><span class="line">        ctx.body = readable;       </span><br><span class="line">    &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">        ctx.body = err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 在Koa中直接创建一个可读流赋值给ctx.body，框架内封装好了pipe方法，下面为源码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">respond</span>(<span class="params">ctx</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> body = ctx.body;</span><br><span class="line">    <span class="keyword">if</span>(body <span class="keyword">instanceof</span> Stream) <span class="keyword">return</span> body.pipe(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用与不使用Stream"><a href="#使用与不使用Stream" class="headerlink" title="使用与不使用Stream"></a>使用与不使用Stream</h3><p>使用了可读流，通过pipe接口监听data与end事件，把data的可读流拆分称为一小块一小块的数据（chunks），像流水一样源源不断吐给客户端，而不再需要等待整个文件都加载到内存后才发送数据。pipe可以视为流的管道/通道方法，任何类型的流都会有这个方法来处理流的输入与输出。</p>
<p>总体来说，使用流可以大大提升响应时间，又能有效减轻服务器内存的压力</p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>在应用层调用 fs.createReadStream 方法，找到这个方法创建的可读流对象pipe的方法实现</p>
<h4 id="lib-fs-js"><a href="#lib-fs-js" class="headerlink" title="/lib/fs.js"></a>/lib/fs.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出一个createReadStream方法，在这个方法里面创建一个ReadSream可读流对象，且ReadStream来自internal/fs/streams</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 懒加载，主要在用到的时候用来实例化 ReadStream/WriteStream等对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyLoadStreams</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!ReadStream)&#123;</span><br><span class="line">        (&#123;ReadStream,WriteStream&#125;) = <span class="built_in">require</span>(<span class="string">'internal/fs/streams'</span>);</span><br><span class="line">        [FileReadStream,FileWriteStream] = [ReadStream,WriteStream];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createReadStream</span>(<span class="params">path,options</span>)</span>&#123;</span><br><span class="line">   lazyLoadStreams();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReadStream(path,options); <span class="comment">// 创建一个可读流</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = fs = &#123;</span><br><span class="line">    createReadStream, <span class="comment">// 导出 createReadStream 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lib-internal-fs-streams-js"><a href="#lib-internal-fs-streams-js" class="headerlink" title="/lib/internal/fs/streams.js"></a>/lib/internal/fs/streams.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个方法定义了构造函数 ReadStream，且在原型上定义了 open、_read、_destroy等方法，没有pipe方法，通过ObjectSetPrototypeOf方法实现了继承，ReadStream继承了Readable在原型中定义的函数，继续查找Readable的实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;Readable,Writeable&#125; = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ReadStream</span>(<span class="params">path,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> ReadStream)) <span class="keyword">return</span> <span class="keyword">new</span> ReadStream(path,options)</span><br><span class="line">    </span><br><span class="line">    Readable.call(<span class="keyword">this</span>,options)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjectSetPrototypeOf(ReadStream.prototype,Readable.prototype);</span><br><span class="line">ObjectStreamProtptypeOf(ReadStream,Readable);</span><br><span class="line"></span><br><span class="line">ReadStream.prototype.open = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">ReadStream.prototype._read = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123;&#125;</span><br><span class="line">ReadStream.prototype._destroy = <span class="function"><span class="keyword">function</span>(<span class="params">err,cb</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">module</span>.<span class="title">exports</span> = </span>&#123;</span><br><span class="line">    ReadStream,</span><br><span class="line">    WriteStream</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="lib-stream-js"><a href="#lib-stream-js" class="headerlink" title="/lib/stream.js"></a>/lib/stream.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// to avoid cross-reference(require) issue</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Stream = <span class="built_in">module</span>.exports = <span class="built_in">require</span>(<span class="string">'internal/streams/legacy'</span>);</span><br><span class="line"></span><br><span class="line">Stream.Readable = <span class="built_in">require</span>(<span class="string">'_stream_readable'</span>);</span><br><span class="line">Stream.Writable = <span class="built_in">require</span>(<span class="string">'_stream_writable'</span>)</span><br><span class="line">Stream.Duplex = <span class="built_in">require</span>(<span class="string">'_stream_duplex'</span>);</span><br><span class="line">Stream.Transform = requier(<span class="string">'_stream_transform'</span>);</span><br><span class="line">Stream.PassThrough = <span class="built_in">require</span>(<span class="string">'_stream_passthrough'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="lib-internal-streams-legacy-js"><a href="#lib-internal-streams-legacy-js" class="headerlink" title="/lib/internal/streams/legacy.js"></a>/lib/internal/streams/legacy.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承了Events 模块，然后在原型上定义了pipe方法，而_stream_readable继承了Stream之后又自己实现了pipe方法</span></span><br><span class="line"><span class="keyword">const</span> &#123;ObjectSetPrototypeOf&#125; = primordials;</span><br><span class="line"><span class="keyword">const</span> EE = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stream</span>(<span class="params">opts</span>)</span>&#123;</span><br><span class="line">   	EE.call(<span class="keyword">this</span>,opts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ObjectSetPrototypeOf(Stream.prototype,EE.prototype);</span><br><span class="line">ObjectSetPrototypeOf(Stream,EE);</span><br><span class="line"></span><br><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = Stream;</span><br></pre></td></tr></table></figure>
<h4 id="lib-stream-readable-js"><a href="#lib-stream-readable-js" class="headerlink" title="/lib/_stream_readable.js"></a>/lib/_stream_readable.js</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了Readable构造函数，且继承于lib/stream.js的Stream，然后重写pipe方法</span></span><br><span class="line"><span class="built_in">module</span>.exports = Readable;</span><br><span class="line">Readable.ReadableState = ReadableState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EE = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="keyword">const</span> Stream = <span class="built_in">require</span>(<span class="string">'stream'</span>);</span><br><span class="line"></span><br><span class="line">ObjectSetPrototypeOf(Readable.prototype,Stream.prototype)</span><br><span class="line">ObjectSetPrototypeOf(Readable,Stream);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Readable</span>(<span class="params">options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Readable)) <span class="keyword">return</span> <span class="keyword">new</span> Readable(options)</span><br><span class="line">    </span><br><span class="line">    Stream.call(<span class="keyword">this</span>,options); <span class="comment">// 继承自 Stream构造函数的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="stream-readable-js实现分析"><a href="#stream-readable-js实现分析" class="headerlink" title="_stream_readable.js实现分析"></a>_stream_readable.js实现分析</h5><p>1.声明构造函数Readable，继承Stream的构造函数和原型。</p>
<p>文件继承了events事件，拥有了events在原型中定义的属性，例如on、emit</p>
<p>2.声明pipe方法，订阅data事件</p>
<p>在Stream原型上声明pipe方法，订阅data事件，src为可读对象，dest为可写流对象。在使用pipe方法的时候也是监听的data事件，一边读取一边写入数据。</p>
<p>ondata方法的几个核心的实现：</p>
<ul>
<li>dest.write(chunk):接受chunk写入数据，如果内部的缓冲小于创建流时配置的highWaterMark，则返回true（缓存未满）,否则返回false时应该停止向流写入数据，直到‘drain’（清空缓存）事件被触发</li>
<li>src.pause()：可读流会停止data事件，意味着此时暂停数据写入了</li>
</ul>
<p>调用src.pause是为了防止读入数据过快来不及写入，如果缓存未满即dest.write(chunk)，这个缓存是根据创建流时创建的highWaterMark属性，默认为16384（16k），对象模式的流默认为16</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> src = <span class="keyword">this</span>;</span><br><span class="line">    src.on(<span class="string">'data'</span>,ondata);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ondata</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> ret = dest.write(chunk);</span><br><span class="line">        <span class="keyword">if</span>(ret === <span class="literal">false</span>)&#123;</span><br><span class="line">            ...</span><br><span class="line">            src.pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.订阅drain事件，继续流动数据。继续写入事件到流时会触发drain事件，也就是dest.write(chunk)等于false(缓存满了)时，如果ondrain不存在则注册drain事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> src = <span class="keyword">this</span>;</span><br><span class="line">    src.on(<span class="string">'data'</span>,ondata);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ondata</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> ret = dest.write(chunk);</span><br><span class="line">        <span class="keyword">if</span>(ret === <span class="literal">false</span>)&#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">if</span>(!ondrain)&#123;</span><br><span class="line">        		<span class="comment">// When the dest drains, it reduces the awaitDrain counter</span></span><br><span class="line">        		<span class="comment">// on the source.  This would be more elegant with a .once()</span></span><br><span class="line">        		<span class="comment">// handler in flow(), but adding and removing repeatedly is</span></span><br><span class="line">        		<span class="comment">// too slow.    </span></span><br><span class="line">                ondrain = pipeOnDrain(src);</span><br><span class="line">                dest.on(<span class="string">'drain'</span>,ondrain);</span><br><span class="line">            &#125;</span><br><span class="line">            src.pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当写入流dest耗尽时，它将会在可读流对象 source上减少 awaitDrain计数器，为了确保所有需要缓存的写入都完成，即state.awaitDrain === 0和src可读流上的data事件存在，切换流到流动模式</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">pipeOnDrain</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">pipeDrainFunctionResult</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">const</span> state = src._readableState;</span><br><span class="line">            debug(<span class="string">'pipeOnDrain'</span>,state.awaitDrain);</span><br><span class="line">            <span class="keyword">if</span>(state.awaitDrain)&#123;</span><br><span class="line">                state.awaitDrain--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(state.awaitDrain ===<span class="number">0</span> &amp;&amp; EE.listenerCount(src,<span class="string">'data'</span>))&#123;</span><br><span class="line">                state.flowing = <span class="literal">true</span>;</span><br><span class="line">                flow(src)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Stream.read() 从内部缓存拉取并返回数据，如果没有可读的数据，则返回null，在可读流上src还有一个readable属性，如果可以安全地调用readable,read(),则为true</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">slow</span>(<span class="params">stream</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> state = stream._readableState;</span><br><span class="line">        debug(<span class="string">'flow'</span>,state.flowing);</span><br><span class="line">        <span class="keyword">while</span>(state.flowing &amp;&amp; stream.read() !== <span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.触发data事件。调用readable的resume方法，触发可读流的data事件，进入流动模式</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> src = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// start the flow if it hasnot been started already.</span></span><br><span class="line">    <span class="keyword">if</span>(!state.flowing)&#123;</span><br><span class="line">        debug(<span class="string">'pipe resume'</span>)</span><br><span class="line">        src.resume();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>resume方法内部又调用resume_()，最终执行了stream.read(0)读取了一次空数据（size设置为0），将会触发实例上的_read()方法，再触发data事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resume</span>(<span class="params">stream,state</span>)</span>&#123;</span><br><span class="line">    process.nextTick(resume_,stream,state)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resume_</span>(<span class="params">stream,state</span>)</span>&#123;</span><br><span class="line">    debug(<span class="string">'resume'</span>,state.reading);</span><br><span class="line">    <span class="keyword">if</span>(!state.reading)&#123;</span><br><span class="line">        stream.read(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.订阅end事件</p>
<p>end事件：当可读流中没有数据可供消费时触发，调用onend函数，执行dest.end()方法，表明已没有数据要被写入可写流，进行关闭（关闭可写流的id）,之后再调用stream.write会导致错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> doEnd = (!pipeOpts || pipeOpts.end !== <span class="literal">false</span>) &amp;&amp; dest !== process.stdout &amp;&amp;</span><br><span class="line">          dest !== process.stderr;</span><br><span class="line">    <span class="keyword">const</span> endFn = doEnd?onend:unpipe;</span><br><span class="line">    <span class="keyword">if</span>(state.endEmitted)&#123;</span><br><span class="line">        process.nestTick(endFn)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        src.once(<span class="string">'end'</span>,endFn)</span><br><span class="line">    &#125;</span><br><span class="line">    dest.on(<span class="string">'unpipe'</span>,onunpipe)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onend</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        debug(<span class="string">'onend'</span>);</span><br><span class="line">        dest.end();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.触发pipe事件，传入可读流对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Readable.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> source = <span class="keyword">this</span>;</span><br><span class="line">    dest.emit(<span class="string">'pipe'</span>,src);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在应用层使用但的时候可以在可写流上订阅pipe事件，做一些判断。</p>
<p>7.支持链式调用，最后返回dest</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.protptype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="lib-internal-streams-legacy-js模块实现分析"><a href="#lib-internal-streams-legacy-js模块实现分析" class="headerlink" title="/lib/internal/streams/legacy.js模块实现分析"></a>/lib/internal/streams/legacy.js模块实现分析</h2><h3 id="声明构造函数Stream"><a href="#声明构造函数Stream" class="headerlink" title="声明构造函数Stream"></a>声明构造函数Stream</h3><p>声明构造函数Stream继承于事件events,此时就拥有了events在原型定义的属性，例如on/emit等方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;ObjectSetPrototypeOf&#125; = primordials;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> EE = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stream</span>(<span class="params">opts</span>)</span>&#123;</span><br><span class="line">    EE.call(<span class="keyword">this</span>,opts)</span><br><span class="line">&#125;</span><br><span class="line">ObjectSetPrototypeOf(Stream.prototype,EE.prototype);</span><br><span class="line">ObjectSetPrototypeOf(Stream,EE)</span><br></pre></td></tr></table></figure>
<h3 id="声明pipe方法，订阅data事件"><a href="#声明pipe方法，订阅data事件" class="headerlink" title="声明pipe方法，订阅data事件"></a>声明pipe方法，订阅data事件</h3><p>在Stream原型上声明pipe方法，订阅data事件，source为可读流对象，dest为可写流对象</p>
<p>在使用pipe方法的时候也是监听的data事件，一边读取数据一边写入数据</p>
<p>ondata方法的几个API：</p>
<ul>
<li>dest.writable：如果调用writable.write()是安全的，则为true</li>
<li>dest.write(chunk)：接收chunk写入数据，如果内部的缓冲小于内部创建流时配置的highWaterMark，则返回true,否则返回false时应该停止向流写入数据，知道drain事件被触发。</li>
<li>source.pause()：可读流会停止data事件，意味着此时暂停数据写入了</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> source = <span class="keyword">this</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ondata</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dest.writable &amp;&amp; dest.write(chunk) === <span class="literal">false</span> &amp;&amp; source.pause)&#123;</span><br><span class="line">            source.pause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    source.on(<span class="string">'data'</span>,ondata)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="订阅drain事件"><a href="#订阅drain事件" class="headerlink" title="订阅drain事件"></a>订阅drain事件</h3><p>如果调用dest.write(chunk)返回false,就会调用source.pause()停止数据流动，继续写入事件到流时会触发drain事件，ondrain方法的几个API：</p>
<ul>
<li>source.readable：如果可以安全地调用readable.read()，则为true,例如数据未读到末尾，则会返回true，表示可读的。</li>
<li>source.resume()：将被暂停的可读流恢复触发data事件，并将流切换流动模式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ondrain</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(source.readable &amp;&amp; source.resume)&#123;</span><br><span class="line">            source.resume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    dest.on(<span class="string">'drain'</span>,ondrain)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选项指定end属性，订阅end-close事件"><a href="#选项指定end属性，订阅end-close事件" class="headerlink" title="选项指定end属性，订阅end,close事件"></a>选项指定end属性，订阅end,close事件</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果end选项没有被提供，可读流订阅end或者close事件，后续将会触发该事件，指定dest.end方法，仅被调用一次，didOnEnd变量做了控制，主要是为了关闭可写流的id</span></span><br><span class="line"><span class="comment">// close:当流或者底层资源（比如文件描述符）被关闭时触发close事件</span></span><br><span class="line"><span class="comment">// end: 当可读流中没有数据可供消费的时候触发</span></span><br><span class="line"><span class="comment">// 可读流的end,destroy方法</span></span><br><span class="line"><span class="comment">// dest.end() 表明已经没有数据要被写入可写流，进行关闭，之后再调用stream.write会导致错误</span></span><br><span class="line"><span class="comment">// dest.destory() 销毁流</span></span><br><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!dest._isStdio &amp;&amp; (!options || options.end !== <span class="literal">false</span>))&#123;</span><br><span class="line">        source.on(<span class="string">'end'</span>,onend);</span><br><span class="line">        source.on(<span class="string">'close'</span>,onclose);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> didOnEnd = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onend</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(didOnEnd) <span class="keyword">return</span>;</span><br><span class="line">        didOnEnd = <span class="literal">true</span>;</span><br><span class="line">        dest.end();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onclose</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(didOnEnd) <span class="keyword">return</span>;</span><br><span class="line">        didOnEnd = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> dest.destory === <span class="string">'function'</span>)&#123;</span><br><span class="line">            dest.destroy();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="订阅可读流与可写流的error事件"><a href="#订阅可读流与可写流的error事件" class="headerlink" title="订阅可读流与可写流的error事件"></a>订阅可读流与可写流的error事件</h3><p>可读流、可写流发生错误时触发error事件，调用onerror方法，首先移除可读流，可写流订阅的所有事件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onerror</span>(<span class="params">er</span>)</span>&#123;</span><br><span class="line">        cleanup();</span><br><span class="line">        <span class="keyword">if</span>(EE.listenerCount(<span class="keyword">this</span>,<span class="string">'error'</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> er;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    source.on(<span class="string">'error'</span>,onerror);</span><br><span class="line">    dest.on(<span class="string">'error'</span>,onerror);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        source.removeListener(<span class="string">'data'</span>,ondata);</span><br><span class="line">        dest.removeListener(<span class="string">'drain'</span>,ondrain);</span><br><span class="line">        </span><br><span class="line">        source.removeListener(<span class="string">'end'</span>,onend);</span><br><span class="line">        source.removelistener(<span class="string">'close'</span>,onclose);</span><br><span class="line">        </span><br><span class="line">        source.removeListener(<span class="string">'error'</span>,onerror);</span><br><span class="line">        dest.removelistener(<span class="string">'error'</span>,onerror);</span><br><span class="line">        </span><br><span class="line">        source.removeListener(<span class="string">'end'</span>,cleanup);</span><br><span class="line">        source.removelistener(<span class="string">'close'</span>,cleanup);     </span><br><span class="line">        </span><br><span class="line">        dest.removelistener(<span class="string">'close'</span>,cleanup);        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="触发pipe事件"><a href="#触发pipe事件" class="headerlink" title="触发pipe事件"></a>触发pipe事件</h3><p>在pipe方法里面最后还会触发一个pipe事件，传入可读流对象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> source = <span class="keyword">this</span>;</span><br><span class="line">    dest.emit(<span class="string">'pipe'</span>,source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="支持链式调用"><a href="#支持链式调用" class="headerlink" title="支持链式调用"></a>支持链式调用</h3><p>最后返回dest,支持<code>A.pipe(B).pipe(c)</code>的写法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream.prototype.pipe = <span class="function"><span class="keyword">function</span>(<span class="params">dest,options</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="util-promisify如何将Callback转换为Promise"><a href="#util-promisify如何将Callback转换为Promise" class="headerlink" title="util.promisify如何将Callback转换为Promise"></a>util.promisify如何将Callback转换为Promise</h2><p>util模块提供了很多工具函数，其中promisify方法可以将callback转换为Promise对象，解决回调地狱的问题。</p>
<h3 id="简单实现版本"><a href="#简单实现版本" class="headerlink" title="简单实现版本"></a>简单实现版本</h3><h4 id="util-promisify基本使用"><a href="#util-promisify基本使用" class="headerlink" title="util promisify基本使用"></a>util promisify基本使用</h4><p>将callback转为promise对象，首先确保这个callback为一个错误优先的回调函数，即<code>(err,value)=&gt;err</code>指定一个错误参数，value为返回值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个text.txt文件，写入一些自定义内容，使用fs.readFile来读取这个文件进行测试</span></span><br><span class="line"><span class="comment">// 传统的Callback写法</span></span><br><span class="line"><span class="keyword">const</span> util = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line">fs.readFile(<span class="string">'text.txt'</span>,<span class="string">'utf8'</span>,(err,result)=&gt;&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Error'</span>,err);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Result: '</span>,result)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise写法</span></span><br><span class="line"><span class="keyword">const</span> &#123;promisify&#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> readFilePromisify = util.promisify(fs.readFile); <span class="comment">// 转换为Promise</span></span><br><span class="line"></span><br><span class="line">readFilePromisify(<span class="string">'text.txt'</span>,<span class="string">'utf8'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span>=&gt;</span><span class="built_in">console</span>.log(result))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure>
<p>自定义mayJunPromisify函数实现</p>
<p>自定义mayJunPromisify函数实现callback转换为promise，核心实现如下：</p>
<ul>
<li>校验传入的参数original是否为Function,不是则抛错</li>
<li>promisify(fs.readFile)执行之后会返回一个函数fn,定义待返回的函数后返回</li>
<li>fn返回的是一个Promise对象，在返回的Promise对象中执行callback函数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mayJunPromisify</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> original !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The "original" argument must be of type Function,Received type undefined'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                original.call(<span class="keyword">this</span>,...args,(err,result)=&gt;&#123;</span><br><span class="line">                    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                        reject(err)</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        resolve(result)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">                resolve(result)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="util-promisify-custom基本使用"><a href="#util-promisify-custom基本使用" class="headerlink" title="util.promisify.custom基本使用"></a>util.promisify.custom基本使用</h4><p>另一个功能是可以使用util.promise.custom符号重写util.promisify返回值。</p>
<p>在fs.readFile上定义util.promisify.custom符号，其功能为禁止读取文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意顺序要在 util.promisify之前</span></span><br><span class="line">fs.readFile[util.promisify.custom] = <span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'该文件暂时禁止读取'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> readFilePromisify = util.promisify(fs.readFile);</span><br><span class="line">readFilePromisify(<span class="string">'text.txt'</span>,<span class="string">'utf8'</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">result</span>=&gt;</span><span class="built_in">console</span>.log(result))</span><br><span class="line">    .catch(<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(err)) <span class="comment">// 该文件暂时禁止读取</span></span><br></pre></td></tr></table></figure>
<p>自定义mayJunPromisify.custom实现</p>
<ul>
<li>定义一个Symbol变量kCustomPromisifiedSymbol赋予mayJunPromisify.custom</li>
<li>校验是否有自定义的promise函数</li>
<li>自定义的mayJunPromisified.custom也要保证是一个函数，否则抛错</li>
<li>直接返回自定义的mayJunPromisify.custom函数，后续的fn函数就不会执行了，所以在这里重写util.promisify返回值</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所以说util.promisify.custom是一个符号</span></span><br><span class="line"><span class="keyword">const</span> kCustomPromisifiedSymbol = <span class="built_in">Symbol</span>(<span class="string">'util,promisify.custom'</span>);</span><br><span class="line">mayJunPromisify.custom = kCustomPromisifiedSymbol;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mayJunPromisify</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> original !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The "original" argument must be of type Function,Received type undefined'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(original[kCustomPromisifiedSymbol])&#123;</span><br><span class="line">        <span class="keyword">const</span> fn = original[kCustomPromisifiedSymbol];</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The "mayJunPromise.custom" property must be of the type Function,Received type number'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.defineProperty(fn,kCustomPromisifiedSymbol,&#123;</span><br><span class="line">            value:fn,</span><br><span class="line">            enumerable:<span class="literal">false</span>,</span><br><span class="line">            writable:<span class="literal">false</span>,</span><br><span class="line">            configurable:<span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">...args</span>)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="util-promisify回调函数多参转换"><a href="#util-promisify回调函数多参转换" class="headerlink" title="util.promisify回调函数多参转换"></a>util.promisify回调函数多参转换</h4><p>有些函数的回调形式是多个参数的，例如dns.lookup，它的回调形式是<code>(err,address,family)=&gt;...</code>拥有 三个参数，对这种情况也做兼容</p>
<p>基本使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dns = <span class="built_in">require</span>(<span class="string">'dns'</span>);</span><br><span class="line"><span class="keyword">const</span> lookupPromisify = util.promisify(dns.lookup);</span><br><span class="line"></span><br><span class="line">lookupPromisify(<span class="string">'laibh.top'</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params">&#123;address,family&#125;</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'地址：'</span>,address,<span class="string">'地址族：'</span>,family)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure>
<p>实现解析：</p>
<p>为了支持util.promisify也都会在函数上定义一个customPromisifyArgs参数，value为回调的多个参数的名称，类型为数组，例如dns.lookup绑定的customPromisifyArgs的value为<code>[&#39;address&#39;,&#39;family&#39;]</code>，其主要目的也是为了适配util.promisify</p>
<p>dns.lookup支持util.promisify核心实现</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;customPromisifyArgs&#125; = <span class="built_in">require</span>(<span class="string">'internal/util'</span>);</span><br><span class="line"></span><br><span class="line">ObjectDefineProperty(lookup,customPromisifyArgs,&#123;</span><br><span class="line">    value:[<span class="string">'address'</span>,<span class="string">'family'</span>],</span><br><span class="line">    enumerable:<span class="literal">false</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>customPromisifyArgs这个参数是从internal/util模块导出的，仅内部调用，在外部util.promisify是没有这个参数的。也就意味着只有Node模块中例如dns.lookup、fs.read等方法在多参数的时候可以使用util.promisify转换为Promise，如果自定义的callback存在多参数的情况，使用util.promisify则不行，不过可以基于util.promisify自己封装一个：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// Symbol used to customize promisify conversion</span></span><br><span class="line">    customPromisifyArgs:kCustomPromisifyArgsSymbol</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义Symbol变量kCustomPromisifyArgsSymbol</li>
<li>获取参数名称列表</li>
<li><code>(err,result)</code>改为<code>(err,...values)</code>,原先的result仅接受一个参数，改为<code>...values</code>接收多个参数</li>
<li>argumentNames存在且value&gt;1,则回调会存在多个参数名称，经常遍历，返回一个obj</li>
<li>否则values最多仅有一个参数名称，即数组values有且仅有一个元素</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> kCustomPromisifyArgsSymbol = <span class="built_in">Symbol</span>(<span class="string">'customPromisifyArgs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisify</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 获取多个回调函数的函数参数列表</span></span><br><span class="line">    <span class="keyword">const</span> argumentName = original[kCustomPromisifyArgsSymbol];</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">..args</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                original.call(<span class="keyword">this</span>,...args,(err,...values)=&gt;&#123;</span><br><span class="line">                    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                        reject(err)</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">// argumentNames存在且values&gt;1,则回调会存在多个参数名称，进行遍历，返回一个obj</span></span><br><span class="line">                        <span class="keyword">if</span>(argumentNames !== <span class="literal">undefined</span> &amp;&amp; values.length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                            <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;argumentNames.length;i+=<span class="number">1</span>)&#123;</span><br><span class="line">                                obj[argumentNames[i]] = values[i];</span><br><span class="line">                                resolve(obj)</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="comment">// 否则values最多只有一个参数名称，即数组values有且只有一个元素</span></span><br><span class="line">                            resolve(values[<span class="number">0</span>])</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于kCustomPromiseArgsSymbol使用Symbol声明（每次重新定义都会不一样），且没有对外提供。要实现这个功能，需要每次在cb重新定义kCustomPromisifyArgsSymbol属性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> kCustomPromisifiedSymbol = <span class="built_in">Symbol</span>(<span class="string">'util.promisify.custom'</span>);</span><br><span class="line"><span class="keyword">const</span> kCustomPromisifyArgsSymbol = <span class="built_in">Symbol</span>(<span class="string">'customPromisifyArgs'</span>);</span><br><span class="line">mayJunPromisify.custom = kCustomPromisifiedSymbol;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mayJunPromisify</span>(<span class="params">original</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> original !== <span class="string">'function'</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The "original" argument must be of type Function,Received type undefined'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(original[kCustomPromisifiesSymbol])&#123;</span><br><span class="line">        <span class="keyword">const</span> fn = original[kCustomPromisifiesSymbol];</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">typeof</span> fn !== <span class="string">'function'</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'The "util.promisify.custom" property must be of type Function.Received type number'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Object</span>.defineProperty(fn,kCustomPromisifiedSymbol,&#123;</span><br><span class="line">            value:fn,</span><br><span class="line">            enumerable:<span class="literal">false</span>,</span><br><span class="line">            writable:<span class="literal">false</span>,</span><br><span class="line">            configurable:<span class="literal">true</span></span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="comment">// 获取多个回调函数的参数列表</span></span><br><span class="line">        <span class="keyword">const</span> argumentNames = original[kCustomPromisifyArgsSymbol];</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    original.call(<span class="keyword">this</span>,...args,(err,...values)=&gt;&#123;</span><br><span class="line">                        <span class="keyword">if</span>(err)&#123;</span><br><span class="line">                            reject)(err);</span><br><span class="line">                        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                            <span class="comment">// argumentName 存在且 values&gt;1,则回调会存在多个参数名称，进行遍历，返回一个obj</span></span><br><span class="line">                            <span class="keyword">if</span>(argumentNames !== <span class="literal">undefined</span> &amp;&amp; values.length &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                                <span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line">                                <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;argumentNames.length;i+=<span class="number">1</span>)&#123;</span><br><span class="line">                                    obj[argumentNames[i]] = values[i]</span><br><span class="line">                                    resolve(obj)</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                <span class="comment">// 否则values最多仅有一个参数名称，即数组values有且仅有一个元素</span></span><br><span class="line">                                resolve(values[<span class="number">0</span>])</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">                    reject(err)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    mayJunPromisify,</span><br><span class="line">    kCustomPromisifyArgsSymbol</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;kCustomPromisifyArgsSymbol,mayJunPromisify&#125; = <span class="built_in">require</span>(<span class="string">'./may-jun-promisify'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// mayJunPromisify.custom自定义Promise函数测试</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promisifyCustomTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    fs.readFile[mayJunPromisify.custom]=<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(<span class="string">'该文件暂时禁止读取'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> readFilePromisify = mayJunPromisify(fs.readFile);</span><br><span class="line">    readFilePromisify(<span class="string">'text.txt'</span>,<span class="string">'utf8'</span>)</span><br><span class="line">        .then(<span class="function"><span class="params">result</span>=&gt;</span><span class="built_in">console</span>.log(result))</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(err)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义cb多参数转换promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cbConverPromiseTest</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getUserById</span>(<span class="params">id,cb</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">const</span> name = <span class="string">'laibh'</span>,</span><br><span class="line">              age = <span class="number">25</span>;</span><br><span class="line">        cb(<span class="literal">null</span>,name,age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(getUserById,kCustomPromisifyArgsSymbol,&#123;</span><br><span class="line">        value:[<span class="string">'name'</span>,<span class="string">'age'</span>],</span><br><span class="line">        enumerable:<span class="literal">false</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> getUserByIdPromisify = mayJunPromisify(getUserById);</span><br><span class="line">    getUserByIdPromisify(<span class="number">1</span>)</span><br><span class="line">        .then(&#123;name,age&#125;=&gt;&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(name,age);</span><br><span class="line">    	&#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">err</span>=&gt;</span><span class="built_in">console</span>.log(err))</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">promisifyCustomTest();</span><br><span class="line">cbConverPromiseTest();</span><br></pre></td></tr></table></figure>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><p>I/O即Input/Output，输入输出端口，是信息处理系统与外部世界之间的通信，输入手是系统接收的信号或数据，输出的则是从其发送的信号或数据</p>
<p>一次I/O操作分为等待资源，使用资源两个阶段，常见的词网络I/O,磁盘I/O</p>
<h3 id="阻塞与非阻塞I-O"><a href="#阻塞与非阻塞I-O" class="headerlink" title="阻塞与非阻塞I/O"></a>阻塞与非阻塞I/O</h3><p>是对于操作系统内核而言的，发生在等待资源阶段，根据发起的I/O请求是否阻塞来判断</p>
<p>阻塞I/O：这种模式下一个用户进程在发起一个I/O操作之后，只有接收到响应或者超时时才可进行处理其他事情，否则I/O将会一直阻塞。以读取磁盘上的一段文件为例子，系统内核在完成磁盘寻道、读取数据、复制数据到内存之中之后，这个调用才算完成。阻塞的这段时间对CPU资源是浪费的。</p>
<p>非阻塞I/O：这种模式下一个用户进程发起一个I/O操作之后，如果数据没有就绪，会立刻返回（标志数据资源不可用），此时CPU时间片可以用来做一些其他事情。</p>
<h3 id="同步与异步I-O"><a href="#同步与异步I-O" class="headerlink" title="同步与异步I/O"></a>同步与异步I/O</h3><p>同步与异步I/O发生在使用资源阶段。</p>
<p>同步I/O：应用发送或接受数据后，如果不返回，继续等待（此处发生阻塞），直到数据成功或失败返回。</p>
<p>异步I/O：应用发送或接受数据后立刻返回，数据写入OS缓存，由OS完成数据发送或接收，并返回成功或者失败的信息给应用，NodeJs就是典型异步编程的例子。</p>
<h3 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h3><p>操作系统为了多个应用同时运行，需要保证不同进程相对独立、内核的安全。所以操作系统把内存空间划分为用户空、内核空间两部分。用户空间存放用户程序代码和数据，而内核空间则存放内核代码和数据。</p>
<p>OSI七层模型与网际网协议族图：传输层之上（会话层、表示层、应用层）为用户空间（Web客户端、浏览器、FTP），下四层（传输层，网络层，数据链路层，物理层）为内核空间，例如传输层的TCP/UDP就对应内核空间。</p>
<h3 id="操作系统I-O模型"><a href="#操作系统I-O模型" class="headerlink" title="操作系统I/O模型"></a>操作系统I/O模型</h3><h4 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h4><p>当进程调用 recvfrom() 函数的时候阻塞，<strong>应用程序</strong>开始系统调用，在<strong>系统内核</strong>数据就绪，将数据从内核中拷贝出来后结束。这个过程应用程序都处于等待状态，不能做其他事情，直到将数据拷贝到用户空间或出错才返回，我们称之为阻塞I/O模式。</p>
<h3 id="同步非阻塞I-O"><a href="#同步非阻塞I-O" class="headerlink" title="同步非阻塞I/O"></a>同步非阻塞I/O</h3><p>想对于同步非阻塞I/O模式，同步非阻塞I/O在 每次调用之后，如果数据没有就绪就会立即返回，之后重复调用检查I/O操作是否就绪，这对CPU资源非常浪费，直到数据就绪将数据从内核拷贝到用户空间，返回成功指示到应用程序。</p>
<h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I/O多路复用"></a>I/O多路复用</h3><p>链接（Socket）并发大的时候，上面的两种就不适合了，前面一个处理不完，后面的就只能干等。多路复用技术先进行select数据就绪后，调用recvfrom进行真正的I/O读写操作。高级之处在于能够一个线程同时处理多个Socket</p>
<p>多路复用中的I/O通常指的是网络I/O,多路指的是多个Socker链接，复用指操作系统进行运算调度最小单位线程，整体的意思就是多个网络I/O复用一个或少量线程来处理Socket</p>
<p>I/O多路复用的四种实现：select/poll/epoll/kqueue</p>
<ul>
<li>select，通过轮询检查在文件描述符上设置的标志位来进行判断，select的轮询相当于在数据库中查找一条记录没有建立索引，对所有的socket进行全部遍历，这对CPU是浪费的。另外select还有一个限制，对于单个线程所能打开的文件描述符最大只有1024，那么基于select的轮询技术最多也只能很好的处理1000并发的吞吐量</li>
<li>poll,poll和select在实现上没有什么本质上的区别，poll基于链表来实现，没有了最大链接1024的限制。当文件描述符多了之后，每次调用都会对链接进行线性遍历，性能也是十分低下的。</li>
<li>epoll。是linux下效率最高的I/O事件通知机制，没有最大链接限制，通过callback回调通知机制，不再是每次调用对链接进行线性遍历，这样就不会随着文件描述符的增加导致效率下降。1GB内存的机器上大概能监听10w个端口，远超过select1024的限制</li>
<li>kqueue，与epoll类似，仅存于FreeBSD(一种类UNIX操作系统)</li>
</ul>
<h3 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h3><p>仅在Unix上支持，与I/O多路复用相比避免了select的阻塞轮询，应用程序进行系统调用后立即返回，处理其他事情，在数据就绪之后系统会发送一个SIGIO信号到应用程序，应用程序开始读取数据</p>
<h3 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h3><p>目前最理想形式的一种，应用程序发起系统调用后无需等待直接返回当前调用状态，进行后续的其他任务，结果由内核完成I/O操作之后通过回调通知到应用程序，中间没有阻塞过程。Linux2.6增加了AIO，但是很少系统能够实现</p>
<h3 id="轮询技术Select-与-Epoll的区别"><a href="#轮询技术Select-与-Epoll的区别" class="headerlink" title="轮询技术Select 与 Epoll的区别"></a>轮询技术Select 与 Epoll的区别</h3><p><strong>操作方式上</strong></p>
<ul>
<li>select采用了线性遍历来查找，链接多了之后在一个庞大的数组中每次遍历来锁定一个链接，非常消耗性能</li>
<li>epoll则不需要遍历，采用的是回调机制，可以看作是一个HashTable，来锁定一个对象非常快。</li>
</ul>
<p><strong>文件描述符限制</strong></p>
<ul>
<li>对于文件描述符最大链接数select限制为1024</li>
<li>epoll则没有这个限制，通常在1GB内存的机器上所能支持的连接数为10W左右。</li>
</ul>
<p><strong>操作系统的支持</strong></p>
<p>目前高性能的Web服务器Nginx是基于epoll来实现高并发的</p>
<h3 id="Nodejs中的内存管理和V8垃圾回收机制"><a href="#Nodejs中的内存管理和V8垃圾回收机制" class="headerlink" title="Nodejs中的内存管理和V8垃圾回收机制"></a>Nodejs中的内存管理和V8垃圾回收机制</h3><p>在Nodejs中，关于垃圾回收、内存释放不需要像C语言创建一个对象之后需手动创建一个delete/free的一个操作之后进行GC,Nodejs与java一样，由虚拟机进行内存自动管理。</p>
<h3 id="NodeJs中的GC"><a href="#NodeJs中的GC" class="headerlink" title="NodeJs中的GC"></a>NodeJs中的GC</h3><p>node.js是基于Chrome v8引擎的javascript运行环境，V8就是虚拟机。</p>
<h3 id="垃圾回收内存管理实践"><a href="#垃圾回收内存管理实践" class="headerlink" title="垃圾回收内存管理实践"></a>垃圾回收内存管理实践</h3><h4 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h4><p>node提供process.memoryUsage方法来查看当前进程内存使用情况，单位为节</p>
<ul>
<li>ress(resident set size)：RAM中保存的进程占用的内存部分，包括代码本身、栈、堆</li>
<li>heapTotal：堆中总共申请到的内存量</li>
<li>heapUsed：堆中目前用到的内存量，判断内存泄露主要以这个字节为准</li>
<li>external：V8引擎内存C++对象占用的内存</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*单位字节格式为MB输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> format = <span class="function"><span class="keyword">function</span>(<span class="params">bytes</span>)</span></span><br><span class="line"><span class="function">    <span class="title">return</span> (<span class="params">bytes<span class="regexp">/1024/</span><span class="number">1024</span></span>).<span class="title">toFixed</span>(<span class="params"><span class="number">2</span></span>)+' <span class="title">MB</span>'</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">/*</span></span><br><span class="line"><span class="function">*封装<span class="title">print</span>方法输出内存占用信息</span></span><br><span class="line"><span class="function">*/</span></span><br><span class="line"><span class="function"><span class="title">const</span> <span class="title">print</span> = <span class="title">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> memoryUsage = process.memoryUsage();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">            res:format(memoryUsage.rss),</span><br><span class="line">            heapTotal:format(memoryUsage.heapTotal),</span><br><span class="line">            heapUsed:format(memoryUsage.heapUsed),</span><br><span class="line">            external:format(memoryUsage.external),</span><br><span class="line">        &#125;)</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内存泄露的例子"><a href="#内存泄露的例子" class="headerlink" title="内存泄露的例子"></a>内存泄露的例子</h4><p>堆用来存放对象引用类型，例如字符串、对象、在代码中创建一个Fruit存放在堆中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// example.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Quantity</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(num)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Array</span>(num * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fruit</span>(<span class="params">name,quantity</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.quantity = <span class="keyword">new</span> Quantity(quantity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> apple = <span class="keyword">new</span> Fruit(<span class="string">'apple'</span>);</span><br><span class="line">print();</span><br><span class="line"><span class="keyword">let</span> banane = <span class="keyword">new</span> Fruit(<span class="string">'banane'</span>,<span class="number">20</span>);</span><br><span class="line">print();</span><br><span class="line"><span class="comment">// 执行代码，aplle对象heapUsed使用仅有4.21M，而banana由于quantity属性创建了一个很大数组空间导致heapUsed飙升到164.21M。</span></span><br><span class="line"><span class="comment">// &#123;"rss":"19.94 MB","heapTotal":"6.83 MB","heapUsed":"4.21 MB","external":"0.01 MB"&#125;</span></span><br><span class="line"><span class="comment">// &#123;"rss":"180.04 MB","heapTotal":"166.84 MB","heapUsed":"164.24 MB","external":"0.01 MB"&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="手动执行垃圾回收内存释放"><a href="#手动执行垃圾回收内存释放" class="headerlink" title="手动执行垃圾回收内存释放"></a>手动执行垃圾回收内存释放</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">banana = <span class="literal">null</span>;</span><br><span class="line">global.gc();</span><br><span class="line">print(); </span><br><span class="line"><span class="comment">// 执行 node --expose-gc xxx.js --expose-gc参数表示运行手动执行垃圾回收机制，将banana对象赋值null进行GC</span></span><br><span class="line"><span class="comment">// &#123;"rss":"52.48 MB","heapTotal":"9.33 MB","heapUsed":"3.97 MB","external":"0.01 MB"&#125;</span></span><br><span class="line"><span class="comment">// heapUsed的使用已经降了下来</span></span><br></pre></td></tr></table></figure>
<h3 id="V8垃圾回收机制"><a href="#V8垃圾回收机制" class="headerlink" title="V8垃圾回收机制"></a>V8垃圾回收机制</h3><p>垃圾回收指的是回收那些在应用程序中不再引用的对象，当一个对象无法从根节点访问这个对象就会作为垃圾回收的候选对象。这里的根对象可以为全局对象、局部变量，无法从根节点访问指的也就是不会再被其他活动对象所引用。</p>
<h4 id="V8堆内存限制"><a href="#V8堆内存限制" class="headerlink" title="V8堆内存限制"></a>V8堆内存限制</h4><p>在V8中限制64位机制大约为1.4G，32位的大概是0.7G，对于一些大内存的操作需要谨慎否则超出V8内存限制会造成进程退出</p>
<p>内存溢出边界的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// overflow.js</span></span><br><span class="line"><span class="keyword">const</span> format = <span class="function"><span class="keyword">function</span>(<span class="params">bytes</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (bytes / <span class="number">1024</span> / <span class="number">1024</span>).toFixed(<span class="number">2</span>)+<span class="string">' MB'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> memoryUsage = process.memoryUsage();</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`heapTotal:<span class="subst">$&#123;format(memoryUsage.heapTotal)&#125;</span>,</span></span><br><span class="line"><span class="string">		 heapUsed: <span class="subst">$&#123;format(memoryUsage.heapUsed)&#125;</span>`</span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> total = [];</span><br><span class="line">setInterval(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    total.push(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>*<span class="number">1024</span>*<span class="number">1024</span>)) <span class="comment">// 大内存占用</span></span><br><span class="line">    print();</span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>total为全局变量每次增长大概在160M左右且不会被回收，在接近V8边界时无法分配内存导致进程内存溢出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> node overflow.js</span></span><br><span class="line">heapTotal: 166.84 MB, heapUsed: 164.23 MB</span><br><span class="line">heapTotal: 326.85 MB, heapUsed: 324.26 MB</span><br><span class="line">heapTotal: 487.36 MB, heapUsed: 484.27 MB</span><br><span class="line">heapTotal: 649.38 MB, heapUsed: 643.98 MB</span><br><span class="line">heapTotal: 809.39 MB, heapUsed: 803.98 MB</span><br><span class="line">heapTotal: 969.40 MB, heapUsed: 963.98 MB</span><br><span class="line">heapTotal: 1129.41 MB, heapUsed: 1123.96 MB</span><br><span class="line">heapTotal: 1289.42 MB, heapUsed: 1283.96 MB</span><br><span class="line"></span><br><span class="line">&lt;--- Last few GCs ---&gt;</span><br><span class="line"></span><br><span class="line">[87581:0x103800000]    11257 ms: Mark-sweep 1283.9 (1290.9) -&gt; 1283.9 (1290.9) MB, 512.1 / 0.0 ms  allocation failure GC in old space requested</span><br><span class="line">[87581:0x103800000]    11768 ms: Mark-sweep 1283.9 (1290.9) -&gt; 1283.9 (1287.9) MB, 510.7 / 0.0 ms  last resort GC in old space requested</span><br><span class="line">[87581:0x103800000]    12263 ms: Mark-sweep 1283.9 (1287.9) -&gt; 1283.9 (1287.9) MB, 495.3 / 0.0 ms  last resort GC in old space requested</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;--- JS stacktrace ---&gt;</span><br></pre></td></tr></table></figure>
<p>v8提供了两个参数仅在启用阶段调整内存限制大小，分别为调整老生代、新生代：</p>
<ul>
<li>–max-old-space-size=2048</li>
<li>–max-new-space-size=2048</li>
</ul>
<p>内存不是越大越好，一方面是服务器资源昂贵，另外是V8以1.5G的堆内存进行一次小的垃圾回收大约需要50毫秒以上时间，会导致JavaScript进程暂停，这也是最主要的一方面。</p>
<h4 id="新生代与老生代"><a href="#新生代与老生代" class="headerlink" title="新生代与老生代"></a>新生代与老生代</h4><p><strong>新生代空间</strong></p>
<p>由于新空间的垃圾回收机制很频繁，所以处理方式必须非常快，采用Scavenge算法，这是一种复制算法，新生代空间会被一分为二划分为两个相等大小的from-space和to-space工作方式是将from space中存活的对象复制出来，然后移动它们到to space 中或者被提升到老生代空间中，对于from space中没有存活的对象将会被释放，完成这些复制后再将from space和to space进行互换。</p>
<p>Scavenge算法适用少量内存的垃圾回收，但是有很大的空间开销，对于新生代少量内存是可以接受的</p>
<p><strong>老生代空间</strong></p>
<p>新生代空间在垃圾回收满足于一定的条件（是否经过Scavenge空间、to space内存占比）会被晋升到老生代空间中，在老生代空间中的对象都已经至少经历了一次或者多次的回收所以它们的存活概率会更大。在使用Scavenge算法会有两个缺点，一是将会重复的复制存活对象使得效率低下，二是对空间资源的浪费，所以在老生代空间中采用了 Mark-Sweep（标记清除）和Mark-Compact（标记整理）算法</p>
<p>Mark-Sweep处理时分为标记、清除两个步骤，与Scavenge算法只复制活对象相反的是在老生代空间中由于活对象占多数Mark-Sweep在标记阶段遍历堆中的所有对象仅标记活对象把未标记的死对象清除，这时一次标记清除就已经完成了。有一个问题是被清除的对象遍布于各内存地址，产生很多内存碎片</p>
<p>Mark-Compact(标记整理算法)为了解决内存碎片问题，在其工作过程中将活着的对象往一端移动，这时内存空间是紧凑的，移动完成之后，直接整理边界之外的内存。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>V8使用了不同的垃圾回收算法Scavenge/Mark-Sweep/Mark-Compact.这三种垃圾回收算法都避免不了在进行垃圾回收时需要将应用程序暂停，待垃圾回收完成之后在恢复应用逻辑，对于新生代空间来说由于很快所以影响不大，但是对于老生代空间由于存活对象较多，停顿还是会造成影响的，因此V8又新增了增量标记的方式减少停顿时间。</p>
<h3 id="内存泄露-1"><a href="#内存泄露-1" class="headerlink" title="内存泄露"></a>内存泄露</h3><p>内存泄露（Memory Leak）是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统奔溃等严重后果。</p>
<p><strong>全局变量</strong>，未声明的变量或挂在全局global下的变量不会自动回收，将会常驻内存直到直到进程退出才会释放，除非通过delete或者重新赋值为undefined/null解决之间的引用关系，才会被回收。</p>
<p><strong>闭包</strong>，也是一个常见的内存泄露问题，闭包会引用父级函数中的变量，如果闭包得不到释放，闭包引用的父级变量也不会释放从而导致内存泄露</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> theThing = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> replaceThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> originalThing = theThing;</span><br><span class="line">    <span class="keyword">var</span> unused = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(originalThing)&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        theThing = &#123;</span><br><span class="line">            longStr:<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1000000</span>).join(<span class="string">'*'</span>),</span><br><span class="line">            someMethod:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(someMessage)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setInterval(replaceThing,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>代码运行时，每次执行replaceThing方法都会生成一个新的对象，但是之前的对象没有释放导致的内存泄露。</p>
<p><strong>慎将内存作为缓存</strong></p>
<p>通过内存来做缓存是最快的实现方式，缓存中的存储的键越多，长期存活的对象就越多，垃圾回收时将这些对象做无用功。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面一个获取用户Token的例子，memoryStore对象会随着用户数的增加而增长，当启动多个线程或者部署在多台机器会造成每个进程都保存一份，显然是资源的浪费，最好是通过Redis做共享</span></span><br><span class="line"><span class="keyword">const</span> memoryStore = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line">exports.getUserToken = <span class="function"><span class="keyword">function</span>(<span class="params">key</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> token = memoryStore.get(key);</span><br><span class="line">    <span class="keyword">if</span>(token &amp;&amp; <span class="built_in">Date</span>.now() - token.now &gt; <span class="number">2</span> * <span class="number">60</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> dbToken = db.get(key);</span><br><span class="line">    memoryStore.set(key,&#123;</span><br><span class="line">        now:<span class="built_in">Date</span>.now(),</span><br><span class="line">        val:dbToken</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> token;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>模块私有变量内存常驻</strong></p>
<p>加载一个模块代码之前，Nodejs会使用一个如下的函数封装器将其封装，保证了顶层的变量（var,const,let）在模块范围内，而不是全局对象。这个时候就会形成一个闭包，在require时会被加载一次，将exports对象保存在内存中，直到进程退出才会回收，这个将会导致的是内存常驻，所以避免一些没必要的模块加载，否则也会造成内存增加</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">exports,require,module,__filename,__dirname</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 模块的代码实际上在这里</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 所以建议对模块的引用仅在头部初次加载之后用const缓存起来，而不是在使用时每次都去加载一起。</span></span><br><span class="line"><span class="comment">// 推荐</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'a.js'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'a.js'</span>).run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>事件反复监听</strong></p>
<p>NodeJs中对一个事件反复监听则会报下面的错误，实际上使用的EventEmitter类，包含一个listeners数组，默认为10个监听器超出这个数则会报警，用于发现内存泄露，也可以通过emitter.setMaxListeners()方法为指定的EventEmitter实例修改限制</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MaxListenersExceededWarning：Possible EventEmitter memory leak detected, 11 connect added.Use emitter.setMaxListeners() to increase limit</span><br></pre></td></tr></table></figure>
<p><strong>其他注意事项</strong></p>
<p>使用定时器setInterval时记得使用对应的clearInterval进行清除。因为setInterval执行完之后会返回一个值且不会自动释放，另外还有map/filter等对数组进行操作，每次操作之后都会创建一个新的数组，将会占用内存，如果单纯的遍历map可以用forEach。</p>
<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><ul>
<li><code>[Cache]</code> <a href="https://github.com/webpack/memory-fs">memory-fs 将文件写入内存</a></li>
<li><code>[Cache]</code> <a href="https://github.com/ptarjan/node-cache#readme">Memory Cache</a></li>
<li><code>[Cache]</code> <a href="https://github.com/mpneuried/nodecache">Node Cache</a></li>
</ul>
<h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><ul>
<li><code>[Schedule]</code> <a href="https://github.com/node-schedule/node-schedule">node-schedule</a></li>
<li><code>[Schedule]</code> <a href="https://github.com/agenda/agenda">Agenda 将Node中的定时任务存储在数据库中（官方推荐MongoDB）</a></li>
<li><code>[Schedule]</code> <a href="https://www.nodejs.red/#/docs/microservice/rabbitmq-base?id=rabbitmq延迟队列实现定时任务">Node.js结合RabbitMQ延迟队列实现定时任务</a></li>
</ul>
<h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><ul>
<li><code>[Template]</code> <a href="https://ejs.co/">Ejs</a></li>
<li><code>[Template]</code> <a href="https://handlebarsjs.com/">Handlebarsjs</a></li>
<li><code>[Template]</code> <a href="http://jade-lang.com/">Jade</a></li>
</ul>
<h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><ul>
<li><code>[Framework]</code> <a href="http://www.expressjs.com.cn/">Express 中文版</a>、<a href="http://www.expressjs.com.cn/">Express of English Version</a></li>
<li><code>[Framework]</code> <a href="https://koajs.com/">Koa 中文版</a>、<a href="https://koajs.com/">Koa of English Version</a></li>
<li><code>[Framework]</code> <a href="https://eggjs.org/zh-cn/intro/quickstart.html">Egg 中文版</a>、<a href="https://eggjs.org/en/intro/quickstart.html">Egg of English Version</a></li>
<li><code>[Framework]</code> <a href="https://docs.nestjs.cn/">Nest.js 中文版</a>、<a href="https://docs.nestjs.com/">Nest.js</a></li>
</ul>
<h3 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h3><ul>
<li><code>[typeorm]</code> <a href="https://typeorm.io/">typeorm</a> 【右上角切换中文】</li>
<li><code>[sequelize]</code> <a href="http://docs.sequelizejs.com/">sequelize</a></li>
<li><code>[prisma]</code> <a href="https://www.prisma.io/docs">prisma</a></li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h3><p><strong>QPS</strong></p>
<p>QPS（Query Per Second）指每秒查询量，规定时间内所能处理的流量大小，通常QPS值越大服务器的吞吐量也就越大，相对服务器负荷也会越高</p>
<p>QPS=并发量/平均响应时间并发量 = QPS * 平均响应时间</p>
<p><strong>TPS</strong></p>
<p>TPS（TransactionPerSecond）指每秒事物处理量，每秒钟系统所能处理的交易或事务的数量，用来形容系统的性能。</p>
<p><strong>两者区别</strong></p>
<p>一次下单请求，访问一次创建接口产生一次TPS,对于服务器的请求可能会产生多次，比如查询用户地址信息、商品数据信息、商品报价信息，这些请求计入QPS,也就是产生了3次QPS</p>
<h3 id="系统扩容评价"><a href="#系统扩容评价" class="headerlink" title="系统扩容评价"></a>系统扩容评价</h3><p>根据二八法则来评估系统扩容需要多少台机器，二八法则即20%的时间承载80%的流量，把20%的时间称为峰值时间，换算公式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(总PV数 * 80%) / (每天描述 * 20%) = 峰值时间每秒请求数</span><br><span class="line">峰值时间内每秒请求数（QPS）/单台机器QPS = 需要的机器</span><br></pre></td></tr></table></figure>
<p>假设有1000wPV,总共需要的QPS为多少？</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1000000 * 0.8) / (24 * 60 * 60 * 0.2) = 463(QPS)</span><br></pre></td></tr></table></figure>
<p>假设每台机器支撑100QPS，则共需要的机器为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">463</span>(总有QPS)/<span class="number">100</span>(单机QPS) = <span class="number">5</span>(约需要<span class="number">5</span>台机器)</span><br></pre></td></tr></table></figure>
<h2 id="Nodejs-CPU使用率"><a href="#Nodejs-CPU使用率" class="headerlink" title="Nodejs CPU使用率"></a>Nodejs CPU使用率</h2><h3 id="os-cups-数据指标"><a href="#os-cups-数据指标" class="headerlink" title="os.cups()数据指标"></a>os.cups()数据指标</h3><p>返回的对象数组中有一个times字段，包含了user/nice/sys/idle/irq几个指标数据，分别代表CPU在用户模式、良好模式、系统模式、空闲模式、中断模式下话费的毫秒数。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    model: <span class="string">'Intel(R) Core(TM) i5-4590 CPU @ 3.30GHz'</span>,</span><br><span class="line">    speed: <span class="number">3292</span>,</span><br><span class="line">    times: &#123;</span><br><span class="line">      user: <span class="number">151474100</span>,</span><br><span class="line">      nice: <span class="number">0</span>,</span><br><span class="line">      sys: <span class="number">95311197</span>,</span><br><span class="line">      idle: <span class="number">2258535287</span>,</span><br><span class="line">      irq: <span class="number">2136605</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    model: <span class="string">'Intel(R) Core(TM) i5-4590 CPU @ 3.30GHz'</span>,</span><br><span class="line">    speed: <span class="number">3292</span>,</span><br><span class="line">    times: &#123;</span><br><span class="line">      user: <span class="number">84900939</span>,</span><br><span class="line">      nice: <span class="number">0</span>,</span><br><span class="line">      sys: <span class="number">65104926</span>,</span><br><span class="line">      idle: <span class="number">2355314423</span>,</span><br><span class="line">      irq: <span class="number">874869</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    model: <span class="string">'Intel(R) Core(TM) i5-4590 CPU @ 3.30GHz'</span>,</span><br><span class="line">    speed: <span class="number">3292</span>,</span><br><span class="line">    times: &#123;</span><br><span class="line">      user: <span class="number">144337320</span>,</span><br><span class="line">      nice: <span class="number">0</span>,</span><br><span class="line">      sys: <span class="number">112618416</span>,</span><br><span class="line">      idle: <span class="number">2248364428</span>,</span><br><span class="line">      irq: <span class="number">699602</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    model: <span class="string">'Intel(R) Core(TM) i5-4590 CPU @ 3.30GHz'</span>,</span><br><span class="line">    speed: <span class="number">3292</span>,</span><br><span class="line">    times: &#123;</span><br><span class="line">      user: <span class="number">110066333</span>,</span><br><span class="line">      nice: <span class="number">0</span>,</span><br><span class="line">      sys: <span class="number">84988268</span>,</span><br><span class="line">      idle: <span class="number">2310265437</span>,</span><br><span class="line">      irq: <span class="number">897333</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>定义方法getCPUInfo用来获取系统CPU信息，提供了CPU利用率的实时监控，这个实时不是绝对的实时，会有时差，下面实现中默认设置的1秒钟，可以通过Options.ms进行调整</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>);</span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function"><span class="params">ms</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, ms));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OSUtils</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.cpuUsageMSDefault = <span class="number">1000</span>; <span class="comment">// CPU 利用率默认时间段</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取CPU信息</span></span><br><span class="line"><span class="comment">   * @return &#123;Object&#125; CPU信息</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> _getCPUInfo() &#123;</span><br><span class="line">  <span class="keyword">const</span> cpus = os.cpus();</span><br><span class="line">  <span class="keyword">let</span> user = <span class="number">0</span>,</span><br><span class="line">    nice = <span class="number">0</span>,</span><br><span class="line">    sys = <span class="number">0</span>,</span><br><span class="line">    idle = <span class="number">0</span>,</span><br><span class="line">    irq = <span class="number">0</span>,</span><br><span class="line">    total = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> cpu <span class="keyword">in</span> cpus) &#123;</span><br><span class="line">    <span class="keyword">const</span> times = cpus[cpu].times;</span><br><span class="line">    user += times.user;</span><br><span class="line">    nice += times.nice;</span><br><span class="line">    sys += times.sys;</span><br><span class="line">    idle += times.idle;</span><br><span class="line">    irq += times.irq;</span><br><span class="line">  &#125;</span><br><span class="line">  total += user + nice + sys + idle + irq;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    user,</span><br><span class="line">    sys,</span><br><span class="line">    idle,</span><br><span class="line">    total</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取某时间段CPU利用率</span></span><br><span class="line"><span class="comment">   * @param &#123;Number&#125; Options.ms [时间段，默认是1000ms，即1秒钟]</span></span><br><span class="line"><span class="comment">   * @param &#123;Boolean&#125; Options.percentage [true（以百分比结果返回）| false]</span></span><br><span class="line"><span class="comment">   * @return &#123;Promise&#125;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">async</span> getCPUUsage(options = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">const</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> &#123; cpuUsageMS, percentage &#125; = options;</span><br><span class="line">    cpuUsageMS = cpuUsageMS || that.cpuUsageMSDefault;</span><br><span class="line">    <span class="keyword">const</span> t1 = that._getCPUInfo(); <span class="comment">// t1时间点的 CPU信息</span></span><br><span class="line">    <span class="keyword">await</span> sleep(cpuUsageMS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> t2 = that._getCPUInfo(); <span class="comment">// t2时间点的 CPU信息</span></span><br><span class="line">    <span class="keyword">const</span> idle = t2.idle - t1.idle;</span><br><span class="line">    <span class="keyword">const</span> total = t2.total - t1.total;</span><br><span class="line">    <span class="keyword">let</span> usage = <span class="number">1</span> - idle / total;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (percentage) usage = (usage * <span class="number">100.0</span>).toFixed(<span class="number">2</span>) + <span class="string">'%'</span>;</span><br><span class="line">    <span class="keyword">return</span> usage;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> osUtils = <span class="keyword">new</span> OSUtils()</span><br><span class="line">osUtils.getCPUUsage(&#123; <span class="attr">percentage</span>: <span class="literal">true</span> &#125;).then(<span class="function"><span class="params">cpuUsage</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'CPU 利用率'</span>, cpuUsage)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="NodeJs与Event-Loop"><a href="#NodeJs与Event-Loop" class="headerlink" title="NodeJs与Event Loop"></a>NodeJs与Event Loop</h2><p>node之前的世界，多线程服务器中，Web应用程序是用一个client/server(客户端/服务端)模式所编写的，其中client将向server请求资源并且将会根据这个资源以响应，server仅在client请求时做出响应，并在每次响应后关闭连接。这种模式是有效的，因为对服务器的每一个请求都需要时间和资源（内存、CPU等等），服务器必须完成上一个请求，才能接受下一个请求。需要同时处理N个请求，服务器就需要N个线程，如果有N+1个请求，就必须等N个线程中的任何一个可用。</p>
<p>服务器中的线程不是唯一的问题，一个线程为什么不能同时处理2个或者更多请求，是因为阻塞了Input/Output操作。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>CPU时钟周期数(ticks)</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU寄存器</td>
<td>3</td>
</tr>
<tr>
<td>L1 Cache(一级缓存)</td>
<td>8</td>
</tr>
<tr>
<td>L2 Cache(二级缓存)</td>
<td>12</td>
</tr>
<tr>
<td>RAM(随机存取存储器)</td>
<td>150</td>
</tr>
<tr>
<td>Disk（磁盘）</td>
<td>30 000 000</td>
</tr>
<tr>
<td>NetWork（网络）</td>
<td>250 000 000</td>
</tr>
</tbody>
</table>
<p>时钟周期也称为tick/clock cycle/clock period等，指一个硬件在被使用过程中，被划分为多个时间周期，当我们需要比较不同硬件性能时，就在不同硬件上测试同一个软件，观察它们的时钟周期时间和周期指数，如果时钟周期越长、周期越多，就意味着这个硬件需要的性能较低。</p>
<h3 id="Event-Loop事件循环"><a href="#Event-Loop事件循环" class="headerlink" title="Event Loop事件循环"></a>Event Loop事件循环</h3><p>事件循环实际上是一个无限循环，并且线程里唯一可用的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> StartNodeInstance(<span class="keyword">void</span>* arg)&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#123;</span><br><span class="line">        SealHandleScope seal(isolate);</span><br><span class="line">        bool more;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            v8::platform::PumpMessageLoop(default_platform,isolate);</span><br><span class="line">            more = uv_run(env-&gt;event_loop(),UV_RUN_ONCE);</span><br><span class="line">            <span class="keyword">if</span>(mode == <span class="literal">false</span>)&#123;</span><br><span class="line">                v8::platform::PumpMessageLoop(default_platform,isolate);</span><br><span class="line">                EmitBeforeExit(env);</span><br><span class="line">                </span><br><span class="line">                more = uv_loop_alive(env-&gt;event_loop());</span><br><span class="line">                <span class="keyword">if</span>(uv_run(env-&gt;event_loop),UV_RUN_NOWAIT)!=<span class="number">0</span>)&#123;</span><br><span class="line">                    more = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">while</span>(more == <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件循环经历6个阶段，所有阶段的执行被称为tick</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">timers-&gt;</span><span class="bash">pending callbacks -&gt;idle,prepare-&gt;poll-&gt;check-&gt;close callbacks</span></span><br></pre></td></tr></table></figure>
<ul>
<li>timers：这个阶段执行定时器setTimeout和setInterval的回调函数</li>
<li>pending callbacks：几乎所有的回调都在这里执行，除了close回调，定时器timers阶段的回调和setImmediate</li>
<li>idle,prepare：仅在内部使用</li>
<li>poll：检索新的I/O事件，适当时Node在此处阻塞</li>
<li>check：setImmediate回调函数将在这里执行</li>
<li>close callbacks：一些准备关闭的回调函数，如 socket.on(‘close’,…)</li>
</ul>
<p>当Event loop需要执行I/O操作时，它将从一个池（通过Libuv库）中使用系统线程，当这个作业完成时，回调将排队等待在pending callbacks阶段被执行</p>
<h3 id="CPU密集型任务问题"><a href="#CPU密集型任务问题" class="headerlink" title="CPU密集型任务问题"></a>CPU密集型任务问题</h3><p>设定一个函数，给定一个数，计算在一个数组中返回N个质数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// primes.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>, s = <span class="built_in">Math</span>.sqrt(n); i &lt;= s; i++)</span><br><span class="line">    <span class="keyword">if</span> (n % i === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> n &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nthPrime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = n;</span><br><span class="line">  <span class="keyword">let</span> iterator = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (counter &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    isPrime(iterator) &amp;&amp; result.push(iterator) &amp;&amp; counter--;</span><br><span class="line">    iterator++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; isPrime, nthPrime &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> primes = <span class="built_in">require</span>(<span class="string">'./primes'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; pathname, query &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (pathname === <span class="string">'/primes'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = primes.nthPrime(query.n || <span class="number">0</span>);</span><br><span class="line">    res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>);</span><br><span class="line">    res.write(<span class="built_in">JSON</span>.stringify(result));</span><br><span class="line">    res.end()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.statusCode = <span class="number">404</span>;</span><br><span class="line">    res.write(<span class="string">'Not Found'</span>);</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(<span class="number">9898</span>);</span><br><span class="line"><span class="comment">// index.js 创建一个服务并在每次请求 /primes这个库，通过query传递参数，假设有3个客户端访问这个非阻塞API,第一个页面请求5个质数，第二个1000个，第三个100000000个，会发现，第三个请求时，客户端就会被阻塞，因为质数会占用大量的CPU,主线程忙于执行密集型的代码，将无法做其他事情，还有Node引入了工作线程</span></span><br></pre></td></tr></table></figure>
<h3 id="工作线程"><a href="#工作线程" class="headerlink" title="工作线程"></a>工作线程</h3><p>工作线程对于执行CPU密集型的javascript操作非常有用，在I/O密集型的工作中用途不大，NodeJs内置的异步I/O操作比工作线程效率更高</p>
<p>修改代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; workerData, parentPort &#125; = <span class="built_in">require</span>(<span class="string">'worker_threads'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPrime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>, s = <span class="built_in">Math</span>.sqrt(n); i &lt;= s; i++)</span><br><span class="line">    <span class="keyword">if</span> (n % i === <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> n &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nthPrime</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> counter = n;</span><br><span class="line">  <span class="keyword">let</span> iterator = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">let</span> result = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (counter &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    isPrime(iterator) &amp;&amp; result.push(iterator) &amp;&amp; counter--;</span><br><span class="line">    iterator++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">parentPort.postMessage(nthPrime(workerData.n))</span><br><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; Worker &#125; = <span class="built_in">require</span>(<span class="string">'worker_threads'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; pathname, query &#125; = url.parse(req.url, <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">if</span> (pathname === <span class="string">'/primes'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> worker = <span class="keyword">new</span> Worker(<span class="string">'./primes.js'</span>, &#123;</span><br><span class="line">      workerData: &#123;</span><br><span class="line">        n: query.n || <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    worker.on(<span class="string">'error'</span>, () =&gt; &#123;</span><br><span class="line">      res.statusCode = <span class="number">500</span>;</span><br><span class="line">      res.write(<span class="string">'Oops there was an error'</span>);</span><br><span class="line">      res.end();</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result;</span><br><span class="line"></span><br><span class="line">    worker.on(<span class="string">'message'</span>, (message) =&gt; &#123;</span><br><span class="line">      result = message;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    worker.on(<span class="string">'exit'</span>, () =&gt; &#123;</span><br><span class="line">      res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>);</span><br><span class="line">      res.write(<span class="built_in">JSON</span>.stringify(result));</span><br><span class="line">      res.end()</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.statusCode = <span class="number">404</span>;</span><br><span class="line">    res.write(<span class="string">'Not Found'</span>);</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).listen(<span class="number">9898</span>);</span><br><span class="line"><span class="comment">// index.js在每个请求中创建一个Worker实例，在一个工作线程中加载并执行primes文件，当这个质数列表计算完成买这个message将会被触发，接受信息并赋值result，由于这个job已完成，将会再次触发exit事件，允许主线程发送数据到客户端</span></span><br><span class="line"><span class="comment">// primes导入 workerData(从主线程传递参数)，parentPort是向主线程发送消息的方式</span></span><br><span class="line"><span class="comment">// 主线程将不会再阻塞，但是生成工作线程并不是最佳实践，创建新线程并不便宜，一定要先创建一个线程池</span></span><br></pre></td></tr></table></figure>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>Redis是一个免费开源、基于内存的高性能Key-Value数据库，具有速度快，数据持久化，多语言和多功能等特性。</p>
<p><strong>速度快</strong>：10w OPS能力，单线程模型，数据存于内存中，注意一次只能运行一次命令，使用过程拒绝使用慢命令，例如keys/flushall/flushdb/slow lua script/mutil/exec等</p>
<p><strong>持久化</strong>：基于内存模型，断电后或者服务重启会造成数据丢失，针对这个问题，提出两种数据持久化策略，分别为RDB和AOF,会将Redis在内存中的数据异步更新到磁盘中，实现数据的持久化功能。</p>
<p><strong>丰富的数据类型</strong>：除了常见的String/HashTable/List/Set/Zset之外还有BitMaps(位图)、HyperLogLog（超小内存唯一计数）</p>
<p><strong>多语言</strong>：基于TCP的通信方式，支持Node.Js/Python/Java/Ruby/Lua等。</p>
<p><strong>多功能</strong>：提供了发布订阅、简单的事务功能、pipeline提高客户端并发效率。另外在Redis中所有单个命令操作都是原子性的，如果想对多个命令一起操作，可以借助Lua脚本（实现自定义命令，保证原子性）</p>
<h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><ul>
<li><code>keys *</code> ：遍历所有key，生产环境不建议使用，时间复杂度O(n)</li>
<li><code>dbsize key</code>：计算key的总数，Redis内置了这个计数器，会实时更新key的总数，时间复杂度O(1)</li>
<li><code>exists key</code>：检查key是否存在，时间复杂度为O(1)</li>
<li><code>expire key seconds</code>：key在指定second后过期，时间复杂度O(1)</li>
<li><code>ttl key</code>：key剩余的过期时间，时间复杂度O(1)</li>
<li><code>persist key</code>: 去掉key的过期时间，时间复杂度O(1)</li>
<li><code>type key</code>：查看key的类型，时间复杂度O(1)</li>
</ul>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    赖彬鸿
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://laibh.top/2020-06-19-NodeJS回顾.html" title="NodeJs回顾">http://laibh.top/2020-06-19-NodeJS回顾.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/NodeJs/" <i class="fa fa-tag"></i> NodeJs</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019-12-07-珠峰架构-Day1.html" rel="next" title="珠峰架构-函数">
                <i class="fa fa-chevron-left"></i> 珠峰架构-函数
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "1",
        "bdMiniList": false,
        "bdPic": ""
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      },
      "slide": {
        "bdImg": "5",
        "bdPos": "left",
        "bdTop": "100"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?v=89860593.js?'+~(-new Date()/36e5)];;
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zOTcwMy8xNjIzMA"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/myPhoto.jpg"
                alt="赖彬鸿" />
            
              <p class="site-author-name" itemprop="name">赖彬鸿</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">131</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          
          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/LbhFront-end" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.cnblogs.com/lbh2018/" target="_blank" title="博客园">
                      
                        <i class="fa fa-fw fa-globe"></i>博客园</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://yq.aliyun.com/users/1802204154913774?spm=a2c4e.11153940.blogcont662526.4.6c0a34f6E2lR5o" target="_blank" title="云栖">
                      
                        <i class="fa fa-fw fa-globe"></i>云栖</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:544289495@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="tencent://AddContact/?fromId=45&fromSubId=1&subcmd=all&uin=544289495&website=www.oicqzone.com" target="_blank" title="QQ">
                      
                        <i class="fa fa-fw fa-qq"></i>QQ</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.google.com.hk/search?safe=strict&source=hp&ei=JtLCXIriJ8G4-gS_-4qABQ&q=site%3Alaibh.top&btnK=Google+%E6%90%9C%E7%B4%A2&oq=site%3Alaibh.top&gs_l=psy-ab.3...1158.6834..7051...5.0..1.246.3720.2-17......0....1..gws-wiz.....0..0j0i10.rJMUHvdrbds" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
            </div>
          
         <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=90  src="//music.163.com/outchain/player?type=0&id=2353471182&auto=0&height=90"></iframe>
          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.chjtx.com/JRoll/" title="醉萝卜" target="_blank">醉萝卜</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://zhdaa.github.io/" title="Zhendong" target="_blank">Zhendong</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.cnblogs.com/cnyball" title="cnyballk" target="_blank">cnyballk</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://johnzz.top/" title="John" target="_blank">John</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://xiaojun1994.top/" title="xiaojun1994" target="_blank">xiaojun1994</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://me.ursb.me" title="Airing" target="_blank">Airing</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.iyouhun.com" title="游魂" target="_blank">游魂</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.teoblog.cn/" title="饼干的垃圾堆" target="_blank">饼干的垃圾堆</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://icoty.github.io/" title="荒野之萍" target="_blank">荒野之萍</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://im-one.github.io/" title="imOne" target="_blank">imOne</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://zzjshuo.club" title="赵子君" target="_blank">赵子君</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://blog.hourxu.com/" title="Ambre" target="_blank">Ambre</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.huyujs.com" title="胡雨" target="_blank">胡雨</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.andou.live" title="安逗" target="_blank">安逗</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.jianshu.com/u/701a8bbf4f7e" title="陈健斌" target="_blank">陈健斌</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://jl66.github.io/" title="咖喱" target="_blank">咖喱</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://itobys.github.io/" title="汤姆Tom酱" target="_blank">汤姆Tom酱</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://breeze2.github.io/blog/" title="林毅锋" target="_blank">林毅锋</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.qzroc.com/" title="大鹏博客" target="_blank">大鹏博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://lyreal666.com/" title="余腾靖的博客" target="_blank">余腾靖的博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.baidu.com/s?ie=UTF-8&wd=site%3Alaibh.top" title="百度" target="_blank">百度</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.google.com.hk/search?safe=strict&source=hp&ei=zXdWXfemLJbO0PEP8qyXyA0&q=site%3Alaibh.top&oq=site%3Alaibh.top&gs_l=psy-ab.3...580.8501..8767...0.0..0.397.934.2-1j2......0....2j1..gws-wiz.QESXfWGadT0&ved=0ahUKEwi3wbusiofkAhUWJzQIHXLWBdkQ4dUDCAU&uact=5" title="谷歌" target="_blank">谷歌</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#NodeJS"><span class="nav-number">1.</span> <span class="nav-text">NodeJS</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#模块与文件"><span class="nav-number">1.1.</span> <span class="nav-text">模块与文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#require-的加载机制"><span class="nav-number">1.1.1.</span> <span class="nav-text">require 的加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#模块的分类"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">模块的分类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#module-exports-与-exports-的区别"><span class="nav-number">1.1.2.</span> <span class="nav-text">module.exports 与 exports 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模块循环引用问题"><span class="nav-number">1.1.3.</span> <span class="nav-text">模块循环引用问题</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#a-模块中的-undeclaredVariable-变量在-b-js-是否会打印？"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">a 模块中的 undeclaredVariable 变量在 b.js 是否会打印？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#假设有-a-js、b-js-两个模块相互引用，会有什么问题，会不会陷入死循环？"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">假设有 a.js、b.js 两个模块相互引用，会有什么问题，会不会陷入死循环？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer"><span class="nav-number">1.2.</span> <span class="nav-text">Buffer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer与Cache的区别"><span class="nav-number">1.2.1.</span> <span class="nav-text">Buffer与Cache的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#缓冲（Buffer）"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">缓冲（Buffer）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缓存（Cache）"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">缓存（Cache）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程与进程"><span class="nav-number">1.3.</span> <span class="nav-text">线程与进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是进程（Process）和线程（Thread），之间的区别"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">什么是进程（Process）和线程（Thread），之间的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#进程"><span class="nav-number">1.3.0.1.1.</span> <span class="nav-text">进程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#线程"><span class="nav-number">1.3.0.1.2.</span> <span class="nav-text">线程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是孤儿进程"><span class="nav-number">1.3.1.</span> <span class="nav-text">什么是孤儿进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建多进程时，代码里有app-listen-port-在进行fork时，为什么没有报端口被占用"><span class="nav-number">1.3.2.</span> <span class="nav-text">创建多进程时，代码里有app.listen(port)在进行fork时，为什么没有报端口被占用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是IPC通信，如何建立，什么场景下会使用"><span class="nav-number">1.3.3.</span> <span class="nav-text">什么是IPC通信，如何建立，什么场景下会使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Node-js是单线程还是多线程，为什么会单线程"><span class="nav-number">1.3.4.</span> <span class="nav-text">Node.js是单线程还是多线程，为什么会单线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关于守护进程，是什么，为什么，怎么编写？"><span class="nav-number">1.3.5.</span> <span class="nav-text">关于守护进程，是什么，为什么，怎么编写？</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建步骤"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">创建步骤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编写demo"><span class="nav-number">1.3.6.</span> <span class="nav-text">编写demo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现一个简单的命令行交互程序"><span class="nav-number">1.3.7.</span> <span class="nav-text">实现一个简单的命令行交互程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的当前工作目录是什么，有什么用"><span class="nav-number">1.3.8.</span> <span class="nav-text">进程的当前工作目录是什么，有什么用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多进程或者多个Web服务之间的状态共享问题"><span class="nav-number">1.3.9.</span> <span class="nav-text">多进程或者多个Web服务之间的状态共享问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是僵尸进程"><span class="nav-number">1.3.10.</span> <span class="nav-text">什么是僵尸进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Console"><span class="nav-number">1.4.</span> <span class="nav-text">Console</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#console是异步还是同步的"><span class="nav-number">1.4.1.</span> <span class="nav-text">console是异步还是同步的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何实现一个console-log"><span class="nav-number">1.4.2.</span> <span class="nav-text">如何实现一个console.log</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么console-log-执行完就退出"><span class="nav-number">1.4.3.</span> <span class="nav-text">为什么console.log()执行完就退出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Net模块"><span class="nav-number">1.5.</span> <span class="nav-text">Net模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是TCP协议，什么时候会选择TCP协议"><span class="nav-number">1.5.1.</span> <span class="nav-text">什么是TCP协议，什么时候会选择TCP协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP粘包是什么-该怎么办"><span class="nav-number">1.5.2.</span> <span class="nav-text">TCP粘包是什么,该怎么办</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#编码-解码的实现"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">编码/解码的实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DNS"><span class="nav-number">1.6.</span> <span class="nav-text">DNS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#底层操作工具域名解析"><span class="nav-number">1.6.1.</span> <span class="nav-text">底层操作工具域名解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链接到DNS服务器执行域名解析"><span class="nav-number">1.6.2.</span> <span class="nav-text">链接到DNS服务器执行域名解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DNS域名解析过程"><span class="nav-number">1.6.3.</span> <span class="nav-text">DNS域名解析过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cluster-（集群）"><span class="nav-number">1.7.</span> <span class="nav-text">Cluster （集群）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#采用了哪种集群方式"><span class="nav-number">1.7.1.</span> <span class="nav-text">采用了哪种集群方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多个进程为什么可以监听同一个端口"><span class="nav-number">1.7.2.</span> <span class="nav-text">多个进程为什么可以监听同一个端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多个进程之间如何通信"><span class="nav-number">1.7.3.</span> <span class="nav-text">多个进程之间如何通信</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#如何对多个Worker进行请求转发"><span class="nav-number">1.7.4.</span> <span class="nav-text">如何对多个Worker进行请求转发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nodejs负载均衡策略设置"><span class="nav-number">1.7.5.</span> <span class="nav-text">Nodejs负载均衡策略设置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于Stream实现多文件合并"><span class="nav-number">1.8.</span> <span class="nav-text">基于Stream实现多文件合并</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一个简单的Stream操作"><span class="nav-number">1.8.1.</span> <span class="nav-text">一个简单的Stream操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多个文件通过Stream合并成一个文件"><span class="nav-number">1.8.2.</span> <span class="nav-text">多个文件通过Stream合并成一个文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream-pipe的使用与实现原理"><span class="nav-number">1.9.</span> <span class="nav-text">Stream pipe的使用与实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#未使用Stream-pipe的情况"><span class="nav-number">1.9.1.</span> <span class="nav-text">未使用Stream pipe的情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用Steam-pipe"><span class="nav-number">1.9.2.</span> <span class="nav-text">使用Steam pipe</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用与不使用Stream"><span class="nav-number">1.9.3.</span> <span class="nav-text">使用与不使用Stream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#源码分析"><span class="nav-number">1.9.4.</span> <span class="nav-text">源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#lib-fs-js"><span class="nav-number">1.9.4.1.</span> <span class="nav-text">/lib/fs.js</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lib-internal-fs-streams-js"><span class="nav-number">1.9.4.2.</span> <span class="nav-text">/lib/internal/fs/streams.js</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lib-stream-js"><span class="nav-number">1.9.4.3.</span> <span class="nav-text">/lib/stream.js</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lib-internal-streams-legacy-js"><span class="nav-number">1.9.4.4.</span> <span class="nav-text">/lib/internal/streams/legacy.js</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#lib-stream-readable-js"><span class="nav-number">1.9.4.5.</span> <span class="nav-text">/lib/_stream_readable.js</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#stream-readable-js实现分析"><span class="nav-number">1.9.4.5.1.</span> <span class="nav-text">_stream_readable.js实现分析</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#lib-internal-streams-legacy-js模块实现分析"><span class="nav-number">1.10.</span> <span class="nav-text">/lib/internal/streams/legacy.js模块实现分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#声明构造函数Stream"><span class="nav-number">1.10.1.</span> <span class="nav-text">声明构造函数Stream</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#声明pipe方法，订阅data事件"><span class="nav-number">1.10.2.</span> <span class="nav-text">声明pipe方法，订阅data事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#订阅drain事件"><span class="nav-number">1.10.3.</span> <span class="nav-text">订阅drain事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#选项指定end属性，订阅end-close事件"><span class="nav-number">1.10.4.</span> <span class="nav-text">选项指定end属性，订阅end,close事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#订阅可读流与可写流的error事件"><span class="nav-number">1.10.5.</span> <span class="nav-text">订阅可读流与可写流的error事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#触发pipe事件"><span class="nav-number">1.10.6.</span> <span class="nav-text">触发pipe事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#支持链式调用"><span class="nav-number">1.10.7.</span> <span class="nav-text">支持链式调用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#util-promisify如何将Callback转换为Promise"><span class="nav-number">1.11.</span> <span class="nav-text">util.promisify如何将Callback转换为Promise</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简单实现版本"><span class="nav-number">1.11.1.</span> <span class="nav-text">简单实现版本</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#util-promisify基本使用"><span class="nav-number">1.11.1.1.</span> <span class="nav-text">util promisify基本使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#util-promisify-custom基本使用"><span class="nav-number">1.11.1.2.</span> <span class="nav-text">util.promisify.custom基本使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#util-promisify回调函数多参转换"><span class="nav-number">1.11.1.3.</span> <span class="nav-text">util.promisify回调函数多参转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#完整代码"><span class="nav-number">1.11.1.4.</span> <span class="nav-text">完整代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O"><span class="nav-number">1.12.</span> <span class="nav-text">I/O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#阻塞与非阻塞I-O"><span class="nav-number">1.12.1.</span> <span class="nav-text">阻塞与非阻塞I/O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步与异步I-O"><span class="nav-number">1.12.2.</span> <span class="nav-text">同步与异步I/O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户空间与内核空间"><span class="nav-number">1.12.3.</span> <span class="nav-text">用户空间与内核空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统I-O模型"><span class="nav-number">1.12.4.</span> <span class="nav-text">操作系统I/O模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#同步阻塞IO"><span class="nav-number">1.12.4.1.</span> <span class="nav-text">同步阻塞IO</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步非阻塞I-O"><span class="nav-number">1.12.5.</span> <span class="nav-text">同步非阻塞I/O</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O多路复用"><span class="nav-number">1.12.6.</span> <span class="nav-text">I/O多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号驱动IO"><span class="nav-number">1.12.7.</span> <span class="nav-text">信号驱动IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异步IO模型"><span class="nav-number">1.12.8.</span> <span class="nav-text">异步IO模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#轮询技术Select-与-Epoll的区别"><span class="nav-number">1.12.9.</span> <span class="nav-text">轮询技术Select 与 Epoll的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Nodejs中的内存管理和V8垃圾回收机制"><span class="nav-number">1.12.10.</span> <span class="nav-text">Nodejs中的内存管理和V8垃圾回收机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NodeJs中的GC"><span class="nav-number">1.12.11.</span> <span class="nav-text">NodeJs中的GC</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#垃圾回收内存管理实践"><span class="nav-number">1.12.12.</span> <span class="nav-text">垃圾回收内存管理实践</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内存泄露"><span class="nav-number">1.12.12.1.</span> <span class="nav-text">内存泄露</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存泄露的例子"><span class="nav-number">1.12.12.2.</span> <span class="nav-text">内存泄露的例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#手动执行垃圾回收内存释放"><span class="nav-number">1.12.12.3.</span> <span class="nav-text">手动执行垃圾回收内存释放</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#V8垃圾回收机制"><span class="nav-number">1.12.13.</span> <span class="nav-text">V8垃圾回收机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#V8堆内存限制"><span class="nav-number">1.12.13.1.</span> <span class="nav-text">V8堆内存限制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新生代与老生代"><span class="nav-number">1.12.13.2.</span> <span class="nav-text">新生代与老生代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#小结"><span class="nav-number">1.12.13.3.</span> <span class="nav-text">小结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存泄露-1"><span class="nav-number">1.12.14.</span> <span class="nav-text">内存泄露</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插件"><span class="nav-number">1.13.</span> <span class="nav-text">插件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#缓存"><span class="nav-number">1.13.1.</span> <span class="nav-text">缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#定时任务"><span class="nav-number">1.13.2.</span> <span class="nav-text">定时任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模板引擎"><span class="nav-number">1.13.3.</span> <span class="nav-text">模板引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#框架"><span class="nav-number">1.13.4.</span> <span class="nav-text">框架</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ORM"><span class="nav-number">1.13.5.</span> <span class="nav-text">ORM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#性能"><span class="nav-number">1.14.</span> <span class="nav-text">性能</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#指标"><span class="nav-number">1.14.1.</span> <span class="nav-text">指标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统扩容评价"><span class="nav-number">1.14.2.</span> <span class="nav-text">系统扩容评价</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Nodejs-CPU使用率"><span class="nav-number">1.15.</span> <span class="nav-text">Nodejs CPU使用率</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#os-cups-数据指标"><span class="nav-number">1.15.1.</span> <span class="nav-text">os.cups()数据指标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NodeJs与Event-Loop"><span class="nav-number">1.16.</span> <span class="nav-text">NodeJs与Event Loop</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Event-Loop事件循环"><span class="nav-number">1.16.1.</span> <span class="nav-text">Event Loop事件循环</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CPU密集型任务问题"><span class="nav-number">1.16.2.</span> <span class="nav-text">CPU密集型任务问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工作线程"><span class="nav-number">1.16.3.</span> <span class="nav-text">工作线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis"><span class="nav-number">1.17.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#通用命令"><span class="nav-number">1.17.1.</span> <span class="nav-text">通用命令</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart throb" style="color: #d43f57;"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">赖彬鸿</span>

  
</div>

  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize("");
    }
  </script>

<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>



-->
<div>
<span id="busuanzi_container_site_pv" title="访问量">
    <i class="fa fa fa-eye"></i> <span id="busuanzi_value_site_pv"></span>
</span>
<span id="busuanzi_container_site_uv" title="访问人数">
  <i class="fa fa-user"></i> <span id="busuanzi_value_site_uv"></span>
</span>
<span class="post-count" title="博客总字数"><i class="fa fa-pagelines" aria-hidden="true"></i>668.6k</span>
</div>
<i class="fa fa-shield" aria-hidden="true" title="本站安全运行时间"></i> <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("01/29/2018 09:47:04");//此处修改你的建站时间或者网站上线时间
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds);
        if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>

        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>
  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="//cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  




  
  
  
  <link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css">

  
  
  <script src="/lib/algolia-instant-search/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.4"></script>



  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("JcDzlAxx8A0MJDQ9xpJTOBUe-gzGzoHsz", "hih724suAgjSWQnvOuIEvxza");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  
  <script type="text/javascript" src="/js/src/js.cookie.js?v=5.1.4"></script>
  <script type="text/javascript" src="/js/src/scroll-cookie.js?v=5.1.4"></script>


  

  <!-- 代码块复制功能 -->
  <script type="text/javascript" src="/js/src/clipboard.js"></script>  
  <script type="text/javascript" src="/js/src/clipboard-use.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginModelPath":"assets/","model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"right","width":200,"height":400},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
